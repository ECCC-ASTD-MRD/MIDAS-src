!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
! MODULE minimization (Minimization for variational assimilation.  prefix="min")
!
! Purpose: 
!
! Subroutines (public):
!    min_setup
!    min_minvar
!
! Dependencies:
!
!--------------------------------------------------------------------------
MODULE minimization_mod
  use MathPhysConstants_mod
  use timeCoord_mod
  use columnData_mod
  use obsSpaceData_mod
  use controlVector_mod
  use mpivar_mod
  use HorizontalCoord_mod
  use gridStateVector_mod
  use bmatrix_mod
  use stateToColumn_mod
  use variableTransforms_mod
  implicit none
  save
  private

  ! public variables
  public              :: min_lvarqc,min_niter,min_nsim
  ! public procedures
  public              :: min_Setup, min_minvar

  type struct_dataptr
    type(struct_obs),pointer        :: obsSpaceData
    type(struct_columnData),pointer :: column
    type(struct_columnData),pointer :: columng
  end type struct_dataptr

  logical             :: initialized = .false.
  real*8, pointer     :: dg_vbar(:)

  integer             :: envar_loop   ! environment variable

  integer             :: nmtra,nwork,min_nsim
  integer             :: nvadim_mpilocal ! for mpi
  integer             :: min_niter
  integer             :: dataptr_int_size=0
  integer,external    :: get_max_rss
  logical             :: preconFileExists
  character(len=20)   :: preconFileName    = './preconin'  
  character(len=20)   :: preconFileNameOut = './pm1q'  
  character(len=20)   :: preconFileNameOut_pert = './pm1q_pert'  
  integer             :: n1gc = 3

  ! namelist variables
  INTEGER NVAMAJ,NITERMAX,NSIMMAX
  LOGICAL lxbar,lwrthess,lgrtest,lvazx
  REAL*8 REPSG,rdf1fac
  LOGICAL min_lvarqc,lvarqc,pertBhiOnly
  integer :: nwoqcv
  integer :: numIterMax_pert, numAnalyses, ntrunc_pert
  character(len=256) :: ensPathName
  real(8) :: e1_scaleFactor, e2_scaleFactor
  integer,parameter   :: maxNumLevels=200
  real(8) :: pertScaleFactor_UV(maxNumLevels)
  character(len=12) :: cetikinc

  NAMELIST /NAMMIN/NVAMAJ,NITERMAX,NSIMMAX
  NAMELIST /NAMMIN/LGRTEST
  NAMELIST /NAMMIN/lxbar,lwrthess,lvazx
  NAMELIST /NAMMIN/REPSG,rdf1fac
  NAMELIST /NAMMIN/LVARQC,NWOQCV
  NAMELIST /NAMMIN/numIterMax_pert,numAnalyses,ensPathName
  NAMELIST /NAMMIN/e1_scaleFactor,e2_scaleFactor,pertBhiOnly
  NAMELIST /NAMMIN/pertScaleFactor_UV,ntrunc_pert
  NAMELIST /NAMMIN/cetikinc

CONTAINS

  SUBROUTINE min_setup(nvadim_mpilocal_in)
    implicit none
    integer :: nvadim_mpilocal_in

    integer :: ierr,nulnam
    integer :: fnom,fclos
    character(len=32) :: envVariable
    integer :: length_envVariableburp, status

    if(nvadim_mpilocal_in.ne.cvm_nvadim) then
      write(*,*) 'nvadim_mpilocal,cvm_nvadim=',nvadim_mpilocal,cvm_nvadim
      call abort3d('aborting in min_setup: control vector dimension not consistent')
    endif

    nvadim_mpilocal=nvadim_mpilocal_in

    ! set default values for namelist variables
    nvamaj = 6
    nitermax = 0
    rdf1fac  = 0.25d0
    nsimmax  = 500
    lgrtest  = .false.
    lwrthess = .true.
    lxbar    = .false.
    lvazx    = .false.
    repsg    = 1.0d-5
    lvarqc   = .false.
    nwoqcv   = 5
    numIterMax_pert = 0
    numAnalyses = 20
    ensPathName = './ensemble'
    e1_scaleFactor = 0.66d0
    e2_scaleFactor = 0.33d0
    pertBhiOnly = .true.
    pertScaleFactor_UV(:) = 1.0d0
    ntrunc_pert = 0
    cetikinc = 'UNDEFINED***'

    ! read in the namelist NAMMIN
    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=nammin,iostat=ierr)
    if(ierr.ne.0) call abort3d('min_setup: Error reading namelist')
    write(*,nml=nammin)
    ierr=fclos(nulnam)

    min_lvarqc=lvarqc

    IF(N1GC.EQ.3)THEN
      NMTRA = (4 + 2*NVAMAJ)*nvadim_mpilocal
    ELSE
      call abort3d('min_setup: only N1GC=3 currently supported!') 
    END IF
    WRITE(*,9401)N1GC,NVAMAJ,NMTRA
 9401 FORMAT(4X,'N1GC = ',I2,4X,'NVAMAJ = ',I3,/5X,"NMTRA =",1X,I14)

    if(LVARQC .and. mpi_myid.eq.0) write(*,*) 'VARIATIONAL QUALITY CONTROL ACTIVATED.'

    ! Retrieve environment variables related to doing an ensemble of perturbed analyses
    status = 0
    call get_environment_variable('envar_loop',envVariable,length_envVariableburp,status,.true.)
    if (status.gt.1) then
      write(*,*) 'min_analysisPert: Problem when getting the environment variable envar_loop'
      envar_loop = 1
    elseif (status.eq.1) then
      envar_loop = 1
    else
      write(*,*) 'min_analysisPert: The environment variable envar_loop has been detected: ',envVariable
      read(envVariable,'(i8)') envar_loop
      write(*,*) 'envar_loop = ',envar_loop
    endif

    initialized=.true.

  END SUBROUTINE min_setup


  SUBROUTINE min_minvar(column,columng,obsSpaceData)
    !
    ! Purpose:
    ! 3D/En VAR minimization
    !
      IMPLICIT NONE

      type(struct_columnData),target :: column,columng
      type(struct_obs),target :: obsSpaceData
      type(struct_dataptr) :: dataptr 
      integer,allocatable  :: dataptr_int(:) ! obs array used to transmit pointer
      integer              :: nulout = 6
      integer              :: impres
      INTEGER              :: NGRANGE = 10 ! range of powers of 10 used for gradient test

      INTEGER IZS(1),IZTRL(10)
      REAL ZZSUNUSED(1)

      real*8,allocatable :: vazg(:)
      real*8,allocatable :: vazx(:)
      real*8,allocatable :: vatra(:)

      real*8 :: dlds(1)
      logical :: lltest, llvarqc, lldf1, lrdvatra, llvazx, llxbar

      integer :: imode, itermax, iterdone, itermaxtodo, isimmax, indic, iitnovqc, jj
      integer :: ierr, itertot, isimdone, isimtot, jdata, isimnovqc
      integer :: ibrpstamp, isim3d, ilen
      real*8 :: zjsp, zxmin, zdf1, zeps0, zeps1
      real*8 :: dlgnorm, dlxnorm, zjotov

      integer fnom,fclos, remove_c
      external fnom,fclos
      external  n1qn3
      real*8 :: zeps0_000,zdf1_000
      integer :: iterdone_000,isimdone_000
      character(len=128) :: clfname

      min_nsim=0 

      if(mpi_myid.eq.0) then
        impres=5
      else 
        impres=0
      endif

      ! Check for preconditioning file
      inquire(file=preconFileName,exist=preconFileExists)
      if(preconFileExists) then
        if(mpi_myid.eq.0) write(*,*) 'PRECONDITIONING FILE FOUND:',preconFileName
      else
        if(mpi_myid.eq.0) write(*,*) 'NO PRECONDITIONING FILE FOUND:',preconFileName
      endif

      ! allocate control vector related arrays (these are all mpilocal)

      allocate(vazx(nvadim_mpilocal),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=3',ierr
        call abort3d('aborting in min_minvar')
      endif

      allocate(dg_vbar(nvadim_mpilocal),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=1',ierr
        call abort3d('aborting in min_minvar')
      endif

      allocate(vazg(nvadim_mpilocal),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=2',ierr
        call abort3d('aborting in min_minvar')
      endif

      allocate(vatra(nmtra),stat=ierr)
      if(ierr.ne.0.or.nmtra.le.0) then
        write(*,*) 'minimization: Problem allocating memory! id=4',ierr
        write(*,*) 'minimization: nmtra=',nmtra
        call abort3d('aborting in min_minvar')
      endif

      ! recast pointer to obsSpaceData as an integer array, so it can be passed through n1qn3 to simvar
      dataptr%obsSpaceData => obsSpaceData
      dataptr%column       => column
      dataptr%columng      => columng
      dataptr_int_size = size(transfer(dataptr,dataptr_int))
      allocate(dataptr_int(dataptr_int_size),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=2',ierr
        call abort3d('aborting in min_minvar')
      endif
      dataptr_int(1:dataptr_int_size)=transfer(dataptr,dataptr_int)

      ! Set-up the minimization

      ! initialize iteration/simulation counters to zero
      ITERTOT  = 0
      isimtot = 0

      ! initialize control vector related arrays to zero
      vazx(:)=0.0d0
      ! extra mpilocal portion of control vector: NOT NEEDED?
      !vazx(1:nvadim_mpilocal)=cvm_vazx(1:nvadim_mpilocal)
      dg_vbar(:)=0.0d0
      vazg(:)=0.0d0
      vatra(:)=0.0d0

      ! save user-requested varqc switch
      llvarqc = lvarqc

      ! If minimization start without qcvar : turn off varqc to compute
      ! innovations and test the gradients

      lldf1 = .true.
      if (preconFileExists) then
        if(mpi_myid.eq.0) write(*,*) 'min_minvar : Preconditioning mode'
        lrdvatra = .true.
        imode = 2
        llvazx = lvazx ! from namelist (default is .false.)
        llxbar = lxbar ! from namelist (default is .false.)
      else
        lrdvatra = .false.
        imode = 0
        zeps0 = repsg
      endif

      ! read the hessian from preconin file
      if (lrdvatra) then
        ibrpstamp = tim_getDatestamp() ! ibrpstamp is a I/O argument of rw_vatra

        call rw_vatra (preconFileName,0,                     &
          isim3d,ibrpstamp,zeps0_000,zdf1_000,iterdone_000,  &
          isimdone_000,iztrl,vatra,dg_vbar,                  &
          vazx,llxbar,llvazx,n1gc,imode)

        if (ibrpstamp == tim_getDatestamp() .and. lxbar) then
          ! use vbar for true outer loop
          zeps0  = zeps0_000
          zdf1   = zdf1_000
          lldf1 = .false.     ! don't re-compute df1 base on Cost function
        else
          zeps0 = repsg
          lldf1 = .true.      ! Compute df1 base on Cost function
        endif
      endif

      iterdone = 0
      isimdone = 0
      itermax = nitermax
      itermaxtodo = itermax
      isimmax = nsimmax

      if (nwoqcv > 0) lvarqc = .false.

      ! do the gradient test for the starting point of minimization
      if(lgrtest) then
        call grtest2(simvar,nvadim_mpilocal,vazx,ngrange,dataptr_int)
      endif

      zeps1 = zeps0

      itertot = iterdone
      isimtot = isimdone

      INDIC =2
      call simvar(indic,nvadim_mpilocal,vazx,zjsp,vazg,dataptr_int(1))

      if (lldf1) ZDF1     =  rdf1fac * ABS(ZJSP)

!     Put QCVAR logical to its original values
      lvarqc=llvarqc

      CALL PRSCAL(nvadim_mpilocal,VAZG,VAZG,DLGNORM)
      DLGNORM = DSQRT(DLGNORM)
      CALL PRSCAL(nvadim_mpilocal,VAZX,VAZX,DLXNORM)
      DLXNORM = DSQRT(DLXNORM)
      WRITE(*,*)' |X| = ', DLXNORM
      WRITE(*,FMT=9220) ZJSP, DLGNORM
 9220 FORMAT(/4X,'J(X) = ',G23.16,4X,'|Grad J(X)| = ',G23.16)

      ! Iterations of the minimization algorithm

      ZXMIN = epsilon(ZXMIN)
      WRITE(*,FMT=9320)ZXMIN,ZDF1,ZEPS0,IMPRES,ITERMAX,NSIMMAX

 9320 FORMAT(//,10X,' Minimization N1QN3 starts ...',/  &
             10x,'DXMIN =',G23.16,2X,'DF1 =',G23.16,2X,'EPSG =',G23.16  &
             /,10X,'IMPRES =',I3,2X,'NITER = ',I3,2X,'NSIM = ',I3)

      ! Begin the minimization
      if(nitermax.gt.0) then

        ! First do iterations without var-QC
        if (lvarqc .and. nwoqcv > 0 .and. iterdone < nwoqcv) then
          iitnovqc = min(nwoqcv - iterdone,itermax)
          isimnovqc = isimmax
          lvarqc = .false.
          call tmg_start(70,'QN')
          call n1qn3(simvar, dscalqn, dcanonb, dcanab, nvadim_mpilocal, vazx,  &
              zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode,       &
              iitnovqc, isimnovqc ,iztrl, vatra, nmtra, dataptr_int(1),   &
              zzsunused, dlds)
          call tmg_stop(70)
          call fool_optimizer(obsSpaceData)

          isimnovqc = isimnovqc - 1
          itermaxtodo = itermaxtodo - iitnovqc + 1
          isimmax = isimmax - isimnovqc + 1

          itertot = itertot + iitnovqc
          isimtot = isimtot + isimnovqc

          zeps1 = zeps0/zeps1
          zeps0 = zeps1
          lvarqc = .true.

          if ((imode == 4 .or. imode == 1) .and. itertot < itermax) then
            imode = 2
            INDIC = 2
            call simvar(indic,nvadim_mpilocal,vazx,zjsp,vazg,dataptr_int(1))
          else
            call abort3d(" MINIMIZATION_MOD: n1qn3 mode ne 4")
          endif
        endif

        ! Now do main minimization with var-QC
        call tmg_start(70,'QN')
        call n1qn3(simvar, dscalqn, dcanonb, dcanab, nvadim_mpilocal, vazx,  &
            zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode,   &
            itermaxtodo,isimmax, iztrl, vatra, nmtra, dataptr_int(1), zzsunused,   &
            dlds)
        call tmg_stop(70)
        call fool_optimizer(obsSpaceData)

        itertot = itertot + itermaxtodo
        isimtot = isimtot + isimmax

        zeps1 = zeps0/zeps1


        WRITE(*,FMT=9500) imode,iterdone,itertot-iterdone,itertot,isimdone,isimtot-isimdone,isimtot
 9500   FORMAT(//,20X,20('*'),2X    &
        ,/,20X,'              Minimization ended with MODE:',I4  &
        ,/,20X,' Number of iterations done in previous job:',I4  &
        ,/,20X,'          Number of iterations in this job:',I4  &
        ,/,20X,'                Total number of iterations:',I4  &
        ,/,20X,'Number of simulations done in previous job:',I4  &
        ,/,20X,'         Number of simulations in this job:',I4  &
        ,/,20X,'               Total number of simulations:',I4)

        min_niter = itertot

        ! Test the gradient at the final point
        if (lgrtest) then
          WRITE(*,FMT=9400)
 9400     FORMAT(//,12X,40('**'),/,12X,'TESTING THE GRADIENT AT THE FINAL POINT',/,40('**'))
          call grtest2(simvar,nvadim_mpilocal,vazx,ngrange,dataptr_int)
        end if

        do jdata = 1, nvadim_mpilocal
          dg_vbar(jdata) = vazx(jdata) + dg_vbar(jdata)
        enddo

        ! Write out the Hessian to file
        if(lwrthess) then
          if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
          call rw_vatra (preconFileNameOut,1,  &
            min_nsim,tim_getDatestamp(),zeps1,zdf1,itertot,isimtot,  &
            iztrl,vatra,dg_vbar,vazx,.true.,llvazx,n1gc,imode)
          if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
        endif

        ! Put final control vector into control vector module for use elsewhere
        call tmg_start(89,'MIN_COMM')
        cvm_vazx(:) = vazx(1:nvadim_mpilocal)      
        call tmg_stop(89)

        ! Print some contents of obsSpaceData to the listing
        do jdata = 1, min(1,obs_numHeader(obsSpaceData))
          call obs_prnthdr(obsSpaceData,jdata)
          call obs_prntbdy(obsSpaceData,jdata)
        end do

        ! output the analysis increment
        call tmg_start(6,'MIN_WRITEINCR')
        call min_writeIncrement(cvm_vazx,columng)
        call tmg_stop(6)

      else

        ! no analysis performed for ensemble mean, ensure mean increment is zero
        cvm_vazx(:) = 0.0d0
        min_niter = 0

      endif ! if nitermax .gt. 0


      ! If requested, compute analysis increment for ensemble perturbations
      if(numIterMax_pert.gt.0) then
        dg_vbar(:) = 0.0d0
        call tmg_start(4,'MINPERT')
        call min_analysisPert(vatra,iztrl,dataptr_int,zdf1,column,columng,obsSpaceData)
        call tmg_stop(4)
      endif

      ! deallocate the control vector related arrays
      deallocate(vazx)
      deallocate(vazg)
      deallocate(vatra)
      deallocate(dg_vbar)

      deallocate(dataptr_int)

  END SUBROUTINE min_minvar

  
  subroutine min_writeIncrement(incr_cv,columng)

    use chem_interface_mod

    implicit none

    ! arguments
    real(8)                        :: incr_cv(:)
    type(struct_columnData),target :: columng
    ! locals
    integer              :: fnom, fstouv, fclos, fstfrm, fstinf
    integer, parameter   :: maxNumFiles = 1000
    integer              :: ierr, ikey, indexStep, indexTrial, numTrials, nulTrials(maxNumFiles)
    integer              :: ni_file, nj_file, nk_file, dateStamp
    real(8)              :: deltaHours
    character(len=4)     :: coffset
    character(len=2)     :: flnum
    character(len=30)    :: fileName
    logical              :: fileExists
    type(struct_gsv)     :: statevector_trial, statevector_incr
    type(struct_hco), pointer :: hco_anl

    if(mpi_myid.eq.0) write(*,*) 'min_writeIncrement: STARTING'

    ! initialize statevector_trial and statevector_incr
    hco_anl => hco_get('Analysis')

    call gsv_setVco(statevector_trial,col_getVco(columng))
    call gsv_setHco(statevector_trial,hco_anl)
    call gsv_allocate(statevector_trial,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    call gsv_setVco(statevector_incr,col_getVco(columng))
    call gsv_setHco(statevector_incr,hco_anl)
    call gsv_allocate(statevector_incr,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    ! compute increment from control vector (multiply by B^1/2)
    call bmat_sqrtB(incr_cv, nvadim_mpilocal, statevector_incr)

    ! open all available trial files
    nulTrials(:) = 0
    numTrials = 0
    do 
      write(flnum,'(I2.2)') numTrials+1
      fileName = './trlm_' // trim(flnum)
      inquire(file=trim(fileName),exist=fileExists)
      if(fileExists) then
        numTrials = numTrials + 1
        ierr = fnom(nulTrials(numTrials),trim(fileName),'RND+OLD+R/O',0)
        if(mpi_myid.eq.0) write(*,*) 'Trial file: ', trim(fileName), ' opened as unit file: ',nulTrials(numTrials)
        ierr =  fstouv(nulTrials(numTrials),'RND+OLD')
      elseif ( (.not. fileExists) .and. numTrials > 0 ) then
        exit  
      elseif ( (.not. fileExists) .and. numTrials == 0 ) then
        call abort3d('min_writeIncrement: No trial files found')
      endif 
    enddo 
    if(numTrials.ne.tim_nstepobs) then
      write(*,*) 'numTrials, tim_nstepobs = ',numTrials, tim_nstepobs
      call abort3d('min_writeIncrement: numTrials <> tim_nstepobs')
    endif

    ! loop over times for which increment is computed
    do indexStep = 1, tim_nstepobsinc
      dateStamp = gsv_getDateStamp(statevector_incr,indexStep)
      if(mpi_myid.eq.0) write(*,*) 'min_writeIncrement: writing increment for time step: ',indexStep, dateStamp

      ! identify which trial file corresponds with current datestamp
      fileName = 'NOTFOUND'
      do indexTrial = 1, numTrials
        ikey = fstinf(nulTrials(indexTrial), ni_file, nj_file, nk_file,  &
                      dateStamp, ' ', -1, -1, -1, ' ', 'P0')
        if(ikey.gt.0) then
          write(flnum,'(I2.2)') indexTrial
          fileName = './trlm_' // trim(flnum)
          ierr = fstfrm(nulTrials(indexTrial))
          ierr = fclos(nulTrials(indexTrial))
          exit
        endif
      enddo
      if(trim(fileName).eq.'NOTFOUND') then 
        write(*,*) 'indexStep, dateStamp = ', indexStep, dateStamp
        call abort3d('min_writeIncrement: trial file not found for this increment timestep')
      endif

      ! read the trial file for this timestep
      call gsv_readFromFile(statevector_trial, fileName, ' ', 'P', 'TRIAL', indexStep)

      ! Compute new diagnotics based on NAMSTATE
      call vtr_setup(statevector_incr) ! IN
      if ( gsv_varExist('QR') .and. gsv_varExist('DD') ) then
        write(*,*)
        write(*,*) 'User is asking for Vort-Div analysis increment'
        call vtr_transform( statevector_incr,  & ! INOUT
                            'UVtoVortDiv' )      ! IN
        if ( gsv_varExist('PP') .and. gsv_varExist('CC') ) then
          write(*,*)
          write(*,*) 'User is asking for Psi-Chi analysis increment'
          call vtr_transform( statevector_incr, & ! INOUT
                              'VortDivToPsiChi' ) ! IN
        end if
      end if

      ! Adjust and or transform chemical consituent concentration increments as needed.
      ! This includes ensuring non-negative analysis values on the analysis/increment grid.
      if (chm_assim()) call chm_transform_final_increments(statevector_incr,statevector_trial)

      ! write the increment file for this time step
      call difdatr(dateStamp,tim_getDatestamp(),deltaHours)
      if(nint(deltaHours*60.0d0).lt.0) then
        write(coffset,'(I4.3)') nint(deltaHours*60.0d0)
      else
        write(coffset,'(I3.3)') nint(deltaHours*60.0d0)
      endif
      fileName = './rebm_' // trim(coffset) // 'm'
      call gsv_writeToFileMpi(statevector_incr, fileName, cetikinc, 1.0d0, 0, indexStep, statevector_trial)

      ! write out interpolated trial file for verification purposes
      fileName = './trlm_interp_' // trim(coffset) // 'm' 
      call gsv_writeToFileMpi(statevector_trial, fileName, 'TRLM_INTRP', 1.0d0, 0, indexStep)

    enddo

    call gsv_deallocate(statevector_trial)
    call gsv_deallocate(statevector_incr)

  end subroutine min_writeIncrement


  subroutine min_analysisPert(vatra,iztrl,dataptr_int,zdf1,column,columng,obsSpaceData)
    implicit none
    ! Purpose: use N1QN3 minimization to perform analysis step on 
    !          ensemble perturbations
    !
    ! arguments
    real(8)                        :: vatra(:)
    type(struct_columnData),target :: column,columng
    type(struct_obs),target        :: obsSpaceData
    ! locals
    type(struct_gsv) :: statevector_ens(numAnalyses)
    type(struct_gsv) :: statevector_mean, statevector_incr, statevector_incr_perturbed, statevector_randpert
    type(struct_hco), pointer :: hco_anl
    real(8), allocatable :: incr_cv(:)
    real(8)           :: scalefactor
    integer :: indexAnalysis,indexStep,cvdim_mpilocal
    character(len=80) :: fileName
    character(len=4)  :: censnumber
    character(len=8)   :: datestr_last
    character(len=2)   :: hourstr_last
    character(len=2)   :: trialTimeIndex_str
    integer :: stamp_last, ndate, ntime, ierr, newdate
    real(8),allocatable :: vazg(:)
    real(8) :: zjsp, zxmin, zdf1, zeps1
    real(8) :: dlds(1)
    real :: zzsunused(1)
    integer :: iztrl(:), dataptr_int(:)
    integer :: nulout, impres, imode, itertot, simtot, indic
    logical :: llvazx = .false.

    ! check if user wants to compute any perturbed analyses
    if(numAnalyses.le.0) then
      write(*,*) 'min_analysisPert: numAnalyses not positive, do nothing'
      return
    endif

    ! initialization
    hco_anl => hco_get('Analysis')

    call gsv_setVco(statevector_mean,col_getVco(columng))
    call gsv_setHco(statevector_mean,hco_anl)
    call gsv_allocate(statevector_mean,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    call gsv_setVco(statevector_incr,col_getVco(columng))
    call gsv_setHco(statevector_incr,hco_anl)
    call gsv_allocate(statevector_incr,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    call gsv_setVco(statevector_incr_perturbed,col_getVco(columng))
    call gsv_setHco(statevector_incr_perturbed,hco_anl)
    call gsv_allocate(statevector_incr_perturbed,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    call gsv_setVco(statevector_randpert,col_getVco(columng))
    call gsv_setHco(statevector_randpert,hco_anl)
    call gsv_allocate(statevector_randpert,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

    ! allocate local arrays
    allocate(incr_cv(nvadim_mpilocal))
    allocate(vazg(nvadim_mpilocal))
    vazg(:)=0.0d0

    ! figure out date strings for origin time of trials
    call incdatr(stamp_last,tim_getDatestamp(),-6.0d0)
    ierr = newdate(stamp_last,ndate,ntime,-3)
    write(datestr_last,'(i8.8)') ndate
    write(hourstr_last,'(i2.2)') ntime/1000000

    ! get all background ensemble members
    do indexAnalysis = 1, numAnalyses
      if(mpi_myid.eq.0) write(*,*) ' '
      if(mpi_myid.eq.0) write(*,*) 'min_analysisPert: reading member #', indexAnalysis
      if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      call gsv_setVco(statevector_ens(indexAnalysis),col_getVco(columng))
      hco_anl => hco_get('Analysis')
      call gsv_setHco(statevector_ens(indexAnalysis),hco_anl)
      call gsv_allocate(statevector_ens(indexAnalysis),tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)

      write(censnumber,'(i4.4)') indexAnalysis + (envar_loop-1)*numAnalyses
      fileName = trim(ensPathName) // '/' // datestr_last // hourstr_last // '_006_' // trim(censnumber)
      if(mpi_myid.eq.0) write(*,*) 'Reading from file: ', fileName
      do indexStep = 1, statevector_ens(indexAnalysis)%numStep
        call gsv_readFromFile(statevector_ens(indexAnalysis),fileName,' ','P','ENSMEMBER',indexStep_in=indexStep)
      enddo

    enddo

    ! read the background ensemble mean
    ! NOTE: assume it is supplied to VAR task as the trial file
    if(mpi_myid.eq.0) write(*,*) 'min_analysisPert: reading ensemble mean'
    do indexStep = 1, statevector_mean%numStep
      write(trialTimeIndex_str,'(i2.2)') indexStep
      fileName = './trlm_' // trim(trialTimeIndex_str)
      call gsv_readFromFile(statevector_mean,fileName,' ','P','ENSMEMBER',indexStep_in=indexStep)
    enddo

    ! remove mean
    do indexAnalysis = 1, numAnalyses
      scaleFactor = -1.0d0
      call gsv_add(statevector_mean,statevector_ens(indexAnalysis),scaleFactor)
    enddo
    
    ! do perturbation minimizations
    lvarqc = .false.
    do indexAnalysis = 1, numAnalyses

      ! write out the original background ensemble perturbation
      call writeToFile4D(statevector_ens(indexAnalysis),'./bgpert','BGPERT',indexAnalysis,statevector_mean)

      ! multiply by -1 (-xb')
      call gsv_scale(statevector_ens(indexAnalysis),-1.0d0)

      ! compute -H*xb', put in OBS_WORK
      call s2c_tl(statevector_ens(indexAnalysis),column,columng,obsSpaceData)  ! put in column H_horiz
      call oda_H(column,columng,obsSpaceData)

      ! undo the multiply by -1 (-xb')
      call gsv_scale(statevector_ens(indexAnalysis),-1.0d0)

      ! obs perturbation added to OBS_WORK and copy into OBS_OMP
      call perturbObs(obsSpaceData,numAnalyses,indexAnalysis,envar_loop,OBS_WORK,OBS_OMP)

      ! compute initial gradient
      incr_cv(:) = 0.0d0
      indic = 2
      call simvar(indic, nvadim_mpilocal, incr_cv, zjsp, vazg, dataptr_int)

      ! Initialization for call to N1QN3
      itertot = numIterMax_pert
      simtot = 2*itertot
      if(indexAnalysis.eq.1) then
        if(preconFileExists) then
          ! warm start with Hessian from file
          imode = 2
        else
          ! cold start and initially double number of iterations
          imode = 0
          vatra(:) = 0.0d0
          itertot = 2*itertot
          simtot = 2*itertot
        endif
      else
        ! warm start with Hessian from previous member
        imode=2
      endif
      zeps1 = 1.0d-5
      zxmin = epsilon(zxmin)
      nulout = 6
      if(mpi_myid.eq.0) then
        impres=5
      else 
        impres=0
      endif
      ! call N1QN3 minimization for perturbation
      call tmg_start(70,'QN')
      call n1qn3(simvar, dscalqn, dcanonb, dcanab, nvadim_mpilocal, incr_cv,  &
          zjsp, vazg, zxmin, zdf1, zeps1, impres, nulout, imode,       &
          itertot, simtot ,iztrl, vatra, nmtra, dataptr_int(1),   &
          zzsunused, dlds)
      call tmg_stop(70)
      call fool_optimizer(obsSpaceData)

      ! multiply by B^1/2
      call bmat_sqrtB(incr_cv,nvadim_mpilocal,statevector_incr)

      ! write perturbation analysis increment to file before adding random model-error
      !call writeToFile4D(statevector_incr,'./pert_inc0','PERT_INC0',indexAnalysis,statevector_mean)

      ! compute random model-error
      call calcRandomPert(statevector_randpert,numAnalyses,indexAnalysis)

      ! add E1 random model-error to increment and write to file
      call gsv_copy(statevector_randpert,statevector_incr_perturbed)
      call gsv_scale(statevector_incr_perturbed,e1_scaleFactor)
      call gsv_add(statevector_incr,statevector_incr_perturbed)
      call writeToFile4D(statevector_incr_perturbed,'./pert_inc1','PERT_INC1',indexAnalysis,statevector_mean)

      ! add E2 random model-error to increment and write to file
      call gsv_copy(statevector_randpert,statevector_incr_perturbed)
      call gsv_scale(statevector_incr_perturbed,e2_scaleFactor)
      call gsv_add(statevector_incr,statevector_incr_perturbed)
      call writeToFile4D(statevector_incr_perturbed,'./pert_inc2','PERT_INC2',indexAnalysis,statevector_mean)

      ! deallocate statevector_ens(indexAnalysis), no longer needed
      call gsv_deallocate(statevector_ens(indexAnalysis))

    enddo

    ! Write out the final Hessian to file
    if(lwrthess) then
      call rw_vatra (preconFileNameOut_pert,1,  &
        min_nsim,tim_getDatestamp(),zeps1,zdf1,itertot,simtot,  &
        iztrl,vatra,dg_vbar,incr_cv,.true.,llvazx,n1gc,imode)
    endif

    ! deallocate all local arrays
    deallocate(incr_cv)
    deallocate(vazg)
    call gsv_deallocate(statevector_incr)
    call gsv_deallocate(statevector_incr_perturbed)
    call gsv_deallocate(statevector_randpert)
    call gsv_deallocate(statevector_mean)

  end subroutine min_analysisPert


  subroutine writeToFile4D(statevector,fileName,cetiket,indexAnalysis,statevector_ref)
    implicit none
    ! arguments
    type(struct_gsv)   :: statevector, statevector_ref
    character(len=*)   :: fileName
    character(len=*)   :: cetiket
    integer            :: indexAnalysis
    ! locals
    character(len=100) :: fileNameFull
    integer            :: indexStep

    do indexStep = 1, statevector%numStep
      fileNameFull = trim(fileName) // trim(fileNameExt(statevector,indexStep,indexAnalysis))
      call gsv_writeToFileMpi(statevector,fileNameFull,cetiket,1.0d0, &
                              ip3_in=0,  &
                              indexStep_in=indexStep,  &
                              statevector_ref=statevector_ref)
    enddo

  end subroutine writeToFile4D


  function fileNameExt(statevector,indexStep,indexAnalysis) result(fileNameExtStr)
    implicit none
    ! arguments
    type(struct_gsv)  :: statevector
    integer           :: indexStep, indexAnalysis
    character(len=20) :: fileNameExtStr
    ! locals
    real(8) :: deltaHours
    character(len=4) :: coffset, cmember

    call difdatr(gsv_getDateStamp(statevector,indexStep),tim_getDatestamp(),deltaHours)
    if(nint(deltaHours*60.0d0).lt.0) then
      write(coffset,'(I4.3)') nint(deltaHours*60.0d0)
    else
      write(coffset,'(I3.3)') nint(deltaHours*60.0d0)
    endif

    write(cmember,'(I4.4)') indexAnalysis + (envar_loop-1)*numAnalyses

    fileNameExtStr = '_' // trim(coffset) // 'm' // '_' // trim(cmember)

  end function fileNameExt


  subroutine calcRandomPert(statevector_randpert,numAnalyses,indexAnalysis)
    implicit none
    type(struct_gsv) :: statevector_randpert
    integer :: numAnalyses, indexAnalysis

    integer :: iseed,jj,nlev_T,nlev_M,jvar,jlev,indexAnalysis2
    real(8) :: gasdev,zdum
    real(8), allocatable :: cv_pert_mpiglobal(:), cv_pert_mpilocal(:)
    real(8), pointer :: cv_pert_bens_mpilocal(:), cv_pert_bhi_mpilocal(:), field(:,:,:,:)
    real(8), allocatable :: scaleFactorBhi(:), stddev_orig(:), stddev_trunc(:)
    integer, allocatable :: countTrunc(:)
    logical, save :: firstTime = .true.
    real(8), allocatable, save :: scaleFactorTrunc(:)
    real(8), allocatable, save :: cv_pert_mean_mpilocal(:)
    integer :: lon1, lon2, lat1, lat2

    allocate(cv_pert_mpiglobal(cvm_nvadim_mpiglobal))
    allocate(cv_pert_mpilocal(cvm_nvadim))

    if(firstTime) then
      firstTime = .false.
      ! compute mean perturbation for this batch
      cv_pert_mpiglobal(:) = 0.0d0
      do indexAnalysis2 = 1, numAnalyses
        iseed = abs(tim_getDatestamp()) + indexAnalysis2 + (envar_loop-1)*numAnalyses
        zdum = gasdev(-iseed)
        do jj = 1, cvm_nvadim_mpiglobal
          cv_pert_mpiglobal(jj) = cv_pert_mpiglobal(jj) + gasdev(1)
        enddo
      enddo
      cv_pert_mpiglobal(:) = cv_pert_mpiglobal(:)/real(numAnalyses,8)

      allocate(cv_pert_mean_mpilocal(cvm_nvadim))
      call bmat_reduceToMPILocal(cv_pert_mean_mpilocal,   & ! OUT
                                 cv_pert_mpiglobal,  & ! IN
                                 jj )         ! OUT

    endif ! firstTime

    ! compute perturbation and make mpilocal
    iseed = abs(tim_getDatestamp()) + indexAnalysis + (envar_loop-1)*numAnalyses
    write(*,*) 'min_calcRandomPert: indexAnalysis, iseed=', indexAnalysis, iseed
    zdum = gasdev(-iseed)
    do jj = 1, cvm_nvadim_mpiglobal
      cv_pert_mpiglobal(jj) = gasdev(1)
    enddo

    call bmat_reduceToMPILocal(cv_pert_mpilocal,   & ! OUT
                               cv_pert_mpiglobal,  & ! IN
                               jj )         ! OUT
    deallocate(cv_pert_mpiglobal)

    ! remove the ensemble mean
    cv_pert_mpilocal(:) = cv_pert_mpilocal(:) - cv_pert_mean_mpilocal(:)

    if(pertBhiOnly) then
      ! set Bensemble component of control vector to zero
      cv_pert_bens_mpilocal => cvm_getSubVector(cv_pert_mpilocal,2)
      if(associated(cv_pert_bens_mpilocal)) cv_pert_bens_mpilocal(:) = 0.0d0
    endif

    ! do spectral truncation of control vector
    if(ntrunc_pert.gt.0) then
      cv_pert_bhi_mpilocal => cvm_getSubVector(cv_pert_mpilocal,1)
      call bhi_truncateCV(cv_pert_bhi_mpilocal,ntrunc_pert)
    endif

    call bmat_sqrtB(cv_pert_mpilocal,cvm_nvadim,statevector_randpert)

    if(ntrunc_pert.gt.0) then
    !  call gsv_scaleVertical(statevector_randpert,scaleFactorTrunc)
      write(*,*) 'WARNING: No scaleFactor applied to truncated perturbation!!!'
    endif

    deallocate(cv_pert_mpilocal)

    lon1=statevector_randpert%myLonBeg
    lon2=statevector_randpert%myLonEnd
    lat1=statevector_randpert%myLatBeg
    lat2=statevector_randpert%myLatEnd

    ! undo the Bhi scaleFactor
    if(pertBhiOnly) then
      nlev_T = gsv_getNumLev(statevector_randpert,'TH')
      nlev_M = gsv_getNumLev(statevector_randpert,'MM')
      allocate(scaleFactorBhi(max(nLev_M,nLev_T)))
      call bhi_getScaleFactor(scaleFactorBhi)
      ! for 3D variables
      do jvar=1,vnl_numvarmax3D 
        if(gsv_varExist(vnl_varNameList3D(jvar))) then
          write(*,*) 'min_calcRandomPert: undo Bhi scaleFactor varname= ',vnl_varNameList3D(jvar)
          field => gsv_getField(statevector_randpert,vnl_varNameList3D(jvar))
          do jlev = 1, gsv_getNumLev(statevector_randpert,vnl_vartypeFromVarname(vnl_varNameList3D(jvar)))   
            if(scaleFactorBhi(jlev).gt.0.0d0) then
              field(lon1:lon2,jlev,lat1:lat2,:)=field(lon1:lon2,jlev,lat1:lat2,:)/scaleFactorBhi(jlev)
            endif
          enddo
        endif
      enddo
      ! for 2D variables
      do jvar=1,vnl_numvarmax2D 
        if(gsv_varExist(vnl_varNameList2D(jvar))) then
          field => gsv_getField(statevector_randpert,vnl_varNameList2D(jvar))
          jlev = max(nLev_M,nLev_T)
          if(scaleFactorBhi(jlev).gt.0.0d0) then
            field(lon1:lon2,1,lat1:lat2,:)=field(lon1:lon2,1,lat1:lat2,:)/scaleFactorBhi(jlev)
          endif
        endif
      enddo
      deallocate(scaleFactorBhi)
    endif

    ! apply additional scaling of random perturbation (initially only for UU, VV)
    nlev_T = gsv_getNumLev(statevector_randpert,'TH')
    nlev_M = gsv_getNumLev(statevector_randpert,'MM')
    ! for 3D variables
    do jvar=1,vnl_numvarmax3D 
      if(gsv_varExist(vnl_varNameList3D(jvar)).and.  &
            (trim(vnl_varNameList3D(jvar)).eq.'UU' .or.  &
             trim(vnl_varNameList3D(jvar)).eq.'VV') ) then
        write(*,*) 'min_calcRandomPert: pertScaleFactor_UV varname= ',vnl_varNameList3D(jvar)
        field => gsv_getField(statevector_randpert,vnl_varNameList3D(jvar))
        do jlev = 1, gsv_getNumLev(statevector_randpert,vnl_vartypeFromVarname(vnl_varNameList3D(jvar)))   
          write(*,*) 'min_calcRandomPert: pertScaleFactor_UV= ',jlev,pertScaleFactor_UV(jlev)
          field(lon1:lon2,jlev,lat1:lat2,:)=field(lon1:lon2,jlev,lat1:lat2,:)*pertScaleFactor_UV(jlev)
        enddo
      endif
    enddo

  end subroutine calcRandomPert


  SUBROUTINE simvar(na_indic,na_dim,da_v,da_J,da_gradJ,dataptr_int)
    implicit none
    ! Argument declarations
    integer :: na_dim ! Dimension of the control vector in forecast error coraviances space
    ! Value of na_indic
    ! Note: 1 and 4 are reserved values for call back from m1qn3.
    !       For direct calls use other value than 1 and 4.
    ! =1 No action taken; =4 Both J(u) and its gradient are computed.
    ! =2 Same as 4 (compute J and gradJ) but do not interrupt timer of the
    !    minimizer.
    ! =3 Compute Jo and gradJo only.
    integer :: na_indic 
    real*8  :: da_J ! Cost function of the Variational algorithm
    real*8, dimension(na_dim) :: da_gradJ ! Gradient of the Variational Cost funtion
    real*8, dimension(na_dim) :: da_v ! Control variable in forecast error covariances space
    integer :: dataptr_int(dataptr_int_size)  ! integer work area used to transmit a pointer to the obsSpaceData
    !
    ! Purpose: Implement the Variational solver as described in
    ! Courtier, 1997, Dual formulation of four-dimentional variational assimilation,
    ! Q.J.R., pp2449-2461.
    !
    ! Author : Simon Pellerin *ARMA/MSC October 2005
    !          (Based on previous versions of evaljo.ftn, evaljg.ftn and evaljgns.ftn).
    !
    ! Local declaration
    real*8, dimension(na_dim) :: dl_v
    real*8 :: dl_Jb, dl_Jo
    type(struct_gsv) :: statevector
    type(struct_dataptr) :: dataptr
    type(struct_obs),pointer :: obsSpaceData
    type(struct_columnData),pointer :: column,columng
    type(struct_hco), pointer :: hco_anl

    ! Convert the integer array dataptr_int back into a pointer to the obsSpaceData
    dataptr=transfer(dataptr_int(1:dataptr_int_size),dataptr)
    obsSpaceData => dataptr%obsSpaceData
    column       => dataptr%column
    columng      => dataptr%columng

    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_stop(70)

    call tmg_start(80,'MIN_SIMVAR')
    if (na_indic .ne. 1) then ! No action taken if na_indic == 1
       min_nsim = min_nsim + 1

       if(mpi_myid == 0) then
         write(*,*) 'Entering simvar for simulation ',min_nsim
         write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
         call flush(6)
       endif

       ! note: dg_vbar = sum(v) of previous outer-loops
       dl_v(1:nvadim_mpilocal) = da_v(1:nvadim_mpilocal) + dg_vbar(1:nvadim_mpilocal)     

       ! Computation of background term of cost function:
       dl_Jb = dot_product(dl_v(1:nvadim_mpilocal),dl_v(1:nvadim_mpilocal))/2.d0  
       call tmg_start(89,'MIN_COMM')       
       call mpi_allreduce_sumreal8scalar(dl_Jb,"GRID")
       call tmg_stop(89)

       call gsv_setVco(statevector,col_getVco(columng))
       hco_anl => hco_get('Analysis')
       call gsv_setHco(statevector,hco_anl)
       call gsv_allocate(statevector,tim_nstepobsinc,mpi_local=.true.)

       call bmat_sqrtB(da_v,nvadim_mpilocal,statevector)

       call tmg_start(30,'OBS_INTERP')
       call s2c_tl(statevector,column,columng,obsSpaceData)  ! put in column H_horiz dx
       call tmg_stop(30)

       call tmg_start(40,'OBS_TL')
       call oda_H(column,columng,obsSpaceData)  ! Save as OBS_WORK: H_vert H_horiz dx = Hdx
       call tmg_stop(40)

       call oda_res(obsSpaceData)  ! Calculate OBS_OMA from OBS_WORK : d-Hdx
     
       call oda_sqrtRm1(obsSpaceData,OBS_WORK,OBS_OMA)  ! Save as OBS_WORK : R**-1/2 (d-Hdx)
     
       call oda_Jo(obsSpaceData)  ! Store J-obs in OBS_JOBS : 1/2 * R**-1 (d-Hdx)**2
     
       IF (LVARQC) THEN          
          call oda_qcv(obsSpaceData)  ! Store modified J_obs in OBS_JOBS : -ln((gamma-exp(J))/(gamma+1)) 
       endif

       dl_Jo = 0.d0
       call oda_sumJo(obsSpaceData,dl_Jo)
       da_J = dl_Jb + dl_Jo
       if (na_indic .eq. 3) then
          da_J = dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  JO = ",G23.16,6X)') dl_Jo
       else
          da_J = dl_Jb + dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  Jb = ",G23.16,6X,"JO = ",G23.16,6X,"Jt = ",G23.16)') dl_Jb,dl_Jo,da_J
       endif

       call oda_sqrtRm1(obsSpaceData,OBS_WORK,OBS_WORK)  ! Modify OBS_WORK : R**-1 (d-Hdx)

       IF (LVARQC) THEN
          call oda_qcvad(obsSpaceData)
       endif

       call oda_resT(obsSpaceData)  ! Calculate adjoint of d-Hdx (mult OBS_WORK by -1)

       call col_zero(column)

       call tmg_start(41,'OBS_AD')
       call oda_HT(column,columng,obsSpaceData)   ! Put in column : -H_vert**T R**-1 (d-Hdx)
       call tmg_stop(41)

       call tmg_start(31,'OBS_INTERPAD')
       call s2c_ad(statevector,column,columng,obsSpaceData)  ! Put in statevector -H_horiz**T H_vert**T R**-1 (d-Hdx)
       call tmg_stop(31)

       da_gradJ(:) = 0.d0
       call bmat_sqrtBT(da_gradJ,nvadim_mpilocal,statevector)
       call gsv_deallocate(statevector)

       if (na_indic .ne. 3) then
          da_gradJ(1:nvadim_mpilocal) = dl_v(1:nvadim_mpilocal) + da_gradJ(1:nvadim_mpilocal)
       endif
    endif
    call tmg_stop(80)
    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_start(70,'QN')

    if(mpi_myid.eq.0) write(*,*) 'end of simvar'

  END SUBROUTINE simvar


  SUBROUTINE DSCALQN(KDIM,PX,PY,DDSC,KZS, PZS, DDZS)
    !***s/r DSCALQN: inner product in canonical space
    !*    ------------------- 
    !**    Purpose: interface for the inner product to be used
    !*     .        by the minimization subroutines N1QN3.
    !*
    !*Arguments
    !*     i : KDIM      : dimension of the vectors
    !*     i : PX, PY    : vector for which <PX,PY> is being calculated
    !*     o : DDSC      : result of the inner product
    !*     --------------
    !*     i :  KZS(1)   : unused working space for INTEGER  (not used)
    !*     i :  PZS(1)   : unused working space for REAL     (not used)
    !*     i : PDZS(1)   : unused working space for REAL*8   (not used)
    IMPLICIT NONE

    REAL PZS(1)
    INTEGER KZS(1)
    REAL*8  DDZS(1)

    INTEGER KDIM
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC

    CALL PRSCAL(KDIM,PX,PY,DDSC)
    RETURN
  END SUBROUTINE DSCALQN


  SUBROUTINE PRSCAL(KDIM,PX,PY,DDSC)
    !***s/r PRSCAL: inner product in canonical space
    !*
    !*Author  : P. Gauthier *ARMA/AES  January 27, 1993
    !**    Purpose: evaluation of the inner product used in the
    !*     .        minimization
    !*
    !*Arguments
    !*     i : KDIM     : dimension of the vectors
    !*     i : PX, PY   : vector for which <PX,PY> is being calculated
    !*     o : DDSC     : result of the inner product
    !*
    !* Implicit argument: SCALP(KDIM) assumed to be unity

    IMPLICIT NONE

    INTEGER KDIM, J, RR, IERR
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC
    REAL*8 partialsum(128)
    INTEGER mythread,numthreads,jstart,jend
    INTEGER omp_get_thread_num,omp_get_num_threads

    call tmg_start(71,'QN_PRSCAL')
    DDSC = 0.D0

    do j=1,nvadim_mpilocal
      DDSC = DDSC + PX(J)*PY(J)
    ENDDO

    call tmg_start(79,'QN_COMM')
    call mpi_allreduce_sumreal8scalar(ddsc,"GRID")
    call tmg_stop(79)

    call tmg_stop(71)

    RETURN
  END SUBROUTINE PRSCAL


  SUBROUTINE DCANAB(KDIM,PY,PX,KZS,PZS,PDZS)
    !***s/r DCANAB  - Change of variable associated with the canonical
    !*     .         inner product
    !*
    !*Author    JM Belanger CMDA/SMC   May 2001
    !*     .    Double precision version based on single precision CTCAB.
    !*          Refered to  as dummy argument DTCAB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PX = L^-1 * Py with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation aboutn DTCAB)
    !*     NOTE: L is assumed to be the identity!
    IMPLICIT NONE

    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PX(JDIM) = PY(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANAB


  SUBROUTINE DCANONB(KDIM,PX,PY,KZS,PZS,PDZS)
    !***s/r DCANONB  - Change of variable associated with the canonical
    !*     .          inner product
    !*
    !*Author    JM Belanger CMDA/SMC  May 2001
    !*     .    Double precision version based on single precision CANONB.
    !*          Refered to as dummy argument DTONB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PY = L * PX with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation about DTONB)
    !*     .

    IMPLICIT NONE
    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PY(JDIM) = PX(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANONB


  SUBROUTINE rw_vatra (cfname,status,                       &
          nsim,kbrpstamp,zeps1,zdf1,itertot,isimtot,      &
          nztrl,vatra,vazxbar,vazx,llxbar,llvazx,k1gc,imode)

    !***s/r RW_VATRA  - Read-Write VAZXBAR and VATRA on file
    !*
    !*
    !*Author  : M. Tanguay RPN January 2005
    !*
    !*Arguments
    !*     i   cfname    : precon file
    !*     i   status    : = 0 if READ, = 1 if WRITE
    !*     i   nsim      : Number of simulations in N1QN3
    !*     io  kbrpstamp : Date
    !*     i   zeps1     : Parameter in N1QN3
    !*     i   zdf1      : Parameter in N1QN3
    !*     i   itertot   : Parameter in N1QN3
    !*     i   isimtot   : Parameter in N1QN3
    !*     i   nztrl     : Localisation parameters for Hessian
    !*     i   vatra     : Hessian
    !*     i   vazxbar   : Vazx of previous loop
    !*     i   vazx      : Current state of the minimization
    !*     i   llxbar    : read in vaxzbar if dates are compatible
    !*     i   llvazx    : Logical to read vazx
    !*     i   k1gc      : Minimizer ID (2: m1qn2, 3: m1qn3)
    !*     o   imode     : If status=0, set imode=0 (no prec) or 2 (prec)
    IMPLICIT NONE

    logical llxbar,llvazx

    integer status,kbrpstamp,nsim,itertot,isimtot
    integer, dimension(10), target :: nztrl
    integer k1gc, imode
    real*8 zeps1,zdf1
    real*8, dimension(nvadim_mpilocal), target :: vazxbar, vazx
    real*8, dimension(nmtra), target :: vatra
    real*4, allocatable :: vatravec_r4_mpiglobal(:)
    real*8, allocatable :: vatravec_r8_mpiglobal(:)
    real*8, allocatable :: vazxbar_mpiglobal(:),vazx_mpiglobal(:)

    integer ibrpstamp,ireslun, ierr, fnom, fclos
    integer :: nvadim_mpiglobal,nmtra_mpiglobal
    integer :: cvDim_return
    integer :: ivadim, itrunc
    integer :: imtra,ivamaj
    integer :: jvec, i1gc,ictrlvec,ii,jproc
    integer, dimension(10), target, save :: iztrl

    character(len=*) :: cfname
    character(len=3) :: cl_version

    call tmg_start(88,'MIN_RWHESS')
    if(status.eq.0) then
      if(mpi_myid.eq.0) write(*,*) 'Read  VATRA in RW_VATRA from file ', cfname
    elseif(status.eq.1) then
      if(mpi_myid.eq.0) write(*,*) 'Write VATRA in RW_VATRA to file ', cfname
    else
      call abort3d(" RW_VATRA: status not valid ")
    endif

    call rpn_comm_allreduce(nvadim_mpilocal,nvadim_mpiglobal,1,"mpi_integer","mpi_sum","GRID",ierr)
    call rpn_comm_allreduce(nmtra,          nmtra_mpiglobal, 1,"mpi_integer","mpi_sum","GRID",ierr)

    ireslun=0

    !*     Read Hessian
    !*     ------------

    if(status.eq.0) then

      ierr = fnom(ireslun,cfname,'FTN+SEQ+UNF+OLD+R/O',0)

      ! Checking version number
      read (ireslun) cl_version,i1gc
      if(trim(cl_version) /= 'V2') then
        if(trim(cl_version) == 'V3') then
          if(mpi_myid.eq.0) write(*,*) 'RW_VATRA: using single precision V3 Hessian'
        elseif(trim(cl_version) == 'V4') then
          if(mpi_myid.eq.0) write(*,*) 'RW_VATRA: using single precision V4 Hessian'
        else
          call abort3d(" RW_VATRA: invalid Hessian version")
        endif
      endif
      if (i1gc == 3 .and. i1gc == k1gc) then
        if(mpi_myid.eq.0) write(*,*) trim(cl_version),' M1QN3'
      else
        write(*,*) 'Version, n1gc =',trim(cl_version),i1gc
        call abort3d(" RW_VATRA: Inconsistant input hessian")
      endif

      rewind (ireslun)

      read(ireslun) cl_version,i1gc,nsim,ibrpstamp,zeps1,zdf1,itertot,isimtot,ivadim,itrunc
      if(trim(cl_version) == 'V4') then
        read(ireslun) ivamaj,iztrl
        if((ivamaj.ne.nvamaj).or.(nvadim_mpiglobal.ne.ivadim)) then
          write(*,*) nvamaj,ivamaj,nvadim_mpiglobal,ivadim
          call abort3d(" RW_VATRA : ERROR, size of V4 Hessian not consistent")
        endif
      else
        read(ireslun) imtra,iztrl
        if(.not.(nmtra_mpiglobal.eq.imtra.or.(nmtra_mpiglobal+nvamaj).eq.imtra).or.nvadim_mpiglobal.ne.ivadim) then
          write(*,*) nmtra_mpiglobal,imtra,nvadim_mpiglobal,ivadim
          write(*,*) ' RW_VATRA : ERROR, size of Hessian not consistent, but not stopping!'
!          call abort3d(" RW_VATRA : ERROR, size of Hessian not consistent")
        endif
      endif

      if(k1gc.eq.3) ictrlvec = 2*nvamaj+1

      ! here the mpiglobal vectors are read in and only the mpilocal 
      ! portion is copied from vatravec into vatra
      if(mpi_myid.eq.0) write(*,*) 'RW_VATRA : reading Hessian'
      if(trim(cl_version) == 'V2') then
        allocate(vatravec_r8_mpiglobal(nvadim_mpiglobal))
        do jvec = 1, ictrlvec
          read(ireslun) vatravec_r8_mpiglobal
          call bmat_reduceToMPILocal(  &
            vatra(((jvec-1)*nvadim_mpilocal+1):jvec*nvadim_mpilocal),  &
            vatravec_r8_mpiglobal,cvDim_return)
        enddo
        deallocate(vatravec_r8_mpiglobal)       
      elseif(trim(cl_version) == 'V3' .or. trim(cl_version) == 'V4') then
        allocate(vatravec_r4_mpiglobal(nvadim_mpiglobal))
        allocate(vatravec_r8_mpiglobal(nvadim_mpiglobal))
        ! set to zero, except 1 for "diag" (first vector) for overdimensioned elements
        do jvec = 1, ictrlvec
          read(ireslun) vatravec_r4_mpiglobal
          vatravec_r8_mpiglobal(:)=real(vatravec_r4_mpiglobal(:),8)
          call bmat_reduceToMPILocal(  &
            vatra(((jvec-1)*nvadim_mpilocal+1):jvec*nvadim_mpilocal),  &
            vatravec_r8_mpiglobal,cvDim_return)
        enddo
        deallocate(vatravec_r4_mpiglobal)       
        deallocate(vatravec_r8_mpiglobal)       
      endif

      imode = 2

      if(k1gc.eq.3) then
        nztrl(1) = nvadim_mpilocal
        nztrl(2) = 0
        nztrl(3) = nvamaj
        nztrl(4) = iztrl(4)
        nztrl(5) = iztrl(5)
      endif

      if(ibrpstamp == kbrpstamp .and. llxbar) then
        if(mpi_myid.eq.0) write(*,*) 'RW_VATRA : reading vazxbar'
        allocate(vazxbar_mpiglobal(nvadim_mpiglobal))
        read(ireslun) vazxbar_mpiglobal
        call bmat_reduceToMPILocal(  &
          vazxbar,  &
          vazxbar_mpiglobal,cvDim_return)
        deallocate(vazxbar_mpiglobal)
      endif

      if(ibrpstamp == kbrpstamp .and. llvazx) then
        if(mpi_myid.eq.0) write(*,*) 'RW_VATRA : reading vazx'
        allocate(vazx_mpiglobal(nvadim_mpiglobal))
        read(ireslun) vazx_mpiglobal
        call bmat_reduceToMPILocal(  &
          vazx,  &
          vazx_mpiglobal,cvDim_return)
        deallocate(vazx_mpiglobal)
      endif

      if(ibrpstamp.ne.kbrpstamp) then
        kbrpstamp = ibrpstamp
      endif

      ierr = fclos(ireslun)

      !*     Write Hessian
      !*     -------------

    elseif(status.eq.1) then
      if(mpi_myid.eq.0) ierr = fnom(ireslun,cfname, 'FTN+SEQ+UNF' , 0)
      cl_version = 'V4'
      itrunc=0
      if(mpi_myid.eq.0) write(ireslun) cl_version,k1gc,nsim,kbrpstamp,zeps1,zdf1,itertot,isimtot,nvadim_mpiglobal,itrunc
      if(mpi_myid.eq.0) write(ireslun) nvamaj,nztrl
      if(k1gc.eq.3) ictrlvec = 2*nvamaj+1

      if(mpi_myid.eq.0) allocate(vatravec_r4_mpiglobal(nvadim_mpiglobal))
      allocate(vatravec_r8_mpiglobal(nvadim_mpiglobal))
      do jvec = 1, ictrlvec
        call bmat_expandToMPIGlobal(  &
          vatra(((jvec-1)*nvadim_mpilocal+1):jvec*nvadim_mpilocal),  &
          vatravec_r8_mpiglobal,cvDim_return)
        if(mpi_myid.eq.0) vatravec_r4_mpiglobal(:)=real(vatravec_r8_mpiglobal(:),4)
        if(mpi_myid.eq.0) write(ireslun) vatravec_r4_mpiglobal
      enddo
      if(mpi_myid.eq.0) deallocate(vatravec_r4_mpiglobal)
      deallocate(vatravec_r8_mpiglobal)

      allocate(vazxbar_mpiglobal(nvadim_mpiglobal))
      call bmat_expandToMPIGlobal(  &
        vazxbar,  &
        vazxbar_mpiglobal,cvDim_return)
      if(mpi_myid.eq.0) write(ireslun) vazxbar_mpiglobal(1:nvadim_mpiglobal)
      deallocate(vazxbar_mpiglobal)

      allocate(vazx_mpiglobal(nvadim_mpiglobal))
      call bmat_expandToMPIGlobal(  &
        vazx,  &
        vazx_mpiglobal,cvDim_return)
      if(mpi_myid.eq.0) write(ireslun) vazx_mpiglobal(1:nvadim_mpiglobal)
      deallocate(vazx_mpiglobal)

      if(mpi_myid.eq.0) ierr = fclos(ireslun)
    else
      call abort3d(" RW_VATRA: status not valid ")
    endif

    call tmg_stop(88)

    return
  END SUBROUTINE RW_VATRA

  subroutine grtest2(simul,na_dim,da_x0,na_range,dataptr)
  implicit none
  ! Dummies
  integer, intent(in) :: na_dim ! Size of the control vector
  integer, intent(in) :: na_range ! the test will be carried over values of
                                  ! ALPHA ranging between
                                  ! 10**(-NA_RANGE) < ALPHA < 0.1
  integer, intent(inout) :: dataptr(:)
  real*8,  intent(in), dimension(na_dim) :: da_x0 ! Control vector
  external simul ! simulator: return cost function estimate and its gradient
  !
  !Purpose:
  !to compare the variation of the functional against what the gradient
  !gives for small changes in the control variable. This test should be
  !accurate for values as small as DLALPHA =  SQRT(machine precision).
  !(see Courtier, 1987)
  !
  !Author  : P. Gauthier *ARMA/AES  June 9, 1992
  !
  !Revision:
  !
  !     JM Belanger CMDA/SMC  Oct 2000
  !                   . 32 bits conversion
  !     P. Gauthier ARMA/MSC July 2003
  !                   . Set the output unit through an argument
  !     S. Pellerin ARMA/MSC Oct. 2005
  !                   . Introduction of call back simulator
  !                   . Automatic array (argument cleanup)
  !                   . F90 free style and ODA Norm coding
  !
  ! Local delcarations
  integer :: nl_indic, nl_j,ierr
  real*8  :: dl_wrk(na_dim),dl_gradj0(na_dim), dl_x(na_dim)
  real*8  :: dl_J0, dl_J, dl_test, dl_start,dl_end
  real*8  :: dl_alpha, dl_gnorm0


  ! 1. Initialize dl_gradj0 at da_x0
  !    ------------------------------------

  nl_indic = 2
  call simul(nl_indic,na_dim,da_x0,dl_j0,dl_gradj0,dataptr(1))
  dl_gnorm0 = dot_product(dl_gradj0,dl_gradj0)
  call mpi_allreduce_sumreal8scalar(dl_gnorm0,"GRID")
  dl_start = 1.d0
  dl_end   = 10.0d0**(-na_range)
  write(*,FMT=9100) dl_start,dl_end, dl_j0, dl_gnorm0
  ! 2. Perform the test
  !    ----------------

  if(dl_gnorm0.eq.0.d0)then
     write(*,FMT=9101)
     return
  end if
  write(*,FMT=9200)
  do  nl_j = 1, na_range
     dl_alpha = 10.0d0**(- nl_j)
     dl_x(:) = da_x0(:) - dl_alpha*dl_gradJ0(:)
     call simul(nl_indic,na_dim,dl_x,dl_j,dl_wrk,dataptr(1))
     dl_test = (dl_j-dl_j0)/(-dl_alpha * dl_gnorm0)
     write(*,FMT=9201)nl_j, dl_alpha, dl_j, dl_test
  end do

9100 format(//,4X,&
          'GRTEST- The gradient is being tested for',&
          G23.16,' <= ALPHA <= ',G23.16,/,12X,&
          'Initial value of J(X):',1x,G23.16,4x,&
          'Norm of GRAD J(X)**2: ',G23.16)
9101 format(/,4X,'-In GRTEST: gradient vanishes exactly',&
          '. Gradient test cannot be performed at this point')
9200 format(/,4X,'J',8X,'ALPHA',11X,'J(X)',12X,'TEST')

9201 format(2X,'GRTEST: step',2X,I3,4X,G23.16,4X,G23.16,4X,&
          G23.16)
  return
end subroutine grtest2



END MODULE minimization_mod
