!--------------------------------------------------------------------------
! MODULE minimization (Minimization for variational assimilation.  prefix="min")
!
! Purpose: 
!
! Subroutines (public):
!    min_setup
!    min_minvar
!    min_get_datestamp, min_set_datestamp - access centre of analysis validity
!
! Dependencies:
!
!--------------------------------------------------------------------------
MODULE minimization_mod
  use MathPhysConstants_mod
  use columnData_mod
  use obsSpaceData_mod
  use controlVector_mod
  use mpi
  use gridStateVector_mod
  use bmatrix_mod

  implicit none
  save
  private

  public              :: min_Setup, min_minvar,lvarqc,min_niter
  public              :: min_get_datestamp, min_set_datestamp

  type struct_dataptr
    type(struct_obs),pointer        :: lobsSpaceData
    type(struct_columnData),pointer :: lcolumn
    type(struct_columnData),pointer :: lcolumng
  end type struct_dataptr

  logical             :: initialized = .false.
  real*8, pointer     :: dg_vbar(:)

  character(len=10)   :: crestart='wrmrestart'
  integer             :: nulout =6
  integer             :: nmtra,nmtra_mpiglobal,nwork,nsim3d
  integer             :: ni,nj,nt
  integer             :: nvadim_beg,nvadim_end,nvadim_mpilocal,nvadim_mpilocalmax,nvadim_mpiglobal ! for mpi
  integer             :: min_niter
  integer             :: dataptr_int_size=0
  integer             :: datestamp      ! window centre of analysis validity

  ! namelist variables
  INTEGER N1GC,NVAMAJ,NIMPRES,NITERMAX,NSIMMAX,niterjob
  INTEGER NGRTEST,NGRANGE
  LOGICAL LRSTART,lxbar,lwrthess
  REAL*8 REPSG,rdf1fac
  LOGICAL LVARQC
  integer :: nwoqcv

  NAMELIST /NAMMIN/N1GC,NVAMAJ,NIMPRES,NITERMAX,NSIMMAX,NITERJOB  
  NAMELIST /NAMMIN/NGRTEST,NGRANGE
  NAMELIST /NAMMIN/LRSTART,lxbar,lwrthess
  NAMELIST /NAMMIN/REPSG,rdf1fac
  NAMELIST /NAMMIN/LVARQC,NWOQCV

CONTAINS

  SUBROUTINE min_setup(nvadim_mpiglobal_in,ni_in,nj_in,nt_in)
    implicit none
    integer :: nvadim_mpiglobal_in,ni_in,nj_in,nt_in

    integer :: ierr,nulnam
    integer :: fnom,fclos

    if(nvadim_mpiglobal_in.ne.cvm_nvadim) then
      write(*,*) 'nvadim_mpiglobal,cvm_nvadim=',nvadim_mpiglobal,cvm_nvadim
      call abort3d('aborting in min_setup: control vector dimension not consistent')
    endif

    nsim3d=0 

    ni=ni_in
    nj=nj_in
    nt=nt_in
    nvadim_mpiglobal=nvadim_mpiglobal_in
    nvadim_beg = 1+(mpi_myid*ceiling(real(nvadim_mpiglobal)/real(mpi_nprocs)))
    nvadim_end = min((mpi_myid+1)*ceiling(real(nvadim_mpiglobal)/real(mpi_nprocs)),nvadim_mpiglobal)
    nvadim_mpilocal = nvadim_end-nvadim_beg+1
    call rpn_comm_allreduce(nvadim_mpilocal,nvadim_mpilocalmax,1,"mpi_integer","mpi_max","GRID",ierr)

    ! set default values for namelist variables
    N1GC = 3
    NVAMAJ = 6
    NIMPRES =  5
    NITERMAX = 400
    RDF1FAC  = 0.25d0
    NITERJOB = -1
    NSIMMAX  = 500
    NGRTEST  = 0
    NGRANGE  = 10
    lwrthess =.true.
    lxbar    = .true.
    REPSG    = 1e-3
    LRSTART  = .FALSE.
    LVARQC   = .false.
    NWOQCV   = 5

    ! read in the namelist NAMMIN
    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=nammin,iostat=ierr)
    write(*,*) 'minimization: reading namelist, ierr=',ierr
    write(*,nml=nammin)
    ierr=fclos(nulnam)

    allocate(dg_vbar(nvadim_mpilocalmax),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'minimization: Problem allocating memory! id=1',ierr
      call abort3d('aborting in min_setup')
    endif
    dg_vbar(:)=0.0d0

    IF(N1GC.EQ.3)THEN
      NMTRA = (4 + 2*NVAMAJ)*nvadim_mpilocalmax
      NMTRA_mpiglobal = (4 + 2*NVAMAJ)*NVADIM_MPIGLOBAL 
    ELSE
      call abort3d('min_setup: only N1GC=3 currently supported!') 
    END IF
    WRITE(*,9401)N1GC,NVAMAJ,NVADIM_MPIGLOBAL,NMTRA
 9401 FORMAT(4X,'N1GC = ',I2,4X,'NVAMAJ = ',I3,/5X,"NVADIM_MPIGLOBAL =",1x,I14,3X,"NMTRA =",1X,I14)
    write(*,*) 'min_setup: nvadim_mpiglobal,_beg,_end,_mpilocal,_mpilocalmax=',  &
               nvadim_mpiglobal,nvadim_beg,nvadim_end,nvadim_mpilocal,nvadim_mpilocalmax
    write(*,*) 'min_setup: nmtra,nmtra_mpiglobal=',nmtra,nmtra_mpiglobal

    IF (LVARQC) WRITE(*,*) 'VARIATIONAL QUALITY CONTROL ACTIVATED.'

    initialized=.true.

  END SUBROUTINE min_setup


  SUBROUTINE min_minvar(lnlvtov,lpcon,lrestart,cpconf,lcolumn,lcolumng,lobsSpaceData)
!
! Purpose:
! 3D/En VAR minimization
!
      IMPLICIT NONE

      type(struct_columnData),target :: lcolumn,lcolumng
      type(struct_obs),target :: lobsSpaceData
      type(struct_dataptr) :: dataptr 
      integer,allocatable :: dataptr_int(:) ! obs array used to transmit pointer

      logical lnlvtov,lpcon,lrestart
      CHARACTER(len=*) :: cpconf

      INTEGER IZS(1),IZTRL(10)
      REAL ZZSUNUSED(1)

      real*8,allocatable :: vazg(:)
      real*8,allocatable :: vazx(:) ! mpi local version of cvm_vazx
      real*8,allocatable :: vatra(:)
      real*8,allocatable :: vazx_mpiglobalmax(:)

      REAL*8 DLDS(1)
      LOGICAL LLTEST,llvarqc, llstop, lldf1, lrdvatra, llvazx, llxbar

      INTEGER IMPRES, IMODE, ITERMAX, iterdone, ISIMMAX, INDIC, IITNOVQC, jj
      INTEGER IERR,ITERTOT,isimdone,isimtot,jdata, ISIMNOVQC
      integer ireslun,ibrpstamp,isim3d
      INTEGER IPRECON,ILEN
      REAL*8 ZJSP, ZXMIN, ZDF1, ZEPS0, ZEPS1
      REAL*8 DLGNORM, DLXNORM, ZJOTOV

      INTEGER FNOM,FCLOS, remove_c
      EXTERNAL FNOM,FCLOS
      EXTERNAL  N1QN3
      real*8 :: zeps0_000,zdf1_000
      integer :: iterdone_000,isimdone_000
      character(len=128) :: clfname

! 
!     allocation (these are all mpilocalmax arrays)
!
      allocate(vazx(nvadim_mpilocalmax),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=3',ierr
        call abort3d('aborting in min_minvar')
      endif
      vazx(:)=0.0d0
      ! extra mpilocal portion of control vector:
      vazx(:)=cvm_vazx(nvadim_beg:nvadim_end) 

      allocate(vazg(nvadim_mpilocalmax),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=2',ierr
        call abort3d('aborting in min_minvar')
      endif
      vazg(:)=0.0d0

      allocate(vatra(nmtra),stat=ierr)
      if(ierr.ne.0.or.nmtra.le.0) then
        write(*,*) 'minimization: Problem allocating memory! id=4',ierr
        write(*,*) 'minimization: nmtra=',nmtra
        call abort3d('aborting in min_minvar')
      endif
      vatra(:)=0.0d0

!
! Prepare for non-linear processing of 'TO' data:
!    - fill PZDBLPRIM8 with Z" = H(xb_lr) + Z'
!                              = H(xb_lr) - H(xb_hr) + Z
      if ( lnlvtov ) then
        call tmg_start(48,'NL_OBS_OPER')
        call tovs_obs ('LR',ZJOTOV,lcolumng,lobsSpaceData)
        call tmg_stop(48)
      endif

      ITERTOT  = 0
      isimtot = 0

      ZXMIN = epsilon(ZXMIN)

      ! recast pointer to obsSpaceData as an integer array, so it can be passed through n1qn3 to simvar
      dataptr%lobsSpaceData => lobsSpaceData
      dataptr%lcolumn       => lcolumn
      dataptr%lcolumng      => lcolumng
      dataptr_int_size = size(transfer(dataptr,dataptr_int))
      allocate(dataptr_int(dataptr_int_size),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'minimization: Problem allocating memory! id=2',ierr
        call abort3d('aborting in min_minvar')
      endif
      dataptr_int(1:dataptr_int_size)=transfer(dataptr,dataptr_int)

!     *    2. Set-up the minimization
!     .  -----------------------
      llvarqc = lvarqc

!     If minimization start without qcvar : turn off varqc to compute
!     innovations and test the gradients

      ireslun=0
      lldf1 = .true.
      if(niterjob /= -1 .and. lrestart) then
        write(*,*) 'Minimize : Restart mode'
        lrdvatra = .true.
        clfname = crestart
        imode = 2
        llvazx = .true.
        llxbar = .true.
      elseif (lpcon) then
        write(*,*) 'Minimize : Preconditioning mode'
        lrdvatra = .true.
        clfname = cpconf
        imode = 2
        llvazx = .false.
        llxbar = lxbar ! from namelist (default is .true.)
      else
        lrdvatra = .false.
        imode = 0
        zeps0 = repsg
      endif
      if(.not.(imode.eq.0.or.imode.eq.2)) call abort3d(' RW_VATRA not done ')

      if (lrdvatra) then
        ibrpstamp = min_get_datestamp() ! ibrpstamp is a I/O argument of rw_vatra

        if(n1gc.eq.3) then
          call rw_vatra (clfname,0,                            &
            isim3d,ibrpstamp,zeps0_000,zdf1_000,iterdone_000   &
            ,isimdone_000,iztrl,vatra,dg_vbar,    &
            vazx,llxbar,llvazx,n1gc,imode)

        endif

        if(niterjob /= -1 .and. lrestart) then
          ierr = remove_c(clfname)
          nsim3d = isim3d
          write(*,*) 'MINVAR : NSIM3D read from precon file: ',nsim3d 
          zeps0  = zeps0_000
          zdf1   = zdf1_000
          lldf1 = .false. ! don't re-compute df1 base on Cost function
          iterdone = iterdone_000
          isimdone = isimdone_000 - 1
          itermax = min(nitermax - iterdone + 1, niterjob)
          isimmax = nsimmax - isimdone + 1
          if (iterdone < nwoqcv) lvarqc = .false.
        else
          if (ibrpstamp == min_get_datestamp() .and. lxbar) then
            zeps0  = zeps0_000
            zdf1   = zdf1_000
            lldf1 = .false.     ! don't re-compute df1 base on Cost function
          else
            zeps0 = repsg
            lldf1 = .true.      ! Compute df1 base on Cost function
          endif
        endif
      endif

      if(niterjob == -1 .or. .not. lrestart) then
        iterdone = 0
        isimdone = 0
        if (niterjob /= -1) then
          itermax = min(nitermax,niterjob)
        else
          itermax = nitermax
        endif
        isimmax = nsimmax

        if (nwoqcv > 0) lvarqc = .false.

        if(ngrtest.ne.0) then
          call grtest2(simvar,nvadim_mpilocalmax,vazx,ngrange)
        endif

      endif

      zeps1 = zeps0

      itertot = iterdone
      isimtot = isimdone

!     *    2. Set-up the minimization
!     .  -----------------------
!
!     *    .   Test the gradient again at the initial point WITH PRECON
!     .   --------------------------------------------------------
!
!     .   2.1.4 Test the complete functional
!
!     *    .   2.2  Compute the value of J(X) and the gradient
!     .        at the initial point
!
      INDIC =2

      call simvar(indic,nvadim_mpilocalmax,vazx,zjsp,vazg,dataptr_int(1))

      if (lldf1) ZDF1     =  rdf1fac * ABS(ZJSP)

!     Put QCVAR logical to its original values

      lvarqc=llvarqc

      CALL PRSCAL(nvadim_mpilocalmax,VAZG,VAZG,DLGNORM)
      DLGNORM = DSQRT(DLGNORM)
      CALL PRSCAL(nvadim_mpilocalmax,VAZX,VAZX,DLXNORM)
      DLXNORM = DSQRT(DLXNORM)
      WRITE(*,*)' |X| = ', DLXNORM
      WRITE(*,FMT=9220) ZJSP, DLGNORM
 9220 FORMAT(/4X,'J(X) = ',G23.16,4X,'|Grad J(X)| = ',G23.16)

!     *    .   2.4. Constants required by MODULOPT
!     .        ------------------------------

      IMPRES   =  NIMPRES

!     *    3. Iterations of the minimization algorithm
!     .  ----------------------------------------


!     *    .   3.2 Starting point of the minimization written to
!     .       RPN standard output file

      IF(N1GC.EQ.3) THEN
      WRITE(*,FMT=9320)ZXMIN,ZDF1,ZEPS0,IMPRES,NITERMAX,NSIMMAX
      ENDIF

 9320 FORMAT(//,10X,' Minimization N1QN3 starts ...',/  &
          10x,'DXMIN =',G23.16,2X,'DF1 =',G23.16,2X,'EPSG =',G23.16  &
          /,10X,'IMPRES =',I3,2X,'NITER = ',I3,2X,'NSIM = ',I3,//  &
          ,15X,'-STARTING POINT IS WRITTEN TO FILE ...')

!     *    .   3.3 Beginning the minimization
!     .       --------------------------

      llstop = .false.
      if (lvarqc .and. nwoqcv > 0 .and. iterdone < nwoqcv) then
        iitnovqc = min(nwoqcv - iterdone,itermax)
        isimnovqc = isimmax
        lvarqc = .false.
        call tmg_start(70,'QN')
        call n1qn3(simvar, dscalqn, dcanonb, dcanab, nvadim_mpilocalmax, vazx,  &
            zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode       &
            ,iitnovqc, isimnovqc ,iztrl, vatra, nmtra, dataptr_int(1), zzsunused  &
            ,dlds)
        call tmg_stop(70)

        isimnovqc = isimnovqc - 1
        itermax = itermax - iitnovqc + 1
        isimmax = isimmax - isimnovqc + 1

        itertot = itertot + iitnovqc
        isimtot = isimtot + isimnovqc

        zeps1 = zeps0/zeps1
        zeps0 = zeps1
        lvarqc = .true.

        if (imode == 4 .and. itertot < nitermax) then
          imode = 2
          INDIC = 2
          call simvar(indic,nvadim_mpilocalmax,vazx,zjsp,vazg,dataptr_int(1))
        else
          llstop = .true.
          call abort3d(" MINIMIZATION_MOD: n1qn3 mode ne 4")
        endif
      endif

      if (.not. llstop) then

        if(N1GC.EQ.3) then

          call tmg_start(70,'QN')
          call n1qn3(simvar, dscalqn, dcanonb, dcanab, nvadim_mpilocalmax, vazx,  &
              zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode,   &
              itermax,isimmax, iztrl, vatra, nmtra, dataptr_int(1), zzsunused,   &
              dlds)
          call tmg_stop(70)
          itertot = itertot + itermax
          isimtot = isimtot + isimmax

          zeps1 = zeps0/zeps1

        endif

      endif

!     if lrestart remain false... postmin will execute
      lrestart = .false.
      ireslun=0
      if (niterjob /= -1 .and. itertot < nitermax .and. imode == 4) then
        clfname = crestart
!     Careful: lrestart before minimisation was used to trigger a
!     read of restart file... now it is set to .true. to avoid
!     execution of postmin.
        lrestart = .true.
      else
        do jdata = 1, nvadim_mpilocal
          dg_vbar(jdata) = vazx(jdata) + dg_vbar(jdata)
        enddo
        clfname = 'pm1q'
      endif

      if(lwrthess) then
        if(n1gc.eq.3) then
        call rw_vatra (clfname,1,  &
          nsim3d,min_get_datestamp(),zeps1,zdf1,itertot,isimtot,  &
          iztrl,vatra,dg_vbar,vazx,.true.,llvazx,n1gc,imode)

        endif
      endif

      WRITE(*,FMT=9500) imode,iterdone,itertot-iterdone,itertot,isimdone,isimtot-isimdone,isimtot
 9500 FORMAT(//,20X,20('*'),2X    &
          ,/,20X,'              Minimization ended with MODE:',I4  &
          ,/,20X,' Number of iterations done in previous job:',I4  &
          ,/,20X,'          Number of iterations in this job:',I4  &
          ,/,20X,'                Total number of iterations:',I4  &
          ,/,20X,'Number of simulations done in previous job:',I4  &
          ,/,20X,'         Number of simulations in this job:',I4  &
          ,/,20X,'               Total number of simulations:',I4)

      min_niter = itertot

!     *    4. Test the gradient at the final point if NGRTEST=1
!     .  ------------------------------------

 400  CONTINUE

      if ((NGRTEST.ne.0 .and. IMODE.ne.4 .and. .not. LRSTART)) then
        WRITE(*,FMT=9400)
 9400   FORMAT(//,12X,40('**'),/,12X,'TESTING THE GRADIENT AT THE FINAL POINT',/,40('**'))

        call grtest2(simvar,nvadim_mpilocalmax,vazx,ngrange)

      END IF

      call tmg_start(89,'MIN_COMM')
      ! transfer the mpilocal vazx into global cvm_vazx
      allocate(vazx_mpiglobalmax(nvadim_mpilocalmax*mpi_nprocs))
      call rpn_comm_allgather(vazx             ,nvadim_mpilocalmax,"mpi_double_precision", &
                              vazx_mpiglobalmax,nvadim_mpilocalmax,"mpi_double_precision", &
                              "grid",ierr)
      cvm_vazx(:)=vazx_mpiglobalmax(1:nvadim_mpiglobal)      
      deallocate(vazx_mpiglobalmax)
      call tmg_stop(89)

      deallocate(vazx,stat=ierr)
      deallocate(vazg,stat=ierr)
      deallocate(vatra,stat=ierr)

      RETURN
  END SUBROUTINE min_minvar


   subroutine min_set_datestamp(datestamp_in)
      !
      ! object: to control access to the minimization object.  Sets the date
      !         of the window centre of analysis validity to the indicated value.

      implicit none
      integer, intent(in) :: datestamp_in

      datestamp = datestamp_in

   end subroutine min_set_datestamp


   function min_get_datestamp() result(datestamp_out)
      !
      ! object: to control access to the minimization object.  Returns the date
      !         of the window centre of analysis validity.

      implicit none
      integer :: datestamp_out

      datestamp_out = datestamp

   end function min_get_datestamp


  SUBROUTINE simvar(na_indic,na_dim,da_v,da_J,da_gradJ,dataptr_int)
    implicit none
    ! Argument declarations
    integer :: na_dim ! Dimension of the control vector in forecast error coraviances space
    ! Value of na_indic
    ! Note: 1 and 4 are reserved values for call back from m1qn3.
    !       For direct calls use other value than 1 and 4.
    ! =1 No action taken; =4 Both J(u) and its gradient are computed.
    ! =2 Same as 4 (compute J and gradJ) but do not interrupt timer of the
    !    minimizer.
    ! =3 Compute Jo and gradJo only.
    integer :: na_indic 
    real*8  :: da_J ! Cost function of the Variational algorithm
    real*8, dimension(na_dim) :: da_gradJ ! Gradient of the Variational Cost funtion
    real*8, dimension(na_dim) :: da_v ! Control variable in forecast error covariances space
    integer :: dataptr_int(dataptr_int_size)  ! integer work area used to transmit a pointer to the obsSpaceData
    !
    ! Purpose: Implement the Variational solver as described in
    ! Courtier, 1997, Dual formulation of four-dimentional variational assimilation,
    ! Q.J.R., pp2449-2461.
    !
    ! Author : Simon Pellerin *ARMA/MSC October 2005
    !          (Based on previous versions of evaljo.ftn, evaljg.ftn and evaljgns.ftn).
    !
    ! Local declaration
    integer :: ierr,jj
    real*8, dimension(na_dim) :: dl_v
    real*8, dimension(nvadim_mpiglobal) :: da_v_mpiglobal
    real*8, dimension(nvadim_mpiglobal) :: da_gradJ_mpiglobal
    real*8, dimension(nvadim_mpilocalmax*mpi_nprocs) :: da_v_mpiglobalmax
    real*8 :: dl_Jb, dl_Jo
    type(struct_gsv) :: statevector
    type(struct_dataptr) :: dataptr
    type(struct_obs),pointer :: lobsSpaceData
    type(struct_columnData),pointer :: lcolumn,lcolumng

    ! Convert the integer array dataptr_int back into a pointer to the obsSpaceData
    dataptr=transfer(dataptr_int(1:dataptr_int_size),dataptr)
    lobsSpaceData => dataptr%lobsSpaceData
    lcolumn       => dataptr%lcolumn
    lcolumng      => dataptr%lcolumng

    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_stop(70)

    call tmg_start(80,'SIMVAR')
    if (na_indic .ne. 1) then ! No action taken if na_indic == 1
       nsim3d = nsim3d + 1

       if(mpi_myid == 0) then
         write(*,*) 'Entering simvar for simulation ',nsim3d
         call flush(6)
       endif

       ! note: dg_vbar = sum(v) of previous outer-loops
       dl_v(1:nvadim_mpilocal) = da_v(1:nvadim_mpilocal) + dg_vbar(1:nvadim_mpilocal)     

       ! Computation of background term of cost function:
       dl_Jb = dot_product(dl_v(1:nvadim_mpilocal),dl_v(1:nvadim_mpilocal))/2.d0  
       call tmg_start(89,'MIN_COMM')       
       call rpn_comm_allreduce(dl_Jb,dl_Jb,1,"mpi_double_precision","mpi_sum","GRID",ierr)
       call tmg_stop(89)

       call gsv_setVco(statevector,col_getVco(lcolumng))
       call gsv_allocate(statevector,ni,nj,nt,mpi_local=.true.)

       ! transfer mpilocal da_v to mpiglobal da_v_mpiglobal
       call tmg_start(89,'MIN_COMM')
       call rpn_comm_allgather(da_v             ,nvadim_mpilocalmax,"mpi_double_precision", &
                               da_v_mpiglobalmax,nvadim_mpilocalmax,"mpi_double_precision", &
                               "grid",ierr)
       da_v_mpiglobal(:)=da_v_mpiglobalmax(1:nvadim_mpiglobal)      
       call tmg_stop(89)

       call bmat_sqrtB(da_v_mpiglobal,nvadim_mpiglobal,statevector)

       call tmg_start(30,'OBS_INTERP')
       call oda_L(statevector,lcolumn,lcolumng,lobsSpaceData)  ! put in column H_horiz dx
       call tmg_stop(30)

       call tmg_start(40,'OBS_TL')
       call oda_H(lcolumn,lcolumng,lobsSpaceData)  ! Modify OBS_OMA ! H_vert H_horiz dx = Hdx
       call tmg_stop(40)

       call oda_res(lobsSpaceData)  ! Modify OBS_OMA : Hdx-d
     
       call oda_sqrtRm1(lobsSpaceData,OBS_OMA,OBS_OMA)  ! Modify OBS_OMA : R**-1/2 (Hdx-d)
     
       call oda_Jo(lobsSpaceData)  ! Temporarily store Jobs in OBS_OMI : 1/2 * R**-1 (Hdx-d)**2
     
       IF (LVARQC) THEN          
          call oda_qcv(lobsSpaceData)  ! Store modify Jobs in OBS_OMI : -ln((gamma-exp(J))/(gamma+1))  
       endif

       dl_Jo = 0.d0
       call oda_sumJo(lobsSpaceData,dl_Jo)
       da_J = dl_Jb + dl_Jo
       if (na_indic .eq. 3) then
          da_J = dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  JO = ",G23.16,6X)') dl_Jo
       else
          da_J = dl_Jb + dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  Jb = ",G23.16,6X,"JO = ",G23.16,6X,"Jt = ",G23.16)') dl_Jb,dl_Jo,da_J
       endif

       call oda_sqrtRm1(lobsSpaceData,OBS_OMI,OBS_OMA)  ! Modify OBS_OMI : R**-1 (Hdx-d)

       IF (LVARQC) THEN
          call oda_qcvad(lobsSpaceData)
       endif

       call col_zero(lcolumn)

       call tmg_start(41,'OBS_AD')
       call oda_HT(lcolumn,lcolumng,lobsSpaceData)   ! Put in column : H_vert**T R**-1 (Hdx-d)
       call tmg_stop(41)

       call tmg_start(31,'OBS_INTERPAD')
       call oda_LT(statevector,lcolumn,lcolumng,lobsSpaceData)  ! Put in statevector H_horiz**T H_vert**T R**-1 (Hdx-d)
       call tmg_stop(31)

       da_gradJ_mpiglobal(:) = 0.d0
       call bmat_sqrtBT(da_gradJ_mpiglobal,nvadim_mpiglobal,statevector)
       call gsv_deallocate(statevector)

       ! make da_gradJ_mpiglobal mpilocal
       da_gradJ(nvadim_mpilocal:nvadim_mpilocalmax)=0.0d0
       da_gradJ(1:nvadim_mpilocal)=da_gradJ_mpiglobal(nvadim_beg:nvadim_end)

       if (na_indic .ne. 3) then
          da_gradJ(1:nvadim_mpilocal) = dl_v(1:nvadim_mpilocal) + da_gradJ(1:nvadim_mpilocal)
       endif
       
    endif
    call tmg_stop(80)
    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_start(70,'QN')

    write(*,*) 'end of simvar'
    call flush(6)

  END SUBROUTINE simvar


  SUBROUTINE DSCALQN(KDIM,PX,PY,DDSC,KZS, PZS, DDZS)
    !***s/r DSCALQN: inner product in canonical space
    !*    ------------------- 
    !**    Purpose: interface for the inner product to be used
    !*     .        by the minimization subroutines N1QN3.
    !*
    !*Arguments
    !*     i : KDIM      : dimension of the vectors
    !*     i : PX, PY    : vector for which <PX,PY> is being calculated
    !*     o : DDSC      : result of the inner product
    !*     --------------
    !*     i :  KZS(1)   : unused working space for INTEGER  (not used)
    !*     i :  PZS(1)   : unused working space for REAL     (not used)
    !*     i : PDZS(1)   : unused working space for REAL*8   (not used)
    IMPLICIT NONE

    REAL PZS(1)
    INTEGER KZS(1)
    REAL*8  DDZS(1)

    INTEGER KDIM
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC

    CALL PRSCAL(KDIM,PX,PY,DDSC)
    RETURN
  END SUBROUTINE DSCALQN


  SUBROUTINE PRSCAL(KDIM,PX,PY,DDSC)
    !***s/r PRSCAL: inner product in canonical space
    !*
    !*Author  : P. Gauthier *ARMA/AES  January 27, 1993
    !**    Purpose: evaluation of the inner product used in the
    !*     .        minimization
    !*
    !*Arguments
    !*     i : KDIM     : dimension of the vectors
    !*     i : PX, PY   : vector for which <PX,PY> is being calculated
    !*     o : DDSC     : result of the inner product
    !*
    !* Implicit argument: SCALP(KDIM) assumed to be unity

    IMPLICIT NONE

    INTEGER KDIM, J, RR, IERR
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC
    REAL*8 partialsum(128)
    INTEGER mythread,numthreads,jstart,jend
    INTEGER omp_get_thread_num,omp_get_num_threads

    call tmg_start(71,'QN_PRSCAL')
    DDSC = 0.

    do j=1,nvadim_mpilocal
      DDSC = DDSC + PX(J)*PY(J)
    ENDDO

    call tmg_start(79,'QN_COMM')
    call rpn_comm_allreduce(ddsc,ddsc,1,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call tmg_stop(79)

    call tmg_stop(71)

    RETURN
  END SUBROUTINE PRSCAL


  SUBROUTINE DCANAB(KDIM,PY,PX,KZS,PZS,PDZS)
    !***s/r DCANAB  - Change of variable associated with the canonical
    !*     .         inner product
    !*
    !*Author    JM Belanger CMDA/SMC   May 2001
    !*     .    Double precision version based on single precision CTCAB.
    !*          Refered to  as dummy argument DTCAB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PX = L^-1 * Py with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation aboutn DTCAB)
    !*     NOTE: L is assumed to be the identity!
    IMPLICIT NONE

    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PX(JDIM) = PY(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANAB


  SUBROUTINE DCANONB(KDIM,PX,PY,KZS,PZS,PDZS)
    !***s/r DCANONB  - Change of variable associated with the canonical
    !*     .          inner product
    !*
    !*Author    JM Belanger CMDA/SMC  May 2001
    !*     .    Double precision version based on single precision CANONB.
    !*          Refered to as dummy argument DTONB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PY = L * PX with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation about DTONB)
    !*     .

    IMPLICIT NONE
    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PY(JDIM) = PX(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANONB


  SUBROUTINE rw_vatra (cfname,status,                       &
          nsim3d,kbrpstamp,zeps1,zdf1,itertot,isimtot,      &
          nztrl,vatra,vazxbar,vazx,lxbar,lvazx,k1gc,imode)

    !***s/r RW_VATRA  - Read-Write VAZXBAR and VATRA on file
    !*
    !*
    !*Author  : M. Tanguay RPN January 2005
    !*
    !*Arguments
    !*     i   cfname    : precon file
    !*     i   status    : = 0 if READ, = 1 if WRITE
    !*     i   nsim3d    : Number of simulations in N1QN3
    !*     io  kbrpstamp : Date
    !*     i   zeps1     : Parameter in N1QN3
    !*     i   zdf1      : Parameter in N1QN3
    !*     i   itertot   : Parameter in N1QN3
    !*     i   isimtot   : Parameter in N1QN3
    !*     i   nztrl     : Localisation parameters for Hessian
    !*     i   vatra     : Hessian
    !*     i   vazxbar   : Vazx of previous loop
    !*     i   vazx      : Current state of the minimization
    !*     i   lxbar     : read in vaxzbar if dates are compatible
    !*     i   lvazx     : Logical to read vazx
    !*     i   k1gc      : Minimizer ID (2: m1qn2, 3: m1qn3)
    !*     o   imode     : If status=0, set imode=0 (no prec) or 2 (prec)
    IMPLICIT NONE

    logical lxbar,lvazx

    integer status,kbrpstamp,nsim3d,itertot,isimtot
    integer, dimension(10), target :: nztrl
    integer k1gc, imode
    real*8 zeps1,zdf1
    real*8, dimension(nvadim_mpilocalmax), target :: vazxbar, vazx
    real*8, dimension(nmtra), target :: vatra
    real*4, allocatable :: vatravec_r4_mpiglobal(:),vatravec_r4_mpilocalmax(:)
    real*8, allocatable :: vatravec_r8_mpiglobal(:)
    real*8, allocatable :: vazxbar_mpilocalmax(:),vazx_mpilocalmax(:)
    real*8, allocatable :: vazxbar_mpiglobal(:),vazx_mpiglobal(:)

    integer ibrpstamp,ireslun, ierr, fnom, fclos
    integer :: ivadim, imtra, itrunc
    integer :: jvec, i1gc,ictrlvec,ii
    integer, dimension(10), target, save :: iztrl

    character(len=*) :: cfname
    character(len=3) :: cl_version

    call tmg_start(88,'MIN_RWHESS')
    if(status.eq.0) then
      write(*,*) 'Read  VATRA in RW_VATRA'
    elseif(status.eq.1) then
      write(*,*) 'Write VATRA in RW_VATRA'
    else
      call abort3d(" RW_VATRA: status not valid ")
    endif

    ireslun=0

    !*     Read Hessian
    !*     ------------

    if(status.eq.0) then

      ierr = fnom(ireslun,cfname,'FTN+SEQ+UNF+OLD+R/O',0)

      ! Checking version number
      read (ireslun) cl_version,i1gc
      if(trim(cl_version) /= 'V2') then
        if(trim(cl_version) == 'V3') then
          write(*,*) 'RW_VATRA: using single precision Hessian'
        else
          call abort3d(" RW_VATRA: invalid Hessian version")
        endif
      endif
      if (i1gc == 3 .and. i1gc == k1gc) then
        write(*,*) trim(cl_version),' M1QN3'
      else
        write(*,*) 'Version, n1gc =',trim(cl_version),i1gc
        call abort3d(" RW_VATRA: Inconsistant input hessian")
      endif

      rewind (ireslun)

      read(ireslun) cl_version,i1gc,nsim3d,ibrpstamp,zeps1,zdf1,itertot,isimtot,ivadim,itrunc
      read(ireslun) imtra,iztrl

      if(.not.(nmtra_mpiglobal.eq.imtra.or.(nmtra_mpiglobal+nvamaj).eq.imtra).or.nvadim_mpiglobal.ne.ivadim) then
        write(*,*) nmtra_mpiglobal,imtra,nvadim_mpiglobal,ivadim
        call abort3d(" RW_VATRA : ERROR, size of Hessian not consistent")
      endif

      if(k1gc.eq.3) ictrlvec = 2*nvamaj+1

      ! here the mpiglobal vectors are read in and only the mpilocal 
      ! portion is copied from vatravec into vatra
      write(*,*) 'RW_VATRA : reading Hessian'
      if(trim(cl_version) == 'V2') then
        allocate(vatravec_r8_mpiglobal(nvadim_mpiglobal))
        vatra(:)=0.0d0
        vatra(1:nvadim_mpilocalmax)=1.0d0 
        do jvec = 1, ictrlvec
          read(ireslun) vatravec_r8_mpiglobal
          vatra((jvec-1)*nvadim_mpilocalmax+1:((jvec-1)*nvadim_mpilocalmax+nvadim_mpilocal))= &
            vatravec_r8_mpiglobal(nvadim_beg:nvadim_end)
        enddo
        deallocate(vatravec_r8_mpiglobal)       
      elseif(trim(cl_version) == 'V3') then
        allocate(vatravec_r4_mpiglobal(nvadim_mpiglobal))
        ! set to zero, except 1 for "diag" (first vector) for overdimensioned elements
        vatra(:)=0.0d0
        vatra(1:nvadim_mpilocalmax)=1.0d0 
        do jvec = 1, ictrlvec
          read(ireslun) vatravec_r4_mpiglobal
          vatra((jvec-1)*nvadim_mpilocalmax+1:((jvec-1)*nvadim_mpilocalmax+nvadim_mpilocal))= &
            real(vatravec_r4_mpiglobal(nvadim_beg:nvadim_end),8)
          write(*,*) 'min/max/size vatra=',jvec,minval(vatra((jvec-1)*nvadim_mpilocalmax+1:((jvec-1)*nvadim_mpilocalmax+nvadim_mpilocal))), &
                                                maxval(vatra((jvec-1)*nvadim_mpilocalmax+1:((jvec-1)*nvadim_mpilocalmax+nvadim_mpilocal))), &
                                                size(vatra((jvec-1)*nvadim_mpilocalmax+1:((jvec-1)*nvadim_mpilocalmax+nvadim_mpilocal)))
        enddo
        deallocate(vatravec_r4_mpiglobal)       
      endif

      imode = 2

      if(k1gc.eq.3) then
        nztrl(1) = nvadim_mpilocalmax
        nztrl(2) = 0
        nztrl(3) = nvamaj
        nztrl(4) = iztrl(4)
        nztrl(5) = iztrl(5)
      endif

      if(ibrpstamp == kbrpstamp .and. lxbar) then
        write(*,*) 'RW_VATRA : reading vazxbar'
        allocate(vazxbar_mpiglobal(nvadim_mpiglobal))
        read(ireslun) vazxbar_mpiglobal
        vazxbar(:)=0.0d0
        vazxbar(1:nvadim_mpilocal)=vazxbar_mpiglobal(nvadim_beg:nvadim_end)
        deallocate(vazxbar_mpiglobal)

        if(lvazx) then
          write(*,*) 'RW_VATRA : reading vazx'
          allocate(vazx_mpiglobal(nvadim_mpiglobal))
          read(ireslun) vazx_mpiglobal
          vazx(:)=0.0d0
          vazx(1:nvadim_mpilocal)=vazx_mpiglobal(nvadim_beg:nvadim_end)
          deallocate(vazx_mpiglobal)
        endif

      else
        kbrpstamp = ibrpstamp
      endif

      ierr = fclos(ireslun)

      !*     Write Hessian
      !*     -------------

    elseif(status.eq.1) then
      if(mpi_myid.eq.0) ierr = fnom(ireslun,cfname, 'FTN+SEQ+UNF' , 0)
      cl_version = 'V3'
      itrunc=0
      if(mpi_myid.eq.0) write(ireslun) cl_version,k1gc,nsim3d,kbrpstamp,zeps1,zdf1,itertot,isimtot,nvadim_mpiglobal,itrunc
      if(mpi_myid.eq.0) write(ireslun) nmtra_mpiglobal,nztrl
      if(k1gc.eq.3) ictrlvec = 2*nvamaj+1
      allocate(vatravec_r4_mpiglobal(nvadim_mpilocalmax*mpi_nprocs))
      allocate(vatravec_r4_mpilocalmax(nvadim_mpilocalmax))
      do jvec = 1, ictrlvec
        vatravec_r4_mpilocalmax(:)=  &
          real(vatra((jvec-1)*nvadim_mpilocalmax+1:jvec*nvadim_mpilocalmax),4)          
        call rpn_comm_gather(vatravec_r4_mpilocalmax ,nvadim_mpilocalmax,"mpi_real", &
                             vatravec_r4_mpiglobal   ,nvadim_mpilocalmax,"mpi_real", &
                             0,"GRID",ierr)
        if(mpi_myid.eq.0) write(ireslun) vatravec_r4_mpiglobal(1:nvadim_mpiglobal)
      enddo
      deallocate(vatravec_r4_mpiglobal)
      deallocate(vatravec_r4_mpilocalmax)

      allocate(vazxbar_mpiglobal(nvadim_mpilocalmax*mpi_nprocs))
      call rpn_comm_gather(vazxbar          ,nvadim_mpilocalmax,"mpi_double_precision", &
                           vazxbar_mpiglobal,nvadim_mpilocalmax,"mpi_double_precision", &
                           0,"GRID",ierr)
      if(mpi_myid.eq.0) write(ireslun) vazxbar_mpiglobal(1:nvadim_mpiglobal)
      deallocate(vazxbar_mpiglobal)

      allocate(vazx_mpiglobal(nvadim_mpilocalmax*mpi_nprocs))
      call rpn_comm_gather(vazx          ,nvadim_mpilocalmax,"mpi_double_precision", &
                           vazx_mpiglobal,nvadim_mpilocalmax,"mpi_double_precision", &
                           0,"GRID",ierr)
      if(mpi_myid.eq.0) write(ireslun) vazx_mpiglobal(1:nvadim_mpiglobal)
      deallocate(vazx_mpiglobal)

      if(mpi_myid.eq.0) ierr = fclos(ireslun)
    else
      call abort3d(" RW_VATRA: status not valid ")
    endif

    call tmg_stop(88)

    return
  END SUBROUTINE RW_VATRA


END MODULE minimization_mod
