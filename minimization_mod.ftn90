!--------------------------------------------------------------------------
! MODULE minimization (Minimization for variational assimilation.  prefix="min")
!
! Purpose: 
!
! Subroutines:
!    min_setup (public)
!
! Dependencies:
!
!--------------------------------------------------------------------------
MODULE minimization

  implicit none
  save
  private

  public              :: min_Setup, min_minvar,ltlmend,nsim3d,niterjob,lvarqc

  logical             :: initialized = .false.
  real*8, pointer     :: dg_vbar(:)

  character(len=10)   :: crestart='wrmrestart'
  integer             :: nulout =6
  integer             :: nmtra,nwork,nsim3d
  integer             :: ni,nj,nk,nlev,nt

  ! namelist variables
  INTEGER N1GC,NVAMAJ,NIMPRES,NITERMAX,NSIMMAX,niterjob
  INTEGER NGRTEST,NGRANGE,SELECT0,BFGSB,IMODE3
  LOGICAL LRSTART,lxbar,lwrthess,ltlmend
  REAL*8 REPSG,EPSNEG,rdf1fac
  LOGICAL LVARQC
  integer :: nwoqcv

  NAMELIST /NAMMIN/N1GC,NVAMAJ,NIMPRES,NITERMAX,NSIMMAX,NITERJOB  
  NAMELIST /NAMMIN/NGRTEST,NGRANGE,SELECT0,BFGSB,IMODE3
  NAMELIST /NAMMIN/LRSTART,lxbar,lwrthess,ltlmend
  NAMELIST /NAMMIN/REPSG,EPSNEG,rdf1fac
  NAMELIST /NAMMIN/LVARQC,NWOQCV

CONTAINS

  SUBROUTINE min_setup(nvadim_in,ni_in,nj_in,nk_in,nlev_in,nt_in)
    implicit none
    integer :: nvadim_in,ni_in,nj_in,nk_in,nlev_in,nt_in

    integer :: ierr,nulnam
    integer :: fnom,fclos

    ni=ni_in
    nj=nj_in
    nk=nk_in
    nlev=nlev_in
    nt=nt_in

    ! set default values for namelist variables
    N1GC = 3
    NVAMAJ = 6
    NIMPRES =  5
    NITERMAX = 400
    RDF1FAC  = 0.25d0
    NITERJOB = -1
    NSIMMAX  = 500
    NGRTEST  = 0
    NGRANGE  = 10
    lwrthess =.true.
    lxbar    = .true.
    ltlmend  = .false.
    REPSG    = 1e-3
    LRSTART  = .FALSE.
    EPSNEG   = 1e-6
    SELECT0  = 0
    BFGSB    = 2
    IMODE3   = 0
    LVARQC   = .false.
    NWOQCV   = 5

    ! read in the namelist NAMMIN
    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=nammin,iostat=ierr)
    write(*,*) 'minimization: reading namelist, ierr=',ierr
    write(*,nml=nammin)
    ierr=fclos(nulnam)

    allocate(dg_vbar(nvadim_in))
    dg_vbar(:)=0.0d0

    IF(N1GC.EQ.2) THEN
       NMTRA = 3*NVADIM_IN + NVAMAJ*(2*NVADIM_IN + 1)
    ELSE IF(N1GC.EQ.3)THEN
      NMTRA = 4*NVADIM_IN + NVAMAJ*(2*NVADIM_IN + 1)
    ELSE IF(N1GC.EQ.4)THEN
       NMTRA = 1 + NVAMAJ*(2*NVADIM_IN + 1)
       NWORK = 5*NVADIM_IN + NVAMAJ
    ELSE
       NMTRA = NVADIM_IN*2
    END IF
    WRITE(NULOUT,9401)N1GC, NVAMAJ,NVADIM_IN,NMTRA
 9401 FORMAT(4X,'N1GC = ',I2,4X,'NVAMAJ = ',I3,/5X,"NVADIM_IN =",1x,I14,3X,"NMTRA =",1X,I14)
    IF(N1GC.EQ.4) THEN
    WRITE(NULOUT,9402)NWORK
 9402 FORMAT(4X,'FOR N1CG1:',4X,'NWORK = ',I9)
    ENDIF

    IF (LVARQC) WRITE(NULOUT,*) 'VARIATIONAL QUALITY CONTROL ACTIVATED.'

    initialized=.true.

  END SUBROUTINE min_setup


  SUBROUTINE min_minvar(ntrunc,nksdim,nbrpstamp,lnlvtov,niter,lpcon,lrestart,cpconf)
      use mod4dv, only : l4dvar
      use controlVector
      use obsSpaceData_mod
!
!Purpose:
!3D/4D VAR minimization
!
      IMPLICIT NONE

      type(struct_obs_ptr) :: obsspacedataptr
      integer,allocatable :: obs_ptr_int(:) ! obs array used to transmit pointer to obsSpaceData
      integer :: nsize

      logical lnlvtov,lpcon,lrestart
      integer ntrunc,nksdim,nbrpstamp,niter
      CHARACTER(len=128) :: cpconf

      INTEGER IZS(1),IZTRL(10)
      REAL ZZSUNUSED(1)

      real*8 vazg(cvm_nvadim)
      real*8 vatr1(nmtra)
      real*8 vatra(nmtra)

      real*8 :: RPRECIS = 1.D-12
      REAL*8 DLDS(1)
      LOGICAL LLTEST,llvarqc, llstop, lldf1, lrdvatra, llvazx, llxbar

      INTEGER IMPRES, IMODE, ITERMAX, iterdone, ISIMMAX, INDIC, IITNOVQC, jj
      INTEGER IERR,ITERTOT,isimdone,isimtot,jdata, ISIMNOVQC
      integer ireslun,ibrpstamp,isim3d
      INTEGER IPRECON,ILEN
      REAL*8 ZJSP, ZXMIN, ZDF1, ZEPS0, ZEPS1
      REAL*8 DLGNORM, DLXNORM, ZJOTOV

      INTEGER FNOM,FCLOS, remove_c
      EXTERNAL FNOM,FCLOS
      EXTERNAL  N1QN3
      real*8 :: zeps0_000,zdf1_000
      integer :: iterdone_000,isimdone_000
      character(len=128) :: clfname

      logical bid_L

!     Additional parameters for minimization (N1CG1)
      real*8 xx,bb,a_not_use,r8_not_use,pj0
      integer in_mode(3),out_mode,i_not_use,nilm,ilm0(10),ilm1(10)
      integer i_pmat1,nl_stat, dl_bidon

! ---------------------------------------
!     Initialization and allocation specific to (N1CG1)
!     -------------------------------------------------
      if( N1GC.EQ.4.and.lvarqc ) call abort3d(nulout,' MINIMIZE N1CG1 with lvarqc not done ')
      if( BFGSB.EQ.1 ) call abort3d(nulout,' MINIMIZE n1cg1: option not validated ')

!     Define i_pmat1 even if BFGSB.NE.1 (Otherwise abort in n1cg1)
!     ------------------------------------------------------------
      i_pmat1 = cvm_NVADIM**2

      in_mode(2) = 0
      in_mode(3) = IMODE3

      nilm = NVAMAJ + 3
      if( nilm.gt.10 .and. N1GC.EQ.4)  call abort3d(nulout,' MINIMIZE n1cg1: ilm0,ilm1 incorrect ')

!     -------------------------------------------------
! Prepare for non-linear processing of 'TO' data:
!    - fill PZDBLPRIM8 with Z" = H(xb_lr) + Z'
!                              = H(xb_lr) - H(xb_hr) + Z
      if ( lnlvtov ) then
        call tmg_start(60,'RTTOV')
        call tovs_obs ('LR', ZJOTOV)
        call tmg_stop(60)
      endif

      ITERTOT  = 0
      isimtot = 0

      ZXMIN  =  RPRECIS

      ! recast pointer to obsSpaceData as an integer array, so it can be passed through n1qn3 to simvar
      obsspacedataptr%ptr => obsSpaceData
      nsize = size(transfer(obsspacedataptr,obs_ptr_int))
      allocate(obs_ptr_int(nsize+1))
      obs_ptr_int(1)=nsize   ! store the size of converted pointer in the first element
      obs_ptr_int(2:(1+nsize))=transfer(obsspacedataptr,obs_ptr_int)

!     *    2. Set-up the minimization
!     .  -----------------------
      llvarqc = lvarqc

!     If minimization start without qcvar : turn off varqc to compute
!     innovations and test the gradients

      ireslun=0
      lldf1 = .true.
      if(niterjob /= -1 .and. lrestart) then
        if( N1GC.EQ.4 ) call abort3d(nulout,' MINIMIZE N1CG1 with restart not done ')
        write(nulout,*) 'Minimize : Restart mode'
        lrdvatra = .true.
        clfname = crestart
        imode = 2
        llvazx = .true.
        llxbar = .true.
      elseif (lpcon) then
        write(nulout,*) 'Minimize : Preconditioning mode'
        lrdvatra = .true.
        clfname = cpconf
        imode = 2
        llvazx = .false.
        llxbar = lxbar ! from namcva (default is .true.)
      else
        lrdvatra = .false.
        imode = 0
        zeps0 = repsg
      endif
      if(.not.(imode.eq.0.or.imode.eq.2)) call abort3d(nulout,' RW_VATRA not done ')

      if (lrdvatra) then
        ibrpstamp = nbrpstamp ! ibrpstamp is a I/O argument of rw_vatra

        if(n1gc.eq.3) then
          call rw_vatra (clfname,0,                            &
            isim3d,ibrpstamp,zeps0_000,zdf1_000,iterdone_000   &
            ,isimdone_000,iztrl,vatra,nmtra,dg_vbar,cvm_nvadim,    &
            cvm_vazx,ntrunc,nksdim,nvamaj,llxbar,llvazx,n1gc,imode)

        elseif(n1gc.eq.4) then
          call rw_vatra (clfname,0,                            &
            isim3d,ibrpstamp,zeps0_000,zdf1_000,iterdone_000   &
            ,isimdone_000,ilm0,vatra,nmtra,dg_vbar,cvm_nvadim,     &
            cvm_vazx,ntrunc,nksdim,nvamaj,llxbar,llvazx,n1gc,imode)
        endif

        if(niterjob /= -1 .and. lrestart) then
          ierr = remove_c(clfname)
          nsim3d = isim3d
          write(nulout,*) 'MINVAR : NSIM3D read from precon file: ',nsim3d 
          zeps0  = zeps0_000
          zdf1   = zdf1_000
          lldf1 = .false. ! don't re-compute df1 base on Cost function
          iterdone = iterdone_000
          isimdone = isimdone_000 - 1
          itermax = min(nitermax - iterdone + 1, niterjob)
          isimmax = nsimmax - isimdone + 1
          if (iterdone < nwoqcv) lvarqc = .false.
        else
          if (ibrpstamp == nbrpstamp .and. lxbar) then
            zeps0  = zeps0_000
            zdf1   = zdf1_000
            lldf1 = .false.     ! don't re-compute df1 base on Cost function
          else
            zeps0 = repsg
            lldf1 = .true.      ! Compute df1 base on Cost function
          endif
        endif
      endif

      if(niterjob == -1 .or. .not. lrestart) then
        iterdone = 0
        isimdone = 0
        if (niterjob /= -1) then
          itermax = min(nitermax,niterjob)
        else
          itermax = nitermax
        endif
        isimmax = nsimmax

        if (nwoqcv > 0) lvarqc = .false.

        if(ngrtest.ne.0) then
          call grtest2(simvar,nulout,cvm_nvadim,cvm_vazx,ngrange)
        endif

      endif

      zeps1 = zeps0

      itertot = iterdone
      isimtot = isimdone

!     *    2. Set-up the minimization
!     .  -----------------------
!
!     *    .   Test the gradient again at the initial point WITH PRECON
!     .   --------------------------------------------------------
!
!     .   2.1.4 Test the complete functional
!
!     *    .   2.2  Compute the value of J(X) and the gradient
!     .        at the initial point
!
      INDIC =2

      call simvar(indic,cvm_nvadim,cvm_vazx,zjsp,vazg,obs_ptr_int(1))

      if (lldf1) ZDF1     =  rdf1fac * ABS(ZJSP)

!     Put QCVAR logical to its original values

      lvarqc=llvarqc

      CALL PRSCAL(cvm_NVADIM,VAZG,VAZG,DLGNORM)
      DLGNORM = DSQRT(DLGNORM)
      CALL PRSCAL(cvm_NVADIM,cvm_VAZX,cvm_VAZX,DLXNORM)
      DLXNORM = DSQRT(DLXNORM)
      WRITE(NULOUT,*)' |X| = ', DLXNORM
      WRITE(NULOUT,FMT=9220) ZJSP, DLGNORM
 9220 FORMAT(/4X,'J(X) = ',G23.16,4X,'|Grad J(X)| = ',G23.16)

!     *    .   2.4. Constants required by MODULOPT
!     .        ------------------------------

      IMPRES   =  NIMPRES

!     *    3. Iterations of the minimization algorithm
!     .  ----------------------------------------


!     *    .   3.2 Starting point of the minimization written to
!     .       RPN standard output file

      IF(N1GC.EQ.3) THEN
      WRITE(NULOUT,FMT=9320)ZXMIN,ZDF1,ZEPS0,IMPRES,NITERMAX,NSIMMAX
      ELSEIF(N1GC.EQ.4) THEN
      WRITE(NULOUT,FMT=9321)ZXMIN,ZDF1,ZEPS0,EPSNEG,SELECT0,BFGSB,IMODE3,IMPRES,NITERMAX,NSIMMAX
      ENDIF

 9320 FORMAT(//,10X,' Minimization N1QN3 starts ...',/  &
          10x,'DXMIN =',G23.16,2X,'DF1 =',G23.16,2X,'EPSG =',G23.16  &
          /,10X,'IMPRES =',I3,2X,'NITER = ',I3,2X,'NSIM = ',I3,//  &
          ,15X,'-STARTING POINT IS WRITTEN TO FILE ...')
 9321 FORMAT(//,10X,' Minimization N1CG1 starts ...',/  &
          10x,'DXMIN =',G23.16,2X,'DF1 =',G23.16,2X,'EPSG =',G23.16,2X,'EPSNEG =',G23.16,/,  &
          10x,'SELECT0 = ',I3,2X,'BFGSB = ',I3,2X,'IMODE3 = ',I3,  &
          /,10X,'IMPRES =',I3,2X,'NITER = ',I3,2X,'NSIM = ',I3,2X,'NHESS = ',I3,//  &
          ,15X,'-STARTING POINT IS WRITTEN TO FILE ...')

!     *    .   3.3 Beginning the minimization
!     .       --------------------------

      llstop = .false.
      if (lvarqc .and. nwoqcv > 0 .and. iterdone < nwoqcv) then
        iitnovqc = min(nwoqcv - iterdone,itermax)
        isimnovqc = isimmax
        lvarqc = .false.
        call tmg_start(21,'QN')
        call n1qn3(simvar, dscalqn, dcanonb, dcanab, cvm_nvadim, cvm_vazx,  &
            zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode       &
            ,iitnovqc, isimnovqc ,iztrl, vatra, nmtra, obs_ptr_int(1), zzsunused  &
            ,dlds)
        call tmg_stop (21)

        isimnovqc = isimnovqc - 1
        itermax = itermax - iitnovqc + 1
        isimmax = isimmax - isimnovqc + 1

        itertot = itertot + iitnovqc
        isimtot = isimtot + isimnovqc

        zeps1 = zeps0/zeps1
        zeps0 = zeps1
        lvarqc = .true.

        if (imode == 4 .and. itertot < nitermax) then
          imode = 2
          INDIC = 2
          call simvar(indic,cvm_nvadim,cvm_vazx,zjsp,vazg,obs_ptr_int(1))
        else
          llstop = .true.
        endif
      endif

      if (.not. llstop) then

        if(N1GC.EQ.3) then

          call tmg_start(21,'QN')
          call n1qn3(simvar, dscalqn, dcanonb, dcanab, cvm_nvadim, cvm_vazx,  &
              zjsp,vazg, zxmin, zdf1, zeps1, impres, nulout, imode,   &
              itermax,isimmax, iztrl, vatra, nmtra, obs_ptr_int(1), zzsunused,   &
              dlds)
          call tmg_stop (21)
          itertot = itertot + itermax
          isimtot = isimtot + isimmax

          zeps1 = zeps0/zeps1

        elseif(N1GC.EQ.4) then

!       Set VAZB = - VAZG (Valid only if VAZX = ZERO)
!       ---------------------------------------------
!modular1          VAZB = - VAZG

!       Keep constant term in pj0 (Valid only if VAZX = ZERO)
!       -----------------------------------------------------
          pj0 = ZJSP

!       Print cost function at iter 0 (Valid only if VAZX = ZERO)
!       ---------------------------------------------------------
          WRITE(NULOUT,FMT=9700) 0,0.d0+pj0,pj0,0.d0
 9700     FORMAT (4x,"n1cga:",i5,1x,e15.8,1x,e15.8,1x,e15.8)

          if(imode.eq.0) in_mode(1) = 0
          if(imode.eq.2) in_mode(1) = 1

!modular1          call n1cg1 (mvprod,cvm_NVADIM,cvm_VAZX,VAZB,a_not_use,pj0,xx,bb,.false
!modular1     &         .,EPSNEG,zeps1,itermax,impres,NULOUT,in_mode,out_mode
!modular1     &         ,VWORK,NWORK,imode,r8_not_use,i_not_use,NVAMAJ,ilm0,nilm
!modular1     &         ,VATRA,NMTRA,BFGSB,r8_not_use,i_pmat1,  NVAMAJ,ilm1,nilm
!modular1     &         ,VATR1,NMTRA,SELECT0,izs,zzsunused,dlds)

          zeps1 = zeps0/zeps1
          zeps0 = zeps1

          imode = out_mode

          isimmax = itermax

          itertot = itertot + itermax
          isimtot = isimtot + isimmax

!       Call 4D-Var simulator without gradient to get ZJSP
!       --------------------------------------------------
          INDIC = 2
          call simvar(indic,cvm_nvadim,cvm_vazx,zjsp,vazg,obs_ptr_int(1))

        endif

      endif

!     if lrestart remain false... postmin will execute
      lrestart = .false.
      ireslun=0
      if (niterjob /= -1 .and. itertot < nitermax .and. imode == 4) then
        clfname = crestart
!     Careful: lrestart before minimisation was used to trigger a
!     read of restart file... now it is set to .true. to avoid
!     execution of postmin.
        lrestart = .true.
      else
        do jdata = 1, cvm_nvadim
          dg_vbar(jdata) = cvm_vazx(jdata) + dg_vbar(jdata)
        enddo
        clfname = 'pm1q'
      endif

      if(lwrthess) then
        if(n1gc.eq.3) then
        call rw_vatra (clfname,1,  &
          nsim3d,nbrpstamp,zeps1,zdf1,itertot,isimtot,  &
          iztrl,vatra,nmtra,  &
          dg_vbar,cvm_nvadim,  &
          cvm_vazx,ntrunc,nksdim,nvamaj,.true.,llvazx,n1gc,imode)

        elseif(n1gc.eq.4) then
            call rw_vatra (clfname,1,  &
            nsim3d,nbrpstamp,zeps1,zdf1,itertot,isimtot,  &
            ilm1,vatr1,nmtra,  &
            dg_vbar,cvm_nvadim,  &
            cvm_vazx,ntrunc,nksdim,nvamaj,.true.,llvazx,n1gc,imode)
          endif
      endif

      WRITE(NULOUT,FMT=9500) imode,iterdone,itertot-iterdone,itertot,isimdone,isimtot-isimdone,isimtot
 9500 FORMAT(//,20X,20('*'),2X    &
          ,/,20X,'              Minimization ended with MODE:',I4  &
          ,/,20X,' Number of iterations done in previous job:',I4  &
          ,/,20X,'          Number of iterations in this job:',I4  &
          ,/,20X,'                Total number of iterations:',I4  &
          ,/,20X,'Number of simulations done in previous job:',I4  &
          ,/,20X,'         Number of simulations in this job:',I4  &
          ,/,20X,'               Total number of simulations:',I4)

      niter = itertot

!     *    4. Test the gradient at the final point if NGRTEST=1
!     .  ------------------------------------

 400  CONTINUE

      if ((NGRTEST.ne.0 .and. IMODE.ne.4 .and. .not. LRSTART)) then
        WRITE(NULOUT,FMT=9400)
 9400   FORMAT(//,12X,40('**'),/,12X,'TESTING THE GRADIENT AT THE FINAL POINT',/,40('**'))

        call grtest2(simvar,nulout,cvm_nvadim,cvm_vazx,ngrange)

      END IF

      if(l4dvar) then
!modular1        call endsim2(cvm_nvadim,cvm_vazx)
      endif

      RETURN
  END SUBROUTINE min_minvar


  SUBROUTINE simvar(na_indic,na_dim,da_v,da_J,da_gradJ,obs_ptr_int)
    use mod4dv, only : l4dvar
    !modular1  use modstag, only : lstagwinds
    use mpi
    use obsSpaceData_mod
    use gridStateVector
    use bmatrix
    implicit none
    ! Argument declarations
    integer :: na_dim ! Dimension of the control vector in forecast error coraviances space
    ! Value of na_indic
    ! Note: 1 and 4 are reserved values for call back from m1qn3.
    !       For direct calls use other value than 1 and 4.
    ! =1 No action taken; =4 Both J(u) and its gradient are computed.
    ! =2 Same as 4 (compute J and gradJ) but do not interrupt timer of the
    !    minimizer.
    ! =3 Compute Jo and gradJo only.
    integer :: na_indic 
    real*8  :: da_J ! Cost function of the Variational algorithm
    real*8, dimension(na_dim) :: da_gradJ ! Gradient of the Variational Cost funtion
    real*8, dimension(na_dim) :: da_v ! Control variable in forecast error covariances space
    integer :: obs_ptr_int(1)  ! integer work area used to transmit a pointer to the obsSpaceData
    !
    ! Purpose: Implement the Variational solver as described in
    ! Courtier, 1997, Dual formulation of four-dimentional variational assimilation,
    ! Q.J.R., pp2449-2461.
    !
    ! Author : Simon Pellerin *ARMA/MSC October 2005
    !          (Based on previous versions of evaljo.ftn, evaljg.ftn and evaljgns.ftn).
    !
    ! Local declaration
    integer :: nl_ilev, nl_err, nsize
    real*8, dimension(na_dim) :: dl_v
    real*8 :: dl_Jb, dl_Jo
    type(struct_gsv) :: statevector
    type(struct_obs_ptr) :: obsspacedataptr

    ! Convert the integer array obs_ptr_int back into a pointer to the obsSpaceData
    nsize=obs_ptr_int(1)
    obsspacedataptr=transfer(obs_ptr_int(2:(1+nsize)),obsspacedataptr)

    write(*,*) 'obsspacedataptr=',obsspacedataptr%ptr%mobhdr(1,1:100)
    write(*,*) 'obsspacedata=   ',obsspacedata%mobhdr(1,1:100)

    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_stop (21)

    call tmg_start(31,'SIMVAR')
    if (na_indic .ne. 1) then ! No action taken if na_indic == 1
       nsim3d = nsim3d + 1

       IF(mpi_myid == 0) write(*,*) 'Entering simvar for simulation ',nsim3d

       dl_v = da_v + dg_vbar      !dg_vbar = sum(v) of previous outer-loops

       ! Computation of background term of cost function
       dl_Jb = dot_product(dl_v,dl_v)/2.d0

       call gsv_allocate(statevector,ni,nj,nk,nlev,nt)

       call oda_sqrtB(da_v,na_dim,statevector)

       call oda_L(statevector)

       call tmg_start(2,'OBS-OPER') !

       call oda_H ! Modify NCM_OMA ! Hdx

       call oda_res              ! Modify NCM_OMA : Hdx-d
     
       call oda_sqrtRm1('OMA ','OMA ')  ! Modify NCM_OMA : R**-1/2*(Hdx-d)
     
       call oda_Jo               ! Store J in NCM_OMI : R**-1(Hdx-d)**2
     
       IF (LVARQC) THEN
          ! Store modify J in NCM_OMI : -ln((gamma-exp(J))/(gamma+1))
          call oda_qcv
       endif

       dl_Jo = 0.d0
       call oda_sumJo(dl_Jo)
       da_J = dl_Jb + dl_Jo
       if (na_indic .eq. 3) then
          da_J = dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  JO = ",G23.16,6X)') dl_Jo
       else
          da_J = dl_Jb + dl_Jo
          IF(mpi_myid == 0) write(*,FMT='(6X,"SIMVAR:  Jb = ",G23.16,6X,"JO = ",G23.16,6X,"Jt = ",G23.16)') dl_Jb,dl_Jo,da_J
       endif

       call oda_sqrtRm1('OMI ','OMA ')

       IF (LVARQC) THEN
          call oda_qcvad
       endif

       CALL TRANSFER3DV('ZOB0')
       call oda_HT
     
       call tmg_stop(2)

       CALL TRANSFER3DV('ZGD0')
       call oda_LT(statevector)

       CALL TRANSFER3DV('ZSP0')
       da_gradJ = 0.d0
       call oda_sqrtBT(da_gradJ,na_dim,statevector)
       call gsv_deallocate(statevector)

       if (na_indic .ne. 3) then
          da_gradJ = dl_v + da_gradJ
       endif

    endif
    call tmg_stop(31)
    if (na_indic .eq. 1 .or. na_indic .eq. 4) call tmg_start(21,'QN')

  END SUBROUTINE simvar


  SUBROUTINE DSCALQN(KDIM,PX,PY,DDSC,KZS, PZS, DDZS)
    !***s/r DSCALQN: inner product in canonical space
    !*    ------------------- 
    !**    Purpose: interface for the inner product to be used
    !*     .        by the minimization subroutines N1QN3.
    !*
    !*Arguments
    !*     i : KDIM      : dimension of the vectors
    !*     i : PX, PY    : vector for which <PX,PY> is being calculated
    !*     o : DDSC      : result of the inner product
    !*     --------------
    !*     i :  KZS(1)   : unused working space for INTEGER  (not used)
    !*     i :  PZS(1)   : unused working space for REAL     (not used)
    !*     i : PDZS(1)   : unused working space for REAL*8   (not used)
    IMPLICIT NONE

    REAL PZS(1)
    INTEGER KZS(1)
    REAL*8  DDZS(1)

    INTEGER KDIM
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC

    CALL PRSCAL(KDIM,PX,PY,DDSC)
    RETURN
  END SUBROUTINE DSCALQN


  SUBROUTINE PRSCAL(KDIM,PX,PY,DDSC)
    !***s/r PRSCAL: inner product in canonical space
    !*
    !*Author  : P. Gauthier *ARMA/AES  January 27, 1993
    !**    Purpose: evaluation of the inner product used in the
    !*     .        minimization
    !*
    !*Arguments
    !*     i : KDIM     : dimension of the vectors
    !*     i : PX, PY   : vector for which <PX,PY> is being calculated
    !*     o : DDSC     : result of the inner product
    !*
    !* Implicit argument: SCALP(KDIM) assumed to be unity

    IMPLICIT NONE

    INTEGER KDIM, J, RR, IERR
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 DDSC,TEMPO
    REAL*8 ZPY(KDIM)

    DDSC = 0.
    DO J = 1, KDIM
      DDSC = DDSC + PX(J)*PY(J)
    ENDDO

    RETURN
  END SUBROUTINE PRSCAL


  SUBROUTINE DCANAB(KDIM,PY,PX,KZS,PZS,PDZS)
    !***s/r DCANAB  - Change of variable associated with the canonical
    !*     .         inner product
    !*
    !*Author    JM Belanger CMDA/SMC   May 2001
    !*     .    Double precision version based on single precision CTCAB.
    !*          Refered to  as dummy argument DTCAB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PX = L^-1 * Py with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation aboutn DTCAB)
    !*     NOTE: L is assumed to be the identity!
    IMPLICIT NONE

    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PX(JDIM) = PY(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANAB


  SUBROUTINE DCANONB(KDIM,PX,PY,KZS,PZS,PDZS)
    !***s/r DCANONB  - Change of variable associated with the canonical
    !*     .          inner product
    !*
    !*Author    JM Belanger CMDA/SMC  May 2001
    !*     .    Double precision version based on single precision CANONB.
    !*          Refered to as dummy argument DTONB by N1QN3 minimization
    !*          package.
    !*    -------------------
    !**    Purpose: to compute PY = L * PX with L related to the inner product
    !*     .        <PX,PY> = PX^t  L^t  L PY
    !*     .        (see the modulopt documentation about DTONB)
    !*     .

    IMPLICIT NONE
    INTEGER KDIM, KZS(1)
    REAL PZS(1)
    REAL*8 PX(KDIM), PY(KDIM)
    REAL*8 PDZS(1)

    INTEGER JDIM

    DO JDIM = 1, KDIM
      PY(JDIM) = PX(JDIM)
    ENDDO

    RETURN
  END SUBROUTINE DCANONB


  SUBROUTINE setvazx(f,ntrunc,f_xx,ntrunc_xx,lower_L,nksdim,nvadim)
    !***s/r SETVAZX  - Transfer of Vazx from source to working resolutions
    !*
    !*Author  : M. Tanguay RPN, January, 2005
    !*
    !*Arguments
    !*     o   f         : Vazx field at working resolution
    !*     i   f_xx      : Vazx field at  source resolution
    !*     i   lower_L   : .T. if source res. is lower than working res.
    !*     i   n(i)trunc : truncation of working (source) resolution
    !*     i   nksdim    : nvar3d*nlev + nvar2d of working field
    !*
    implicit none

    logical lower_L
    real*8 f(*),f_xx(*)
    integer :: ntrunc, ntrunc_xx, nksdim, nvadim

    integer jlev,jdim,jla,m,start,end,rdim

    !modular1 !!!assume resolution is unchanged!!!
    f(1:nvadim)=f_xx(1:nvadim)
    !modular1 !!!assume resolution is unchanged!!!



    if(.false.) then

    !*     If source resolution is lower than working resolution
    !*     -----------------------------------------------------
    if(lower_L) then

      jdim = 0
      rdim = 0
      do jlev = 1, nksdim

        do jla = 1, ntrunc_xx + 1
          jdim = jdim + 1
          rdim = rdim + 1
          f(jdim) = f_xx(rdim)
        enddo

        jdim = jdim + ntrunc - ntrunc_xx

        start = ntrunc_xx + 2

        do  m = 2,ntrunc_xx + 1

          end   = start + (ntrunc_xx-(m-1))

          do jla = start, end

            jdim = jdim + 1
            rdim = rdim + 1
            f(jdim) = f_xx(rdim)

            jdim = jdim + 1
            rdim = rdim + 1
            f(jdim) = f_xx(rdim)

          enddo

          jdim = jdim + 2*(ntrunc - ntrunc_xx)

          start = end + 1

        enddo

        jdim = jdim + (ntrunc - ntrunc_xx)*(ntrunc - ntrunc_xx + 1)

      enddo

      !*     If source resolution is higher than working resolution
      !*     ------------------------------------------------------
    else

      jdim = 0
      rdim = 0
      do jlev = 1, nksdim

        do jla = 1, ntrunc + 1
          jdim = jdim + 1
          rdim = rdim + 1
          f(rdim) = f_xx(jdim)
        enddo

        jdim = jdim + ntrunc_xx - ntrunc

        start = ntrunc + 2

        do  m = 2,ntrunc + 1

          end   = start + (ntrunc-(m-1))

          do jla = start, end

            jdim = jdim + 1
            rdim = rdim + 1
            f(rdim) = f_xx(jdim)

            jdim = jdim + 1
            rdim = rdim + 1
            f(rdim) = f_xx(jdim)

          enddo

          jdim = jdim + 2*(ntrunc_xx - ntrunc)

          start = end + 1

        enddo

        jdim = jdim + (ntrunc_xx - ntrunc)*(ntrunc_xx - ntrunc + 1)

      enddo

    endif

    endif

    return
  END SUBROUTINE setvazx


  SUBROUTINE setvatra (v,   nmtra,   nvadim, ntrunc,  iztrl,    &
                       v_xx,nmtra_xx,nvadim_xx,itrunc,iztrl_xx, &
                       lower_L,nksdim,nvamaj,k1gc)
    !*
    !***s/r SETVATRA  - Transfer of Hessian from source to working resolutions
    !*
    !*Author  : M. Tanguay RPN, January, 2005
    !*
    !*     ----------------------------------------------------------------------------
    !*     Transfer of Hessian from source to working resolutions is done according
    !*     to the splitting of vatra as described in N1QN3 or N1CG1 (See MODULOPT lib.)
    !*     ----------------------------------------------------------------------------
    !*
    !*Arguments
    !*     o   v          : Hessian at working resolution
    !*     o   iztrl      : Localisation parameters for Hessian at working res.
    !*     i   v_xx       : Hessian at source resolution
    !*     i   iztrl_xx   : Localisation parameters for Hessian at source res.
    !*     i   nmtra(_xx) : Size of Hessian at working (source) res.
    !*     i   nvadim(_xx): Size of Vazx field at working (source) res.
    !*     i   lower_L    : .T. if source res. is lower than working res.
    !*     i   n(i)trunc  : truncation of working (source) resolution
    !*     i   nksdim     : nvar3d*nlev + nvar2d of working field
    !*     i   nvamaj     : number of updates in Hessian
    !*     i   k1gc       : Minimizer ID (2: m1qn2, 3: m1qn3, 4: m1gc)
    !*
    !*     --------------------------------------------
    !*     CAUTION: When K1GC=3, iztrl assumes DIS mode
    !*     --------------------------------------------

    implicit none

    integer ntrunc,itrunc,nksdim,nvamaj,k1gc,nmtra,nvadim
    integer nmtra_xx,nvadim_xx,iztrl(10),iztrl_xx(10)

    real*8 v(nmtra),v_xx(nmtra_xx)
    logical lower_L
    integer n,n_xx
    integer idiag,iybar,isbar,isize
    integer idiag_xx,iybar_xx,isbar_xx,isize_xx
    integer ii,jj,mmemo,mmemo_xx


    if(lower_L) then
       write(nulout,*) 'SETVATRA using source resolution lower than working resolution'
    else
      write(nulout,*) 'SETVATRA using source resolution greater or equal than working resolution'
    endif

    n    = nvadim
    n_xx = nvadim_xx

    !*     Mmemo = number of (y,s) pairs in core memory
    !*     --------------------------------------------
    mmemo    = NVAMAJ
    !mmemo_xx = NVAMAJ
    mmemo_xx = (nmtra_xx - 4*n_xx)/(2*n_xx + 1)

    !*     Split Hessian at working resolution
    !*     -----------------------------------
    idiag=1
    iybar=idiag+n
    !if(sscale)    iybar=1
    if(k1gc.eq.4) iybar=1
    isbar=iybar+n*mmemo
    isize=isbar+n*mmemo

    !*     Split Hessian at source resolution
    !*     ----------------------------------
    idiag_xx=1
    iybar_xx=idiag_xx+n_xx
    !if(sscale)    iybar_xx=1
    if(k1gc.eq.4) iybar_xx=1
    isbar_xx=iybar_xx+n_xx*mmemo_xx
    isize_xx=isbar_xx+n_xx*mmemo_xx

    !*     Transfer vazx field from source to working resolutions
    !*     ------------------------------------------------------
    !if(sscale)    call setvazx (v(idiag),ntrunc,v_xx(idiag_xx),itrunc,lower_L,nksdim,nvadim)
    if(k1gc.eq.3) call setvazx (v(idiag),ntrunc,v_xx(idiag_xx),itrunc,lower_L,nksdim,nvadim)

    do jj = 1,min(mmemo,mmemo_xx)
       call setvazx (v(iybar+(jj-1)*n),ntrunc,v_xx(iybar_xx+(jj-1)*n_xx),itrunc,lower_L,nksdim,nvadim)
    enddo
    do jj = 1,min(mmemo,mmemo_xx)
       call setvazx (v(isbar+(jj-1)*n),ntrunc,v_xx(isbar_xx+(jj-1)*n_xx),itrunc,lower_L,nksdim,nvadim)
    enddo

    !*     Transfer IZTRL
    !*     --------------
    if(k1gc.eq.3) then

       iztrl(1) = n
       iztrl(2) = 0
       !if(sscale) iztrl(2) = 1
       iztrl(3) = mmemo
       iztrl(4) = iztrl_xx(4)
       iztrl(5) = iztrl_xx(5)

    elseif(k1gc.eq.4) then

       do ii=1,10
          iztrl(ii) = iztrl_xx(ii)
       enddo

       v(isize) = v_xx(isize_xx)

    endif

    return
  END SUBROUTINE setvatra


  SUBROUTINE rw_vatra (cfname,status,                       &
          nsim3d,kbrpstamp,zeps1,zdf1,itertot,isimtot,      &
          nztrl,vatra,nmtra,                                &
          vazxbar,kvadim,                                   &
          vazx,ktrunc,kksdim,nvamaj,lxbar,lvazx,k1gc,imode)

    !***s/r RW_VATRA  - Read-Write VAZXBAR and VATRA on file
    !*
    !*
    !*Author  : M. Tanguay RPN January 2005
    !*Revision: S. Pellerin (January 2005)
    !*          . Dynamical Multi-Inc.: Read and write based on date,
    !*            working and stored resolutions
    !*          M. Buehner (May 2008)
    !*          . Added code for dealing with multiple bands of
    !*            correlations (corns) - changed some argument names
    !*            to avoid complict with comdecks
    !*Revision: M. Tanguay  (December 2007)
    !*          . Lam4d Limited-Area: Add grd_typ in rw_vatra parameters
    !*Revision: L. Fillion - ARMA/EC - 12 Jan 2009
    !*          . Upgrade lam4d to v_10_1_2.
    !*
    !*Arguments
    !*     i   cfname    : precon file
    !*     i   status    : = 0 if READ, = 1 if WRITE
    !*     i   nsim3d    : Number of simulations in N1QN3
    !*     io  kbrpstamp : Date
    !*     i   zeps1     : Parameter in N1QN3
    !*     i   zdf1      : Parameter in N1QN3
    !*     i   itertot   : Parameter in N1QN3
    !*     i   isimtot   : Parameter in N1QN3
    !*     i   nztrl     : Localisation parameters for Hessian
    !*     i   vatra     : Hessian
    !*     i   nmtra     : Size of Hessian
    !*     i   vazxbar   : Vazx of previous loop
    !*     i   kvadim    : Dimension of vazxbar
    !*     i   vazx      : Current state of the minimization
    !*     i   ktrunc    : truncation of working resolution
    !*     i   kksdim    : nvar3d*nlev + nvar2d of working field
    !*     i   nvamaj    : nomber of updates in Hessian
    !*     i   lxbar     : read in vaxzbar if dates are compatible
    !*     i   lvazx     : Logical to read vazx
    !*     i   k1gc      : Minimizer ID (2: m1qn2, 3: m1qn3, 4: m1gc)
    !*     o   imode     : If status=0, set imode=0 (no prec) or 2 (prec)

    IMPLICIT NONE

    logical lxbar,lvazx

    integer status,kbrpstamp,nsim3d,itertot,isimtot
    integer, dimension(10), target :: nztrl
    integer nmtra, kvadim, ktrunc, kksdim, nvamaj, k1gc, imode
 
    real*8 zeps1,zdf1

    real*8, dimension(kvadim), target :: vazxbar, vazx
    real*8, dimension(nmtra), target :: vatra

!#include "pardim.cdk"
!#include "comdim.cdk"

    integer isize, ibrpstamp,ireslun, ierr, fnom, fclos
    integer, save :: ivadim = 0, imtra = 0, itrlsize = 1, imemo = 1
    integer, save :: itrunc = 0
    integer :: jvadim, i1gc,ictrlvec
    integer, dimension(10), target, save :: iztrl
    integer itemp
    real*8, allocatable, dimension(:), target, save :: zvatra
    real*8, allocatable, dimension(:), target, save :: zvazxbar,zvazx

    integer, pointer, dimension(:) :: iptrl
    real*8, pointer, dimension(:) :: pvatra , pvazxbar, pvazx

    character(len=128) :: cfname
    character(len=3) :: cl_version
    character*2 grd_typ_S

    if(status.eq.0) then
      write(nulout,*) 'Read  VATRA in RW_VATRA'
    elseif(status.eq.1) then
      write(nulout,*) 'Write VATRA in RW_VATRA'
    else
      call abort3d(nulout," RW_VATRA: status not valid ")
    endif

    ireslun=0

    !*     Read Hessian
    !*     ------------
    if(status.eq.0) then

      ierr = fnom(ireslun,cfname,'FTN+SEQ+UNF+OLD+R/O',0)

      ! Checking version number
      read (ireslun) cl_version,i1gc
      if(trim(cl_version) /= 'V2') then
        call abort3d(nulout," RW_VATRA: invalid Hessian version")
      endif
      if (i1gc == 3 .and. i1gc == k1gc) then
        write(*,*) trim(cl_version),' M1QN3'
      elseif (i1gc == 4 .and. i1gc == k1gc) then
        write(*,*) trim(cl_version),' N1CG1'
      else
        write(*,*) 'Version, n1gc =',trim(cl_version),i1gc
        call abort3d(nulout," RW_VATRA: Inconsistant input hessian")
      endif

      rewind (ireslun)

      read(ireslun) cl_version,k1gc,nsim3d,ibrpstamp,zeps1,zdf1,itertot,isimtot,ivadim, itrunc

      read(ireslun) imtra,iztrl
      if(.not. allocated(zvatra)) then
        allocate(zvatra(imtra))
        zvatra = 0.d0
      endif
      !imemo = nvamaj
      imemo = (imtra - 4*ivadim)/(2*ivadim + 1)
      if(k1gc.eq.3) ictrlvec = 2*imemo+1
      if(k1gc.eq.4) ictrlvec = 2*imemo

      if(.not. allocated(zvatra)) allocate(zvatra(imtra))
      zvatra = 0.d0

      do jvadim = 1, ictrlvec
        read(ireslun) zvatra((jvadim-1)*ivadim+1:jvadim*ivadim)
      enddo

      !*       Write Residual Hessian (needed when LAM)
      !*       ----------------------------------------
      if(k1gc.eq.4) read(ireslun) zvatra(ictrlvec*ivadim+1:ictrlvec*ivadim+1)
      !if(k1gc.eq.3) read(ireslun) iztrl,zvatra(1:(2*imemo+1)*ivadim  )
      !if(k1gc.eq.4) read(ireslun) iztrl,zvatra(1:(2*imemo)*ivadim+1)
      !read(ireslun) iztrl, zvatra
      imemo = nvamaj ! saved for writing
      if(itrunc .ge. ktrunc) then
        write(nulout,*) 'RW_VATRA : setting vatra'
        call setvatra(vatra,nmtra,kvadim,ktrunc,nztrl,zvatra,imtra,ivadim,itrunc,iztrl,.false.,kksdim,nvamaj,k1gc)
        imode = 2
      else
        imode = 0
      endif

      if(ibrpstamp == kbrpstamp .and. lxbar) then
        if(.not. allocated(zvazxbar)) allocate(zvazxbar(ivadim))
        read(ireslun) zvazxbar
        write(nulout,*) 'RW_VATRA : setting vazxbar'
        if(itrunc .ge. ktrunc) then ! Given res. > working res.
          call setvazx(vazxbar,ktrunc,zvazxbar,itrunc,.false.,kksdim,kvadim)
        else
          vazxbar = 0.d0
          call setvazx(vazxbar,ktrunc,zvazxbar,itrunc,.true.,kksdim,kvadim)
        endif

        if(lvazx) then
          write(nulout,*) 'RW_VATRA : setting vazx'
          if(.not. allocated(zvazx)) allocate(zvazx(ivadim))
          read(ireslun) zvazx
          if(itrunc .ge. ktrunc) then ! Given res. > working res.
            call setvazx(vazx,ktrunc,zvazx,itrunc,.false.,kksdim,kvadim)
          else
            vazx = 0.d0
            call setvazx(vazx,ktrunc,zvazx,itrunc,.true.,kksdim,kvadim)
          endif
        endif

      else
        kbrpstamp = ibrpstamp
      endif

      ierr = fclos(ireslun)

      !*     Write Hessian
      !*     -------------
    elseif(status.eq.1) then
      ierr = fnom(ireslun,cfname, 'FTN+SEQ+UNF' , 0)

      !if ivadim = 0 then no precon file has been read
      if (ivadim .le. kvadim) then
        if (ivadim == 0) imemo = nvamaj
        ivadim = kvadim
        itrunc = ktrunc
        imtra  = nmtra
        iptrl => nztrl
        pvatra => vatra
        pvazxbar => vazxbar
        pvazx => vazx
      else
        if(.not. allocated(zvatra)) allocate(zvatra(imtra))

        iptrl => iztrl
        pvatra => zvatra
        call setvatra(pvatra,imtra,ivadim,itrunc,iptrl,vatra,nmtra,kvadim,ktrunc,nztrl,.true.,kksdim,nvamaj,k1gc)
        if(.not. allocated(zvazxbar)) allocate(zvazxbar(ivadim))
        pvazxbar => zvazxbar
        pvazxbar = 0.d0
        call setvazx(pvazxbar,itrunc,vazxbar,ktrunc,.true.,kksdim,kvadim)
        if(.not. allocated(zvazx)) allocate(zvazx(ivadim))
        pvazx => zvazx
        pvazx = 0.d0
        call setvazx(pvazx,itrunc,vazx,ktrunc,.true.,kksdim,kvadim)
      endif
      cl_version = 'V2'
      write(ireslun) cl_version,k1gc,nsim3d,kbrpstamp,zeps1,zdf1,itertot,isimtot,ivadim, itrunc
      write(ireslun) imtra,iptrl
      !write(ireslun) iptrl, pvatra
      if(k1gc.eq.3) ictrlvec = 2*imemo+1
      if(k1gc.eq.4) ictrlvec = 2*imemo
      do jvadim = 1, ictrlvec
        write(ireslun) pvatra((jvadim-1)*ivadim+1:jvadim*ivadim)
      enddo

      !*       Write Residual Hessian (needed when LAM)
      !*       ----------------------------------------
      if (ictrlvec*ivadim.lt.imtra) write(ireslun) pvatra(ictrlvec*ivadim+1:imtra)

      if(k1gc.eq.4) write(ireslun) pvatra(ictrlvec*ivadim+1:ictrlvec*ivadim+1)
      !if(k1gc.eq.3)  write(ireslun) iptrl, pvatra(1:(2*imemo+1)*ivadim  )
      !if(k1gc.eq.4)  write(ireslun) iptrl, pvatra(1:(2*imemo)  *ivadim+1)
      write(ireslun) pvazxbar
      write(ireslun) pvazx
      ierr = fclos(ireslun)
    else
      call abort3d(nulout," RW_VATRA: status not valid ")
    endif

    return
  END SUBROUTINE RW_VATRA


END MODULE minimization
