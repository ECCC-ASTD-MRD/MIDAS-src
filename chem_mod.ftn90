!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_mod
!
! Module managers: Mike Sitwell and Yves Rochon (ARQI/AQRD)
!
! PURPOSE:
!    Repository of obs space structures, arrays, and routines specific to the 
!    CH chemical constituents family and constituent observations.
!
!    Main content (public routines):
!
!       - Public routines
!         "chm_read_obs_err_stddev,chm_get_obs_err_stddev,chm_dealloc_obs_err_stddev":
!         Routines and strucure for setting of obs error std. dev. used in
!         'observation_erreurs_mod.ftn90'. 
!
!       - Public routine "chm_obsoperators": Applies observation operators. 
!
!       - Public routine "chm_setup": Routines and structure for setting and assignment 
!         of observation layer top and bottom levels (and averaging kernel matrices - tbc). 
!         See 'preproc.ftn90' and 'chm_obsoperators'. 
!
!       - Public routines: "chm_get_stringId,chm_get_ID": Routines for use 
!         in filtering out obs based on model vertical boundaries. See 'filterobs_mod.ftn90'.
!
!       - Public routine chm_lcheck_skipassim: Identify if data is to be assimilated or only used
!         for independent verifications.
!
!       - Public routine chm_comboIDlist: Provide list of fixed or accumulated stnid, 
!         (stnid,varno) or (stnid,varno,multi/uni-level) combinations. For use in
!         in obsspacediag_mod.ftn90.
!
!       - Public routine "chm_get_col_boundary": Provides column boundary pressure pressure levels
!         at obs locations (could be set as tropopause, PBL, or static value). Relevant only for
!         assimilation of total column measurements. Public routines "chm_add_col_boundary" and
!         "chm_retrieve_col_boundary" provide a means of storing and retrieving this value, respectively.
!
!       - Public routine "chm_convert_z_to_pressure".
!
!       - Public routines "chm_apply_bounds" and "chm_apply_transform" applied to analysis increment fields.
!
!       - Public routine "chm_varnumFromVarname" to obtain the BUFR varno corresponding to
!         to the constituent.
!
! COMMENT:
!
!    This module can be expanded to contain other constituent related info
!    or routines.
!
! Author  : Y.J Rochon - ARQI/AQRD, 2014
!
! Revisions:
!           M. Sitwell, ARQI/AQRD, Feb 2015
!           - Created struct_chm_info and struct_chm_std structures for storing
!             information read from ascii/burp file and removal of earlier structure.
!           M. Sitwell and Y. Rochon, ARQI/AQRD, Aug 2015
!           - Created struct_config (M. Sitwell) following specification of related
!             variables (Y. Rochon) for reading in routine chm_read_misc.
!           
!
!----------------------------------------------------------------------------------
   
  implicit none
  private

! public procedures
! -----------------

  public :: chm_setup,chm_dealloc_obs_err_stddev,chm_read_obs_err_stddev, &
            chm_get_obs_err_stddev,chm_obsspace_diagnostic,chm_convert_z_to_pressure
  public :: chm_obsoperators,chm_get_stringID,chm_get_ID,stnid_equal
  public :: chm_lcheck_skipassim,chm_comboIDlist,chm_required_field
  public :: chm_apply_bounds,chm_apply_transform,chm_get_col_boundary
  public :: chm_add_col_boundary,chm_retrieve_col_boundary

! public variables and types
! --------------------------

  public :: chm_constituents_size,struct_chm_obsoperators

! module constants
! -----------------
  integer, parameter :: chm_cfg_size=100           ! max size of config arrays
  integer, parameter :: chm_constituents_size=30   ! max size of constituents arrays


! module interfaces
! -----------------

  ! interface for resizing arrays
  interface resize
     module procedure resize_1d_real
     module procedure resize_1d_int
     module procedure resize_1d_str
     module procedure resize_2d_real
     module procedure resize_3d_real
  end interface resize

  ! interface for conversion to a left-justified string (useful for calls to abort3d)
  interface str
     module procedure int2str
     module procedure float2str
  end interface str

  ! interface for generating obsdata loctime codes
  interface obsdata_get_loctime_code
     module procedure obsdata_get_loctime_code_i
     module procedure obsdata_get_loctime_code_r
  end interface obsdata_get_loctime_code

! module structures
! -----------------

  type :: struct_chm_std
     !
     ! Structure containing information retrieved from file obsinfo_chm for holding 
     ! observation std dev information
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block 
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                            (may be adjusted after input)
     !  std_type               Index of setup approach (used in combination with
     !                            nstd_brp_chm)
     !                         For nstd_brp_chm value 0 or 1, 
     !                         0: std1 or BURP file vales (sigma)
     !                         1: min(std3,max(std2,std1_chm*ZVAL))
     !                                                   or
     !                            max(std2(ISTNID),xstd_std1_chm(ILEV)*sigma)
     !                         2: sqrt(std2**2+(std1*ZVAL)**2))
     !                                                   or
     !                                              not applicable
     !  ibegin                 Position index of start of data for given
     !                         sub-family in the arrays std1,levels,lat
     !  n_lvl                  Number of vertical levels
     !  levels                 Vertical levels (in coordinate of sub-family data)
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !  std1                   See std_type for usage
     !  std2                   See std_type for usage
     !  std3                   See std_type for usage  

     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),std_type(:),n_lat(:)
     integer, allocatable :: brp(:),ibegin(:),n_lvl(:)
     real(8), allocatable :: std1(:),std2(:),std3(:)
     real(8), allocatable :: levels(:),lat(:)

  end type struct_chm_std
  
  type :: struct_chm_info
     !  Information arrays retrieved from file obsinfo_chm regarding vertical levels 
     !  or averaging kernels
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                             (may be adjusted after input)
     !  vco                    Vertical coordinate type (1, 2, or 3, see bufr_read_mod)
     !
     !  ibegin                 Position index of start of data for given
     !                         sub-family.
     !  n_lvl                  Number of vertical levels
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !
     !  vlayertop              Layer top 
     !  vlayerbottom           Layer bottom
     !  rak                    Averaging kernel matrices
     
     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),brp(:)
     integer, allocatable :: vco(:),n_lat(:)
     integer, allocatable :: ibegin(:),n_lvl(:)
     real(8), allocatable :: rak(:),vlayertop(:),vlayerbottom(:)
     real(8), allocatable :: lat(:)
  
  end type struct_chm_info

  type :: struct_chm_obsoperators  
  
     !  Structure holding work variables for observation operators
     !     
     !  Variable               Description
     !  --------               -----------
     !  nobslev                Number of observations in the profile
     !  nmodlev                Number of model levels in the column
     !  varno                  BUFR descriptor element for obs units
     !  constituent_id         BUFR code element of Table 08046 identifying the constituent
     !  modelIndex             Obs operator index
     !                         0 - vertical interpolator
     !                         1 - layer averaging
     !                         2 - layer integration
     !  layer_identified       .true. if a layer (with identified layer boundaries)
     !                         .false if layer boundaries are not available.
     !  vmodpress              Model layer boundaries taken as middle between model level
     !  vlayertop              Layer top (final work values in Pa)
     !  vlayerbottom           Layer bottom (final work values in Pa)
     !  vweights               Second order Lagrangian interp integration weights
     !  zh                     Initial innovation model array (other than conversion constants)
     !  zhp                    Part of innovation operator not related to resolution.
     !  lvl_top                Top level of non-zero values in zh
     !  lvl_bot                Bottom level of non-zero values in zh
     !  trial                  Trial (background) field at observation location
     !  tt                     Temperature profile on model levels (Kelvin)
     !  gz                     Geopotential height on model levels (m)
     !  pp                     Pressure on model levels (Pa)
     !  lat                    Latitude of observation (radians)
     !  lon                    Longitude of observation (radians)
     !  obslev                 Observation profile level values (OBS_PPP)
     !  varName                Variable/obs nomvar
     !  stnid                  Observation station ID
     !  date                   YYYYMMDD (date of obs)
     !  hhmm                   HHMM (time of obs)
     !  vco                    Index of vertical coord type for obs
     !                           1 - Altitudes (m)
     !                           2 - Pressure (Pa)
     !                           3 - Channel index
     !                           4 - not provided with obs (normally for total column values)
     !  iavgkern               Integer indicating if averaging kernels are to be applied. Value
     !                         of zero indicates no averaging kernel to be applied. Non-zero value
     !                         indicates index in chm_avgkern,chm_burp_avgkern arrays.
     !  apply_genoper          Indicates if the generalized observation operator should be applied
     !  column_bound           Boudary imporsed on a column measurement

     integer :: nobslev,nmodlev,modelIndex,constituent_id,vco,varno,date,hhmm,iavgkern
     logical :: layer_identified,apply_genoper
     real(8) :: lat,lon,column_bound
     character(len=12) :: stnid
     character(len=4)  :: varName
     real(8), allocatable :: vlayertop(:),vlayerbottom(:),vmodpress(:),tt(:),gz(:),pp(:),trial(:)
     real(8), allocatable :: zh(:,:),zhp(:,:),vweights(:,:),obslev(:)
     integer, allocatable :: lvl_top(:),lvl_bot(:)

  end type struct_chm_obsoperators

  type :: struct_chm_obsdata

     !  Structure storing information associated to observations such
     !  as BURP file reports (irep) either retrieved from BURP files 
     !  themselves or from other sources.  
     !     
     !  Variable               Description
     !  --------               -----------
     !  ndim                   number of dimensions of the data arrays
     !                         (i.e. ndim=1 for std and ndim=2 for averaging kernels)
     !  nrep                   number of reports or observations
     !  dim1                   first array dimension for each  report/observation
     !  dim2                   second array dimension for each  report/observation (only relevant for ndim=2)
     !  data1d                 obs data of dimension (nrep,dim1)
     !  data2d                 obs data of dimension (nrep,dim1,dim2)
     !  irep                   current report position
     !  idim1                  current position in the first dimension of the data array
     !  code                   unique character string for identifying the report/observation                    
     
     real(8), pointer :: data1d(:,:),data2d(:,:,:)
     character(len=22), pointer :: code(:)
     integer :: ndim,nrep,dim1,dim2,irep,idim1
  
  end type struct_chm_obsdata

  type :: struct_config
     
     !  Structure to store general config information.
     !     
     !  Variable               Description
     !  --------               -----------
     !  generalized_operator   Logical indicating if the generalized innovation operator is to
     !                         be applied in routine chm_obsoperators
     !
     !  assim_num              Number of combinations (stnid, bufr element, multi/uni-level) 
     !                         identified for obs to be assimilated. All others will not
     !                         be assimilated. OmP and OmA diagnostics and output
     !                         will still be produced for non-assimilated datasets.
     !                         (see routines chm_lcheck_skipassim, oonl_chm in obsoperators_mod.ftn90)
     !
     !                           <0:  all are to be assimilated
     !                            0:  none are to be assimilated
     !                           >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
     !
     !  assim_varno            Bufr elements of obs sets for assimilation. A value of
     !                         0 implies that all are to be used.
     !
     !  assim_stnid            Stnids of obs sets for assimilation. '*' denote wild cards
     !       
     !  assim_nlev             0:  multi-level and uni-level
     !                         1:  uni_level
     !                         >1: multi-level 
     !
     !  diagn_pressmin         Bottom of top layer for diagnostics (in Pa).
     !
     !  diagn_save             Logical indicating gridded diagnostics are to be saved
     !                         in an ascii file in addition to overall diagnostics. 
     !                         (see routine chm_obsspace_diagnostic)
     !
     !  amu                    Molecular mass of constituents in g/moles (needed for unit conversions)
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent.
     !
     !  tropo_mode             Integer indicating if special treatment is to be given to the troposphere
     !                         when assimilating total column measurements. Values indicate
     !                           0:  No special treatment given (default)
     !                           1:  Values of the adjoint model above obsoper%column_bound set to zero.
     !                               If specified, generalized innovation operator only applied below
     !                               obsoper%column_bound in the tangent linear model.
     !                           2:  Values of tangent linear model and adjoint model above 
     !                               obsoper%column_bound set to zero.
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent. Relevant for total column measurements only.
     !
     !  tropo_bound            Integer indicating which column top value to use if tropo_mode is non-zero.
     !                           0: Use fixed value of tropo_column_top
     !                           1: Use model determination of tropopause
     !                           2: Use model determination of PBL
     !                         Options 1 and 2 will default to the value set in tropo_column_top if the model
     !                         derived column top could not be determined. Relevant for total column measurements only.
     !
     !  tropo_column_top       Default value to use for the column boundary (in Pa). Array index refers to BUFR code
     !                         element of Table 08046 (iconstituent_id) identifying the constituent. 
     !                         Relevant for total column measurements only.
     !
     !  obsdata_maxsize        Maximum size for struct_chm_obsdata arrays if not specified by other means
     !                         
     !  low_cutoff             min value allowed for increments prior to storage in rebm expressed as a fraction
     !                         of the background field (generally < 1)
     !  high_cutoff            max value allowed for increments prior to storage in rebm expressed as a multiple
     !                         of the background field (generally > 1)
     !  transform              Index specifying form of analysis increment (and related adjoint operation)
     !                         0: no transformation (dx given input trial field denoted as x)
     !                         1: dlnx 
     
     logical :: generalized_operator,diagn_save
     integer :: assim_num,tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
     integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size)
     integer :: transform(0:chm_constituents_size)
     integer :: obsdata_maxsize
     character(len=9) :: assim_stnid(chm_cfg_size)
     real(8) :: diagn_pressmin
     real(8) :: amu(0:chm_constituents_size),tropo_column_top(0:chm_constituents_size)
     real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)

  end type struct_config

  type(struct_chm_info) :: chm_layers
  type(struct_chm_info) :: chm_avgkern
  type(struct_chm_std)  :: chm_std
  type(struct_config)   :: chm_config

! Array of pointers to hold std's/averaging kernels read from BURP file.
! Note: Ideally, these should be an element in the 'struct_chm_std' /
! 'struct_chm_info' derived types, but currently this results
! in an internal compiler error.

  type(struct_chm_obsdata), allocatable :: chm_burp_std(:),chm_burp_avgkern(:)

! Arrays for integration upper boundary of retrieved total column measurements 

  type(struct_chm_obsdata) :: chm_column_boundary

  ! File containing various warnings related to chemical constituents that
  ! are not included in the listing file.
  character(len=14), parameter :: chm_warnings_filename='chem_warnings_'


contains

!------------------------------- Setup called from "preproc" ---------------------------

  subroutine chm_setup
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: M. Sitwell, Feb 2015
!            - Removed references to earlier structure
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData.
!
!----------------------------------------------------------------------------------------

  implicit none
  
  write(*,*) 'Begin chm_setup'

! Read miscellaneous flags and constants 
    
  call chm_read_misc
      
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_read_layers
      
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_layers
   
! Read averaging kernel matrices
  
  call chm_read_avgkern
  
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_avgkern

  write(*,*) 'Completed chm_setup'
  
  end subroutine chm_setup

!------------------------------------------------------------------------------------

  subroutine chm_read_misc
!
! Author   : Y. Rochon, ARQI/AQRD, Apr 2015 
!
! Purpose: Read and store miscellaneous flags and constants.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Aug 2015
!            - Incorporated input fields in chm_config
!            Y. Rochon, ARQI/AQRD, Sept 2015
!            - Added reading of variables related to options for attributing only 
!              tropospheric portion of the increment to total column observations
!            M. Sitwell, ARQI/AQRD, Oct 2015
!            - Moved amu from obsinfo_chm to namelist namchem    
!
! Output:
!
!   Read from NAMCHEM namelist
!
!        genoper             If generalized observation operator should be used
!
!        diagn_num           Prescribed (starting) number of (stnid, bufr, nlev) for the diagnostics calc
!
!        diagn_stnid         Prescribed (starting) list of stnid (with *s as needed) for the diagnostics calc
!                            with '*' denoting wild cards
!
!        diagn_varno         Prescribed (starting) list of bufr elments for the diagnostics calc
!
!        diagn_unilev        Prescribed (starting) list of logicals indicating uni-level obs for the diagnostics calc
!
!        diagn_pressmin      Bottom of top layer for diagnostics (in Pa).
!
!        diagn_save          Logical indicating gridded diagnostics are to be saved
!                            in an ascii file in addition to overall diagnostics. 
!
!        diagn_nset          Integer indicating grouping of diagnostics with
!                            1: group by stnid
!                            2: group by (stnid,bufr)
!                            3: group by (stnid,bufr,nlev)
!
!        diagn_all           Logical indicating if all combinations specified by diagn_nset are to be
!                            used in diagnostics or only those specified by the diagn_* arrays
!
!        assim_num           Number combinations (stnid, bufr element, multi/uni-level) 
!                            identified for assimilation. All others will not
!                            be assimilated. OmP and OmA diagnostics and output
!                            will still be produced for non-assimilated datasets.
!                         
!                            <0:  all are to be assimilated
!                             0:  none are to be assimilated
!                            >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
!
!        assim_varno         Bufr elements of obs sets for assimilation. A value of
!                            0 implies that all are to be used.
!
!        assim_stnid         Stnids of obs sets for assimilation. '*' denote wild cards
!
!        assim_nlev           0:  multi-level and uni-level
!                             1:  uni_level
!                            >1: multi-level 
!
!        tropo_mode          Integer indicating if special treatment is to be given to the troposphere
!                            when assimilating total column measurements. Values indicate
!                             0:  No special treatment given (default)
!                             1:  Values of the adjoint model above obsoper%column_bound set to zero.
!                                 If specified, generalized innovation operator only applied below
!                                 obsoper%column_bound in the tangent linear model.
!                             2:  Values of tangent linear model and adjoint model above
!                                 obsoper%column_bound set to zero.
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent. Relevant for total column measurements only.
!
!        tropo_bound         Integer indicating which column top value to use if tropo_mode is non-zero.
!                              0: Use fixed value of tropo_column_top
!                              1: Use model determination of tropopause
!                              2: Use model determination of PBL
!                            Options 1 and 2 will default to the value set in tropo_column_top if the model
!                            derived column top could not be determined. Relevant for total column measurements only.
!
!        tropo_column_top    Default value to use for the column boundary (in Pa). Array index refers to BUFR code
!                            element of Table 08046 (iconstituent_id) identifying the constituent.
!                            Relevant for total column measurements only.
!
!        amu                 Molecular mass  of constituents in g/moles (needed for unit conversions)
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent.
!
!       low_cutoff           min value allowed for increments prior to storage in rebm expressed as a fraction
!                            of the background field (generally < 1)
!
!       high_cutoff          max value allowed for increments prior to storage in rebm expressed as a multiple
!                            of the background field (generally > 1)
!
!       transform            Index specifying form of analysis increment (and related adjoint operation)
!                              0: no transformation (dx given input trial field denoted as x)
!                              1: dlnx 
!
!---------------------------------------------------------------------------------------- 
 
  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JELM, nulstat, ios, isize, nulnam, i
  logical :: genoper
  
  character(len=128) :: ligne  
  character(len=10)  :: namfile 

  integer :: assim_num,diagn_num,diagn_nset
  integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size)
  integer :: diagn_varno(chm_cfg_size),tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
  character(len=9) :: assim_stnid(chm_cfg_size),diagn_stnid(chm_cfg_size)
  logical :: diagn_save,diagn_all,diagn_unilev(chm_cfg_size)
  real(8) :: diagn_pressmin,tropo_column_top(0:chm_constituents_size)
  real(8) :: amu(0:chm_constituents_size)
  real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)
  integer :: transform(0:chm_constituents_size),obsdata_maxsize

  EXTERNAL FNOM,FCLOS

  namelist /namchem/ genoper, &
                     assim_num,assim_stnid,assim_varno,assim_nlev, &
                     diagn_num,diagn_stnid,diagn_varno,diagn_unilev, &
                     diagn_save,diagn_all,diagn_nset,diagn_pressmin, &
                     tropo_mode,tropo_bound,tropo_column_top,amu, &
                     low_cutoff,high_cutoff,transform,obsdata_maxsize
  
  ! Default NAMCHEM values
  
  genoper=.true.
  low_cutoff(:)=0.1
  high_cutoff(:)=10.0
  transform(:)=0

  assim_num=-1  
  assim_stnid(:)='*********'
  assim_varno(:)=0
  assim_nlev(:)=0
 
  diagn_save=.false.
  diagn_all=.true. 
  diagn_pressmin=10.  !  0.1 hPa
  diagn_nset=2
  diagn_num=0
  diagn_stnid(:)='*********'
  diagn_varno(:)=0
  diagn_unilev(:)=.false.

  tropo_mode(:) = 0
  tropo_bound(:) = 0
  tropo_column_top(:) = 0.0

  obsdata_maxsize = 90000

  amu(:) = -1.0
  amu(0) = 48.0    ! Molecular mass in g/mole for O3
  amu(1) = 18.02   ! H2O
  amu(2) = 16.04   ! CH4
  amu(3) = 44.01   ! CO2
  amu(4) = 28.01   ! CO
  amu(5) = 46.01   ! NO2
  amu(6) = 44.01   ! N2O
  amu(7) = 30.03   ! HCHO=Formaldehyde
  amu(8) = 64.06   ! SO2
  amu(9) = 17.03   ! NH3
  amu(11) = 30.0   ! NO
  amu(26) = 1.0    ! PM2.5 - Not applicable
  amu(27) = 1.0    ! PM10  - Not applicable

  ! Read from namelist file NAMCHEM

  namfile=trim("flnml")
  nulnam=0
  ierr=FNOM(nulnam,namfile,'R/O',0)

  read(nulnam,nml=namchem,iostat=ios)
  if (ios.lt.-4.or.ios.gt.0) then 
     call abort3d('chm_read_misc: Error in reading NAMCHEM namelist. iostat = ' // trim(str(ios)) )
  end if
  
  ierr=FCLOS(nulnam)      
  
  ! Set config values

  chm_config%generalized_operator = genoper
  chm_config%assim_num = assim_num
  chm_config%assim_varno = assim_varno
  chm_config%assim_stnid = assim_stnid
  chm_config%assim_nlev = assim_nlev 
  chm_config%diagn_pressmin = diagn_pressmin
  chm_config%diagn_save = diagn_save
  chm_config%tropo_mode = tropo_mode
  chm_config%tropo_bound = tropo_bound
  chm_config%tropo_column_top = tropo_column_top
  chm_config%amu = amu
  chm_config%low_cutoff = low_cutoff
  chm_config%high_cutoff = high_cutoff
  chm_config%transform = transform
  chm_config%obsdata_maxsize = obsdata_maxsize

  ! Initialize chm_comboIDlist and add (stnid,varno) pairs from the namelist

  call chm_comboIdlist(initialize=.true., nset=diagn_nset, all_combos=diagn_all)
  do jelm=1,diagn_num
     call chm_comboIdlist(stnid_add=diagn_stnid(jelm), varno_add=diagn_varno(jelm), unilev_add=diagn_unilev(jelm))
  end do

  end subroutine chm_read_misc

!-----------------------------------------------------------------------------------------
!--------------------- Routines related to layer top & bottom levels----------------------

  subroutine chm_read_layers
!
! Author   : Y. Rochon, ARQI/AQRD, Dec 2014 
!            - Partially based on oer_read_obs_erreurs_conv.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Feb 2015
!            - Renaming of routine and removal of lines no longer required.
!          
! Purpose: Read and store top and bottom layer boundaries for CH sub-families
!
! Comments:
!
! A) The option of reading from BURP files is TBD. This will change the approach in allocating
!    the arrays size as the sizes will become dependent on the number of related obs for
!    which the BURP files will need to be read.
!----------------------------------------------------------------------------------------

  use bufr

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_layers%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_layers: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_layers%stnids(chm_layers%n_stnid))
  allocate(chm_layers%vco(chm_layers%n_stnid))
  allocate(chm_layers%brp(chm_layers%n_stnid),chm_layers%ibegin(chm_layers%n_stnid))
  allocate(chm_layers%bfr(chm_layers%n_stnid),chm_layers%n_lvl(chm_layers%n_stnid))
  allocate(chm_layers%vlayertop(isize),chm_layers%vlayerbottom(isize))
 
  chm_layers%bfr(:)=0
  chm_layers%vco(:)=0
  chm_layers%brp(:)=0
  chm_layers%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_layers%n_stnid
    chm_layers%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_layers%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%bfr(jelm),chm_layers%vco(jelm),  &
       chm_layers%brp(jelm),chm_layers%n_lvl(jelm)  
    
    if (icount+chm_layers%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_layers%n_lvl(jelm).ge.1) then   
       do jlev=1,chm_layers%n_lvl(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_layers%vlayertop(icount),chm_layers%vlayerbottom(icount)
       end do
    end if

!    if (chm_layers%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_layers

!-----------------------------------------------------------------------------------------

  subroutine chm_get_layer_boundaries(cstnid,varno,ivco,nlev,default_top,default_bottom, &
                                      lfound,layertop,layerbottom)
!
! Author  : M. Sitwell, Y. Rochon, Feb 2015
! Revision: 
!
! Purpose: Return layer boundaries for an observation. Combination of STNID, BUFR element
!          and number of vertical levels to determine association to the observations.
!          Default values for top and bottom layers for total column measurements are to
!          be provided.
!
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - ivco            type of vertical coordinate (see burp_read_mod.ftn90 or
!                     routine chm_obsoperators for definitions)
!   - nlev            number of levels in the observation
!   - default_top     default value for top layer for total column measurement
!   - default_bottom  default value for bottom layer for total column measurement
!
! Outputs:
!   - lfound          Logical being .true. if layer boundaries found.
!   - layertop        top layer values
!   - layerbottom     bottom layer values
! ---------------------------------------------------------------------------------------

    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in)           :: varno,ivco,nlev
    real(8), intent(in)           :: default_top,default_bottom
    real(8), intent(out)          :: layertop(nlev),layerbottom(nlev)
    logical, intent(inout)        :: lfound
    integer                       :: ISTNID,JN,start_index
    logical                       :: iset


    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0
    lfound=.false.

    DO JN=1,chm_layers%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_layers%stnids(JN) as wildcards
       iset = stnid_equal(chm_layers%stnids(JN),CSTNID)

       ! Check if number of levels, code, and vertical coordinate type are equal.
       ! If number of levels is one and no vertical coordinate provided for total column measurement (i.e. IVCO.eq.4),
       ! then check of vertical coordinate type is disregarded afterwards.
       IF (iset) THEN
          IF ( varno.EQ.chm_layers%bfr(JN) .AND. NLEV.EQ.chm_layers%n_lvl(JN) .AND. &
              (IVCO.EQ.chm_layers%vco(JN).OR.IVCO.EQ.4) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

    IF (ISTNID.EQ.0) THEN
       ! If integrated layer information not found, if a total column measurement
       ! set to defaults, else do nothing

       if (chm_checkfor_integlayer(varno) .and. nlev.eq.1) then          
          lfound=.true.
          layertop(1) = default_top
          layerbottom(1) = default_bottom
       end if

    ELSE
       ! layer information has been found in ascii file
       lfound=.true.
       start_index = chm_layers%ibegin(ISTNID)
       layertop(:) = chm_layers%vlayertop(start_index:start_index+nlev-1)
       layerbottom(:) = chm_layers%vlayerbottom(start_index:start_index+nlev-1)  
    END IF

  end subroutine chm_get_layer_boundaries

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_layers
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for layer info
!
! ---------------------------------------------------------------------------------------

    implicit none

    if (chm_layers%n_stnid.eq.0) return

    call chm_dealloc_info(chm_layers)
 
  end subroutine chm_dealloc_layers

!-----------------------------------------------------------------------------------------
!-------------------- Routines related averaging kernel matrices -------------------------
  
  subroutine chm_read_avgkern
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Revision: 
!
! Purpose:  Read averaging kernels from ascii file and BURP file if specified in ascii file
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the averaging kernel information from the ascii file
    call chm_read_avgkern_ascii

    ! set size of BURP file array
    allocate(chm_burp_avgkern(chm_avgkern%n_stnid))

    ! read from BURP file
    do istnid=1,chm_avgkern%n_stnid
       if (chm_avgkern%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_avgkern(istnid) = chm_read_burp('brpch', chm_avgkern%stnids(istnid), &
               15044, chm_avgkern%n_lvl(istnid), 2, 14, 'DATA')
          
       end if
    end do

  end subroutine chm_read_avgkern

!----------------------------------------------------------------------------------------

  subroutine chm_read_avgkern_ascii
!
! Author   : Y. Rochon, M. Sitwell, ARQI/AQRD, Feb 2015 
!            - Currently implemented for only one latitude band
!
! Revisions: 
!          
! Purpose: Read and store averaging kernel matricesfor CH sub-families
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_avgkern%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '--------------------------------------------------'
    WRITE(*,*)   'chm_read_avgkern_ascii: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '--------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_avgkern_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:14))).ne.'SECTION III:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_avgkern%stnids(chm_avgkern%n_stnid))
  allocate(chm_avgkern%brp(chm_avgkern%n_stnid),chm_avgkern%ibegin(chm_avgkern%n_stnid))
  allocate(chm_avgkern%bfr(chm_avgkern%n_stnid),chm_avgkern%n_lvl(chm_avgkern%n_stnid))
  allocate(chm_avgkern%rak(isize))
 
  chm_avgkern%bfr(:)=0
  chm_avgkern%brp(:)=0
  chm_avgkern%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=1
  STNIDLOOP: do jelm=1,chm_avgkern%n_stnid
    chm_avgkern%ibegin(jelm)=icount

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_avgkern%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Flag indication if avgkern provided from this ascii file or
!            to be read from the BURP file,
!        (3) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%bfr(jelm),  &
       chm_avgkern%brp(jelm),chm_avgkern%n_lvl(jelm)  
    
    if (icount+chm_avgkern%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! disregard data section if values to be specified in BUFR file
    if (chm_avgkern%brp(jelm).eq.1) cycle STNIDLOOP
    
    if (chm_avgkern%n_lvl(jelm).gt.1) then   
       do jlev=1,chm_avgkern%n_lvl(jelm)

          iend=icount+chm_avgkern%n_lvl(jelm)-1

          ! Read averaging kernel matrix   
          read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%rak(icount:iend)

          icount=iend+1

       end do
    end if

 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_avgkern_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_avgkern
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for averaging kernels
!
!---------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    if (chm_avgkern%n_stnid.eq.0) return

    if (allocated(chm_burp_avgkern)) then
       do istnid=1,chm_avgkern%n_stnid
          if (chm_avgkern%brp(istnid).eq.1) call obsdata_dealloc(chm_burp_avgkern(istnid))
       end do
       deallocate(chm_burp_avgkern)
    end if

    call chm_dealloc_info(chm_avgkern)
  
  end subroutine chm_dealloc_avgkern

!-----------------------------------------------------------------------------------------

  function chm_find_avgkern(cstnid,varno,nlev) result(ISTNID)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Finds the averaging kernel for an observation if one is specified. Returns 0 if
!          either not found or not specified. Combination of STNID, BUFR element and number
!          of vertical levels to determine association to the observations.
!          
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - nlev            number of levels in the observation
!
! Returns:
!   - ISTNID          Index of averaging kernel in chm_avgkern if found. Zero indicates
!                     averaging kernel not found.
! ---------------------------------------------------------------------------------------
    
    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in) :: varno,nlev
    integer :: ISTNID,JN
    logical :: iset

    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0

    DO JN=1,chm_avgkern%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_avgkern%stnids(JN) as wildcards
       iset = stnid_equal(chm_avgkern%stnids(JN),CSTNID)

       ! Check if number of levels and BUFR code are equal.
       IF (iset) THEN
          IF ( varno.EQ.chm_avgkern%bfr(JN) .AND. NLEV.EQ.chm_avgkern%n_lvl(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

  end function chm_find_avgkern

!-----------------------------------------------------------------------------------------

  subroutine chm_get_avgkern(istnid,nlev,zlat,zlon,idate,itime,avg_kern)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Return averaging kernel for an observation.
!
! Inputs:
!   - istnid          index of averaging kernel in chm_avgkern
!   - nlev            number of observation levels
!   - idate           YYYYMMDD
!   - itime           HHMM
!
! Outputs:
!   - avg_kern        the averaging kernel
!---------------------------------------------------------------------------------------

    implicit none

    integer, intent(in)  :: istnid,nlev,idate,itime
    real(8), intent(in)  :: zlat,zlon
    real(8), intent(out) :: avg_kern(nlev,nlev)
    integer :: start_index,end_index

    if (istnid.gt.0 .and. istnid.le.chm_avgkern%n_stnid) then
       
       if (chm_avgkern%brp(istnid).eq.0) then
          ! get averaging kernel from ascii file
          start_index = chm_avgkern%ibegin(ISTNID)
          end_index = nlev*(start_index+nlev-1)
          avg_kern = RESHAPE(chm_avgkern%rak(start_index:end_index),(/nlev,nlev/),ORDER =(/2,1/))
       else
          ! get averaging kernel from BURP file
          avg_kern = obsdata_get_array2d(chm_burp_avgkern(istnid), obsdata_get_loctime_code(zlon,zlat,idate,itime))
       end if

    else
       call abort3d("chm_get_avgkern: Invalid station ID index.")
    end if

  end subroutine chm_get_avgkern

!-----------------------------------------------------------------------------------------
!----------- Routines relevant to error std. dev. (observation_erreurs.ftn90) ------------

  subroutine chm_read_obs_err_stddev
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
!
! Revision: 
!
! Purpose:  Read observation errors from ascii file and BURP file if specified in ascii file
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the error std. dev. information from the ascii file
    call chm_read_obs_err_stddev_ascii

    ! set size of BURP file std array
    allocate(chm_burp_std(chm_std%n_stnid))

    ! read from BURP file
    do istnid=1,chm_std%n_stnid
       if (chm_std%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_std(istnid) = chm_read_burp('brpch', chm_std%stnids(istnid), &
               chm_std%bfr(istnid), chm_std%n_lvl(istnid), 1, 14, 'DATA')
          
       end if
    end do

  end subroutine chm_read_obs_err_stddev

!----------------------------------------------------------------------------------------

  subroutine chm_read_obs_err_stddev_ascii
!
! Author   : Y. Rochon, Nov 2014 
!             (initial part follows the format of oer_read_obs_erreurs_conv)
! Revisions: 
!             M. Sitwell, Feb 2015
!             - Content formed as a separate routine called in oer_read_obs_erreurs_chm.
!          
! Purpose: Read and store observation error std. dev. as needed for CH family obs.
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_std%n_stnid=0
!
! CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists) then
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! chm_read_obs_err_stddev: obsinfo_chm not available.   '
    WRITE(*,*) 'WARNING! Default CH family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
    return
  ENDIF
!
! Read observation error std dev. from file obsinfo_chm for constituent data
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_obs_err_stddev_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

! Read error standard deviations for constituents if available.
! (CH family; ozone and others)
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:12))).ne.'SECTION I:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space

  read(nulstat,*,iostat=ios,err=10,end=10) chm_std%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_std%stnids(chm_std%n_stnid))
  allocate(chm_std%std_type(chm_std%n_stnid),chm_std%n_lat(chm_std%n_stnid))
  allocate(chm_std%brp(chm_std%n_stnid),chm_std%ibegin(chm_std%n_stnid))
  allocate(chm_std%bfr(chm_std%n_stnid),chm_std%n_lvl(chm_std%n_stnid))
  allocate(chm_std%std1(isize),chm_std%std2(chm_std%n_stnid),chm_std%std3(chm_std%n_stnid))
  allocate(chm_std%levels(isize),chm_std%lat(isize))
 
  chm_std%bfr(:)=0
  chm_std%brp(:)=0
  chm_std%std_type(:)=0
  chm_std%n_lvl(:)=1
  chm_std%n_lat(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  STNIDLOOP: do jelm=1,chm_std%n_stnid
    chm_std%ibegin(jelm)=icount+1

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! Read STNID (* as wildcard)    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_std%stnids(jelm) 

!   Read (1) BUFR element,
!        (2) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (3) Index specifying OER setup method,
!        (4) Number of vertical levels
!        (5) Number of latitudes
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_std%bfr(jelm),chm_std%brp(jelm),  &
       chm_std%std_type(jelm), chm_std%n_lvl(jelm), chm_std%n_lat(jelm),  &
       chm_std%std2(jelm), chm_std%std3(jelm)

    if (chm_std%n_lvl(jelm).lt.1) chm_std%n_lvl(jelm)=1
    if (chm_std%n_lat(jelm).lt.1) chm_std%n_lat(jelm)=1
    
    if (icount+chm_std%n_lvl(jelm)*chm_std%n_lat(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    ! disregard data section if set to be specified by BUFR values only
    if (chm_std%brp(jelm).eq.1.and.chm_std%std_type(jelm).eq.0) cycle STNIDLOOP 
       
    if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Read one value only (independent of level and latitude)
       
       icount=icount+1
       read(nulstat,*,iostat=ios,err=10,end=10) chm_std%std1(icount)

    else if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on latitude only
       
!      Read reference latitudes (must be in order of increasing size)
       
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
!      Read OER-related values
  
       read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%std1(icount+1:icount+chm_std%n_lat(jelm))

       icount=icount+chm_std%n_lat(jelm)

    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Value dependent on vertical level only
      
       do jlev=1,chm_std%n_lvl(jelm)
          icount=icount+1
          
!         Read vertical level and OER-related value.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%levels(icount),chm_std%std1(icount)

       end do
   
    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on vertical level and latitude 
       
!      Read reference latitudes (must be in order of increasing size)
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
!       write(*, '(10X,20F9.3)') chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
       do jlev=1,chm_std%n_lvl(jelm)
          
!         Read vertical level and OER-related lat-dependent values.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                   &
                 chm_std%levels(icount+jlev),                           &
                 chm_std%std1(icount+(jlev-1)*chm_std%n_lat(jelm)+1:icount+jlev*chm_std%n_lat(jelm))

       end do
       icount=icount+chm_std%n_lat(jelm)*chm_std%n_lvl(jelm)
    end if
 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_obs_err_stddev_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)
!
!  s/r chm_set_obs_err_stddev_index - Returns the station ID and latitude 
!                                     indices corresponding to a measurement
!
!  Author   : M. Sitwell Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!             
!  Revisions: 
!
!----------------------------------------------------------------------------------------
   
    implicit none

    character(len=*), intent(in)  :: CSTNID
    integer, intent(in)           :: NLEV,VARNO
    real(8), intent(in)           :: ZLAT
    integer, intent(out)          :: ISTNID,JINT

    integer                       :: JN,ilen1,ilen2,ji,ibegin

 ! Important: Combination of STNID, BUFR element and number of vertical levels
 !            to determine association to the observations.

 !            Find stnid with same number of vertical levels and same BUFR element.
 !            Note: * in chm_std%stnids stands for a wildcard
     
    ISTNID=0

    DO JN=1,chm_std%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_std%stnids(JN) as wildcards
                   
       IF (stnid_equal(chm_std%stnids(JN),CSTNID)) THEN
          IF (NLEV .EQ. chm_std%n_lvl(JN) .AND. VARNO .EQ. chm_std%bfr(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF

    END DO

    IF (ISTNID.NE.0) THEN

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN

          ! Find latitude index for interpolation.
          ! Assuming increasing latitudes in chm_std%lat

          ibegin=chm_std%ibegin(ISTNID)-1
          IF (ZLAT .GE. chm_std%lat(ibegin+chm_std%n_lat(ISTNID))) THEN
             JINT=chm_std%n_lat(ISTNID)+1
          ELSE
             DO JINT=1,chm_std%n_lat(ISTNID)
                IF (ZLAT .LE. chm_std%lat(ibegin+JINT) ) exit
             END DO
          END IF
                                           
       END IF
    END IF

  end subroutine chm_obs_err_stddev_index

!----------------------------------------------------------------------------------------

  function chm_get_obs_err_stddev(CSTNID,NLEV,VARNO,ZLAT,ZLON,IDATE,ITIME,ZVAL,ZLEV,IFIRST) result(obs_err_stddev) 
!
!  s/r chm_set_obs_err_stddev - Returns the observational error std for a CH family measurement
!
!  Author   : M. Sitwell, ARQI/AQRD, Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!
!  Revisions: 
!
!----------------------------------------------------------------------------------------

    implicit none
   
    character(len=*), intent(in) :: CSTNID
    real(8), intent(in) :: ZVAL,ZLEV,ZLAT,ZLON
    integer, intent(in) :: NLEV,VARNO,IDATE,ITIME
    logical, intent(in) :: IFIRST
    real(8)  :: obs_err_stddev 

    real(8) :: wgt,zwb,sigma
    integer :: ibegin,ILEV,JN

    integer, save :: ISTNID,JINT

    ! If this call is for the first level for this measurement, get
    ! the station ID and latitude indices corresponding to this measurement
    if (ifirst) call chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)
    
    ! Identify level if needed
                   
    IF (ISTNID .EQ. 0) THEN
       
       ! Set error standard deviations as 5% default value.
       
       obs_err_stddev = 0.05D0*ZVAL
       
       WRITE(*,'(1X,"Error std. dev. for STNID= ",A10," not found. Set to 5%.")') CSTNID

    ELSE
             
       IF (chm_std%n_lvl(ISTNID) .GT. 1) THEN
                  
          ! Find nearest vertical level (no interpolation)
                 
          zwb=1.E10
          ibegin=chm_std%ibegin(ISTNID)-1
          DO JN=1,chm_std%n_lvl(ISTNID)
             IF (zwb .GT. abs(ZLEV-chm_std%levels(ibegin+JN)) ) THEN
                ILEV=JN
                zwb=abs(ZLEV-chm_std%levels(ibegin+JN))
             END IF
          END DO
          ILEV=ibegin+(ILEV-1)*chm_std%n_lat(ISTNID)+1
       ELSE
          ILEV=chm_std%ibegin(ISTNID)     
       END IF

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN
                
          ! Apply interpolation

          ILEV=ILEV+JINT-1
          ibegin=chm_std%ibegin(ISTNID)-1
          IF (JINT.EQ.1.OR.JINT.GT.chm_std%n_lat(ISTNID)) THEN
             wgt=chm_std%std1(ILEV)
          ELSE
             wgt=(chm_std%std1(ILEV-1)*(chm_std%lat(ibegin+JINT)-ZLAT)+ &
                  chm_std%std1(ILEV)*(ZLAT-chm_std%lat(ibegin+JINT-1)))/ &
                  (chm_std%lat(ibegin+JINT)-chm_std%lat(ibegin+JINT-1))
          END IF
       ELSE
          wgt=chm_std%std1(ILEV)                
       END IF
                                         
       IF (chm_std%brp(ISTNID).EQ.0) THEN
               
          ! Set error standard deviations from scratch using content of
          ! previously read content of the "obsinfo_chm" file.
                
          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
             obs_err_stddev = wgt
          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
             obs_err_stddev = min(chm_std%std3(ISTNID),max(chm_std%std2(ISTNID),wgt*ZVAL))
          ELSE IF (chm_std%std_type(ISTNID) .EQ. 2) THEN
             obs_err_stddev = sqrt(chm_std%std2(ISTNID)**2+(wgt*ZVAL)**2)
          ELSE 
!             IF (INDEX_BODY.EQ.IDATA)  &
!                  WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
!                  chm_std%std_type(ISTNID) , CSTNID
             WRITE(*,'(1X,"EOR setup type ",I3," is not recognized.")')     &
                  chm_std%std_type(ISTNID)
          END IF

       ELSE
          
          ! Adjust error standard deviations read from BURP file if requested.
          
          sigma = obsdata_get_element(chm_burp_std(istnid), obsdata_get_loctime_code(zlon,zlat,idate,itime))
          
          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
             obs_err_stddev = sigma
          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
             obs_err_stddev = max(chm_std%std2(ISTNID),wgt*sigma)
          ELSE
             WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
                  chm_std%std_type(ISTNID) , CSTNID
             call abort3d('chm_get_obs_err_stddev:')
          END IF
       END IF
              
    END IF

  end function chm_get_obs_err_stddev

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_obs_err_stddev
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for observation errors for the CH family
!
!---------------------------------------------------------------------------------------
  
    implicit none

    integer :: istnid

    if (chm_std%n_stnid.eq.0) return
    
    if (allocated(chm_burp_std)) then
       do istnid=1,chm_std%n_stnid
          if (chm_std%brp(istnid).eq.1) call obsdata_dealloc(chm_burp_std(istnid))
       end do
       deallocate(chm_burp_std)       
    end if

    if (allocated(chm_std%stnids))   deallocate(chm_std%stnids)
    if (allocated(chm_std%n_lvl))    deallocate(chm_std%n_lvl)
    if (allocated(chm_std%std_type)) deallocate(chm_std%std_type)
    if (allocated(chm_std%ibegin))   deallocate(chm_std%ibegin)
    if (allocated(chm_std%bfr))      deallocate(chm_std%bfr)
    if (allocated(chm_std%brp))      deallocate(chm_std%brp)
    if (allocated(chm_std%n_lat))    deallocate(chm_std%n_lat)
    if (allocated(chm_std%std1))     deallocate(chm_std%std1)
    if (allocated(chm_std%std2))     deallocate(chm_std%std2)
    if (allocated(chm_std%std3))     deallocate(chm_std%std3)
    if (allocated(chm_std%levels))   deallocate(chm_std%levels)
    if (allocated(chm_std%lat))      deallocate(chm_std%lat)

  end subroutine chm_dealloc_obs_err_stddev

!-----------------------------------------------------------------------------------------
!------------------- BURP functions and routines -----------------------------------------

  function chm_read_burp(filename,stnid,varno,nlev,ndim,bkstp,block_type) result(burp_out)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Purpose:  Retrieve information from BURP file for CH family observations. Can retrieve
!           either 1D or 2D data from a report.
!           Note: Exponent BUFR data (i.e. data with BUFR number 8090) will only be applied
!                 to 1D data.
!
! Revision:  M. Sitwell, ARQI/AQRD, May 2015
!            - Modified to read both 1D and 2D data from a report
!
! Arguments:
!
!  Input
!           filename      BURP file name
!           stnid         station ID of observation
!           varno         BUFR code
!           nlev          number of levels in the observation
!           ndim          number of dimensions for the retrieved data in
!                         each report (i.e. ndim=1 for std, ndim=2 for
!                         averagine kernels) 
!           bkstp         bkstp number of requested block
!           block_type    block type indicated by the two rightmost bits
!                         of bknat. Valid values are 'DATA', 'INFO', '3-D',
!                         and 'MRQR'.
!
!  Output 
!           burp_out      struct_chm_obsdata object
!
!-----------------------------------------------------------------------------------------
    
    use burp_module

    implicit none

    character(len=*), intent(in) :: filename
    character(len=9), intent(in) :: stnid
    character(len=4), intent(in) :: block_type
    integer, intent(in)          :: ndim,varno,nlev,bkstp
    type(struct_chm_obsdata) :: burp_out
    character(len=9)      :: rep_stnid
    character(len=22)     :: code
    type(burp_file)       :: brp
    type(burp_rpt)        :: rep
    type(burp_block)      :: blk
    integer               :: error,ref_rpt,nrep,ref_blk
    integer               :: ref_bkstp,nval,ivar,iexp,ilev,icount
    integer               :: date,time,ilat,ilon,iele,nele,icol
    real(8)               :: val,exponent
      
    ! initialize burp file, report, and block
    Call BURP_Init(brp, iostat=error)
    Call BURP_Init(rep, iostat=error)
    Call BURP_Init(blk, iostat=error)

    ! open the burp file
    Call BURP_New(brp, FILENAME=filename, MODE=FILE_ACC_READ, IOSTAT=error)
    
    if (error.ne.0) CALL ABORT3D('chm_read_burp: Could not open BURP file: ' // filename)

    ! get number of reports in file
    Call BURP_Get_Property(brp, NRPTS=nrep)
    
    ! allocate memory
    if (ndim.eq.1) then
       call obsdata_alloc(burp_out,nrep,dim1=nlev)
    else
       call obsdata_alloc(burp_out,nrep,dim1=nlev,dim2=nlev)
    end if

    icount = 0  ! counter of reports with same stnid and number of levels as input 
    ref_rpt = 0
    
    ! loop through reports    
    REPORTS: do

       ref_rpt = BURP_Find_Report(brp, REPORT=rep, SEARCH_FROM=ref_rpt, IOSTAT=error)

       if (ref_rpt<0) exit REPORTS
       
       call BURP_Get_Property(rep, STNID=rep_stnid, DATE=date, TEMPS=time, LATI=ilat, LONG=ilon) 

       if (.not.stnid_equal(stnid,rep_stnid)) cycle REPORTS

       ! loop through blocks
       ref_blk = 0
       BLOCKS: do
          
          ref_blk = BURP_Find_Block(rep, BLOCK=blk, SEARCH_FROM=ref_blk, IOSTAT=error)          
          if (ref_blk<0) exit BLOCKS
          
          call BURP_Get_Property(blk, NELE=nele, NVAL=nval, BKSTP=ref_bkstp, IOSTAT=error)
          
          if (.not.IS_Burp_Btyp(trim(block_type),BLOCK=blk) .or. bkstp.ne.ref_bkstp .or. nval.ne.nlev) cycle BLOCKS

          ! required block found if code reaches this point, retrieve data and store in burp_out

          icount=icount+1
          burp_out%code(icount) = obsdata_get_loctime_code(ilon,ilat,date,time)  ! this code is a unique identifier for this report

          if (ndim.eq.1) then
             ! retrieve 1D data
             
             ivar = BURP_Find_Element(blk, ELEMENT=varno, IOSTAT=error)
             iexp = BURP_Find_Element(blk, ELEMENT=8090, IOSTAT=error)
                
             if (iexp.lt.0) then
                ! No exponent found in block
                do ilev=1,nval                   
                   burp_out%data1d(icount,ilev) = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                end do
             else
                ! Apply exponent
                do ilev=1,nval                   
                   val = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                   exponent = BURP_Get_Rval(blk, NELE_IND=iexp, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                   burp_out%data1d(icount,ilev) = val * 10**exponent
                end do
             end if
                   
          else if (ndim.eq.2) then
             ! retrieve 2D data
             
             icol = 0
             do iele=1,nele
                ivar = BURP_Get_Element(blk, INDEX=iele, IOSTAT=error)
                if (ivar.eq.varno) then
                   icol = icol+1
                   do ilev=1,nval                  
                      burp_out%data2d(icount,ilev,icol) = BURP_Get_Rval(blk, NELE_IND=iele, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                   end do
                end if
             end do

          end if

          exit BLOCKS

       end do BLOCKS
    end do REPORTS
   
    ! resize first dimension of data arrays from length of nrep to icount
    call resize(burp_out%code,icount)
    if (ndim.eq.1) then
       call resize(burp_out%data1d,icount,nlev)
    else if (ndim.eq.2) then
       call resize(burp_out%data2d,icount,nlev,nlev)
    end if
    burp_out%nrep = icount
    
    ! deallocate
    Call BURP_Free(brp,iostat=error)
    Call BURP_Free(rep,iostat=error)
    Call BURP_Free(blk,iostat=error)
    
  end function chm_read_burp

!-----------------------------------------------------------------------------------------
!------------------- OBSDATA functions and routines -----------------------------------------

  subroutine obsdata_alloc(obsdata,nrep,dim1,dim2)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Allocates memory for structure struct_chm_obsdata to hold obs data file information.
!          If dim2 is specified, then the data array associated with each observation/report
!          will be 2D array. will be a 1D array if dim2 is not specified.
!
! Revision:
!     Y. Rochon and M. Sitwell  April 2016
!       - strucutre generalized for more types of observational data
!
! Input
!
!    obsdata      data structure to allocate
!    nrep         max number of associated observations/reports for data 
!    dim1         first dimension length of the array associated to each observation/report
!    dim2         second dimension length of the array associated to each observation/report (optional)
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsdata), intent(inout) :: obsdata
    integer, intent(in) :: nrep,dim1 
    integer, intent(in), optional :: dim2 
    
    obsdata%nrep = nrep
    obsdata%dim1 = dim1
    
    if (present(dim2)) then
       obsdata%dim2 = dim2
       obsdata%ndim = 2
       allocate(obsdata%data2d(nrep,dim1,dim2))
    else
       obsdata%dim2 = 0
       obsdata%ndim = 1
       allocate(obsdata%data1d(nrep,dim1))
    end if

    ! code is a character string assigned to each observation/report to uniquely identify it
    allocate(obsdata%code(nrep))
    
    ! The following are counters used to keep tract of position in the
    ! data arrays when extracting values via obsdata_get_element.
    ! The values are initialized to one, pointing to the very first element.
    obsdata%irep = 1
    obsdata%idim1 = 1

  end subroutine obsdata_alloc

!-------------------------------------------------------------------------------------------

  subroutine obsdata_dealloc(obsdata)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Deallocates memory for structure struct_chm_obsdata
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsdata), intent(inout) :: obsdata
    
    if (associated(obsdata%data1d)) deallocate(obsdata%data1d)
    if (associated(obsdata%data2d)) deallocate(obsdata%data2d)
    if (associated(obsdata%code))   deallocate(obsdata%code)

  end subroutine obsdata_dealloc

!-------------------------------------------------------------------------------------------

  function obsdata_get_element(obsdata,code) result(element)
! 
!   Purpose: Returns element of array from obsdata 1D data array. The returned element is the
!            one with the specified identifying code.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!
!  Output
!           element       retrieved element from obsdata%data1d
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=22), intent(in) :: code
    real(8) :: element
    
    ! find (obsdata%irep,obsdata%idim1) for current observation
    call obsdata_set_index(obsdata,code)
        
    ! get element from data array at current position
    element = obsdata%data1d(obsdata%irep,obsdata%idim1)

    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep .and. obsdata%idim1.eq.obsdata%dim1) then
       obsdata%irep = 1
       obsdata%idim1 = 1
    else

       if (obsdata%dim1.gt.1) then
          obsdata%idim1=obsdata%idim1+1
          if (obsdata%idim1.gt.obsdata%dim1) then
             obsdata%idim1=1
             obsdata%irep=obsdata%irep+1
          end if
       else
          obsdata%irep=obsdata%irep+1
       end if

    end if

  end function obsdata_get_element

!-------------------------------------------------------------------------------------------

  function obsdata_get_array1d(obsdata,code) result(array)
! 
!   Purpose: Returns 1D data array from obsdata. The returned array is the one with the specified
!            identifying code.
!
!   Author: Y. Rochon, ARQI/AQRD, Nov 2015
!           - Largely a copy of obsdata_get_array2d by M. Sitwell
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!
!  Output
!           array        retrieved array from obsdata%data1d of dimension obsdata%dim1
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=22), intent(in) :: code
    real(8) :: array(obsdata%dim1)
    
    ! find obsdata%irep for current observation
    call obsdata_set_index(obsdata,code)
    
    ! get element from data array at current position
    array = obsdata%data1d(obsdata%irep,:)
    
    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep) then
       obsdata%irep = 1
    else
       obsdata%irep=obsdata%irep+1
    end if

  end function obsdata_get_array1d

!-------------------------------------------------------------------------------------------

  function obsdata_get_array2d(obsdata,code) result(array)
! 
!   Purpose: Returns 2D data array from obsdata. The returned array is the one with the specified
!            identifying code.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!
!  Output
!           array        retrieved array from obsdata%data2d of dimension (obsdata%dim1,obsdata%dim2)
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=22), intent(in) :: code
    real(8) :: array(obsdata%dim1,obsdata%dim2)
    
    ! find obsdata%irep for current observation
    call obsdata_set_index(obsdata,code)
    
    ! get elements from data array at current position
    array = obsdata%data2d(obsdata%irep,:,:)
    
    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep) then
       obsdata%irep = 1
    else
       obsdata%irep=obsdata%irep+1
    end if

  end function obsdata_get_array2d

!-------------------------------------------------------------------------------------------

  subroutine obsdata_set_index(obsdata,code)
! 
!  Purpose: Sets the position variables in struct_chm_obsdata (burp%irep, burp%idim1)
!           to reference the record that matches the input identifying code.
!
!  Author: Y. Rochon, ARQI/AQRD, Oct 2015
!
!  Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           index         obs index
!
!  Output
!           obsdata%irep      current index position for the observation/report
!           obsdata%idim1     current index position that iterates through the first dimension
!                             of the data array
! 
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=22), intent(in) :: code
    integer :: i
     
    if (obsdata%nrep.le.0) call abort3d("obsdata_set_index: No reports available.")
    i=0
    
    ! Search for matching identifier code
    do while (obsdata%code(obsdata%irep).ne.code)
       obsdata%irep=obsdata%irep+1
       if (obsdata%irep.gt.obsdata%nrep) obsdata%irep=1
       obsdata%idim1=1
       if (i.gt.obsdata%nrep) &
            call abort3d("obsdata_set_index: Obs index not found for nrep = " // trim(str(obsdata%nrep)) // " and code = '" // code // "'" )
       i=i+1       
    end do        

  end subroutine obsdata_set_index

!-------------------------------------------------------------------------------------------

  function obsdata_get_loctime_code_i(ilon,ilat,date,time) result(code)
! 
!  Purpose: Generates a unique 22 character code corresponding to lon,lat,date,time. To be
!           used for setting the unique identifier 'code' in struct_chm_obsdata. Can be
!           called under the interface obsdata_get_loctime_code.
!
!  Author: M. Sitwell, April 2016
!    
!  Input
!           ilon          longitude integer
!           ilat          latitude integer
!           date          date in YYYYMMDD
!           time          time in HHMM
!
!  Output
!           code          unique code
! 
!-------------------------------------------------------------------------------------------
    
    implicit none

    integer, intent(in) :: ilon,ilat,date,time
    character(len=22)   :: code

    if (ilon.gt.0) then
       write(code(1:5),'(I5.5)') ilon
    else
       write(code(1:5),'(I5.5)') 36000 + ilon
    end if
    
    write(code(6:10),'(I5.5)') ilat
    write(code(11:18),'(I8.8)') date
    write(code(19:22),'(I4.4)') time

  end function obsdata_get_loctime_code_i

!-------------------------------------------------------------------------------------------

  function obsdata_get_loctime_code_r(lon,lat,date,time) result(code)
! 
!  Purpose: Generates a unique 22 character code corresponding to lon,lat,date,time. To be
!           used for setting the unique identifier 'code' in struct_chm_obsdata. Can be
!           called under the interface obsdata_get_loctime_code.
!
!  Author: M. Sitwell, April 2016
!    
!  Input
!           lon           longitude real (radians)
!           lat           latitude real (radians)
!           date          date in YYYYMMDD
!           time          time in HHMM
!
!  Output
!           code          unique code
! 
!-------------------------------------------------------------------------------------------
    
    use MathPhysConstants_mod

    implicit none

    real(8), intent(in) :: lon,lat
    integer, intent(in) :: date,time
    character(len=22)   :: code
    integer :: ilon,ilat
    
    ilon = nint(100*(lon/MPC_RADIANS_PER_DEGREE_R8))
    ilat = nint(100*(90. + lat/MPC_RADIANS_PER_DEGREE_R8))

    code = obsdata_get_loctime_code_i(ilon,ilat,date,time)

  end function obsdata_get_loctime_code_r

!-----------------------------------------------------------------------------------------
!------------------- Miscellaneous utilities functions and routines ----------------------

  function stnid_equal(id1,id2) result(same)
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!           M. Sitwell, Feb 2015
!           - Code set as a function.
!           Y. Rochon, July 2015
!           - Accounted for ilen1>ilen2 with the additional characters being *
!           M. Sitwell, Aug 2015
!           - Made function symmetric so that * is treated as a wildcard
!             for both arguments
!
! Purpose: Compares STNID values allowing for * as wildcards and trailing blanks 
!
! Input
!          id1         reference stnid
!          id2         stnid being verified
!
! Output
!
!          same        logical indicating if id1 and id2 match
!     
!-----------------------------------------------------------------------------------------    

    implicit none

    logical :: same
    CHARACTER(len=*), intent(in) :: id1,id2
    integer :: ilen1,ilen2,ji

    same=.true.
    ilen1=len_trim(id1)
    ilen2=len_trim(id2)  
              
    do ji=1,min(ilen1,ilen2)
       if ( id1(ji:ji).ne.'*' .and. id2(ji:ji).ne.'*' .and. id2(ji:ji).ne.id1(ji:ji) ) then
          same = .false.
          exit
       end if
    end do
    
    if (same.and.ilen1.gt.ilen2) then
       do ji=ilen2+1,ilen1
          if (id1(ji:ji).ne.'*') then
              same=.false.
              exit
          end if
       end do
    else if (same.and.ilen2.gt.ilen1) then
       do ji=ilen1+1,ilen2
          if (id2(ji:ji).ne.'*') then
              same=.false.
              exit
          end if
       end do
    end if
        
  end function stnid_equal
 
!-------------------------------------------------------------------------------------------

  character(len=20) function int2str(i)
!
! Author  : M. Sitwell Oct 2015
!
! Purpose: Function for integer to string conversion. Helpful when calling subroutine abort3d.
!
!-------------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: i
    
    write(int2str,*) i
    int2str = adjustl(int2str)
    
  end function int2str
  
!-------------------------------------------------------------------------------------------

  character(len=20) function float2str(x)
!-------------------------------------------------------------------------------------------
!
! Author:  M. Sitwell April 2016
!
! Purpose: Function for integer to string conversion. Helpful when calling subroutine abort3d.
!
!-------------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: x

    write(float2str,*) x
    float2str = adjustl(float2str)

  end function float2str

!-------------------------------------------------------------------------------------------

  subroutine chm_get_stringId(cstringin,nobslev,CList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from a list of accumulating character 
!            strings (e.g. stnids).
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!            Y.J. Rochon, ARQI/AQRD, July 2015
!            - Account for wildcards (use if stnid_equal) when present.         
!
!   Input:
!
!       Nmax            Max allowed dimension.
!       NListSize       Input number of identified IDs (must be >=0 and <=Nmax)
!       CList           Input list of accumulated character strings
!                       for uni and multi-level data.
!       cstringin       Input character string
!       nobslev         Number of elements in profile associated to cstringin.
!
!   Output:
!
!       NListSize       Updated number of identified IDs
!       CList           Updated list of accumulated character strings
!       elemId          Index of cstringin within CList_chm
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,nobslev
    integer, intent(inout) :: NListSize
    integer, intent(out)   :: elemId
    character(len=*), intent(in)     :: cstringin
    character(len=*),  intent(inout) :: CList(Nmax)
  
    integer :: i
    character(len=120) :: cstring
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_stringId: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       if (nobslev.eq.1) then 
          cstring=trim(cstringin)//'U'
          do i=1,NListSize
             if (trim(cstring).eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       else 
          cstring=trim(cstringin)       
          do i=1,NListSize
             if (trim(cstring).eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       end if
       
       if (elemId.eq.0) then
          do i=1,NListSize
             if (stnid_equal(trim(CList(i)),trim(cstring))) then
                elemId=i
                exit
             end if
          end do
       end if
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        if (nobslev.eq.1) then
           CList(NListSize)=trim(cstringin)//'U'
        else
           CList(NListSize)=trim(cstringin)
        end if
    end if
    
  end subroutine chm_get_stringId

!-------------------------------------------------------------------------------------------
  subroutine chm_get_Id(id,IdList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from list of accumulating integer IDs.
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!
!   Input:
!
!       Nmax         Max allowed dimension.
!       NListSize    Input number of IDs (must be >=0 and <=Nmax)
!       IdList       Input list of accumulated IDs.
!       id           Input id for individual obs
!
!   Output:
!
!       NListSize    Updated number of IDs
!       IdList       Updated list of accumulated IDs.
!       elemId       Index of id within List
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,id
    integer, intent(inout) :: NListSize,IdList(Nmax)
    integer, intent(out)   :: elemId
  
    integer :: i
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_Id: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       do i=1,NListSize
          if (id.eq.IdList(i)) then
              elemId=i
              exit
          end if
       end do
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        IdList(NListSize)=id
    end if
    
  end subroutine chm_get_Id

!-------------------------------------------------------------------------------------------

  subroutine chm_comboIdlist(stnid_add,varno_add,unilev_add,stnid_list,varno_list,unilev_list, &
                             num_elements,initialize,nset,gather_mpi,all_combos)
! 
!   Purpose: Provide list of fixed or accumulated stnid, (stnid,varno) or 
!            (stnid,varno,multi/uni-level) combinations to be used in searches.
!
!            Can be used for both single processor and  MPI mode, where 'gather_mpi' must be set
!            to .true. at some point for use with MPI.
!
!            Called from osd_chem_diagnmostics in file obspacediag_mod.ftn90.
!
!   Author: Y.J. Rochon, ARQI/AQRD, Aug 2015
!    
!   Revisions: M. Sitwell, ARQI/AQRD, Aug 2015
!              - Moved module variables required for this subroutine to local saved variables
!              - Merged MPI and non-MPI routines (although rpn_comm_* routines must be available 
!                at compilation even if not run in MPI mode)
!
!   Input:
!
!       stnid_add      stnid to add to stnid_list if part of unique set
!       varno_add      varno to add to varno_list if part of unique set
!       unilev_add     unilev logical to add to unilev_list if part of unique set
!       initialize     Initialize internal arrays and counters
!       gather_mpi     Gather all local MPI process and recompile unique lists
!
!   Inout:
!
!       nset           Integer indicating grouping of diagnostics. Input variable
!                      if initialize=.true., output variable otherwise.
!                      Values indicate
!                       1: group by stnid
!                       2: group by (stnid,bufr)
!                       3: group by (stnid,bufr,multi/uni-level)
!
!       all combos     Indicates if all combinations specified by nset are to
!                      be use, or only those specified in the namelist NAMCHEM
!                      Input variable if initialize=.true., output variable
!                      otherwise.
!
!   Output:
!
!       stnid_list     List of unique stnids
!       varno_list     List of unique varno
!       unilev_list    List of unique uni/multi-level identifications
!       num_elements   Number of unique elements in *_list arrrays
!
!-------------------------------------------------------------------------------------------
 
    implicit none
    
    integer, parameter :: nmax=100,stnid_len=9

    logical, intent(in), optional :: initialize,gather_mpi,unilev_add
    integer, intent(in), optional :: varno_add
    character(len=stnid_len), intent(in), optional :: stnid_add

    integer, intent(inout), optional :: nset
    logical, intent(inout), optional :: all_combos

    integer, intent(out), optional :: varno_list(nmax),num_elements
    character(len=stnid_len), intent(out), optional :: stnid_list(nmax)
    logical, intent(out), optional :: unilev_list(nmax)

    ! local arrays of unique values
    integer, save :: varno_unique(nmax)
    character(len=stnid_len), save :: stnid_unique(nmax)
    logical, save :: unilev_unique(nmax)
    
    ! global arrays of unique values
    integer, allocatable :: num_unique_all(:),varno_unique_all(:,:)
    character(len=stnid_len),allocatable :: stnid_unique_all(:,:)
    logical, allocatable :: unilev_unique_all(:,:)

    integer, save :: num_unique ! running count of number of unique elements
    integer, save :: iset=2
    logical, save :: lall_combos=.true.

    logical :: same,init
    integer :: i,j,nproc,iproc,ierr

    init=.false.
    if (present(initialize)) init = initialize

    
    ! Initialize internal arrays and counters
    if (init) then
       stnid_unique(:) = ''
       varno_unique(:) = 0
       unilev_unique(:) = .false.
       num_unique = 0
       if (present(nset)) iset = nset
       if (present(all_combos)) lall_combos = all_combos
    end if      


    ! Add new elements to internal arrays if not there already
    if (present(stnid_add)) then
      
       if (iset.ge.2 .and. (.not. present(varno_add))) call abort3d('chm_comboIdlist: varno_add must be present to add element for nset>=2.')
       if (iset.ge.3 .and. (.not. present(unilev_add))) call abort3d('chm_comboIdlist: unilev_add must be present to add element for nset>=3.')

       same = .false.

       do i=1,num_unique
          same = stnid_equal(stnid_add,stnid_unique(i))
          if (iset.ge.2) same = same .and. varno_add.eq.varno_unique(i)
          if (iset.ge.3) same = same .and. unilev_add.eqv.unilev_unique(i)
          if (same) exit
       end do

       if (.not.same) then
          num_unique=num_unique+1
          if (num_unique.gt.nmax) call abort3d("chm_comboIDlist: Max allowed dimension exceeded.")
          stnid_unique(num_unique) = stnid_add
          if (iset.ge.2) varno_unique(num_unique) = varno_add
          if (iset.ge.3) unilev_unique(num_unique) = unilev_add
       end if
    end if
        

    ! Gather unique arrays from each local mpi process and compile global unique arrays
    if (present(gather_mpi)) then
       if (gather_mpi) then

          call rpn_comm_size("GRID",nproc,ierr)

          allocate(num_unique_all(nproc))
          allocate(stnid_unique_all(nmax,nproc))
          if (iset.ge.2) allocate(varno_unique_all(nmax,nproc))
          if (iset.ge.3) allocate(unilev_unique_all(nmax,nproc))
          
          num_unique_all(:) = 0
          stnid_unique_all(:,:) = ''
          if (iset.ge.2) varno_unique_all(:,:) = 0
          if (iset.ge.3) unilev_unique_all(:,:) = .false.
          
          call rpn_comm_barrier("GRID",ierr)

          call rpn_comm_allgather(num_unique,1,"MPI_INTEGER",num_unique_all,1,"MPI_INTEGER","GRID",ierr)
          call allgather_string(stnid_unique,stnid_unique_all,nmax,stnid_len,nproc,"GRID",ierr)
          if (iset.ge.2) call rpn_comm_allgather(varno_unique,nmax,"MPI_INTEGER",varno_unique_all,nmax,"MPI_INTEGER","GRID",ierr)
          if (iset.ge.3) call rpn_comm_allgather(unilev_unique,nmax,"MPI_LOGICAL",unilev_unique_all,nmax,"MPI_LOGICAL","GRID",ierr)
          
          stnid_unique(:) = ''
          if (iset.ge.2) varno_unique(:) = 0
          if (iset.ge.3) unilev_unique(:) = .false.
          num_unique = 0
          
          ! Amalgamate unique lists
          do iproc=1,nproc
             do j=1,num_unique_all(iproc)

                same = .false.

                do i=1,num_unique
                   same = stnid_equal(stnid_unique_all(j,iproc),stnid_unique(i))
                   if (iset.ge.2) same = same .and. varno_unique_all(j,iproc).eq.varno_unique(i)
                   if (iset.ge.3) same = same .and. unilev_unique_all(j,iproc).eqv.unilev_unique(i)
                   if (same) exit
                end do
              
                if (.not.same) then
                   num_unique=num_unique+1
                   if (num_unique.gt.nmax) call abort3d("chm_comboIDlist: Max allowed dimension exceeded.")
                   stnid_unique(num_unique) = stnid_unique_all(j,iproc)
                   if (iset.ge.2) varno_unique(num_unique) = varno_unique_all(j,iproc)
                   if (iset.ge.3) unilev_unique(num_unique) = unilev_unique_all(j,iproc)
                end if
             end do
          end do

          deallocate(num_unique_all,stnid_unique_all)
          if (allocated(varno_unique_all)) deallocate(varno_unique_all)
          if (allocated(unilev_unique_all)) deallocate(unilev_unique_all)

       end if
    end if


    ! Return internal arrays (and other info) if requested
    if (present(varno_list)) varno_list = varno_unique
    if (present(stnid_list)) stnid_list = stnid_unique
    if (present(unilev_list)) unilev_list = unilev_unique
    if (present(num_elements)) num_elements = num_unique
    if (.not. init) then
       if (present(nset)) nset = iset
       if (present(all_combos)) all_combos = lall_combos
    end if
    
  end subroutine chm_comboIdlist

!-------------------------------------------------------------------------------------------

  subroutine allgather_string(str_list,str_list_all,nlist,nchar,nproc,comm,ierr)
! 
!   Purpose: Performs the MPI 'allgather' routine for an array of strings
!
!   Author:  Y. Rochom, ARQI/AQRD, July 2015
!
!   Revisions:  M. Sitwell, ARQI/AQRD, Aug 2015
!               - Code set as a subroutine
!-------------------------------------------------------------------------------------------

    implicit none

    character(len=nchar), intent(in) :: str_list(nlist)
    character(len=*), intent(in) :: comm
    integer, intent(in) :: nlist,nchar,nproc
    character(len=nchar), intent(out) :: str_list_all(nlist,nproc)
    integer, intent(out) :: ierr

    integer :: num_list(nlist*nchar),num_list_all(nlist*nchar,nproc)
    integer :: ilist,ichar,iproc
              
    ! Convert strings to integer sequences

    do ilist=1,nlist
       do ichar=1,nchar
          num_list((ilist-1)*nchar+ichar) = iachar(str_list(ilist)(ichar:ichar))
       end do
    end do

    ! Perform allgather with converted integer sequences

    call rpn_comm_allgather(num_list,nlist*nchar,"MPI_INTEGER",num_list_all,nlist*nchar,"MPI_INTEGER",comm,ierr)
       
    ! Convert integer sequences to stnid character strings
          
    do iproc=1,nproc
       do ilist=1,nlist
          do ichar=1,nchar
             str_list_all(ilist,iproc)(ichar:ichar) = achar(num_list_all((ilist-1)*nchar+ichar,iproc))
          end do
       end do
    end do

  end subroutine allgather_string

!-------------------------------------------------------------------------------------------

  logical function chm_lcheck_skipassim(cstnid,varno,nobslev,iass)

! 
!   Purpose: Identify whether or not the obs set identified by 
!            the combination of (cstnidin, bufrin,nlevs) will be
!            be assimilated or used for independent verifications.
!
!
!   Author: Y.J. Rochon, ARQI/AQRD, July 2015
!    
!   Revisions:
!
!   Input:
!
!       cstnid           Input station id
!       varno            Obs BUFR number
!       nobslev          Number of levels
!       iass             Initial flag indicating if assimilatation status
!
!                          0: cannot (will not) be assimilated.
!                          1: can be assimilated
!
!   Output:
!
!       chm_lcheck_skipassim   Indicating if assimilation to be skipped but data
!                              is to be used for independent verifications after 
!                              assimilation/minimization.
!
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in) :: varno, nobslev, iass
    character(len=*), intent(in) :: cstnid
  
    integer :: i,elemId
    
    chm_lcheck_skipassim=.false.
    if (iass.ne.1.or.chm_config%assim_num.eq.-1) return
    
    if (chm_config%assim_num.eq.0) then
       chm_lcheck_skipassim=.true.  ! will not be assimilated
    else if (chm_config%assim_num.gt.0) then
       elemId=0   
       do i=1,chm_config%assim_num
          if (stnid_equal(trim(chm_config%assim_stnid(i)),trim(cstnid))) then
             if (chm_config%assim_varno(i).eq.0.or.chm_config%assim_varno(i).eq.varno) then
                if (chm_config%assim_nlev(i).eq.0.or.(nobslev.eq.1.and.chm_config%assim_nlev(i).eq.1).or. &
                   (nobslev.gt.1.and.chm_config%assim_nlev(i).gt.1)) then
                    elemId=i
                    exit
                end if
             end if
          end if
       end do
       if (elemId.eq.0) chm_lcheck_skipassim=.true.   ! will not be assimilated
    end if
       
  end function chm_lcheck_skipassim

!-------------------------------------------------------------------------------------------

  subroutine resize_1d_real(arr,dim1)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
    implicit none

    real(8), pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    real(8), pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = 0.0D0
    
    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_1d_real
!-------------------------------------------------------------------------------------------

  subroutine resize_1d_int(arr,dim1)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
     
    implicit none

    integer, pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    integer, pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = 0
    
    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_1d_int

!-------------------------------------------------------------------------------------------

  subroutine resize_1d_str(arr,dim1)
!
! Author  : M. Sitwell  April 2016
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
     
    implicit none

    character(len=*), pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    character(len=len(arr(1))), pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = ""
    
    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_1d_str

!-------------------------------------------------------------------------------------------
  
  subroutine resize_2d_real(arr,dim1,dim2)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Resize 2D array
!
! Revision: 
!           Y. Rochon Feb 2016
!           - Added option to increase array sizes
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:)
    integer, intent(in) :: dim1,dim2
    real(8), pointer :: tmp(:,:)
    integer :: dim1_in,dim2_in,d1,d2

    dim1_in = size(arr,dim=1)
    dim2_in = size(arr,dim=2)
    d1 = min(dim1_in, dim1)
    d2 = min(dim2_in, dim2)

    allocate(tmp(dim1,dim2))
    tmp(1:d1,1:d2) = arr(1:d1,1:d2)
    
    if (dim1.gt.dim1_in) tmp(d1+1:dim1,:) = 0.0D0
    if (dim2.gt.dim2_in) tmp(:,d2+1:dim2) = 0.0D0
      
    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_2d_real

!-------------------------------------------------------------------------------------------
  
  subroutine resize_3d_real(arr,dim1,dim2,dim3)
!
! Author  : M. Sitwell  May 2015
! Revision: 
!
! Purpose: Resize 3D array
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:,:)
    integer, intent(in) :: dim1,dim2,dim3
    real(8), pointer :: tmp(:,:,:)
    integer :: dim1_in,dim2_in,dim3_in,d1,d2,d3

    dim1_in = size(arr,dim=1)
    dim2_in = size(arr,dim=2)
    dim3_in = size(arr,dim=3)
    d1 = min(dim1_in, dim1)
    d2 = min(dim2_in, dim2)
    d3 = min(dim3_in, dim3)

    allocate(tmp(dim1,dim2,dim3))
    tmp(1:d1,1:d2,1:d3) = arr(1:d1,1:d2,1:d3)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1,:,:) = 0.0D0
    if (dim2.gt.dim2_in) tmp(:,d2+1:dim2,:) = 0.0D0
    if (dim3.gt.dim3_in) tmp(:,:,d3+1:dim3) = 0.0D0

    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_3d_real

!---------------------------------------------------------------------------------------
  
  subroutine chm_dealloc_info(info)
!
! Author  : M. Sitwell  May 2015
!
! Purpose: Deallocates struct_chm_info instance
!
!---------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_info), intent(inout) :: info

    if (allocated(info%stnids))       deallocate(info%stnids)
    if (allocated(info%bfr))          deallocate(info%bfr)
    if (allocated(info%brp))          deallocate(info%brp)
    if (allocated(info%vco))          deallocate(info%vco)
    if (allocated(info%n_lat))        deallocate(info%n_lat)
    if (allocated(info%ibegin))       deallocate(info%ibegin)
    if (allocated(info%n_lvl))        deallocate(info%n_lvl)
    if (allocated(info%rak))          deallocate(info%rak)
    if (allocated(info%vlayertop))    deallocate(info%vlayertop)
    if (allocated(info%vlayerbottom)) deallocate(info%vlayerbottom)
    if (allocated(info%lat))          deallocate(info%lat)

  end subroutine chm_dealloc_info

!-----------------------------------------------------------------------------------

  subroutine chm_apply_transform(varName,bkgrnd_ptr,l_reverse,mode,incr_ptr)
!
! Author: Y. Rochon, Nov 2015
!
! Purpose: Apply transform (or its inverse) of background field or increment field.
!          Called by chm_transform_final_increments in file chem_interface_mod.ftn90.
!
! Revisions:
!        M. Sitwell, April 2016
!          - Added input integer mode for selection of transform sub-type.
!          - Create new sub-function log_matrix from previous code for handling
!            negative values before taking the log. 
!
! Arguments:
!
!   In
!
!     varName          Field name (nomvar)
!     l_reverse        Reverse/inverse transformation
!     mode             selected sub-transformation type (defined for each transformation
!                      given in chm_config%transform)
!
!   InOut
!
!     bkgrnd_ptr       pointer to statevector for the background
!     incr_ptr         pointer to increment field
!
!-----------------------------------------------------------------------------------

    implicit none
    
    character(len=*), intent(in) :: varName
    integer, intent(in) :: mode
    logical, intent(in) :: l_reverse

    real(8), intent(inout), pointer :: bkgrnd_ptr(:,:,:,:)        
    real(8), intent(inout), pointer, optional :: incr_ptr(:,:,:,:)   

    integer :: iconstituent_id

    iconstituent_id = chm_varnumFromVarname(varName)
    if (iconstituent_id.lt.0) return
    
    write(*,'(A,I2,A,I2,A,A)') "chm_apply_transform: applying transform number ",chm_config%transform(iconstituent_id), &
         " with mode = ",mode," for field ",trim(varName)

    select case(chm_config%transform(iconstituent_id))
    case(0)
       return
    case(1)
    
       ! Transform lnx to/from x or dlnx to/from dx
       
       if (.not.present(incr_ptr).and.(mode.eq.1.or.mode.eq.2)) &
            call abort3d("chm_apply_transform: incr_ptr must be provided for mode = " // trim(str(mode)) )

       if (.not.l_reverse) then

          ! Forward transformation
              
          select case(mode)
          case(0)
             bkgrnd_ptr = log_matrix(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = log_matrix(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = log_matrix(bkgrnd_ptr+incr_ptr) - log_matrix(bkgrnd_ptr)           
          end select

       else
    
          ! Reverse transformation          
       
          select case(mode)
          case(0)
             bkgrnd_ptr = exp(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = exp(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = exp(bkgrnd_ptr+incr_ptr) - exp(bkgrnd_ptr)
          end select 
             
       end if

    case default
       call abort3d("chm_apply_transform: transform selection " // trim(str(chm_config%transform(iconstituent_id))) // " not currenly defined." )
    end select
    
  contains

    function log_matrix(mat)
    !
    ! Author: Y. Rochon, Nov 2015 (made into function by M. Sitwell)
    !
    ! Purpose: Helper function for taking the log of a matrix that might contain negative values.
    !          Places where negative values occur will be set as the log of the minimum positive
    !          value along the first (longitudinal) dimension.
    !
    !-----------------------------------------------------------------------------------

      implicit none

      real(8), intent(in) :: mat(:,:,:,:)
      real(8) :: log_matrix(size(mat,1),size(mat,2),size(mat,3),size(mat,4))

      integer :: j,k,m
      real(8) :: valmin

      do m=1,size(mat,4)
         do j=1,size(mat,3)
            do k=1,size(mat,2)

               valmin = minval(mat(:,k,j,m), mask=mat(:,k,j,m).gt.0.0)
               if (valmin.gt.1.E30) valmin=1.E-20

               where (mat(:,k,j,m).gt.0.0)
                  log_matrix(:,k,j,m) = log(mat(:,k,j,m))
               elsewhere
                  log_matrix(:,k,j,m) = log(valmin)
               end where
               
            end do
         end do
      end do

    end function log_matrix

  end subroutine chm_apply_transform

!-----------------------------------------------------------------------------------
 
  function chm_varnumFromVarName(varName) result(varNumber)
!
!   Author: Y.J. Rochon (ARQI), Jan. 2016
!
!   Revisions:
!
!   Purpose: Identifies varNumber from varName 
!          
!-----------------------------------------------------------------------------------

      use bufr
      implicit none
      character(len=*),  intent(in) :: varName
      integer    :: varNumber
      
      varNumber=0
      select case (varName)
      
      ! Weather variables (assumes one specific BUFR per varname (for other possible
      ! cases, see varnamelist_mod)
      
      case('UU')
        varNumber=BUFR_NEUU
      case('VV')
        varNumber=BUFR_NEVV
      case('TT')
        varNumber=BUFR_NETT
      case('GZ')
        varNumber=BUFR_NEDZ
      case('HU')
        varNumber=BUFR_NEHU
      case('P0')
        varNumber=BUFR_NEPS
      case('DW')
        varNumber=BUFR_NEDW

      ! Atmospheric constituents other that H2O
              
      case('O3','TO3')
        varNumber=BUFR_NECH_O3
      case('TCH4')
        varNumber=BUFR_NECH_CH4
      case('TCO2')
        varNumber=BUFR_NECH_CO2
      case('TCO','ECO')
        varNumber=BUFR_NECH_CO
      case('TNO2','ENO2')
        varNumber=BUFR_NECH_NO2
      case('TN2O')
        varNumber=BUFR_NECH_N2O
      case('TNO')
        varNumber=BUFR_NECH_NO
      case('HCHO','THCH','EHCH')
        varNumber=BUFR_NECH_HCHO
      case('SO2','TSO2','ESO2')
        varNumber=BUFR_NECH_HCHO
      case('NH3','TNH3','ENH3')
        varNumber=BUFR_NECH_NH3
      case('AF')
        varNumber=BUFR_NECH_PM25
      case('AC')
        varNumber=BUFR_NECH_PM10
        
      case default
         write(*,*) 'chm_varnumFromVarName: Unknown variable name! ',varName
         call abort3d('aborting in chm_varnumFromVarName')
      end select

    end function chm_varnumFromVarname

!-----------------------------------------------------------------------------------

  subroutine chm_apply_bounds(varName,bkgrnd_ptr,inc_ptr)
!
! Author: M. Sitwell Sept 2015
!         - Originally as chm_check_negative
!
! Revisions:
!            Y. Rochon, Nov 2015
!            - Modified to chm_apply_bounds
!
! Purpose: Checks for negative analysis values and if any negative values found will
!          modify the increment so that the analysis  is reset to low_cutoff*background
!          at these points. This check is done with fields of the same resolution as
!          the increment. Also applies upper bound.
!
!          Called by chm_transform_final_increments in file chem_interface_mod.ftn90.
!
! In
!
!    varName          Field name (nomvar)
!
! InOut
!
!   inc_prt          pointer to statevector for the increment
!   bkgrnd_prt       pointer to statevector for the background (with same resolution as the increment)
!
!-----------------------------------------------------------------------------------

    implicit none
    
    character(len=*), intent(in) :: varName

    real(8), intent(inout), pointer :: inc_ptr(:,:,:,:),bkgrnd_ptr(:,:,:,:)        
    logical, allocatable :: outside(:,:,:,:)

    integer :: iconstituent_id,nlow,nhigh,i1,i2,i3,i4
    logical :: file_exists

    integer, parameter :: unit=10
    
    iconstituent_id = chm_varnumFromVarname(varName)
    if (iconstituent_id.lt.0) return

    ! Open output file
    inquire(file=chm_warnings_filename, exist=file_exists)
    if (file_exists) then
       open(unit, file=chm_warnings_filename, status="old", position="append", action="write")
    else
       open(unit, file=chm_warnings_filename, status="new", action="write")
    end if
    
    allocate(outside(size(inc_ptr,1),size(inc_ptr,2),size(inc_ptr,3),size(inc_ptr,4)))

    if (chm_config%low_cutoff(iconstituent_id).ge.0.0) then

       ! Check if both background and analysis are negative. If so set the increment to force an analysis of zero at these locations
       outside = bkgrnd_ptr.lt.0.0 .and. bkgrnd_ptr+inc_ptr.lt.0.0
       nlow = count(outside)

       if (nlow.gt.0) then
          write(unit,'(A,I7,A,A,A)') "chm_apply_bounds: ",nlow," negative background and analysis values were found for field ",trim(varName),"."
          write(unit,'(A)') "Modifying the increment so the analysis is instead equal to zero at these locations."       
          write(unit,'(A)') "JLON JLEV JLAT TSTEP   Background   Init. incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(unit,'(4(I4,1X),2G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4),inc_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = -bkgrnd_ptr
          write(unit,*)
       end if
            
       ! Check if the analysis is below the trial field cutoff. If so set analysis to this cut-off value at these locations.
       outside = bkgrnd_ptr+inc_ptr.lt.chm_config%low_cutoff(iconstituent_id)*bkgrnd_ptr .and. bkgrnd_ptr.ge.0.0
       nlow = count(outside)
            
       if (nlow.gt.0) then
          write(unit,'(A,I7,A,F4.1,A,A,A)') "chm_apply_bounds: ",nlow," analysis values were found below the cut-off of ", &
               100*chm_config%low_cutoff(iconstituent_id), &
               "% of the trial field for field ",trim(varName),"."
          write(unit,'(A)') "Modifying the increment so the analysis is instead equal to the lower bound cut-off value at these locations."
          write(unit,'(A)') "JLON JLEV JLAT TSTEP   Background  Init.-incr.  New-incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(unit,'(4(I4,1X),3G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4), &
                           inc_ptr(i1,i2,i3,i4),(chm_config%low_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = (chm_config%low_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr
       end if

    end if

    if (chm_config%high_cutoff(iconstituent_id).ge.0.0) then

       ! Check if the analysis is above the imposed upper bound. If so set analysis to this cut-off value at these locations.
       outside = bkgrnd_ptr+inc_ptr.gt.chm_config%high_cutoff(iconstituent_id)*bkgrnd_ptr .and. bkgrnd_ptr.ge.0.0
       nhigh = count(outside)
            
       if (nhigh.gt.0) then
          write(unit,'(A,I7,A,F5.2,A,A,A)') "chm_apply_bounds: ",nhigh," analysis values were found above the cut-off of ", &
               chm_config%high_cutoff(iconstituent_id), &
               " times the trial field for field ",trim(varName),"."
          write(unit,'(A)') "Modifying the increment so the analysis is instead equal to the upper bound cut-off value at these locations."
          write(unit,'(A)') "JLON JLEV JLAT TSTEP   Background  Init.-incr.  New-incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(unit,'(4(I4,1X),3G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4), &
                           inc_ptr(i1,i2,i3,i4),(chm_config%high_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = (chm_config%high_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr
       end if

    end if

    close(unit)
    deallocate(outside)

  end subroutine chm_apply_bounds
      
!-------------------------------------------------------------------------------------------

  function chm_convert_z_to_pressure(altitude,rgz_mod,press_mod,nlev,nlev_mod,lat,success) result(press)
!
! Author   : M. Sitwell, May 2015
!          
! Purpose: Converts an array of geopotential heights to pressures. Uses linear interpolation
!          in log(p).
!
! Arguments:
!
!   Input
!     altitude      altitudes to convert to pressures (m)
!     rgz_mod       geopotential heights on model levels (m), assumed to be in decending order
!     press_mod     pressure on model levels, assumed to be in ascending order
!     nlev          length of altitude array
!     nlev_mod      number of model levels
!     lat           latitude (rad)
!
!   Output
!     press         rz converted to pressures
!
!----------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: altitude(nlev),rgz_mod(nlev_mod),press_mod(nlev_mod),lat
    integer, intent(in) :: nlev,nlev_mod
    logical, intent(inout) :: success(nlev)
    real(8) :: press(nlev),rgz(nlev)
    integer :: ilev,ilev_mod

    ! Convert altitudes to geopotential heights
    rgz = chm_convert_z_to_gz(altitude,lat,nlev)

    do ilev=1,nlev

       ! Check if height is above or below model boundaries
       if ( rgz(ilev).gt.rgz_mod(1) .or. rgz(ilev).lt.rgz_mod(nlev_mod) ) then
          success(ilev)=.false.
       end if

       if (success(ilev)) then

          ! Find model layers directly above and below rgz(ilev).
          ! After exit of loop we will have 
          ! rgz_mod(ilev_mod) >= rgz(ilev) > rgz_mod(ilev_mod+1)
          do ilev_mod=1,nlev_mod-1
             if ( rgz(ilev).le.rgz_mod(ilev_mod) .and. &
                  rgz(ilev).gt.rgz_mod(ilev_mod+1) ) exit
          end do
          
          ! Linear interpolation in gz,log(p)
          press(ilev) = press_mod(ilev_mod+1) * (press_mod(ilev_mod)/press_mod(ilev_mod+1))**( &
               (rgz(ilev)-rgz_mod(ilev_mod+1))/(rgz_mod(ilev_mod)-rgz_mod(ilev_mod+1)) )

       else
          press(ilev) = 0.0
       end if

    end do

  end function chm_convert_z_to_pressure

!----------------------------------------------------------------------------------------

  function chm_convert_z_to_gz(altitude,lat,nlev) result(rgz)
!
! Author   : M. Sitwell, June 2015
!          
! Purpose: Converts altitudes to geopotential heights. Uses the Helmert formula to
!          parameterize the latitude dependence and uses analytical result of the
!          integral of \int g(z)dz for the altitude dependence (see J.A. Dutton 1976,
!          p.65). At an altitude of 50 km, the altitude and geopotential height
!          differ by around 0.2-0.5 km, depending on the latitude.
!
! Arguments:
!
!   Input
!     altitude      altitudes (m)
!     lat           latitude (rad)
!
!   Output
!     rgz           geopotential heights (m)
!
!----------------------------------------------------------------------------------------
  
    use earthconstants_mod
    
    implicit none

    real(8), intent(in) :: altitude(nlev),lat
    integer, intent(in) :: nlev
    real(8) :: rgz(nlev)

    rgz = (RG/9.8) * (1.-2.64D-03*cos(2.*lat)+5.9D-6*cos(2.*lat)**2) * RA*altitude/(RA+altitude)

  end function chm_convert_z_to_gz

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagnostic(lat,lon,pressure,OmP,OmA,obs,Jo,sigma_obs,success,deltaPressure,nlev_obs, &
                                     initialize,print_stats,print_summary,unilevel,label,filename)
!
! Author   : M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Computes and prints observation space diagnostics. The data for a full profile is added to the
!          statistics in a single call.
!
!          If <initialize>==.TRUE. then the input parameters lat,lon,vert refer to the bin size for that
!          variable and the input parameters OmP,OmA,obs,Jo are not used.
!
! Revisions: 
!           Y. Rochon ARQI/AQRD July 2015
!           - Further generalizations.
!          
! Arguments:
!
!   Input
!     lat            latitude in degrees
!     lon            longitutde in degrees
!     pressure       pressures of the profile (Pa)
!     OmP            obs - background
!     OmA            obs - analysis
!     obs            observations
!     Jo             cost function
!     sigma_obs      observation error standard deviation
!     success        determines which points in the profile should be added to the statistics
!     deltaPressure  used to determine ln(P) bin size (deltaPressure in Pascal)
!     nlev_obs       number of observations in the profile
!     initialize     initialize the statistics arrays
!     print_stats    output statistics and deallocate statistics arrays
!     print_summary  output summary of CH family statistics 
!     unilevel       if the observation does not have a defined height coordinate
!     label          label to print when print_stats is called
!     filename       file name for lat/lon dependent statistics
!
!----------------------------------------------------------------------------------------
    
    use mpi_mod, only: mpi_myid

    implicit none

    real(8), intent(in) :: lat,lon
    real(8), intent(in), optional :: deltaPressure,pressure(:),OmP(:),OmA(:),obs(:),Jo(:),sigma_obs(:)
    logical, intent(in), optional :: initialize,print_stats,print_summary,unilevel,success(:)
    integer, intent(in), optional :: nlev_obs
    character(len=256), intent(in), optional :: label,filename

    ! MPI local arrays
    ! Real arrays indexed by (lat,lon,lev,stat), where stat=1 for RMS and stat=2 for mean for all except Jo_stats.
    ! For Jo_stats, stat=1 is Jo for x=x_analysis and stat=2 is Jo for x=x_background
    real(8), allocatable, save :: OmP_stats(:,:,:,:), OmA_stats(:,:,:,:), obs_stats(:,:,:,:), Jo_stats(:,:,:,:)
    integer, allocatable, save :: counts(:,:,:)
    
    ! MPI global arrays
    real(8), allocatable :: OmP_global(:,:,:,:), OmA_global(:,:,:,:), obs_global(:,:,:,:), Jo_global(:,:,:,:)
    integer, allocatable :: counts_global(:,:,:)

    logical, save :: allow_print_summary=.false.
    integer, save :: nlev,nlat,nlon,nbin
    real(8), save :: deltaLat,deltaLon,deltaLogPressure

    real(8) :: Jo_a,Jo_b
    real(8), save :: Jo_a_total=0.0d0, Jo_b_total=0.0d0
    integer, save :: Jo_count_total=0

    integer, parameter :: nstat=2
    integer :: ilev,ilat,ilon,ierr,unit,ilev_obs,icount
    integer, allocatable :: ncounts(:)
    real(8), allocatable :: press_bins(:)
    logical :: fileout_exist
   
    ! Intialize arrays
    if (present(initialize)) then
       if (initialize) then

          deltaLat = lat
          deltaLon = lon
          if (present(deltaPressure)) then
             deltaLogPressure=deltaPressure/1.0d5 ! set constant delta ln(P) bin
          else
             call abort3d("chm_obsspace_diagnostic: deltaPressure not defined in intialization call.")
          end if

          nlat = floor(180.0d0/deltaLat)
          nlon = floor(360.0d0/deltaLon)

          ! Add a last unequal size bin if remainder is larger than one degree
          if (180.0d0-nlat*deltaLat.gt.1.) nlat=nlat+1
          if (360.0d0-nlon*deltaLon.gt.1.) nlon=nlon+1

          ! Set number of levels for a pressure coordinate in hPa to cover the range
          ! of 0.01*chm_config%diagn_pressmin (in hPa) to 1000 hPa for layers 2 to nlev-1. 
          ! Layer 1 covers all pressure levels <= 0.01*chm_config%diagn_pressmin hPa = top of layer 2,
          ! The bottom of layer nlev-1 is provided by press_bins(nlev).
          nlev = 2 + nint(log(1.0d5/chm_config%diagn_pressmin)/deltaLogPressure) ! last index is for unilevel observations
          nbin = nlev*nlat*nlon

          if (.not. allocated(OmP_stats)) allocate(OmP_stats(nlat,nlon,nlev,nstat))
          if (.not. allocated(OmA_stats)) allocate(OmA_stats(nlat,nlon,nlev,nstat))
          if (.not. allocated(obs_stats)) allocate(obs_stats(nlat,nlon,nlev,nstat))
          if (.not. allocated(Jo_stats))  allocate(Jo_stats(nlat,nlon,nlev,nstat))
          if (.not. allocated(counts))    allocate(counts(nlat,nlon,nlev))

          OmP_stats(:,:,:,:) = 0.0d0
          OmA_stats(:,:,:,:) = 0.0d0
          obs_stats(:,:,:,:) = 0.0d0
          Jo_stats(:,:,:,:)  = 0.0d0
          counts(:,:,:)  = 0

          return
       end if
    end if

    ! Accumulate the diagnostic statistics from all processors, print out when mpi_myid=0, and then deallocate the arrays
    if (present(print_stats)) then
       if (print_stats) then
          
          ! Allocate memory for mpi global arrays
          if (.not. allocated(OmP_global)) allocate(OmP_global(nlat,nlon,nlev,nstat))
          if (.not. allocated(OmA_global)) allocate(OmA_global(nlat,nlon,nlev,nstat))
          if (.not. allocated(obs_global)) allocate(obs_global(nlat,nlon,nlev,nstat))
          if (.not. allocated(Jo_global))  allocate(Jo_global(nlat,nlon,nlev,nstat))
          if (.not. allocated(counts_global))  allocate(counts_global(nlat,nlon,nlev))
         
          ! Reduce from all mpi processes
          call rpn_comm_allreduce(OmP_stats,OmP_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
          call rpn_comm_allreduce(OmA_stats,OmA_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
          call rpn_comm_allreduce(obs_stats,obs_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
          call rpn_comm_allreduce(Jo_stats,Jo_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
          call rpn_comm_allreduce(counts,counts_global,nbin,"MPI_INTEGER","MPI_SUM","GRID",ierr)
          
          if (mpi_myid.eq.0) then
             
             ! Print globally averaged output to listing file or to output file 'filename'.
             
             ! Open and append to output file if requested
             
             if (present(filename)) then
                unit = 10
                inquire(file=filename, exist=fileout_exist)
                if (fileout_exist) then
                   open(unit, file=filename, status="old", position="append", action="write")
                else
                   open(unit, file=filename, status="new", action="write")
                end if
             else
                unit=6             
             end if
             
             if (present(label)) then
                write(unit,*)
                write(unit,*) trim(label)
             end if
                      
             if (any(counts_global.gt.0)) then

                allocate(ncounts(nlev), press_bins(nlev+1))

                ! total counts for each level 
                ncounts = sum(sum(counts_global,dim=1),dim=1)
                Jo_count_total = Jo_count_total + sum(ncounts)
             
                Jo_a = sum(Jo_global(:,:,1:nlev,1))
                Jo_b = sum(Jo_global(:,:,1:nlev,2))
                Jo_a_total = Jo_a_total + Jo_a
                Jo_b_total = Jo_b_total + Jo_b
             
                ! Set permission for allowing summary output (Jo_*_total) via print_summary.
          
                allow_print_summary=.true.
                
                ! Pressure boundaries for each bin starting from a top layer with lower boundary of 0.01*config%diagn_pressmin (i=2) in hPa 
                ! and extending to the surface.
                
                press_bins(2:nlev-1) = (/ (0.01*chm_config%diagn_pressmin*exp((ilev-2)*deltaLogPressure), ilev=2,nlev-1) /)
                press_bins(1) = 0.0d0
                press_bins(nlev) = 1200.0d0 ! set to pressure larger than the largest expected surface pressure.
                press_bins(nlev+1) = 0.0d0  ! set to zero for unilevel
             
                ! Multi-level data
             
                icount=sum(ncounts(1:nlev-1))
             
                if (icount.gt.0) then
            
                   write(unit,*)
                   write(unit,*) " Multi-level data:"
                   write(unit,*) " Cost function for this BUFR number/station ID:   Jo(x_analysis) = ",Jo_a," ,   2*Jo(x_analysis)/N = ",2.*Jo_a/icount,' with N = ',icount
                   write(unit,*) "                                                  Jo(x_backgrnd) = ",Jo_b," ,   2*Jo(x_backgrnd)/N = ",2.*Jo_b/icount

                   call chm_print_diagnostics(unit, 1, nlev-1, ncounts, press_bins, & 
                        sum(sum(obs_global(:,:,1:nlev-1,1),dim=1),dim=1), sum(sum(obs_global(:,:,1:nlev-1,2),dim=1),dim=1), &
                        sum(sum(OmP_global(:,:,1:nlev-1,1),dim=1),dim=1), sum(sum(OmP_global(:,:,1:nlev-1,2),dim=1),dim=1), &
                        sum(sum(OmA_global(:,:,1:nlev-1,1),dim=1),dim=1), sum(sum(OmA_global(:,:,1:nlev-1,2),dim=1),dim=1), &
                        sum(sum(Jo_global(:,:,1:nlev-1,1),dim=1),dim=1), sum(sum(Jo_global(:,:,1:nlev-1,2),dim=1),dim=1) )
  
                end if
             
                ! Uni-level data
             
                if (ncounts(nlev).gt.0) then
             
                   write(unit,*)
                   write(unit,*) " Uni-level data:"
                   write(unit,*) " Cost function for this BUFR number/station ID:   Jo(x_analysis) = ",Jo_a," ,   2*Jo(x_analysis)/N = ",2.*Jo_a/ncounts(nlev),' with N = ',ncounts(nlev)
                   write(unit,*) "                                                  Jo(x_backgrnd) = ",Jo_b," ,   2*Jo(x_backgrnd)/N = ",2.*Jo_b/ncounts(nlev)

                   call chm_print_diagnostics(unit, nlev, nlev, ncounts, press_bins, & 
                        sum(sum(obs_global(:,:,:,1),dim=1),dim=1), sum(sum(obs_global(:,:,:,2),dim=1),dim=1), &
                        sum(sum(OmP_global(:,:,:,1),dim=1),dim=1), sum(sum(OmP_global(:,:,:,2),dim=1),dim=1), &
                        sum(sum(OmA_global(:,:,:,1),dim=1),dim=1), sum(sum(OmA_global(:,:,:,2),dim=1),dim=1), &
                        sum(sum(Jo_global(:,:,:,1),dim=1),dim=1), sum(sum(Jo_global(:,:,:,2),dim=1),dim=1) )

                end if
                          
                deallocate(ncounts)
             
                ! Output lat,lon dependent averages to file if filename is provided
                if (present(filename).and.chm_config%diagn_save.and.(nlat.gt.1.or.nlon.gt.1)) then

                   write(unit,*)
                   write(unit,*) " Lat-long gridded statistics: "
                   write(unit,'(2X,3(A,I4))') "nlat = ",nlat," , nlon = ",nlon," , nlev = ",nlev
                   write(unit,*)

                   do ilat=1,nlat
                      do ilon=1,nlon
                         write(unit,'(2X,2(A,I6),3X,2(F8.1,A,F8.1))') "ilat = ",ilat," , ilon = ",ilon, &
                              (ilat-1.)*deltaLat-90.," < lat < ",ilat*deltaLat-90., &
                              (ilon-1.)*deltaLon," < lon < ",ilon*deltaLon
                         if (sum(counts_global(ilat,ilon,1:nlev-1)).gt.0) then
                            write(unit,*)
                            write(unit,*) " Multi-level data:"
                            call chm_print_diagnostics(unit, 1,nlev-1, counts_global(ilat,ilon,1:nlev-1), press_bins, &
                                 obs_global(ilat,ilon,1:nlev-1,1), obs_global(ilat,ilon,1:nlev-1,2), &
                                 OmP_global(ilat,ilon,1:nlev-1,1), OmP_global(ilat,ilon,1:nlev-1,2), &
                                 OmA_global(ilat,ilon,1:nlev-1,1), OmA_global(ilat,ilon,1:nlev-1,2), &
                                 Jo_global(ilat,ilon,1:nlev-1,1), Jo_global(ilat,ilon,1:nlev-1,2) )
                         else if (sum(counts_global(:,:,1:nlev-1)).gt.0) then
                            write(unit,*)
                            write(unit,*) " No multi-level data."
                            write(unit,*)
                         end if
                         if (counts_global(ilat,ilon,nlev).gt.0) then
                            write(unit,*)
                            write(unit,*) " Uni-level data:"
                            call chm_print_diagnostics(unit, nlev,nlev, counts_global(ilat,ilon,:), press_bins, &
                                 obs_global(ilat,ilon,:,1), obs_global(ilat,ilon,:,2), &
                                 OmP_global(ilat,ilon,:,1), OmP_global(ilat,ilon,:,2), &
                                 OmA_global(ilat,ilon,:,1), OmA_global(ilat,ilon,:,2), &
                                 Jo_global(ilat,ilon,:,1), Jo_global(ilat,ilon,:,2) )
                         else if (sum(counts_global(:,:,nlev)).gt.0) then
                            write(unit,*)
                            write(unit,*) " No uni-level data."
                            write(unit,*)
                         end if
                      end do
                   end do
                
                end if

                deallocate(press_bins)

             else
                write(unit,*)
                write(unit,*) "No data found for this combination."
                write(unit,*)
             end if

             if (present(filename)) close(unit)     

             call flush(6)
             
          end if

          ! Deallocate arrays
          deallocate(OmP_stats,OmA_stats,obs_stats,Jo_stats,counts)
          deallocate(OmP_global,OmA_global,obs_global,Jo_global,counts_global)

          return
       end if
    end if

    if (present(print_summary)) then             
        if (allow_print_summary.and.mpi_myid.eq.0.and.print_summary) then        
            if (present(filename)) then
               unit = 10
               inquire(file=filename, exist=fileout_exist)
               if (fileout_exist) then
                  open(unit, file=filename, status="old", position="append", action="write")
               else
                  open(unit, file=filename, status="new", action="write")
               end if              
            else
               unit=6
            end if
            
            write(unit,*)
            write(unit,*) "------------------------------------------------------------------------------------------------------------------------------------------------"
            write(unit,*)
            write(unit,*) " Total cost function for CH observations:   Jo(x_analysis) = ",Jo_a_total," ,   2*Jo(x_analysis)/N = ",2.*Jo_a_total/Jo_count_total,' with N = ',Jo_count_total
            write(unit,*) "                                            Jo(x_backgrnd) = ",Jo_b_total," ,   2*Jo(x_backgrnd)/N = ",2.*Jo_b_total/Jo_count_total
            write(unit,*)
            
            if (present(filename)) close(unit)     
        end if
        if (print_summary) return
    end if

    ! Add observation stats to the arrays
    ! Put in first/list bin if lat,lon,level lower/higher than diagnostic range
    
    ilat = max(min(1 + floor((90.0d0+lat)/deltaLat), nlat), 1)
    ilon = max(min(1 + floor(lon/deltaLon), nlon), 1)

    if (present(nlev_obs)) then

       LEVELS: do ilev_obs=1,nlev_obs

          if (present(success)) then
             if (.not. success(ilev_obs)) cycle LEVELS
          end if
          
          ilev = max(min(2 + floor(log(pressure(ilev_obs)/chm_config%diagn_pressmin)/deltaLogPressure), nlev-1), 1)
          
          if (present(unilevel)) then
             if (unilevel) ilev = nlev ! put unilevel data in last level index
          end if
          
          counts(ilat,ilon,ilev)  = counts(ilat,ilon,ilev) + 1

          if (present(OmP)) then
             OmP_stats(ilat,ilon,ilev,1) = OmP_stats(ilat,ilon,ilev,1) + OmP(ilev_obs)**2
             OmP_stats(ilat,ilon,ilev,2) = OmP_stats(ilat,ilon,ilev,2) + OmP(ilev_obs)
          end if
          if (present(OmA)) then
             OmA_stats(ilat,ilon,ilev,1) = OmA_stats(ilat,ilon,ilev,1) + OmA(ilev_obs)**2
             OmA_stats(ilat,ilon,ilev,2) = OmA_stats(ilat,ilon,ilev,2) + OmA(ilev_obs)
          end if
          if (present(obs)) then
             obs_stats(ilat,ilon,ilev,1) = obs_stats(ilat,ilon,ilev,1) + obs(ilev_obs)**2
             obs_stats(ilat,ilon,ilev,2) = obs_stats(ilat,ilon,ilev,2) + obs(ilev_obs)
          end if
          if (present(Jo)) then
             Jo_stats(ilat,ilon,ilev,1)  = Jo_stats(ilat,ilon,ilev,1)  + Jo(ilev_obs)
             Jo_stats(ilat,ilon,ilev,2)  = Jo_stats(ilat,ilon,ilev,2)  + 0.5 * OmP(ilev_obs)**2 / sigma_obs(ilev_obs)**2
          end if

       end do LEVELS
    else
       call abort3d("chm_obsspace_diagnostic: nlev_obs not specified")
    end if

  end subroutine chm_obsspace_diagnostic

!----------------------------------------------------------------------------------------

  subroutine chm_print_diagnostics(unit,nstart,nlev,counts,pressure,obs_square,obs_mean,OmP_rms,OmP_mean,OmA_rms,OmA_mean,jo_a,jo_b)
!
! Author   : M. Sitwell, June 2015
!          
! Purpose: Prints observation space diagnostics for a set of levels
!
! Arguments:
!
!   Input
!     unit           unit number for output
!     nstart         first level to save
!     nlev           number of level bins for the statistics
!     counts         counts per bin
!     pressure       pressure level boundaries of the bins
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: unit,nlev,nstart,counts(nlev)
    real(8), intent(in) :: pressure(nlev+1),obs_square(nlev),obs_mean(nlev),OmP_rms(nlev),OmP_mean(nlev), &
                           OmA_rms(nlev),OmA_mean(nlev),jo_a(nlev),jo_b(nlev)

    integer :: ilev

    write(unit,*)
                   
    write(unit,*) " Layer #    Pressure (hPa)       Counts  obs (mean)   obs (std)   rms(O-P)/<O>  <O-P>/<O>   rms(O-A)/<O>  <O-A>/<O>", &
                                                                      "    Jo(O-A)     2*Jo(O-A)/N   Jo(O-P)     2*Jo(O-P)/N"
    do ilev=nstart,nlev
       if (counts(ilev).le.0) cycle
       if (nstart.lt.nlev) then
          write(unit,11) ilev,pressure(ilev),pressure(ilev+1),counts(ilev),obs_mean(ilev)/counts(ilev), &
               sqrt(max(0.0D0,(obs_square(ilev)-obs_mean(ilev)*obs_mean(ilev)/counts(ilev))/counts(ilev))),sqrt(counts(ilev)*OmP_rms(ilev))/obs_mean(ilev), &
               OmP_mean(ilev)/obs_mean(ilev),sqrt(counts(ilev)*OmA_rms(ilev))/obs_mean(ilev),OmA_mean(ilev)/obs_mean(ilev),jo_a(ilev),2.*jo_a(ilev)/counts(ilev), &
               jo_b(ilev),2.*jo_b(ilev)/counts(ilev)
       else
          write(unit,11) 0,0.0d0,0.0d0,counts(ilev),obs_mean(ilev)/counts(ilev), &
               sqrt(max(0.0D0,(obs_square(ilev)-obs_mean(ilev)*obs_mean(ilev)/counts(ilev))/counts(ilev))),sqrt(counts(ilev)*OmP_rms(ilev))/obs_mean(ilev), &
               OmP_mean(ilev)/obs_mean(ilev),sqrt(counts(ilev)*OmA_rms(ilev))/obs_mean(ilev),OmA_mean(ilev)/obs_mean(ilev),jo_a(ilev),2.*jo_a(ilev)/counts(ilev), &
               jo_b(ilev),2.*jo_b(ilev)/counts(ilev)
       end if
    end do
    
    write(unit,*)

11  FORMAT(2X, I4, 2(F11.3), 2X, I9, 10(2X, ES11.4))
    
  end subroutine chm_print_diagnostics

!----------------------------------------------------------------------------------------

  function chm_get_col_boundary(iconstituent_id,n_modlvl,pressmodlvl,tt,gz,hu,uu,vv) result(bound_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!
! Purpose: Determine and store the boundary (e.g. tropopause or PBL) pressure levels if needed by
!          the observation operators.
!
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      iconstituent_id   BUFR code element of Table 08046 identifying the constituent.
!      n_modlvl     Number of model levels for variables other than uu and vv
!      pressmodlvl  Model pressure array
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (meters)
!      hu           Specific humidity 
!      uu           Model zonal wind component (m/s)
!      vv           Model meridional wind component (m/s)
!
!   Output
!
!      bound_press  Pressure level of boundary to be imposed
!
!   Comments
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: n_modlvl,iconstituent_id
    real(8), intent(in) :: pressmodlvl(n_modlvl),tt(n_modlvl),gz(n_modlvl)
    real(8), optional, intent(in) :: uu(:),vv(:),hu(n_modlvl)
   
    real(8) :: bound_press
        
    bound_press = -1.

    if (chm_config%tropo_mode(iconstituent_id).eq.0) return

    if (chm_config%tropo_bound(iconstituent_id).gt.0) then
       if (.not.all(tt.lt.0.) .and. .not.all(gz.lt.0.) ) then

          select case(chm_config%tropo_bound(iconstituent_id))
          case(1)
    
             ! Get tropopause pressure level
          
             if (present(hu)) then
                bound_press = chm_get_tropopause(n_modlvl,pressmodlvl,tt,gz,hu=hu)
             else
                bound_press = chm_get_tropopause(n_modlvl,pressmodlvl,tt,gz)
             end if
    
          case(2)
 
             ! Get PBL pressure level
          
             if (present(hu).and.present(uu).and.present(vv)) then
                bound_press = chm_get_pbl(n_modlvl,pressmodlvl,tt,gz,hu=hu,uu=uu,vv=vv) 
             else if (present(hu)) then
                bound_press = chm_get_pbl(n_modlvl,pressmodlvl,tt,gz,hu=hu)
             else if (present(uu).and.present(vv)) then
                bound_press = chm_get_pbl(n_modlvl,pressmodlvl,tt,gz,uu=uu,vv=vv) 
             end if

          case default
             call abort3d("chm_get_col_boundary: Unrecognized value for chm_config%tropo_bound of " // trim(str(chm_config%tropo_bound(iconstituent_id))) )
          end select

       end if
    end if

    ! Use tropo_column_top value if tropo_bound=0 or model derived boundary was unsuccessful
    if (bound_press.lt.0.0) &
         bound_press = chm_config%tropo_column_top(iconstituent_id)
      
  end function chm_get_col_boundary

!----------------------------------------------------------------------------------------

  function chm_get_tropopause(n_modlvl,pressmodlvl,tt,gz,hu) result(tropo_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!            - Following consultation with Irena Paunova for water vapour based approach
!                                     with Sylive Gravel (and wikipedia) for temperature based approach
!          
! Purpose: Determines pressure level of tropopause. 
!          Final tropopause is taken as max pressure (lowest altitude) from the
!          water vapour and temperature based tropopauses.
!
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      n_modlvl     Number of model levels
!      pressmodlvl  Model pressure array (Pa)
!      hu           Model specific humidity 
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (m)
!
!   Output
!
!     tropo_press   Tropopause level in Pa
!             
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: n_modlvl
    real(8), intent(in) :: pressmodlvl(n_modlvl),tt(n_modlvl),gz(n_modlvl)
    real(8), intent(in), optional :: hu(n_modlvl)

    real(8) :: tropo_press
  
    integer :: itop,i,k,ilaps
    real(8) :: hu_ppmv1,hu_ppmv2,hu_ppmv3,xlaps,tropo_press_hu

    real(8), parameter :: press_min=6000.         ! Min tropoause pressure 60 hPa.; equivalent to ~ 20km
    real(8), parameter :: gz_min=6000.0           ! Min tropopause level in meters.
    real(8), parameter :: ppmv_threshold=10.0     
    real(8), parameter :: tgrad_threshold=0.002   ! degrees/m (2 degrees/km)
    real(8), parameter :: consth=0.160754938e+07  ! conversion from mass mixing ratio to ppmv;  1.0e+06 / (18.015/28.96)

    tropo_press=-1.0
    if (all(gz.lt.0.0))  call abort3d('chm_get_tropopause: Missing GZ for determining tropopause pressure')

!   Initialize tropopause pressure level using temperature gradient.
!   Thermal tropopause is defined as the lowest level (above gz_min) at which (1) the lapse rate decreases
!   to <= 2 C/km and (2) the average lapse rate between this level and all higher levels within 2 km are <= 2 C/km. 
!   Ref: International Meteorological Vocabulary (2nd ed.). Geneva: Secretariat of the World Meteorological
!        Organization. 1992. p. 636. ISBN 92-63-02182-1.
!   The second requirement, based on hu, may give levels that are to high (pressure too low) in the winter hemisphere.

    do itop=3,n_modlvl
       if (pressmodlvl(itop).ge.press_min) exit
    end do
    itop=itop-1
       
    do i=n_modlvl,itop+1,-1
       if (gz(i)-gz(n_modlvl).lt.gz_min) cycle
       xlaps=-(tt(i)-tt(i-1))/(gz(i)-gz(i-1))
       if (xlaps.le.tgrad_threshold) then
          ilaps=1
          do k=i-1,itop,-1
             if (gz(k)-gz(i).gt.2000.0) exit
             xlaps=xlaps-(tt(k)-tt(k-1))/(gz(k)-gz(k-1))
             ilaps=ilaps+1
          end do
          if (xlaps/ilaps.le.tgrad_threshold) exit
       end if
    enddo
    tropo_press=pressmodlvl(i)
    
!   Improve on tropopause pressure levels using specific humidity if available,

    if (present(hu)) then
    
!      Use water vapour
      
       hu_ppmv1=0.0
       do i=itop,n_modlvl

!         Convert specific humidity to ppmv mixing ratio.
!         First apply r=q/(1-q) to convert to mass mixing ratio.
!
          if (hu(i).le.0.8.and.hu(i).ge.0) then
               hu_ppmv2 = consth*hu(i)/(1.0-hu(i))
          else if (hu(i).gt.0.8) then
               hu_ppmv2 = consth*0.8/(1.0-0.8)
          else if (hu(i).lt.0.0) then
               hu_ppmv2 = 0.0
          end if

!         Check if transition point reached.
!         Added requirement that levels below also satisfy this condition.

          if (hu_ppmv2.ge.ppmv_threshold) then
             ilaps=1
             do k=i+1,n_modlvl
                if (gz(i)-gz(k).gt.5000.0) exit
                if (hu(k).le.0.8.and.hu(k).ge.0) then
                   hu_ppmv3 = consth*hu(k)/(1.0-hu(k))
                else if (hu(k).gt.0.8) then
                   hu_ppmv3 = consth*0.8/(1.0-0.8)
                else
                   hu_ppmv3=0.0
                end if
                if (hu_ppmv3.lt.ppmv_threshold) ilaps=0
             end do
             if (ilaps.eq.1) exit
          end if
          hu_ppmv1=hu_ppmv2
       end do
       
       if (hu_ppmv2.ge.ppmv_threshold.and.ilaps.eq.1) then
       
!            Interpolate between levels
      
             if (abs(hu_ppmv2-hu_ppmv1).lt.0.1) hu_ppmv1=hu_ppmv2-0.1
!             tropo_press_hu=(log(pressmodlvl(i))*(ppmv_threshold-hu_ppmv1)+ &
!                    log(pressmodlvl(i-1))*(hu_ppmv2-ppmv_threshold)) &
!                   /(hu_ppmv2-hu_ppmv1)
!             tropo_press_hu=exp(tropo_press_hu)
             tropo_press_hu=pressmodlvl(i)
             
             tropo_press=min(tropo_press,tropo_press_hu)
       else
          write(*,*) 'chm_get_tropopause: Level and specific humidity: ',itop,hu_ppmv2
          call abort3d('chm_get_tropopause: Specific humidity too small.')
       end if
                             
    end if
    
  end function chm_get_tropopause

!----------------------------------------------------------------------------------------

  function chm_get_pbl(n_modlvl,pressmodlvl,tt,gz,hu,uu,vv) result(pbl_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!            - Following consultation with Amir Aliabadi, Shuzhan Ren and Saroja Polavarapu.
!            - RiB case based on original routine 'mixing_properties' by Chris Golaz (GFDL) 
!              and Sungsu Park(NCAR) provided by Shuzhan Ren.
!
! Purpose: Determines pressure level of planetary boundary layer using 
!          a first threshold of 0.5 for the bulk Richadson number (after Mahrt, 1981; 
!          requires availability of uu and vv). Threshold reduced to largest value
!          between 0.25 and 0.5 if first not satisfied. 
!
!          If not found with this approach, applies a variant of the Heffter approach 
!          described in Aliabadi et al (2016), with some local variation.
!
! References:
!
!  Aliabadi A.A., R.M. Staebler, J. de Grandpre, A. Zadra, and P.A.
!       Vaillancourt, 2016: Comparison of Estimated Atmospheric
!       Boundary Layer Mixing Height in teh Arctic and Southern Great
!       Plains under Statisticallt Stable Conditions: Experimental
!       and Numerical Aspects, Submitted to Atmosphere-Ocean (2015).
!  Mahrt, L. 1981: Modelling depth of the stable boundary-layer,
!       Bound-Lay. Meteorol., 21, 3-19
!  Heffter, J.L.,1980: Transport layer depth calculations, Second Joint Conference on Applications
!       of Air Pollution Meteorology, New Orleans, LA, 24-27 March 1980. American Meteorological
!       Society, Boston, MA.
!       
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      n_modlvl     Number of model levels for variables other than uu and vv
!      pressmodlvl  Model pressure array (Pa)
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (meters)
!      hu           Specific humidity
!      uu           Model zonal wind component (m/s)
!      vv           Model meridional wind component (m/s)
!
!   Output
!
!     pbl_press     PBL level in Pa
! 
!   Comments
!
!   A) Currently assumes (uu,vv) midlayer levels approximately at tt, gz, and hu levels
!      when size(uu).ne.n_modlvl.
!
!----------------------------------------------------------------------------------------

    use earthconstants_mod

    implicit none

    integer, intent(in) :: n_modlvl
    real(8), intent(in) :: pressmodlvl(n_modlvl),tt(n_modlvl),gz(n_modlvl)
    real(8), optional :: uu(:),vv(:),hu(n_modlvl)
   
    real(8) :: pbl_press
  
    integer :: itop,i,id,igradmax,inv,iRiBmax
    real(8) :: RiB1,RiB2,RiBmax,zs,thetavs,thetavh(n_modlvl),us,vs,uv,hus,huh,gradmax,grad
    real(8), parameter :: kappa = 287.04/1004.67  ! R/Cp
    real(8), parameter :: RiB_threshold=0.5, reduced=0.5 

!   Imposed min presssure of PBL height of 200 hPa (extreme; PBL height should normally be under 3km)
    real(8), parameter :: press_min=20000.  

    real(8) :: huw(n_modlvl)

    pbl_press=-1.0
    
!   Set values for lowest prognostic level 

    i = n_modlvl   
    
    if (all(gz.lt.0.0))  call abort3d('chm_get_pbl: Missing GZ for determining PBL pressure')

!   Convert hu to mass mixing ratio

    if (present(hu)) then
       huw(:)=hu(:)
    else
       huw(:)=0.0
    end if
    
    if (huw(i).le.0.8.and.huw(i).ge.0) then
        hus = huw(i)/(1.0-huw(i))
    else if (huw(i).gt.0.8) then
        hus = 0.8/(1.0-0.8)
    else if (huw(i).lt.0.0) then
        hus = 0.0
    end if
    zs = gz(i)*0.001
    
!   Potential virtual temperature at lowest prognostic level

    thetavs = tt(i)*(1.D5/pressmodlvl(i))**kappa* (1.0 + 0.61*hus )
    thetavh(n_modlvl)=thetavs

!   Set max vertical level

    do itop=2,n_modlvl-1
       if (pressmodlvl(itop).ge.press_min) exit
    end do

    RiB1=0.0
    RiB2=0.0
    RiBmax=0.0
    iRiBmax=0
    if (present(uu).and.present(vv)) then
       id=n_modlvl-size(uu)
       if (id.gt.1.or.id.lt.0) then
          call abort3d('chm_get_pbl: Unexpected number of UV levels, n_modlvl = ' // trim(str(n_modlvl)) // ' , size(uu) = ' // trim(str(size(uu))) )    
       end if
       us = uu(size(uu))
       vs = vv(size(vv))
!      us,vs set to 0.0
!      us=0.0
!      vs=0.0

!      Calc RiB from near-surface to level attaining RiB_threshold

       do i=n_modlvl-1,itop,-1
  
           if (huw(i).le.0.8.and.huw(i).ge.0) then
               huh = huw(i)/(1.0-huw(i))
           else if (huw(i).gt.0.8) then
               huh = 0.8/(1.0-0.8)
           else if (huw(i).lt.0.0) then
               huh = 0.0
           end if
           thetavh(i) = tt(i)*(1.D5/pressmodlvl(i))**kappa* ( 1.0 + 0.61*huh )

           if (id.eq.0) then
               uv = max( (uu(i)-us)**2 + (vv(i)-vs)**2, 1.D-8 ) 
           else
!             Take layer midpoint values
              uv = max( ((uu(i)+uu(i-1))/2.0-us)**2 + ((vv(i)+vv(i-1))/2.0-vs)**2, 1.D-8 ) 
           end if
         
           RiB2 = grav * (thetavh(i)-thetavs) * (gz(i)*0.001-zs) / (thetavs*uv)
           if (RiBmax.lt.RiB2.and.RiB2.ge.reduced*RiB_threshold) then
              RiBmax=RiB2
              iRiBmax=i
           end if
           if (RiB2.ge.RiB_threshold) exit
           RiB1=RiB2
       end do
    else

!      Calc only theta
      
       do i=n_modlvl-1,itop,-1
  
           if (huw(i).le.0.8.and.huw(i).ge.0) then
               huh = huw(i)/(1.0-huw(i))
           else if (huw(i).gt.0.8) then
               huh = 0.8/(1.0-0.8)
           else if (huw(i).lt.0.0) then
               huh = 0.0
           end if
           thetavh(i) = tt(i)*(1.D5/pressmodlvl(i))**kappa* ( 1.0 + 0.61*huh )
       end do
    end if   
    
    if (RiB2.ge.RiB_threshold) then    
   
 !     Interpolate between levels

       pbl_press=(log(pressmodlvl(i))*(RiB_threshold-RiB1)+ &
               log(pressmodlvl(i+1))*(RiB2-RiB_threshold)) &
               /(RiB2-RiB1)
       pbl_press=exp(pbl_press)
    else if (RiBmax.ge.reduced*RiB_threshold) then
!      Apply to level with largest RiB between reduced*RiB_threshold and RiB_threshold
       pbl_press=pressmodlvl(iRiBmax)
    else
    
!      Estimate PBL level using the Heffter conditions:
!      First find lowest inversion layer where dtheta>2K.
!      If found, assign mid of layer as PBL level. 
!      Otherwise, assign PBL level as that with largest
!      theta gradient.
       
       i=n_modlvl-1
       do while (i.gt.itop) 
          !if (thetavh(i)-thetavh(i+1).gt.0.0) then
          if ((thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1)).ge.0.005) then
             ! Near bottom of inversion layer found
             inv=i+1
             i=i-1
             !do while (thetavh(i)-thetavh(i+1).gt.0.0.and.i.gt.itop) 
             do while ((thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1)).ge.0.005.and.i.gt.itop) 
                 i=i-1
             end do
             if ((thetavh(i+1)-thetavh(inv)).gt.2.0)  then
                ! Apply  midlayer as PBL
                pbl_press=sqrt(pressmodlvl(i+1)*pressmodlvl(inv))
                exit
             end if 
          else
             i=i-1
          end if
       end do
       if (pbl_press.le.0.0) then
          gradmax=-1.D30
          igradmax=n_modlvl-1
          do i=n_modlvl-1,itop,-1
             grad=(thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1))
             if (gradmax.lt.grad) then
                gradmax=(thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1))
                igradmax=i
                if (grad.ge.0.005) then ! Check next layer as well
                   if ((thetavh(i-1)-thetavh(i))/(gz(i-1)-gz(i)).ge.0.005) exit
                end if
            end if
          end do          
          pbl_press=pressmodlvl(igradmax)
          ! write(*,*) 'chm_get_pbl: Warning2 - Max allowed altitude reached for. ',pbl_press,igradmax,gradmax,RiB2,iRiBmax,RiBmax
       !else
       !   write(*,*) 'chm_get_pbl: Warning1 - Max allowed altitude reached for. ',pbl_press,i,RiB2,iRiBmax,RiBmax     
       end if
    end if

  end function chm_get_pbl

!----------------------------------------------------------------------------------------

  subroutine chm_add_col_boundary(headerIndex,bound_press)
!
! Author: M. Sitwell, ARQI/AQRD, April 2016
!
! Purpose: Adds column boundary data to chm_column_boundary which can be retreived later
!          using a header index.
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: headerIndex
    real(8), intent(in) :: bound_press

    if (.not.associated(chm_column_boundary%data1d)) then
       call obsdata_alloc(chm_column_boundary, chm_config%obsdata_maxsize, dim1=1)
       chm_column_boundary%nrep = 0
    end if

    ! In this case nrep will count the number of filled reps in the data arrays
    chm_column_boundary%nrep = chm_column_boundary%nrep+1 

    if (chm_column_boundary%nrep.gt.chm_config%obsdata_maxsize) &
         call abort3d('chm_add_col_boundary: Reach max size of array ' // trim(str(chm_config%obsdata_maxsize)) )
    
    ! Use the header number as the unique code for this obs data
    write(chm_column_boundary%code(chm_column_boundary%nrep),'(I22)') headerIndex

    chm_column_boundary%data1d(chm_column_boundary%nrep,1) = bound_press

  end subroutine chm_add_col_boundary

!----------------------------------------------------------------------------------------

  function chm_retrieve_col_boundary(headerIndex) result(bound_press)
!
! Author: M. Sitwell, ARQI/AQRD, April 2016
!
! Purpose: Retrieves previously saved column boundary data in chm_column_boundary from
!          the header index.
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: headerIndex
    real(8) :: bound_press
    character(len=22) :: code

    write(code,'(I22)') headerIndex
    
    bound_press = obsdata_get_element(chm_column_boundary,code)

  end function chm_retrieve_col_boundary

!-------------------------------------------------------------------------------------------
!--------------------------- Routines for observation operators ----------------------------

  subroutine chm_obsoperators(obsoper,model_col,obs_col,kmode,ixtr,success)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!           Ping Du, Mar 2015
!           - Finalization of Ht*grad contribution (case(3))
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           M. Sitwell, ARQI/AQRD, May 2015
!           - Added vertical interpolation operator
!           M. Sitwell, ARQI/AQRD, June 2015
!           - Changed calculation of HBH^T to forgo calculating off-diagonal elements
!             of the final product
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Modified input arguments so that most inputs are passed through obsoper
!
! Purpose: Apply obs operator for indicated obs data and condition.
!
!          Usable as
!
!                 - general (potentially non-linear) simulation operator (kmode=0)
!                 - determination of sqrt(diag(H*B*H^T)) (kmode=1)
!                 - tangent linear operator (kmode=2)
!                 - linear adjoint operator (kmode=3)
!
! Further changes required for generalization:
!
! 1) Add layer average operators.
! 2) Add AOD operators (summation over model layers).
! 3) Add option to include use of obs error correlation matrix for kmode=2,3 
!    (This may/will need to be done in oda_Hchm and odaHTchm where the division 
!     by sigma_obs is applied. A new chem_mod routine will be needed for this
!     operation - and others for reading the correlation matrices similarly to the
!     averaging kernels.)
!
! Arguments:
!
!   Input
!
!     kmode      0 for non-linear/linear model in assimilation (all models included are currently linear)
!                1 for determination of sqrt(diag(H*B*H^T))
!                2 for tangent linear model
!                3 for adjoint model 
!
!   Inout
!
!     obsoper    Structure that holds information needed by the observation operator
!
!     obs_col    Observation space input/output profile
!                  kmode     input/output       profile
!                  -----     ------------       -------
!                    0           out            H(xb)
!                    1           out            sqrt(diag(H*B*H^T))
!                    2           out            H*dx
!                    3           in             R**-1 (Hdx-d)
!
!     model_col  Model space input/output profile
!                  kmode     input/output       profile
!                  -----     ------------       -------
!                    0           in             xb
!                    1           not used       not used
!                    2           in             dx at obs location
!                    3           out            adjoint product H^T(...)
!
!     ixtr       Flag indicating if obs within the model vertical coord range (.ne.0 for no) 
!                Can be modified internally - hence intent(inout) - even though
!                these changes will not be needed outside this routine.
!
!     success    Indicates if the observation was successfully assimilated
!
! Comments:
!
!     A. Does not yet account for potential future applications of obs 
!        vertical correlation matrices.
!        
!-------------------------------------------------------------------------------------------

  implicit none

! Declarations

! Structure to hold observation operator information

  type(struct_chm_obsoperators), intent(inout) :: obsoper

! I/O arguments: obs space variables
    
  integer, intent(in) :: kmode 
  integer, intent(inout) :: ixtr(obsoper%nobslev)
  logical, intent(inout) :: success(obsoper%nobslev)

! I/O arguments: model space profile data and others
    
  real(8), intent(inout) :: model_col(obsoper%nmodlev), obs_col(obsoper%nobslev)

! Local variables
  
  real(8) :: press_obs(obsoper%nobslev),zwork(obsoper%nmodlev),unit_conversion(obsoper%nmodlev),rsig(obsoper%nmodlev,2)
  integer :: iobslev
  real(8), allocatable :: avg_kern(:,:)
  logical :: lget_rsig


! Apply unit conversion (apply unit conversion later for kmode=3)

  select case(kmode)
  case(0,2)
     ! Convert the field in model space 
     call chm_convert_units(obsoper,model_col,kmode)
  case(1)
     ! Save the conversion factor in <unit_conversion>
     unit_conversion(:) = 1.0
     call chm_convert_units(obsoper,unit_conversion,kmode)
  end select
       
! Determine if layer boundaries are assigned to this data source.
! If so, obtain them for use in this routine. 
! Routine provides obsoper%layer_identified,
!                  obsoper%vlayertop(nobslev), 
!                  obsoper%vlayerbottom(nobslev) 
 
  call chm_get_layer_boundaries(obsoper%stnid,obsoper%varno,obsoper%vco, &
       obsoper%nobslev,obsoper%pp(1),obsoper%pp(obsoper%nmodlev), &
       obsoper%layer_identified,obsoper%vlayertop,obsoper%vlayerbottom)

! Identify observation operator based on observation units and presence or
! not of layer boundaries

  if (chm_checkfor_integlayer(obsoper%varno)) then
     if (.not.obsoper%layer_identified) then
        write(*,*)   '----------------------------------------------------------'
        write(*,*)   'STNID, BUFR index, nobslev: ',obsoper%stnid,' ',obsoper%varno,obsoper%nobslev
        call abort3d('chm_obsoperators: Required layer boundaries not available!')
     else
        ! Vertical integration operator
        obsoper%modelIndex=3
     end if
  else if (obsoper%layer_identified) then
     ! Layer averaging operator
     obsoper%modelIndex=2
  else
     ! Vertical interpolation operator
     obsoper%modelIndex=1
  end if

! Indicates if the generalized innovation operator is to be applied.

  obsoper%apply_genoper = kmode.ge.2 .and. chm_config%generalized_operator .and. &
       (obsoper%modelIndex.eq.2 .or. obsoper%modelIndex.eq.3)

! Convert observation vertical coordinate value(s) to pressure if needed

  select case(obsoper%vco)
  case(1)
     ! Convert altitude to pressure
     select case(obsoper%modelIndex)
     case(1)
        press_obs = chm_convert_z_to_pressure(obsoper%obslev,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
     case(2,3)
        obsoper%vlayertop = chm_convert_z_to_pressure(obsoper%vlayertop,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
        obsoper%vlayerbottom = chm_convert_z_to_pressure(obsoper%vlayerbottom,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
     end select
  case(2)
     ! Pressure, no conversion needed
     if (obsoper%modelIndex.eq.1) press_obs = obsoper%obslev
  case(4)
     ! No actions taken
  case default
     call abort3d("chm_obsoperators: vertical coordinate type vco = " // trim(str(obsoper%vco)) // " not available for this operator.")
  end select

! Determine if averaging kernel is to be applied

  obsoper%iavgkern = chm_find_avgkern(obsoper%stnid,obsoper%varno,obsoper%nobslev)

! Apply appropriate core observation operator
   
  select case(obsoper%modelIndex)
  case(1)

!    Vertical interpolation operator

     call chm_vert_interp_operator(obsoper,press_obs,ixtr,success)
     
!  case(2)

!    Layer averaging operator

!     call chm_layer_avg_operator  ! see 3dvar_chem routine ch_vavg

   case(3)

!    Layer integration operator

     call chm_layer_integ_operator(obsoper,ixtr,success,kmode)

  end select

! Apply averaging kernel if requested

  if (obsoper%iavgkern.gt.0) then

     allocate(avg_kern(obsoper%nobslev,obsoper%nobslev))
     
     call chm_get_avgkern(obsoper%iavgkern,obsoper%nobslev,obsoper%lat,obsoper%lon,obsoper%date,obsoper%hhmm,avg_kern)
     obsoper%zh = matmul(avg_kern,obsoper%zh)
     if (obsoper%apply_genoper) obsoper%zhp = matmul(avg_kern,obsoper%zhp)

     deallocate(avg_kern)

  end if

! Apply generalized innovation operator if requested

  if (obsoper%apply_genoper) call chm_genoper(obsoper,kmode,success)

! Finalize required quantities depending on kmode
   
  select case(kmode)

  case(0,2)
!
!     Finalize non-linear/linear operator step
!
      do iobslev=1,obsoper%nobslev
        if (success(iobslev)) then
           obs_col(iobslev)=dot_product(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)), &
                                 model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)))
        end if
      end do

  case(1)
!
!    Compute sqrt(diag(H*B*H^T))
!
     
     ! Apply unit conversion to observation operator
     do iobslev=1,obsoper%nobslev
        obsoper%zh(iobslev,:) = unit_conversion * obsoper%zh(iobslev,:)
     end do

     lget_rsig=.TRUE.
     do iobslev=1,obsoper%nobslev
        if (success(iobslev)) then
           call chm_corvert_mult(obsoper%varName,obsoper%zh(iobslev,:),obs_col(iobslev),obsoper%lvl_top(iobslev), & 
                obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,1,.TRUE.,obsoper%lat,lget_rsig,3,rsig) ! get h*B*h^T
           lget_rsig=.FALSE.
           obs_col(iobslev) = sqrt(obs_col(iobslev))  ! save as sqrt(h*B*h^T)
        else
           obs_col(iobslev) = 0.0
        end if
     end do

  case(3)
!
!     Ht*grad contribution from adjoint of tangent linear model.
!
      model_col(:) = 0.0

      do iobslev=1,obsoper%nobslev
         if (success(iobslev)) then
            zwork(:)=0.0D0
            zwork(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) = &
                 obs_col(iobslev)*obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev))
                
            call chm_convert_units(obsoper,zwork,4)
           
            model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) = &
                 model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) + &
                 zwork(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev))
         end if
      end do
      
  end select

  end subroutine chm_obsoperators

!-------------------------------------------------------------------------------------------

  logical function chm_checkfor_integlayer(varno)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose: Idenitfy if obs is a vertically integrated constituent measurement.
!
! ---------------------------------------------------------------------------------------
  
  implicit none
  integer, intent(in) :: varno
 
  if (varno.eq.15198.or.varno.eq.15001.or.varno.eq.15005.or.varno.eq.15045.or. &
      varno.eq.15020.or.varno.eq.15021.or.varno.eq.15200.or. &
      varno.eq.15009.or.varno.eq.15012) then
      
      chm_checkfor_integlayer=.true.     
  else
      chm_checkfor_integlayer=.false.
  end if
  
  end function chm_checkfor_integlayer
   
!-------------------------------------------------------------------------------------------

  subroutine chm_convert_units(obsoper,model_col,kmode)
!
! Author  : Y. Rochon and Y. Yang, June 2005 to June 2011
!           - Pre-EnVar version
! Revision: 
!           Ping Du, CDMA,Jan 2015
!           - Adapted for the EnVar
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Moved most of the inputs into obsoper
!
! Purpose: Set unit conversion factor and model variable transformations 
!          for consistency of Hx units with obs units.  
!
!          For H2O, there are preliminary conversions related to transforming
!          ln(q) to vmr and/or its TLM equivalent.
! 
! Further changes required for generalization 
!
! 1) May ultimately have two versions, with one called outside the minimization section. 
! 2) Adapt to model variable units other than vmr.
!
! Arguments:
!
!   Input
!
!     kmode     This flag has two uses.
!
!               1: For H2O, it directs conversions related to 'ln(q) to vmr'
!                   0 for model_col = trial
!                   1 for model_col = sigma
!                   2 for model_col = dx
!                   3 applied same as 2 for the ln(q) conversion to vmr
!                   4 Same as 2 and or but the conversion to rval has already been done.
!               
!               2: For linear unit conversion:
!                  Conversion applied when kmode=2,3, this depending on the BUFR element.
!                  This conversion for rval only needed for chm_genoper
!                  and when the variation in vertical must account for
!                  unit changes involving pressure and or temperature.
!                  Only the relative variation in the vertical matters as opposed
!                  to the absolute values and so the conversion is not applied for
!                  all BUFR elements.
!
!   InOut
!
!     model_col       Model space profile that has its units changed
!
!     obsoper%trial   Trial profile to have its units changed
!
!  Other
!
!     chm_config%amu(iconstituent_id)  Molecular mass of constituent (g/mol). 
!
! Comments:
!
!     A. Standard model/analysis species field provided as volumetric mixing 
!        ratio (vmr). Conversion to vmr is to applied when this is not the case. 
!        As this is hardcoded, any changes in analysis variable must
!        be reflected by correspondingly modifying this module.
!
!     B. Unit conversion factor is calculated in chm_convert_units
!        from the following factors:
!          (1) physical constants
!          (2) parameters related to a particular species such as molecular
!              mass
!          (3) variables such as T and P from background field at each
!              iteration
!
!     Coefficients related to unit conversion
!
!        conv=1.E5                 ! m to 1e-5m (=1DU)
!        rho_stp=1.293             ! air density at STP (1.293 kg/m^3)
!        RG=9.807                  ! Acceleration due to gravity (m/s^2)
!        MPC_AVOGADRO_R8           ! Avogadro's number. 6.023E23 molecules/mole
!        PC_MOLAR_MASS_DRY_AIR_R8  ! Dry air molecular mass. 28.9644 g/mole
!        MPC_RGAS_IDEAL_R8         ! Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
!      C. List should be revised following changes to the 'tableburp' file.
!
! ---------------------------------------------------------------------------------------

  use earthconstants_mod
  use MathPhysConstants_mod
  
  implicit none

  integer, intent(in) :: kmode
  type(struct_chm_obsoperators), intent(inout) :: obsoper
  real(8), intent(inout)  :: model_col(obsoper%nmodlev)

! Declaration of local variables
  integer :: jk
  real(8) :: conv, zcoef
  real(8), parameter :: rho_stp=1.293  ! kg/m^3
  real(8), save :: zval1(100),zval2(100)
!
  if (obsoper%constituent_id.lt.0) return
  
  if (obsoper%constituent_id.eq.1) then
!
!     Since the data is for H2O (iconstituent_id=1), then a conversion from the 
!     incremental variable LQ (ln q) must be performed. 
!     Then a variable transformation to vmr is performed.
!
!     First apply exponential or its TLM equivalent to get specific humidity q
!
      if (kmode.ge.2) then  ! TLM of exponential
!
!         dx = x dlnx, with lnx = trial, dlnx=model_col
!         Note: x=trial when kmode>3
!
          if (kmode.le.3) then
             obsoper%trial(:) = exp(obsoper%trial(:))
             zval1(1:obsoper%nmodlev) = obsoper%trial(:)
             if (kmode.ne.3) model_col(:) = zval1(1:obsoper%nmodlev)*model_col(:)
          else
!
!            zval1 should be the same as previously transformed in an earlier 
!            call with kmode=3 (see above the 'else').
!
             model_col(:) = zval1(1:obsoper%nmodlev)*model_col(:)
          end if
      else
          if (kmode.eq.0) then  
!
!            Converts LQ to HU or ln(x) to x
!
             model_col(:) = exp(model_col(:))
          else
!
!            Converts dLQ to dHU or dln(x) to dx 
!
!x           dx = x dlnx, with lnx = trial, dlnx=model_col
!            dx = x dlnx, with x = trial, dlnx=model_col
!                 
             model_col(:) = obsoper%trial(:)*model_col(:)
          end if
      end if
!
!     Convert specific humidity to mass mixing ratio (or mass mixing ratio increment)
!
      if (kmode.ge.2) then
         if (kmode.le.3) THEN
!
!           Apply tangent linear of r=q/(1-q):
!
!           dr = dq/(1-q)^2
!
            do jk=1,obsoper%nmodlev
               conv=obsoper%trial(jk)
               if (conv.gt.0.8) then
                  write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q exceeds 0.8 at',conv
                  conv=0.8
               else if (conv.lt.-1.D-5) then
                  write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q less than -1E-5 at ',conv
                  conv=-1.D-5
               end if
               if (kmode.ne.3) model_col(jk)=model_col(jk)/(1.0-conv)**2
               zval2(jk)=obsoper%trial(jk)
               obsoper%trial(jk) = obsoper%trial(jk)/(1.0-conv)
            end do
         else
!
!            rval (zval2) should be the same as previously transformed in an earlier 
!            call with kmode=3 (see above the 'else').
!            
             model_col(:) = model_col(:)/(1.0-zval2(1:obsoper%nmodlev))**2
         end if
      else
         do jk=1,obsoper%nmodlev
            conv=obsoper%trial(jk)   
            if (conv.gt.0.8) then
               write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q exceeds 0.8 at',conv
               conv=0.8
            else if (conv.lt.-1.D-5) then
               write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q less than -1E-5 at ',conv
               conv=-1.D-5
            end if
            model_col(jk) = model_col(jk)/(1.0-conv)**2
         end do
      end if
!
!     Mass mixing ratio to volume mixing ratio conversion
!
      if (kmode.ne.3) model_col(:) = model_col(:)*MPC_MOLAR_MASS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)
  end if
!
! Identify unit conversion factor and variable conversion
! assuming model variable is in vmr.

  if (kmode.eq.3) then
!
!     Apply conversion only to obsoper%trial (if needed)
!
      zcoef=1.0
      select case (obsoper%varno)
      case(15023,15027,15194,15195,15223) 
!
!        For conversion from vmr to kg/m^3
!     
         zcoef = zcoef*chm_config%amu(obsoper%constituent_id)/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
!
      case(15199,15003,15010) 
!     
!        For conversion from vmr to partial pressure (PA)
!
         obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)*zcoef
!
      case(15230,15022) 
!
!        For conversion from vmr to molecules/m^3
!        RDCJ: Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
         zcoef = zcoef*MPC_AVOGADRO_R8/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
!         
      end select
      return
  end if
!  
! Apply conversion to incrrement-related profile (and obsoper%trial if needed)
!
  zcoef=1.0
  select case (obsoper%varno)
      case(15198,15001,15005,15045) 
!
!        For conversion of vmr*dP integral to DU
!
         conv=1.E5              ! m to 1e-5m (=1DU)
         zcoef = zcoef/RG/rho_stp*conv
         model_col(:) = model_col(:)*zcoef
!
      case(15009,15012)
!
!        For conversion of vmr*dP integral to molecules/m^2
!
         conv=1.E3         ! 1.E3 g/kg
!                          ! required for conversion of PC_MOLAR_MASS_DRY_AIR_R8 from g/mol
!                          ! to kg/mol
         zcoef = zcoef*MPC_AVOGADRO_R8*conv/MPC_MOLAR_MASS_DRY_AIR_R8/RG
         model_col(:) = model_col(:)*zcoef
!
      case(15020,15021,15200) 
!
!        For conversion of vmr*dP integral to kg/m^2
!
         zcoef = zcoef*chm_config%amu(obsoper%constituent_id)/MPC_MOLAR_MASS_DRY_AIR_R8/RG
         model_col(:) = model_col(:)*zcoef
!
      case(15023,15027,15194,15195,15223) 
!
!        For conversion from vmr to kg/m^3
!     
         zcoef = zcoef*chm_config%amu(obsoper%constituent_id)/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         model_col(:) = model_col(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
!
      case(15199,15003,15010) 
!     
!        For conversion from vmr to partial pressure (PA)
!
         model_col(:) = model_col(:)*obsoper%pp(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)*zcoef
!
      case(15230,15022) 
!
!        For conversion from vmr to molecules/m^3
!        RDCJ: Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
         zcoef = zcoef*MPC_AVOGADRO_R8/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         model_col(:) = model_col(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) obsoper%trial(:) = obsoper%trial(:)*obsoper%pp(:)/obsoper%tt(:)*zcoef
!
      case(15026,15008,15197,15208) 
!
!        Observation in molecules/molecules by volume (vmr).
!        No conversion needed.
!     
         zcoef = zcoef*1.0D0
         model_col(:) = model_col(:)*zcoef

      case(15024,15196,12001,15055,15062)

!        Do nothing

      case(15192,15011) 
!
!        Code to be revised when actually applied for the first time
!        according to model field units.
!
         call abort3d('CHM_CONVERT_UNITS: Obs conversion not yet defined for varno = ' // trim(str(obsoper%varno)) )
!
      case default 
!
         call abort3d('CHM_CONVERT_UNITS: Unknown obs units for varno = ' // trim(str(obsoper%varno)) )
         
  end select

  end subroutine chm_convert_units

!---------------------------------------------------------------------------------------

  function chm_required_field(varName,varno) result(needed)
!
! Author:  M. Sitwell Dec 2015 
!
! Purpose: Determines if the specifed field name is required somewhere in
!          in the observation operators for a particular observation type 
!
! Revisions:
!
! Arguments:
!
!   Input
!
!     varName   Name of field 
!     varno     BUFR descriptor element
!
!----------------------------------------------------------------------------------------

    implicit none

    character(len=*), intent(in) ::varName
    integer, intent(in) :: varno
    logical :: needed
    
    select case(trim(varName))
    case('TT')
 
       select case (varno)
       case(15023,15027,15194,15195,15223,15230,15022)
          needed = .true.
       case default
          needed = .false.
       end select
         
    case default
       needed = .false.
    end select

  end function chm_required_field

!---------------------------------------------------------------------------------------

  subroutine chm_layer_integ_operator(obsoper,ixtr,success,kmode)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input of ixtr and iavgkern
!           Y. Rochon ARQOI/AQRD, Sept 2015
!           - Added iconstituent_id, kmode, ... to varName and related option of producing
!             tropo increments from total column data.
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Many of the input arguments moved into obsoper
!
! Purpose:  Perform layer integration and calculations.
!
! Arguments:
!
!  Input 
!
!     ixtr         Flag indicating if obs outside model vertical range
!                  0 for no.
!     kmode        Observation model stage used to allow option of
!                  tropo increment determination from total column data when
!                  obsoper%column_bound > obsoper%vlayertop for
!                  nobslev=1. For kmode=3, calc only for region between
!                  obsoper%column_bound and surface. For kmode=2, split
!                  calc for model top to obsoper%column_bound and 
!                  obsoper%column_bound and surface.
!     iconstituent_id  BUFR constituent ID.
!
!  InOut
!
!     obsoper  observation operator object
!     success      success of integration
!     ixtr         Modified ixtr as needed. 
!
!-----------------------------------------------------------------------------------------

  implicit none

  type(struct_chm_obsoperators), intent(inout) :: obsoper
  integer, intent(in) :: kmode
  integer, intent(inout) :: ixtr(obsoper%nobslev)
  logical, intent(inout) :: success(obsoper%nobslev)

  integer :: ij,iobslev
  real(8) :: vlayertop_ref,vlayerbottom_ref,lvl_bot_ref

! Conduct initial setup for vertical integration components

  call chm_vertintg_setup(obsoper)

! Ensure that each layer is within model vertical range.
  
  do iobslev=1,obsoper%nobslev
     
      if (obsoper%vlayerbottom(iobslev).lt.obsoper%vlayertop(iobslev)) then
         success(1:obsoper%nobslev)=.false.
         write(*,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',obsoper%vlayertop(iobslev), obsoper%vlayerbottom(iobslev)
         write(*,*) 'chm_layer_integ_operator: Entire profile skipped over.'
         return
      else if (obsoper%vlayerbottom(iobslev).lt.obsoper%pp(1)*1.01 .or. &  
           obsoper%vlayertop(iobslev).gt.obsoper%pp(obsoper%nmodlev)*0.99) then
         success(iobslev)=.false.
         if (obsoper%vlayerbottom(iobslev).lt.obsoper%pp(1)*1.01) then
            ixtr(iobslev)=1
         else
            ixtr(iobslev)=2
         end if 
         write(*,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',obsoper%vlayertop(iobslev), obsoper%vlayerbottom(iobslev)
         cycle
      end if
      if (obsoper%vlayerbottom(iobslev).gt.obsoper%pp(obsoper%nmodlev)*0.999) obsoper%vlayerbottom(iobslev)=obsoper%pp(obsoper%nmodlev)*0.999
      if (obsoper%vlayertop(iobslev).lt.obsoper%pp(1)*1.001) obsoper%vlayertop(iobslev)=obsoper%pp(1)*1.001
      
  end do


  ! Check for special treatment if chm_config%tropo_mode>=1, kmode=2,3, and nobslev=1 for
  ! column observations that extend to the surface.
   
  if (obsoper%nobslev.eq.1.and.kmode.ge.2.and.obsoper%vlayerbottom(1).gt.obsoper%pp(obsoper%nmodlev)*0.99.and. &
      obsoper%constituent_id.ge.0) then

     if (obsoper%constituent_id.gt.chm_constituents_size) &
          call abort3d("chm_layer_integ_operator: Invalid constituent ID with value " // trim(str(obsoper%constituent_id)))
     
     vlayerbottom_ref=obsoper%vlayerbottom(1)
     
     if ( chm_config%tropo_mode(obsoper%constituent_id).ge.1 .and. obsoper%column_bound.gt.obsoper%vlayertop(1) ) then

        if (obsoper%iavgkern.ne.0) &
             call abort3d("chm_layer_integ_operator: Use of averaging kernels not possible with reduced range of increment profile.")
        
        if (kmode.eq.2.and.chm_config%tropo_mode(obsoper%constituent_id).eq.1) then
           
           ! When kmode=2, split calc in two. This is done due to difference in 
           ! calc at the interface region when producing zh and zhp. The tangent linear
           ! model in the lower region for kmode=2 must be consistent with 
           ! that associated to kmode=3.
           
           ! Start with bottom region in order to use correct zhp with chm_genoper
           ! when use of this operator is requested.
           
           vlayertop_ref=obsoper%vlayertop(1)

           obsoper%vlayertop(1) = obsoper%column_bound
           
           call chm_vertintg(obsoper,ixtr,success)
           
           ! Apply generalized innovation operator if requested
           
           if (obsoper%apply_genoper) call chm_genoper(obsoper,kmode,success)
           
           obsoper%apply_genoper=.false.
           
           lvl_bot_ref=obsoper%lvl_bot(1)
            
           ! Reset top and bottom values for integration of the remaining region.
           ! The second integration provides the change in upper level contributions to the
           ! total column from the assimilation of other observations.
           
           obsoper%vlayertop(1)=vlayertop_ref
           obsoper%vlayerbottom(1)=obsoper%column_bound
        else
           ! Reset top new value. Restricts adjoint/tangent linear calcs to this reduced region.            
           obsoper%vlayertop(1)=obsoper%column_bound
        end if
      
     end if
  end if
  
   ! Calculate vertical integration components for specified obs layer.

  call chm_vertintg(obsoper,ixtr,success)
   
  ! If chm_config%tropo_mode=1, reset original vertical range for the tangent
  ! linear operator 
  if (obsoper%nobslev.eq.1.and.kmode.eq.2.and.obsoper%constituent_id.ge.0) then
      if (chm_config%tropo_mode(obsoper%constituent_id).eq.1.and.  &
         obsoper%column_bound.gt.obsoper%vlayertop(1).and. &
         vlayerbottom_ref.gt.obsoper%pp(obsoper%nmodlev)*0.99) then    
          
         obsoper%vlayerbottom(1)=vlayerbottom_ref
         obsoper%lvl_bot(1)=lvl_bot_ref
      end if
  end if
  
  end subroutine chm_layer_integ_operator

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg_setup(obsoper)
!
! Author  : Y. Rochon, (ARQI/AQRD), Ping Du (CMDA), and M. Sitwell (ARQI/AQRD) Feb 2015.
!           - Based on Pre-Envar version by Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!
! Revision: 
!
! Purpose:  Preliminary calcs for producing components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
!           This includes:
!
!                    - Setting of model layer boundaries
!                    - Determining integration weights associated to
!                      second order Lagrangian interpolation.
!
!           Layer boundaries are taken as mid-point between eta levels in lnP
!           coordinate. Layer values are set to be the values interpolated
!           to the mid-point in P within the various layers. Interpolation
!           in P is done quadratically. 
!
! Arguments:
!
!  Output  
!           obsoper%vmodpress(nmodlev+1) -- Model layer boundaries given that pressmod are
!                                                taken at mid-layer values.
!           obsoper%vweights(nmodlev,nmodlev)   -- Second order Lagrangian interp integration weights
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      type(struct_chm_obsoperators), intent(inout) :: obsoper
!
!*    Declaration of local variables
!
      integer   :: jk
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3
!
!*    Determine P boundaries of analysis layers and save weights for
!     use in setting innovation operator array.
!
!     N.B.: Boundaries of layers set to mid-point of model levels
!      
!     Calculate layer boundaries
!
      obsoper%vmodpress(1)=obsoper%pp(1)
      obsoper%vmodpress(obsoper%nmodlev+1)= obsoper%pp(obsoper%nmodlev)
!
      DO JK = 2, obsoper%nmodlev
         obsoper%vmodpress(jk)=sqrt(obsoper%pp(jk-1)*obsoper%pp(jk))
      END DO
!
!     Interpolation to mid-layer level in P using
!     second degree Lagrangian interpolator.
!     N.B.: Integration is w.r.t. P
!
!     Calculating for jk=1
!
      zp1= obsoper%pp(1)
      zp2= obsoper%pp(2)
      zp3= obsoper%pp(3)
      zp = (obsoper%vmodpress(2)+obsoper%vmodpress(1))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      obsoper%vweights(1,1)=zr1
      obsoper%vweights(2,1)=zr2
      obsoper%vweights(3,1)=zr3
!
      DO JK=2,obsoper%nmodlev-1
         zp1=obsoper%pp(jk-1)
         zp2=obsoper%pp(jk)
         zp3=obsoper%pp(jk+1)
         zp=(obsoper%vmodpress(jk+1)+obsoper%vmodpress(jk))/2.0
         zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
         zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
         zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
         obsoper%vweights(jk-1,jk)=zr1
         obsoper%vweights(jk,jk)=zr2
         obsoper%vweights(jk+1,jk)=zr3
      ENDDO
!
!     Calculating  for jk=obsoper%nmodlev
!
      zp1= obsoper%pp(obsoper%nmodlev-2)
      zp2= obsoper%pp(obsoper%nmodlev-1)
      zp3= obsoper%pp(obsoper%nmodlev)
      zp = (obsoper%vmodpress(obsoper%nmodlev+1)+obsoper%vmodpress(obsoper%nmodlev))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      obsoper%vweights(obsoper%nmodlev-2,obsoper%nmodlev)=zr1
      obsoper%vweights(obsoper%nmodlev-1,obsoper%nmodlev)=zr2
      obsoper%vweights(obsoper%nmodlev,obsoper%nmodlev)=zr3
!
  end subroutine chm_vertintg_setup 

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg(obsoper,ixtr,success)
!
! Author  : Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!           Ping Du and Y. Rochon, Jan-Feb 2015
!           - Adapted for the EnVar
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Some input arguments moved into obsoper
!
! Purpose:  Calculate components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
! Arguments:
!
!  Input   
!           n_modlvl              -- # of model vertical levels
!           nobslev               -- # of obs vertical levels
!           obsoper%vweights  -- See routine chm_vertintg_setup
!           obsoper%vmodpress
!           success               -- Logical indicating if calc are to be performed.
!           ixtr                  -- Flag indicating if obs outside model vertical range
!                                    0 for no.

!
!  Output  
!           obsoper%zh(nobslev,nmodlev)  -- Initial innovation model array 
!                                                (other than conversion constants)
!           obsoper%zhp(nobslev,nmodlev) -- Part of innovation operator not 
!                                                related to resolution
!
!-----------------------------------------------------------------------------------------

      implicit none

      type(struct_chm_obsoperators), intent(inout) :: obsoper
      integer, intent(in) ::ixtr(obsoper%nobslev)
      logical, intent(in) :: success(obsoper%nobslev)

      integer, parameter :: ivweights=2  ! Order of Lagrangian interpolation.
!
!*    Declaration of local variables
!
      integer   :: J,JK,ILMAX2,ILMIN2
      integer   :: ILMIN, ILMAX, iobslev
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3, ptop, pbtm


      do iobslev=1,obsoper%nobslev

         if (success(iobslev).or.(ixtr(iobslev).eq.0.and.obsoper%iavgkern.ne.0)) then

            ptop = obsoper%vlayertop(iobslev)
            pbtm = obsoper%vlayerbottom(iobslev)
         
!*          Find the range of vertical levels over which to perform the integration
!           and set innovation operator ZH over this range.

            ilmin=1
            ilmax=obsoper%nmodlev
            if (ptop.le.obsoper%vmodpress(1)*1.01.and.pbtm.ge.obsoper%vmodpress(obsoper%nmodlev+1)*0.99) then
!
!             Total column integration part
!
               do jk = 1,obsoper%nmodlev
                  do j=max(1,jk-ivweights),min(obsoper%nmodlev,jk+ivweights)
                     obsoper%zh(iobslev,jk)=obsoper%zh(iobslev,jk)+(obsoper%vmodpress(j+1) &
                         -obsoper%vmodpress(j))*obsoper%vweights(jk,j)
                     obsoper%zhp(iobslev,jk)=obsoper%zhp(iobslev,jk)+obsoper%vweights(jk,j)
                  end do
               end do
               
            else
!
!              Partial column integration part (special treatment at boundaries)
!
!              Identify analysis layer boundaries just within obs layer.
!
               ilmin = chm_igetmodlev(ptop, obsoper%vmodpress, 'top', obsoper%nmodlev+1)
               ilmax = chm_igetmodlev(pbtm, obsoper%vmodpress, 'btm', obsoper%nmodlev+1)
               
               if (ilmin.eq.ilmax+1) then
!
!                 Entire obs layer within one analysis layer
!
                  j=ilmin
                  if (j.lt.3) j=3
                  if (j.gt.obsoper%nmodlev) j=obsoper%nmodlev
                  zp1=obsoper%vmodpress(j-2)
                  zp2=obsoper%vmodpress(j-1)
                  zp3=obsoper%vmodpress(j)
                  zp=(ptop+pbtm)/2.0
                  zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                  zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                  zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)

                  obsoper%zh(iobslev,j-2)=(pbtm-ptop)*zr1
                  obsoper%zh(iobslev,j-1)=(pbtm-ptop)*zr2
                  obsoper%zh(iobslev,j)=(pbtm-ptop)*zr3
                  obsoper%zhp(iobslev,j-2)=zr1
                  obsoper%zhp(iobslev,j-1)=zr2
                  obsoper%zhp(iobslev,j)=zr3
                  ilmin=j-2
                  ilmax=j
                  
               else
!
!                 Determine terms from the inner layers (excluding the lower and upper
!                 boundary layers when these layers not covering entire analyses layers)
!
                  if (pbtm.ge.obsoper%vmodpress(obsoper%nmodlev)*0.99) then
                     ilmax2=obsoper%nmodlev
                  else
                     ilmax2=ilmax-1
                  end if
                  if (ptop.le.obsoper%vmodpress(1)*1.01) then
                     ilmin=1
                     ilmin2=ilmin
                  else
                     ilmin2=ilmin
                  end if
                  if (ilmin2.le.ilmax2) then
                     do jk = ilmin2,ilmax2
                        do j=max(1,jk-ivweights),min(obsoper%nmodlev,jk+ivweights)
                           obsoper%zh(iobslev,jk)=obsoper%zh(iobslev,jk)+(obsoper%vmodpress(j+1) &
                               -obsoper%vmodpress(j))*obsoper%vweights(jk,j)
                           obsoper%zhp(iobslev,jk)=obsoper%zhp(iobslev,jk)+obsoper%vweights(jk,j)
                        end do
                     end do
                  end if
!
!                 Determine terms from the lower and upper boundary layers
!                 when these layers do not cover entire analyses layers.
!
                  if (pbtm.lt.obsoper%vmodpress(obsoper%nmodlev)*0.99) then
                     
                     j=ilmax+1
                     if (j.gt.obsoper%nmodlev) j=obsoper%nmodlev
                     if (j.lt.3) j=3
                     zp1=obsoper%vmodpress(j-2)
                     zp2=obsoper%vmodpress(j-1)
                     zp3=obsoper%vmodpress(j)
                     zp=(obsoper%vmodpress(ilmax)+pbtm)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     obsoper%zh(iobslev,j-2)=obsoper%zh(iobslev,j-2)+(pbtm - obsoper%vmodpress(ilmax))*zr1
                     obsoper%zh(iobslev,j-1)=obsoper%zh(iobslev,j-1)+(pbtm - obsoper%vmodpress(ilmax))*zr2
                     obsoper%zh(iobslev,j)=obsoper%zh(iobslev,j)+(pbtm - obsoper%vmodpress(ilmax))*zr3
                     obsoper%zhp(iobslev,j-2)=obsoper%zhp(iobslev,j-2)+zr1
                     obsoper%zhp(iobslev,j-1)=obsoper%zhp(iobslev,j-1)+zr2
                     obsoper%zhp(iobslev,j)=obsoper%zhp(iobslev,j)+zr3
                     ilmax=j
                  
                  end if
                  
                  if (ptop.gt.obsoper%vmodpress(1)*1.01) then
                     
                     j=ilmin-1
                     if (j.lt.1) j=1
                     if (j.gt.obsoper%nmodlev-2) j=obsoper%nmodlev-2
                     zp1= obsoper%vmodpress(j)
                     zp2= obsoper%vmodpress(j+1)
                     zp3= obsoper%vmodpress(j+2)
                     zp = (obsoper%vmodpress(ilmin)+ptop)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     obsoper%zh(iobslev,j)=obsoper%zh(iobslev,j)+(obsoper%vmodpress(ilmin)-ptop)*zr1
                     obsoper%zh(iobslev,j+1)=obsoper%zh(iobslev,j+1)+(obsoper%vmodpress(ilmin)-ptop)*zr2
                     obsoper%zh(iobslev,j+2)=obsoper%zh(iobslev,j+2)+(obsoper%vmodpress(ilmin)-ptop)*zr3
                     obsoper%zhp(iobslev,j)=obsoper%zhp(iobslev,j)+zr1
                     obsoper%zhp(iobslev,j+1)=obsoper%zhp(iobslev,j+1)+zr2
                     obsoper%zhp(iobslev,j+2)=obsoper%zhp(iobslev,j+2)+zr3
                     ilmin=j
                     if (ilmax.lt.j+2) ilmax=j+2
                     
                  end if
                  if (ilmin.gt.ilmax-2) ilmin=ilmax-2
               end if
            end if

            obsoper%lvl_top(iobslev)=ilmin
            obsoper%lvl_bot(iobslev)=ilmax
            
         else
            obsoper%zh(iobslev,:) = 0.0D0
            obsoper%zhp(iobslev,:) = 0.0D0
            
            obsoper%lvl_top(iobslev)=1
            obsoper%lvl_bot(iobslev)=1
         end if

      end do

  end subroutine chm_vertintg

!-----------------------------------------------------------------------------------------

  subroutine chm_vert_interp_operator(obsoper,pres_obs,ixtr,success)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!           - Based on ch_vprof from 3DVAR-CHEM by Y. Rochon July 2005
!
! Revision:
!           Y.J. Rochon, ARQI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!           M. Sitwell, ARQI/AQRD, April 2015
!           - Some input arguments moved into obsoper
!
! Purpose:  Interpolation to point in profile. Uses piecewise linear vertical
!           interpolation in log(Pressure).
!
! Arguments:
!
!  Input
!
!       obsoper%pp      pressure on model levels, assumed to be in ascending order
!       pres_obs        pressure on observation levels
!       ixtr            Flag indicating if obs outside model vertical range
!                       0 for no.
!
!  Output
!
!       obsoper%zh      interpolation coefficients
!       success         success of interpolation
!       ixtr            Modified ixtr as needed.
!
! Comments:  Current implementation searches for index of nearest model level. This step
!            is redundant since this information is already save in obsSpaceData in OBS_LYR.
!            This step is repeated so that the routines in chem_mod are more independent
!            of the rest of the EnVar code. If it is desired to skip this redundant step,
!            the content of the OBS_LYR column could be passed to chm_obsoperators and
!            subsequentially to this subroutine.
!
!-----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsoperators), intent(inout) :: obsoper
    integer, intent(inout) :: ixtr(obsoper%nobslev)
    real(8), intent(in) :: pres_obs(obsoper%nobslev)
    logical, intent(inout) :: success(obsoper%nobslev)

    integer :: iobslev,jmodlev

    do iobslev=1,obsoper%nobslev

       ! check if obs is above or below model boundaries
       if ( pres_obs(iobslev).lt.obsoper%pp(1) .or. &
            pres_obs(iobslev).gt.obsoper%pp(obsoper%nmodlev) ) then
          success(iobslev)=.false.
          if (pres_obs(iobslev).lt.obsoper%pp(1)) then
              ixtr(iobslev)=1
          else
              ixtr(iobslev)=2
          end if 
       end if

       if (success(iobslev).or.(ixtr(iobslev).eq.0.and.obsoper%iavgkern.ne.0)) then

          ! Find model layers directly above and below obs.
          ! After exit of loop, the obs will be between model
          ! levels jmodlev and jmodlev+1.
          do jmodlev=1,obsoper%nmodlev-1
             if ( pres_obs(iobslev).ge.obsoper%pp(jmodlev) .and. &
                  pres_obs(iobslev).lt.obsoper%pp(jmodlev+1) ) then
                exit
             end if
          end do

          ! Set interpolation weights
          obsoper%zh(iobslev,jmodlev+1) = LOG(pres_obs(iobslev)/obsoper%pp(jmodlev)) &
                                        / LOG(obsoper%pp(jmodlev+1)/obsoper%pp(jmodlev))
          obsoper%zh(iobslev,jmodlev) = 1.0D0 - obsoper%zh(iobslev,jmodlev+1)

          ! set range of nonzero elements for model vertical levels
          obsoper%lvl_top(iobslev) = jmodlev
          obsoper%lvl_bot(iobslev) = jmodlev+1

       else
          obsoper%lvl_top(iobslev) = 1
          obsoper%lvl_bot(iobslev) = 1
       end if

    end do

  end subroutine chm_vert_interp_operator

!-----------------------------------------------------------------------------------------

  integer function chm_igetmodlev(rpress, rppobs, topbtm, ntotlev)

!
!  Author: Y. Yang    May 2004
!
!  Revisions:
!             Y.J. Rochon, ARQI/MSC May 2005 - May 2007, Feb 2015
!             - Changes to form and comments
!
!  Purpose: Get the vertical level index for the pressure in rppobs
!           within obs layer and nearest specified obs layer boundary.
!
!  Arguments:
!
!              rpress : pressure value in Pascal
!              rppobs : profile of pressure at obs. location
!              topbtm : indicating whether we are looking for top or bottom
!                       presure
!              ntotlev: total number of levels of rppobs
!
!-----------------------------------------------------------------------------------------
      implicit none
 
      integer, intent(in) :: ntotlev
      real(8), intent(in) :: rpress, rppobs(ntotlev)
      character(len=*), intent(in) :: topbtm
      
      integer     :: ilev1, ilev2
      integer     :: jk
!
!     Find the model levels adjacent to pressure level rpress
!
!     Default values
!
      if (rpress .lt. 0.) then
        if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
             chm_igetmodlev = ntotlev
        endif
        if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
             chm_igetmodlev = 1
        endif
                                                       
      endif
!
      ilev1=0
      ilev2=1
      do jk=1,ntotlev
         if (rpress.gt.rppobs(jk)) then
           ilev1=jk
           ilev2=jk+1
         else
           exit
         endif
      enddo
!
!     Find the model level index
!
!     If we are looking for top level, the index is the level immediately 
!     below. if looking for bottom level, the index is the one immediately 
!     above.
!
      if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
           chm_igetmodlev=ilev1
      else if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
           chm_igetmodlev=ilev2
      endif
!
      if (chm_igetmodlev .lt. 1) chm_igetmodlev=1
      if (chm_igetmodlev .gt. ntotlev) chm_igetmodlev=ntotlev
!     
  end function chm_igetmodlev 
!-----------------------------------------------------------------------------------------

  subroutine chm_genoper(obsoper,kmode,success)
!
! Author  : Y. Rochon, April 2015
!           - From pre-EnVar version of Nov 2004.
!
! Revision: 
!           M. Sitwell, April 2016
!           - Some input arguments moved into obsoper
!
! Purpose:  Set generalized innovation operator for integral or layer avg obs.
!           Relevant only for 3D incremental fields.
!           This version is intended to vertically distribute the obs increments 
!           proportionally to the background state. See comments section for 
!           details.
!
! Arguments:
!
!  Input   

!           obsoper%zh, zhp   -- See routine chm_vertintg_setup
!           kmode             -- Index specifying if content to be applied,
!                                i.e. if kmode >1.

!           success           -- Logical indicating if calc are to be performed.
!
!  Output  
!           obsoper%zh(nmodlev)  -- a*w: Final innovation model array 
!                                        (other than conversion constants)
!           obsoper%zhp(nmodlev) -- w (see comments section)
!
! Comments:
!
!     (1) This routine prepares an alternative innovation operator g, called
!     the generalized innovation operator, to take the place of the
!     innovation (TLM) operator h (row of zh). The operator g is
!     specified as:
!
!            g = a*w
!
!     where the modified innovation operator 'w' can be set as:
!
!            w= P[ (h'x)^T ] *  B^{-1}     
!
!     with  h' is the part of h which excludes resolution dependence
!              (only/mostly contains the physics part of h; zhp),
!           x is the state profile rval
!           P is a window cutoff operator (sets small values to zero), and
!           B is the original/initial total "vertical" covariance matrix (in 2D)
!         
!
!     and 'a' is a proportionality constant ensuring that the innovation
!             increment remains unchanged for the 1D case in the absence
!             of other obs., i.e.,
!
!                 a^2 = (h*B*h^T)(w*B*w^T)^{-1},
!
!     Application of the state profile x (rval) is to make the
!     increment profile be more proportional to the state profile.
!
!     The presence of B^{-1} is to negate the weight re-distribution from the later 
!     application of B in grad(Jo).
!
!     While dx is provided to the obs operator, the minimization is done for
!     dx/sigma where sigma is the background error std. dev. in B and so C (correlation matrix)
!     is used instead of B in the minimization. Moreover, the transformation from dx/sigma 
!     to dx is done outside the forward model operators (at the spectral to physical space 
!     transformation step). For this reason, the expression for w should technically be replaced by
! 
!            w= P[ (h'x/sigma^2)^T ] *  C^{-1}             (Option 1 below)
!
!     still with
!
!            a^2 = (h*B*h^T)(w*B*w^T)^{-1}
! 
!     The presence of C^{-1} does/can give difficulty to the iterative variational 
!     minimization. It can result in oscillations in the increment profile depending on
!     where the iterations are stopped. Moreover, if the spectral space C matrix is for 
!     non-seperable vertical and horizontal correlations, there will be oscillations 
!     due to inconstencies between the total inverse vertical correlation C^{-1} in physical space 
!     and the inverse vertical correlation matrix for each spectral wavenumber.
!
!     As alternatives, one can completely omit the role of  C^{-1} from w, i.e.
!
!            w= P[ (h'x/sigma^2)^T ]                        (Option 3)
!
!      or use the following substitute to approximate the role of C^{-1} in approximatily
!      negating the weight re-distribution from later application of C in grad(Jo), i.e.
!
!            w(i)= P[ (h'x/sigma^2)^T ]_i / sum(C(:,i))     (Option 2 - preferred)
!
!     (2) The matrices B and B^{-1} are the total error covariance matrix (in physical space)
!     and its inverse with the related error correlation matrices 'corvert' and 'corverti' 
!     provided from 'bmatrixchem_mod.ftn90'.
!
!     (3) In the presence of both (a) neighbouring measurements and (b) horizontal background error 
!     correlation lengths that vary in vertical, the increments will also be subject to the
!     the latter, displaying larger increments in vertical regions with larger horizontal
!     error correlation lengths - this distorting the vertical increment distribution stemming
!     from chm_genoper alone.
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      type(struct_chm_obsoperators), intent(inout) :: obsoper
      integer, intent(in) :: kmode
      logical, intent(in) :: success(obsoper%nobslev)
!
!     Declaration of local variables
!
      real(8), parameter :: pwin=0.01
      integer  :: iobslev
      logical  :: lstart,lrgsig
      real(8)  :: zwbw(1),zhbh(1),za,work(obsoper%nmodlev)
      real(8)  :: zmin,rsig(obsoper%nmodlev,2)
   
      if (kmode.le.1) return

      lstart=.true. 
      lrgsig=.true. 
      do iobslev=1,obsoper%nobslev
           
         if (.not.success(iobslev)) cycle   
!          
!        First determine background error std. dev. and determine/estimate h*B*h^T. 
!        Done first to acquire 'rsig' at the same time!
!
         call chm_corvert_mult(obsoper%varName,obsoper%zh(iobslev,1:obsoper%nmodlev),zhbh, &
                  obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,1, &
                  lrgsig,obsoper%lat,lstart,3,rsig)

         lstart=.false.         
!
!        Begin preparation of the new innovation operator w (=new zhp)
!
         if (obsoper%nobslev.eq.1.and.obsoper%lvl_top(iobslev).eq.1.and. &
            obsoper%lvl_bot(iobslev).eq.obsoper%nmodlev) then
            
!           Treat as total column obs. Here, zhp would be approx. equal
!           to 1 except for the near-end points of the model vertical domain,
!           the latter due to the discretized domain. Not using zhp avoids this
!           discretization issue from weakly affecting results at the boundaries.
!
            work(1:obsoper%nmodlev)=obsoper%trial(1:obsoper%nmodlev)/rsig(1:obsoper%nmodlev,1) 
         else 

!           Account for localized obs function (e.g. partial columns, Jacobians. For Jacobians,
!           zhp must also be independent of the model layer thicknesses.)
            work(1:obsoper%nmodlev)=obsoper%zhp(iobslev,1:obsoper%nmodlev)*obsoper%trial(1:obsoper%nmodlev)/rsig(1:obsoper%nmodlev,1) 
         end if

!        Apply cutoff (apply to zhp*obsoper%trial/rsig instead of the resultant zh)
!        Resultant outside cutoff region should be zhp*obsoper%trial/rsig/rsig.
 
         zmin=pwin*maxval(abs(work(1:obsoper%nmodlev)))
         where (abs(work(1:obsoper%nmodlev)).lt.zmin) 
             work(1:obsoper%nmodlev)=0.0D0 
         elsewhere        
             work(1:obsoper%nmodlev)=work(1:obsoper%nmodlev)/rsig(1:obsoper%nmodlev,1)
         endwhere
!
!        Application of C^{-1} or substitute (for negating the weight impact of the
!        later application of C in finalizing grad(Jo). Option 2 is favoured.
!  
!        Option 1: Application of C^{-1}
!         call chm_corvert_mult(varName,work(1:obsoper%nmodlev),chm_obsoper%zhp(iobslev,1:obsoper%nmodlev), &
!                  chm_obsoper%lvl_top(iobslev),chm_obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,obsoper%nmodlev, &
!                  .false.,obsoper%lat,lstart,-1)
!
!        Option 2: Application of 1/sum(C(:,j)) to approximately negate the weight re-distribution from C
!                  in the calc of grad(Jo).

         call chm_corvert_mult(obsoper%varName,work(1:obsoper%nmodlev),obsoper%zhp(iobslev,1:obsoper%nmodlev), &
                  obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,obsoper%nmodlev, &
                  .false.,obsoper%lat,lstart,0)
!
!        Option 3: Just skip over consideration attempt at negating the weight re-distribution from C.
!         chm_obsoper%zhp(iobslev,1:obsoper%nmodlev)=work(1:obsoper%nmodlev)
!
!        Determine proportionality factor 'a' = (h*B*h^T)(w*B*w^T)^{-1}
!
!        Determine/estimate w*B*w^T 
!
         call chm_corvert_mult(obsoper%varName,obsoper%zhp(iobslev,1:obsoper%nmodlev),zwbw, &
                   obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,1, &
                   lrgsig,obsoper%lat,lstart,3,rsig)
!
!        Set proportionality factor 'a'
!
         za=sqrt(zhbh(1)/zwbw(1))
!         if (abs(obsoper%lat*180./3.1415-78.).lt.2.0.and.abs(rlon*180./3.1415-185.).lt.2.0) then
!             write(6,*) 'ZA  ',obsoper%lat*180.0/3.1415,rlon*180.0/3.1415,za,zhbh(1),zwbw(1)
!             write(6,*) 'obsoper%trial',obsoper%trial(1:obsoper%nmodlev)
!             write(6,*) 'obsoper%trial',rsig(1:obsoper%nmodlev,1)
!             write(6,*) 'ZH  ',chm_obsoper%zh(iobslev,1:obsoper%nmodlev)
!             write(6,*) 'ZHP ',chm_obsoper%zhp(iobslev,1:obsoper%nmodlev)*za
!         end if
!
!        Set final innovation operator
!
         obsoper%zh(iobslev,1:obsoper%nmodlev)=obsoper%zhp(iobslev,1:obsoper%nmodlev)*za
!
      end do
  
  end subroutine chm_genoper
!-----------------------------------------------------------------------------------------

  subroutine chm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                              lrgsig,rlat,lstart,itype,rsig)
!
! Author  : Y. Rochon, April 2015
!
! Revision: 
!
! Purpose: Multiplication with covariance matrix(ces) C=corvert (itype>0) or their 
!          inverse CI=corverti (itype<0).
!
!          Given A=rmat_in (=input)
!
!          itype       Output
!          -----       ------
!            0          D(i,j)=A(i,j)/sum(C(1:n,i))
!            1          A*C
!            2          C*A
!            3          A*C*A^T
!           -1          A*CI
!           -2          CI*A
!           -3          A*CI*A^T
!
! Arguments:
!
!  Input
!
!           varName              -- Variable name
!           rmat_in(ndim1,ndim2) -- Input matrix/vector A (see comments sections)
!           lvl_top(ndim1)       -- Top level of non-zero values in rmat_in
!           lvl_bot(ndim1)       -- Bottom level of non-zero values in rmat_in
!           ndim1,ndim2          -- Matrix dimensions
!                                   ndim1 to be 1 one 1D input vectors
!           ndim3                -- Expected output dimension.
!                                   =ndim1 for itype= +/-3
!                                   =ndim2 otherwise
!           lrgsig               -- Index to indicate if rgsig to be included as part of C or CI below.
!           rlat                 -- Input latitude (radians).
!           itype                -- Type of operator (see above). 
!           lstart               -- Logical indicating if local initiliation if std. dev. required 
!                                   for given obs location. 
!           rsig(ndim2,2)        -- Background error std. dev. at obs locations.
!                                   Must be provided when lstart=.false. and lrgsig=.true.    
!
!  Output:
!
!           rmat_out(ndim1,ndim2) -- Output matrix/vector (see comments sections)
!           rsig(ndim2,2)         -- Background error std. dev. at obs locations 
!                                    Set/provided when lstart.eq.true.   
!
! Comments:
!
! (A) If rmat_in is a 1-D vector, then 
!     
!     for cases +/- 2, one should have set ndim2=1 and ndim1=vector-length.
!     for cases +/- 1,3, one should have set ndim1=1 and ndim2=vector-length.
!
! (B) Revisions required whem LAM and ensembles cases become available.
!
!-----------------------------------------------------------------------------------------
      use bmatrixchem
 
      implicit none
      character(len=*), intent(in) :: varName
      logical, intent(in)    :: lstart,lrgsig
      integer, intent(in)    :: ndim1,ndim2,ndim3,itype
      integer, intent(in)    :: lvl_top(ndim1),lvl_bot(ndim1)
      real(8), intent(in)    :: rmat_in(ndim1,ndim2),rlat
      real(8), intent(out)   :: rmat_out(ndim1,ndim3)
      real(8), intent(inout), optional :: rsig(ndim2,2)
   
      integer :: nsize
      real(8) :: rsig_local(ndim2,2)
      
      rsig_local(:,:)=0.0D0
      rmat_out(:,:)=0.0D0
  
!     Set background error std. dev. if needed.

      if (lstart) then
!
!        Get background error standard deviations
!        Applicability tests within b*chm_getsigma.
!
         call bchm_getsigma(varName,ndim2,rlat,rsig_local(:,1),nsize)   
!         call blamchm_getsigma(varName,ndim2,rlat,rsig_local(:,1),nsize)      
         if (nsize.ne.ndim2) then
             write(6,*) 'NSIZE, NDIM2: ',nsize,ndim2
             call abort3d('CHM_corvert_mult: Inconsistent size')
         end if

!         call benschm_getsigma(varName,ndim2,rlat,rsig_local(:,2),nsize)      
!         if (nsize.eq.ndim2) then
!             write(6,*) 'NSIZE, NDIM2: ',nsize,ndim2
!             call abort3d('CHM_corvert_mult: Inconsistent size')
!         end if

          if (present(rsig)) rsig(:,:)=rsig_local(:,:)
      else     
          if (.not.present(rsig).and.lrgsig) &
              call abort3d('CHM_corvert_mult: Missing rsig')
          rsig_local(:,:)=rsig(:,:)
      end if
      
!     Apply operation related to static background error covariance/correlation matrix.
!     Applicability tests within b*chm_corvert_mult.

      call bchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                             lrgsig,itype,rsig_local(:,1))
!      call blamchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                             lrgsig,itype,rsig_local(:,1))

!     Apply operation related to ensemble-based background error covariance/correlation matrix.
!     Applicability test within benschm_corvert_mult.

!      call benschm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                                lrgsig,itype,rsig_local(:,2))

  end subroutine chm_corvert_mult
!-----------------------------------------------------------------------------------------

end module chem_mod
