!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_mod
!
! PURPOSE:
!    Repository of obs space structures, arrays, and routines specific to the 
!    CH chemical constituents family and constituent observations.
!
!    Main content (public routines):
!
!       - Public routines
!         "chm_read_obs_err_stddev,chm_get_obs_err_stddev,chm_dealloc_obs_err_stddev":
!         Routines and strucure for setting of obs error std. dev. used in
!        'observation_erreurs_mod.ftn90'. 
!
!       - Public routine "chm_obsoperators": Applies observation operators. 
!
!       - Public routine "chm_setup": Routines and structure for setting and assignment 
!         of observation layer top and bottom levels (and averaging kernel matrices - tbc). 
!         See 'preproc.ftn90' and 'chm_obsoperators'. 
!
!       - Public routines: "chm_adj_model_bndry,chm_get_stringId,chm_get_ID": Routines for use 
!         in filtering out obs based on model vertical boundaries. See 'filterobs_mod.ftn90'. 
!
! COMMENT:
!
!    This module can be expanded to contain other constituent related info
!    or routines.
!
! Author  : Y.J Rochon - ARQI/AQRD, 2014
!
! Revisions:
!           M. Sitwell, ARQI/AQRD, Feb 2015
!           - Created struct_chm_info and struct_chm_std structures for storing
!             information read from ascii/burp file and removal of earlier structure.
!
!----------------------------------------------------------------------------------
   
  implicit none
  private

! public procedures
! -----------------

  public :: chm_setup,chm_dealloc_obs_err_stddev,chm_read_obs_err_stddev, &
            chm_get_obs_err_stddev
  public :: chm_obsoperators,chm_adj_model_bndry,chm_get_stringID,chm_get_ID

  type :: struct_chm_std
     !
     ! Structure for holding observation std information
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block 
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                            (may be adjusted after input)
     !  std_type               Index of setup approach (used in combination with
     !                            nstd_brp_chm)
     !                         For nstd_brp_chm value 0 or 1, 
     !                         0: std1 or BURP file vales (sigma)
     !                         1: min(std3,max(std2,std1_chm*ZVAL))
     !                                                   or
     !                            max(std2(ISTNID),xstd_std1_chm(ILEV)*sigma)
     !                         2: sqrt(std2**2+(std1*ZVAL)**2))
     !                                                   or
     !                                              not applicable
     !  ibegin                 Position index of start of data for given
     !                         sub-family in the arrays std1,levels,lat
     !  n_lvl                  Number of vertical levels
     !  levels                 Vertical levels (in coordinate of sub-family data)
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !  std1                   See std_type for usage
     !  std2                   See std_type for usage
     !  std3                   See std_type for usage  

     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),std_type(:),n_lat(:)
     integer, allocatable :: brp(:),ibegin(:),n_lvl(:)
     real(8), allocatable :: std1(:),std2(:),std3(:)
     real(8), allocatable :: levels(:),lat(:)

  end type struct_chm_std
  
  type :: struct_chm_info
     !  Information arrays retrieved from obsinfo_chm regarding vertical levels 
     !  or averaging kernels
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                             (may be adjusted after input)
     !  vco                    Vertical coordinate type (1, 2, or 3, see bufr_read_mod)
     !
     !  ibegin                 Position index of start of data for given
     !                         sub-family.
     !  n_lvl                  Number of vertical levels
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !
     !  vlayertop              Layer top 
     !  vlayerbottom           Layer bottom
     !  rak                    Averaging kernel matrices
     
     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),brp(:)
     integer, allocatable :: vco(:),n_lat(:)
     integer, allocatable :: ibegin(:),n_lvl(:)
     real(8), allocatable :: rak(:),vlayertop(:),vlayerbottom(:)
     real(8), allocatable :: lat(:)
  
  end type struct_chm_info

  type :: struct_chm_obsoperators  
  
     !  Structure holding work variables for observation operators
     !     
     !  Variable               Description
     !  --------               -----------
     !  modelIndex             Obs operator index
     !                         0 - vertical interpolator
     !                         1 - layer averaging
     !                         2 - layer integration
     !  layer_identified       .true. if a layer (with identified layer boundaries)
     !                         .false if layer boundaries are not available.
     !  modelvarcolumn         Field or increment column at observation location
     !                         with necessary unit conversions.
     !  vmodpress              Model layer boundaries taken as middle between model level
     !  vlayertop              Layer top (final work values in Pa)
     !  vlayerbottom           Layer bottom (final work values in Pa)
     !  vweights               Second order Lagrangian interp integration weights
     !  zh                     Initial innovation model array (other than conversion constants)
     !  zhp                    Part of innovation operator not related to resolution.
     !  lvl_top                Top level of non-zero values in zh
     !  lvl_bot                Bottom level of non-zero values in zh
     
     integer :: modelIndex
     logical :: layer_identified
     real(8), allocatable :: vlayertop(:),vlayerbottom(:),vmodpress(:)      
     real(8), allocatable :: modelvarcolumn(:),zh(:,:),zhp(:,:),vweights(:,:)
     integer, allocatable :: lvl_top(:),lvl_bot(:)

  end type struct_chm_obsoperators

  type :: struct_chm_burp

     !  Structure storing information retrieved from BURP files
     !  for individual reports.
     !     
     !  Variable               Description
     !  --------               -----------
     !  ndim                   number of dimension of the BURP data
     !                         per report (i.e. ndim=1 for std and
     !                         ndim=2 for averaging kernels)
     !  data1d                 BURP file data indexed by (irep,ilev)
     !  data2d                 BURP file data indexed by (irep,ilev,ilev)
     !  ilev                   current level position
     !  irep                   current report position
     !  date                   YYYYMM
     !  time                   HHMM
     !  lat,lon                lat,lon in radians

     real(8), pointer :: data1d(:,:),data2d(:,:,:), lat(:), lon(:)
     integer, pointer :: date(:),time(:)
     integer :: ndim,nlev,nrep,ilev,irep
  
  end type struct_chm_burp

  type(struct_chm_info) :: chm_layers
  type(struct_chm_info) :: chm_avgkern
  type(struct_chm_std)  :: chm_std

! Array of pointers to hold std's/averaging kernels read from BURP file.
! Note: Ideally, these should be an element in the 'struct_chm_std' /
! 'struct_chm_info' derived types, but currently this results
! in an internal compiler error.

  type(struct_chm_burp), allocatable :: chm_burp_std(:),chm_burp_avgkern(:)

  
! Miscellaneous flags and constants read/set from chm_read_misc

  integer  :: chm_ngenoper
  real(8)  :: chm_amu(0:100)

contains

!------------------------------- Setup called from "preproc" ---------------------------

  subroutine chm_setup
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: M. Sitwell, Feb 2015
!            - Removed references to earlier structure
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData.
!
!----------------------------------------------------------------------------------------

  implicit none
  
  write(*,*) 'Begin chm_setup'

! Read miscellaneous flags and constants 
    
  call chm_read_misc
      
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_read_layers
      
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_layers
   
! Read averaging kernel matrices
  
  call chm_read_avgkern
  
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_avgkern

  write(*,*) 'Completed chm_setup'
  
  end subroutine chm_setup

!------------------------------------------------------------------------------------

  subroutine chm_read_misc
!
! Author   : Y. Rochon, ARQI/AQRD, Apr 2015 
!
! Revisions: 
!         
! Purpose: Read and store miscellaneous flags and constants.
!
! Comments:
!
!----------------------------------------------------------------------------------------  
  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JELM, nulstat, ios, isize, nulnam
  logical :: LnewExists
  
  character(len=128) :: ligne  
  character(len=10)  :: rparm,parm,namfile
  real(8)            :: val 
  integer            :: index

  EXTERNAL FNOM,FCLOS

  namelist /NAMCHEM/chm_ngenoper
  
! Initialization

  chm_ngenoper=0    
  chm_amu(:)=-1.0

! Read from namelist file (not implemented)
! Should read chm_ngenoper from namelist instead of 'obsinfo_chm' 

!  namfile=trim("flnml")
!  nulnam=0
!  ier=FNOM(nulnam,namfile,'R/O',0)

!  read(nulnam,NML=NAMCHEM)

!  ier=FCLOS(nulnam)

! Read from 'obsinfo_chm' file

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_misc: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_misc: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:6))).ne.'MISC') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of elements in section
   
  read(nulstat,*,iostat=ios,err=10,end=10) isize
  read(nulstat,*,iostat=ios,err=10,end=10) 

! Read elements

  do jelm=1,isize
      read(nulstat,*,iostat=ios,err=10,end=10) rparm,val
      parm=trim(adjustl(rparm))
      if (parm(1:4).eq.'amu_') then
         read(parm(5:8),'(I4)') index
         chm_amu(index)=val
      else if (parm(1:8).eq.'ngenoper') then
         chm_ngenoper=int(val+0.1)
      end if
  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_misc: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_misc

!-----------------------------------------------------------------------------------------
!--------------------- Routines related to layer top & bottom levels----------------------

  subroutine chm_read_layers
!
! Author   : Y. Rochon, ARQI/AQRD, Dec 2014 
!            - Partially based on oer_read_obs_erreurs_conv.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Feb 2015
!            - Renaming of routine and removal of lines no longer required.
!          
! Purpose: Read and store top and bottom layer boundaries for CH sub-families
!
! Comments:
!
! A) The option of reading from BURP files is TBD. This will change the approach in allocating
!    the arrays size as the sizes will become dependent on the number of related obs for
!    which the BURP files will need to be read.
!----------------------------------------------------------------------------------------

  use bufr

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_layers%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_layers: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_layers%stnids(chm_layers%n_stnid))
  allocate(chm_layers%vco(chm_layers%n_stnid))
  allocate(chm_layers%brp(chm_layers%n_stnid),chm_layers%ibegin(chm_layers%n_stnid))
  allocate(chm_layers%bfr(chm_layers%n_stnid),chm_layers%n_lvl(chm_layers%n_stnid))
  allocate(chm_layers%vlayertop(isize),chm_layers%vlayerbottom(isize))
 
  chm_layers%bfr(:)=0
  chm_layers%vco(:)=0
  chm_layers%brp(:)=0
  chm_layers%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_layers%n_stnid
    chm_layers%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_layers%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%bfr(jelm),chm_layers%vco(jelm),  &
       chm_layers%brp(jelm),chm_layers%n_lvl(jelm)  
    
    if (icount+chm_layers%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_layers%n_lvl(jelm).ge.1) then   
       do jlev=1,chm_layers%n_lvl(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_layers%vlayertop(icount),chm_layers%vlayerbottom(icount)
       end do
    end if

!    if (chm_layers%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_layers

!-----------------------------------------------------------------------------------------

  subroutine chm_get_layer_boundaries(cstnid,varno,ivco,nlev,default_top,default_bottom,lfound,layertop,layerbottom)
!
! Author  : M. Sitwell, Y. Rochon, Feb 2015
! Revision: 
!
! Purpose: Return layer boundaries for an observation. Combination of STNID, BUFR element
!          and number of vertical levels to determine association to the observations.
!          Default values for top and bottom layers for total column measurements are to
!          be provided.
!
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - ivco            type of vertical coordinate (see burp_read_mod.ftn90 for definitions)
!   - nlev            number of levels in the observation
!   - default_top     default value for top layer for total column measurement
!   - default_bottom  default value for bottom layer for total column measurement
!
! Outputs:
!   - lfound          Logical being .true. if layer boundaries found.
!   - layertop        top layer values
!   - layerbottom     bottom layer values
! ---------------------------------------------------------------------------------------

    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in)           :: varno,ivco,nlev
    real(8), intent(in)           :: default_top,default_bottom
    real(8), intent(out)          :: layertop(nlev),layerbottom(nlev)
    logical, intent(inout)        :: lfound
    integer                       :: ISTNID,JN,start_index
    logical                       :: iset


    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0
    lfound=.false.

    DO JN=1,chm_layers%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_layers%stnids(JN) as wildcards
       iset = stnid_equal(chm_layers%stnids(JN),CSTNID)

       ! Check if number of levels, code, and vertical coordinate type are equal.
       ! If number of levels is one and no vertical coordinate provided in the obs file (i.e. IVCO=4;
       ! as for a total column measurement), then check of vertical coordinate type is disregarded.
       IF (iset) THEN
          IF ( varno.EQ.chm_layers%bfr(JN) .AND. NLEV.EQ.chm_layers%n_lvl(JN) .AND. &
              (IVCO.EQ.chm_layers%vco(JN).OR.IVCO.EQ.4) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

    IF (ISTNID.EQ.0) THEN
       ! If integrated layer information not found, if a total column measurement
       ! set to defaults, else do nothing

       if (chm_checkfor_integlayer(varno) .and. nlev.eq.1) then          
          lfound=.true.
          layertop(1) = default_top
          layerbottom(1) = default_bottom
       end if

    ELSE
       ! layer information has been found in ascii file
       lfound=.true.
       start_index = chm_layers%ibegin(ISTNID)
       layertop(:) = chm_layers%vlayertop(start_index:start_index+nlev-1)
       layerbottom(:) = chm_layers%vlayerbottom(start_index:start_index+nlev-1)  
    END IF

  end subroutine chm_get_layer_boundaries


!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_layers
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for layer info
!
! ---------------------------------------------------------------------------------------

    implicit none

    if (chm_layers%n_stnid.eq.0) return

    call chm_dealloc_info(chm_layers)
 
  end subroutine chm_dealloc_layers

!-----------------------------------------------------------------------------------------
!-------------------- Routines related averaging kernel matrices -------------------------
  
  subroutine chm_read_avgkern
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Revision: 
!
! Purpose:  Read averaging kernels from ascii file and BURP file if specified in ascii file
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the averaging kernel information from the ascii file
    call chm_read_avgkern_ascii

    ! set size of BURP file array
    allocate(chm_burp_avgkern(chm_avgkern%n_stnid))

    ! read from BURP file
    do istnid=1,chm_avgkern%n_stnid
       if (chm_avgkern%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_avgkern(istnid) = chm_read_burp('brpch', chm_avgkern%stnids(istnid), &
               15044, chm_avgkern%n_lvl(istnid), 2, 14, 'DATA')
          
       end if
    end do

  end subroutine chm_read_avgkern

!----------------------------------------------------------------------------------------

  subroutine chm_read_avgkern_ascii
!
! Author   : Y. Rochon, M. Sitwell, ARQI/AQRD, Feb 2015 
!            - Currently implemented for only one latitude band
!
! Revisions: 
!          
! Purpose: Read and store averaging kernel matricesfor CH sub-families
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_avgkern%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '--------------------------------------------------'
    WRITE(*,*)   'chm_read_avgkern_ascii: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '--------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_avgkern_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:14))).ne.'SECTION III:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_avgkern%stnids(chm_avgkern%n_stnid))
  allocate(chm_avgkern%brp(chm_avgkern%n_stnid),chm_avgkern%ibegin(chm_avgkern%n_stnid))
  allocate(chm_avgkern%bfr(chm_avgkern%n_stnid),chm_avgkern%n_lvl(chm_avgkern%n_stnid))
  allocate(chm_avgkern%rak(isize))
 
  chm_avgkern%bfr(:)=0
  chm_avgkern%brp(:)=0
  chm_avgkern%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=1
  STNIDLOOP: do jelm=1,chm_avgkern%n_stnid
    chm_avgkern%ibegin(jelm)=icount

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_avgkern%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Flag indication if avgkern provided from this ascii file or
!            to be read from the BURP file,
!        (3) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%bfr(jelm),  &
       chm_avgkern%brp(jelm),chm_avgkern%n_lvl(jelm)  
    
    if (icount+chm_avgkern%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! disregard data section if values to be specified in BUFR file
    if (chm_avgkern%brp(jelm).eq.1) cycle STNIDLOOP
    
    if (chm_avgkern%n_lvl(jelm).gt.1) then   
       do jlev=1,chm_avgkern%n_lvl(jelm)

          iend=icount+chm_avgkern%n_lvl(jelm)-1

          ! Read averaging kernel matrix   
          read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%rak(icount:iend)

          icount=iend+1

       end do
    end if

 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_avgkern_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_avgkern
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for averaging kernels
!
!---------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    if (chm_avgkern%n_stnid.eq.0) return

    if (allocated(chm_burp_avgkern)) then
       do istnid=1,chm_avgkern%n_stnid
          if (chm_avgkern%brp(istnid).eq.1) call dealloc_burp(chm_burp_avgkern(istnid))
       end do
       deallocate(chm_burp_avgkern)
    end if

    call chm_dealloc_info(chm_avgkern)
  
  end subroutine chm_dealloc_avgkern

!-----------------------------------------------------------------------------------------

  function chm_find_avgkern(cstnid,varno,nlev) result(ISTNID)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Finds the averaging kernel for an observation if one is specified. Returns 0 if
!          either not found or not specified. Combination of STNID, BUFR element and number
!          of vertical levels to determine association to the observations.
!          
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - nlev            number of levels in the observation
!
! Returns:
!   - ISTNID          Index of averaging kernel in chm_avgkern if found. Zero indicates
!                     averaging kernel not found.
! ---------------------------------------------------------------------------------------
    
    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in) :: varno,nlev
    integer :: ISTNID,JN
    logical :: iset

    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0

    DO JN=1,chm_avgkern%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_avgkern%stnids(JN) as wildcards
       iset = stnid_equal(chm_avgkern%stnids(JN),CSTNID)

       ! Check if number of levels and BUFR code are equal.
       IF (iset) THEN
          IF ( varno.EQ.chm_avgkern%bfr(JN) .AND. NLEV.EQ.chm_avgkern%n_lvl(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

  end function chm_find_avgkern

!-----------------------------------------------------------------------------------------

  subroutine chm_get_avgkern(istnid,nlev,zlat,zlon,idate,itime,avg_kern)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Return averaging kernel for an observation.
!
! Inputs:
!   - istnid          index of averaging kernel in chm_avgkern
!   - nlev            number of observation levels
!   - idate           YYYYMMDD
!   - itime           HHMM
!
! Outputs:
!   - avg_kern        the averaging kernel
!---------------------------------------------------------------------------------------

    implicit none

    integer, intent(in)  :: istnid,nlev,idate,itime
    real(8), intent(in)  :: zlat,zlon
    real(8), intent(out) :: avg_kern(nlev,nlev)
    integer :: start_index,end_index

    if (istnid.gt.0 .and. istnid.le.chm_avgkern%n_stnid) then
       
       if (chm_avgkern%brp(istnid).eq.0) then
          ! get averaging kernel from ascii file
          start_index = chm_avgkern%ibegin(ISTNID)
          end_index = nlev*(start_index+nlev-1)
          avg_kern = RESHAPE(chm_avgkern%rak(start_index:end_index),(/nlev,nlev/),ORDER =(/2,1/))
       else
          ! get averaging kernel from BURP file
          avg_kern = chm_get_burp_array2d(chm_burp_avgkern(istnid),zlat,zlon,idate,itime,nlev)
       end if

    else
       call abort3d("chm_get_avgkern: Invalid station ID index.")
    end if

  end subroutine chm_get_avgkern

!-----------------------------------------------------------------------------------------
!----------- Routines relevant to error std. dev. (observation_erreurs.ftn90) ------------

  subroutine chm_read_obs_err_stddev
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
!
! Revision: 
!
! Purpose:  Read observation errors from ascii file and BURP file if specified in ascii file
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the error std. dev. information from the ascii file
    call chm_read_obs_err_stddev_ascii

    ! set size of BURP file std array
    allocate(chm_burp_std(chm_std%n_stnid))

    ! read from BURP file
    do istnid=1,chm_std%n_stnid
       if (chm_std%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_std(istnid) = chm_read_burp('brpch', chm_std%stnids(istnid), &
               chm_std%bfr(istnid), chm_std%n_lvl(istnid), 1, 14, 'DATA')
          
       end if
    end do

  end subroutine chm_read_obs_err_stddev

!----------------------------------------------------------------------------------------

  subroutine chm_read_obs_err_stddev_ascii
!
! Author   : Y. Rochon, Nov 2014 
!             (initial part follows the format of oer_read_obs_erreurs_conv)
! Revisions: 
!             M. Sitwell, Fdeb 2015
!             - Content formed as a separate routine called in oer_read_obs_erreurs_chm.
!          
! Purpose: Read and store observation error std. dev. as needed for CH family obs.
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_std%n_stnid=0
!
! CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists) then
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! chm_read_obs_err_stddev: obsinfo_chm not available.   '
    WRITE(*,*) 'WARNING! Default CH family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
    return
  ENDIF
!
! Read observation error std dev. from file obsinfo_chm for constituent data
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_obs_err_stddev_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

! Read error standard deviations for constituents if available.
! (CH family; ozone and others)
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:12))).ne.'SECTION I:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space

  read(nulstat,*,iostat=ios,err=10,end=10) chm_std%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_std%stnids(chm_std%n_stnid))
  allocate(chm_std%std_type(chm_std%n_stnid),chm_std%n_lat(chm_std%n_stnid))
  allocate(chm_std%brp(chm_std%n_stnid),chm_std%ibegin(chm_std%n_stnid))
  allocate(chm_std%bfr(chm_std%n_stnid),chm_std%n_lvl(chm_std%n_stnid))
  allocate(chm_std%std1(isize),chm_std%std2(chm_std%n_stnid),chm_std%std3(chm_std%n_stnid))
  allocate(chm_std%levels(isize),chm_std%lat(isize))
 
  chm_std%bfr(:)=0
  chm_std%brp(:)=0
  chm_std%std_type(:)=0
  chm_std%n_lvl(:)=1
  chm_std%n_lat(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  STNIDLOOP: do jelm=1,chm_std%n_stnid
    chm_std%ibegin(jelm)=icount+1

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! Read STNID (* as wildcard)    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_std%stnids(jelm) 

!   Read (1) BUFR element,
!        (2) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (3) Index specifying OER setup method,
!        (4) Number of vertical levels
!        (5) Number of latitudes
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_std%bfr(jelm),chm_std%brp(jelm),  &
       chm_std%std_type(jelm), chm_std%n_lvl(jelm), chm_std%n_lat(jelm),  &
       chm_std%std2(jelm), chm_std%std3(jelm)

    if (chm_std%n_lvl(jelm).lt.1) chm_std%n_lvl(jelm)=1
    if (chm_std%n_lat(jelm).lt.1) chm_std%n_lat(jelm)=1
    
    if (icount+chm_std%n_lvl(jelm)*chm_std%n_lat(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    ! disregard data section if set to be specified by BUFR values only
    if (chm_std%brp(jelm).eq.1.and.chm_std%std_type(jelm).eq.0) cycle STNIDLOOP 
       
    if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Read one value only (independent of level and latitude)
       
       icount=icount+1
       read(nulstat,*,iostat=ios,err=10,end=10) chm_std%std1(icount)

    else if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on latitude only
       
!      Read reference latitudes (must be in order of increasing size)
       
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
!      Read OER-related values
  
       read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%std1(icount+1:icount+chm_std%n_lat(jelm))

       icount=icount+chm_std%n_lat(jelm)

    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Value dependent on vertical level only
      
       do jlev=1,chm_std%n_lvl(jelm)
          icount=icount+1
          
!         Read vertical level and OER-related value.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%levels(icount),chm_std%std1(icount)

       end do
   
    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on vertical level and latitude 
       
!      Read reference latitudes (must be in order of increasing size)
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
!       write(*, '(10X,20F9.3)') chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
       do jlev=1,chm_std%n_lvl(jelm)
          
!         Read vertical level and OER-related lat-dependent values.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                   &
                 chm_std%levels(icount+jlev),                           &
                 chm_std%std1(icount+(jlev-1)*chm_std%n_lat(jelm)+1:icount+jlev*chm_std%n_lat(jelm))

       end do
       icount=icount+chm_std%n_lat(jelm)*chm_std%n_lvl(jelm)
    end if
 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_obs_err_stddev_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)
!
!  s/r chm_set_obs_err_stddev_index - Returns the station ID and latitude 
!                                     indices corresponding to a measurement
!
!  Author   : M. Sitwell Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!             
!  Revisions: 
!
!----------------------------------------------------------------------------------------
   
    implicit none

    character(len=*), intent(in) :: CSTNID
    integer, intent(in)           :: NLEV,VARNO
    real(8), intent(in)           :: ZLAT
    integer, intent(out)          :: ISTNID,JINT
    integer                       :: JN,ilen1,ilen2,ji,ibegin
    logical                       :: iset

 ! Important: Combination of STNID, BUFR element and number of vertical levels
 !            to determine association to the observations.

 !            Find stnid with same number of vertical levels and same BUFR element.
 !            Note: * in cstd_stndi_chm stands for a wildcard
     
    ISTNID=0
    DO JN=1,chm_std%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_std%stnids(JN) as wildcards
       iset = stnid_equal(chm_std%stnids(JN),CSTNID)
                   
       IF (iset) THEN
          IF (NLEV .EQ. chm_std%n_lvl(JN) .AND. &
               VARNO .EQ. chm_std%bfr(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF

    END DO

    IF (ISTNID.EQ.0) THEN
       WRITE(*,'(1X,"Error std. dev. for STNID= ",A10," not found. Set to 5%.")') &
            CSTNID
    ELSE

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN

          ! Find latitude index for interpolation.
          ! Assuming increasing latitudes in chm_std%lat

          ibegin=chm_std%ibegin(ISTNID)-1
          IF (ZLAT .GE. chm_std%lat(ibegin+chm_std%n_lat(ISTNID))) THEN
             JINT=chm_std%n_lat(ISTNID)+1
          ELSE
             DO JINT=1,chm_std%n_lat(ISTNID)
                IF (ZLAT .LE. chm_std%lat(ibegin+JINT) ) exit
             END DO
          END IF
                                           
       END IF
    END IF

  end subroutine chm_obs_err_stddev_index

!----------------------------------------------------------------------------------------

  function chm_get_obs_err_stddev(CSTNID,NLEV,VARNO,ZLAT,ZLON,IDATE,ITIME,ZVAL,ZLEV,IFIRST) result(obs_err_stddev) 
!
!  s/r chm_set_obs_err_stddev - Returns the observational error std for a CH family measurement
!
!  Author   : M. Sitwell, ARQI/AQRD, Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!
!  Revisions: 
!
!----------------------------------------------------------------------------------------

    implicit none
   
    character(len=*), intent(in) :: CSTNID
    real(8), intent(in) :: ZVAL,ZLEV,ZLAT,ZLON
    integer, intent(in) :: NLEV,VARNO,IDATE,ITIME
    logical, intent(in)  :: IFIRST

    real(8)  :: obs_err_stddev 
       
    real(8)  :: wgt,zwb,sigma
    integer  :: ibegin,ILEV,JN    
    integer, save  :: ISTNID,JINT

    ! If this call is for the first level for this measurement, get
    ! the station ID and latitude indices corresponding to this measurement
    if (ifirst) call chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)

    ! Identify level if needed
                   
    IF (ISTNID .EQ. 0) THEN
       
       ! Set error standard deviations as 5% default value.       
       obs_err_stddev = 0.05D0*ZVAL
       
    ELSE
             
       IF (chm_std%n_lvl(ISTNID) .GT. 1) THEN
                  
          ! Find nearest vertical level (no interpolation)
                 
          zwb=1.E10
          ibegin=chm_std%ibegin(ISTNID)-1
          DO JN=1,chm_std%n_lvl(ISTNID)
             IF (zwb .GT. abs(ZLEV-chm_std%levels(ibegin+JN)) ) THEN
                ILEV=JN
                zwb=abs(ZLEV-chm_std%levels(ibegin+JN))
             END IF
          END DO
          ILEV=ibegin+(ILEV-1)*chm_std%n_lat(ISTNID)+1
       ELSE
          ILEV=chm_std%ibegin(ISTNID)     
       END IF

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN
                
          ! Apply interpolation

          ILEV=ILEV+JINT-1
          ibegin=chm_std%ibegin(ISTNID)-1
          IF (JINT.EQ.1.OR.JINT.GT.chm_std%n_lat(ISTNID)) THEN
             wgt=chm_std%std1(ILEV)
          ELSE
             wgt=(chm_std%std1(ILEV-1)*(chm_std%lat(ibegin+JINT)-ZLAT)+ &
                  chm_std%std1(ILEV)*(ZLAT-chm_std%lat(ibegin+JINT-1)))/ &
                  (chm_std%lat(ibegin+JINT)-chm_std%lat(ibegin+JINT-1))
          END IF
       ELSE
          wgt=chm_std%std1(ILEV)                
       END IF
                                         
       IF (chm_std%brp(ISTNID).EQ.0) THEN
               
          ! Set error standard deviations from scratch using content of
          ! previously read content of the "obsinfo_chm" file.
                
          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
             obs_err_stddev = wgt
          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
             obs_err_stddev = min(chm_std%std3(ISTNID),max(chm_std%std2(ISTNID),wgt*ZVAL))
          ELSE IF (chm_std%std_type(ISTNID) .EQ. 2) THEN
             obs_err_stddev = sqrt(chm_std%std2(ISTNID)**2+(wgt*ZVAL)**2)
          ELSE 
!             IF (INDEX_BODY.EQ.IDATA)  &
!                  WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
!                  chm_std%std_type(ISTNID) , CSTNID
             WRITE(*,'(1X,"EOR setup type ",I3," is not recognized.")')     &
                  chm_std%std_type(ISTNID)
          END IF

       ELSE
          
          ! Adjust error standard deviations read from BURP file if requested.

          sigma = chm_get_burp_element(chm_burp_std(istnid),zlat,zlon,idate,itime)
          
          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
             obs_err_stddev = sigma
          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
             obs_err_stddev = max(chm_std%std2(ISTNID),wgt*sigma)
          ELSE
             WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
                  chm_std%std_type(ISTNID) , CSTNID
             call abort3d('chm_get_obs_err_stddev:')
          END IF
       END IF
              
    END IF

  end function chm_get_obs_err_stddev

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_obs_err_stddev
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for observation errors for the CH family
!
!---------------------------------------------------------------------------------------
  
    implicit none

    integer :: istnid

    if (chm_std%n_stnid.eq.0) return
    
    if (allocated(chm_burp_std)) then
       do istnid=1,chm_std%n_stnid
          if (chm_std%brp(istnid).eq.1) call dealloc_burp(chm_burp_std(istnid))
       end do
       deallocate(chm_burp_std)       
    end if

    if (allocated(chm_std%stnids))   deallocate(chm_std%stnids)
    if (allocated(chm_std%n_lvl))    deallocate(chm_std%n_lvl)
    if (allocated(chm_std%std_type)) deallocate(chm_std%std_type)
    if (allocated(chm_std%ibegin))   deallocate(chm_std%ibegin)
    if (allocated(chm_std%bfr))      deallocate(chm_std%bfr)
    if (allocated(chm_std%brp))      deallocate(chm_std%brp)
    if (allocated(chm_std%n_lat))    deallocate(chm_std%n_lat)
    if (allocated(chm_std%std1))     deallocate(chm_std%std1)
    if (allocated(chm_std%std2))     deallocate(chm_std%std2)
    if (allocated(chm_std%std3))     deallocate(chm_std%std3)
    if (allocated(chm_std%levels))   deallocate(chm_std%levels)
    if (allocated(chm_std%lat))      deallocate(chm_std%lat)

  end subroutine chm_dealloc_obs_err_stddev

!-----------------------------------------------------------------------------------------
!------------------- BURP functions and routines -----------------------------------------

  function chm_read_burp(filename,stnid,varno,nlev,ndim,bkstp,block_type) result(burp_out)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Purpose:  Retrieve information from BURP file for CH family observations. Can retrieve
!           either 1D or 2D data from a report.
!           Note: Exponent BUFR data (i.e. data with BUFR number 8090) will only be applied
!                 to 1D data.
!
! Revision:  M. Sitwell, ARQI/AQRD, May 2015
!            - Modified to read both 1D and 2D data from a report
!
! Arguments:
!
!  Input
!           filename      BURP file name
!           stnid         station ID of observation
!           varno         BUFR code
!           nlev          number of levels in the observation
!           ndim          number of dimensions for the retrieved data in
!                         each report (i.e. ndim=1 for std, ndim=2 for
!                         averagine kernels) 
!           bkstp         bkstp number of requested block
!           block_type    block type indicated by the two rightmost bits
!                         of bknat. Valid values are 'DATA', 'INFO', '3-D',
!                         and 'MRQR'.
!
!  Output 
!           burp_out      struct_chm_burp object
!
!-----------------------------------------------------------------------------------------
    
    use burp_module
    use MathPhysConstants_mod

    implicit none

    character(len=*), intent(in) :: filename
    character(len=9), intent(in) :: stnid
    character(len=4), intent(in) :: block_type
    integer, intent(in)          :: ndim,varno,nlev,bkstp
    type(struct_chm_burp) :: burp_out
    character(len=9)      :: rep_stnid
    type(burp_file)       :: brp
    type(burp_rpt)        :: rep
    type(burp_block)      :: blk
    integer               :: error,ref_rpt,nrep,ref_blk
    integer               :: ref_bkstp,nval,ivar,iexp,ilev,icount
    integer               :: idate,itime,ilat,ilon,iele,nele,icol
    real(8)               :: val,exponent
      
    ! initialize burp file, report, and block
    Call BURP_Init(brp, iostat=error)
    Call BURP_Init(rep, iostat=error)
    Call BURP_Init(blk, iostat=error)

    ! open the burp file
    Call BURP_New(brp, FILENAME=filename, MODE=FILE_ACC_READ, IOSTAT=error)
    
    if (error.ne.0) CALL ABORT3D('chm_read_burp: Could not open BURP file: ' // filename)

    ! get number of reports in file
    Call BURP_Get_Property(brp, NRPTS=nrep)

    ! allocate memory
    call alloc_burp(burp_out,nrep,nlev,ndim)
    
    icount = 0  ! counter of reports with same stnid and number of levels as input 
    ref_rpt = 0
    
    ! loop through reports    
    REPORTS: do

       ref_rpt = BURP_Find_Report(brp, REPORT=rep, SEARCH_FROM=ref_rpt, IOSTAT=error)

       if (ref_rpt<0) exit REPORTS
       
       call BURP_Get_Property(rep, STNID=rep_stnid, DATE=idate, TEMPS=itime, LATI=ilat, LONG=ilon) 

       if (.not. stnid_equal(stnid,rep_stnid)) cycle REPORTS

       ! loop through blocks
       ref_blk = 0
       BLOCKS: do
          
          ref_blk = BURP_Find_Block(rep, BLOCK=blk, SEARCH_FROM=ref_blk, IOSTAT=error)          
          if (ref_blk<0) exit BLOCKS
          
          call BURP_Get_Property(blk, NELE=nele, NVAL=nval, BKSTP=ref_bkstp, IOSTAT=error)
          
          if (IS_Burp_Btyp(trim(block_type),BLOCK=blk) .and. bkstp.eq.ref_bkstp) then
             if (nval.eq.nlev) then
                
                ! required block found, retrieve data and store in burp_out

                icount=icount+1

                burp_out%date(icount) = idate
                burp_out%time(icount) = itime

                burp_out%lon(icount) = .01*ilon
                if (burp_out%lon(icount).lt.0.) burp_out%lon(icount) = 360. + burp_out%lon(icount)
                burp_out%lat(icount) = ilat*.01 -90.
                burp_out%lon(icount) = burp_out%lon(icount)*MPC_RADIANS_PER_DEGREE_R8
                burp_out%lat(icount) = burp_out%lat(icount)*MPC_RADIANS_PER_DEGREE_R8

                if (ndim.eq.1) then
                   ! retrieve 1D data

                   ivar = BURP_Find_Element(blk, ELEMENT=varno, IOSTAT=error)
                   iexp = BURP_Find_Element(blk, ELEMENT=8090, IOSTAT=error)
                
                   if (iexp.lt.0) then
                      ! No exponent found in block
                      do ilev=1,nval                   
                         burp_out%data1d(icount,ilev) = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                      end do
                   else
                      ! Apply exponent
                      do ilev=1,nval                   
                         val = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                         exponent = BURP_Get_Rval(blk, NELE_IND=iexp, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                         burp_out%data1d(icount,ilev) = val * 10**exponent
                      end do
                   end if
                   
                else if (ndim.eq.2) then
                   ! retrieve 2D data

                   icol = 0
                   do iele=1,nele
                      ivar = BURP_Get_Element(blk, INDEX=iele, IOSTAT=error)
                      if (ivar.eq.varno) then
                         icol = icol+1
                         do ilev=1,nval                  
                            burp_out%data2d(icount,ilev,icol) = BURP_Get_Rval(blk, NELE_IND=iele, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                         end do
                      end if
                   end do

                end if

             end if
             exit BLOCKS
          end if

       end do BLOCKS
      
    end do REPORTS

    ! resize first dimension of output from length
    ! of nrep to icount
    call resize_1d_real(burp_out%lat,icount)
    call resize_1d_real(burp_out%lon,icount)
    call resize_1d_int(burp_out%date,icount)
    call resize_1d_int(burp_out%time,icount)
    if (ndim.eq.1) then
       call resize_2d_real(burp_out%data1d,icount,nlev)
    else if (ndim.eq.2) then
       call resize_3d_real(burp_out%data2d,icount,nlev,nlev)
    end if

    burp_out%nrep = icount
    burp_out%nlev = nlev

    ! The following are counters used to keep tract of position 
    ! in burp_out%data array when extracting values via
    ! chm_get_burp_element. The values are initialized to one,
    ! pointing to the very first element.
    burp_out%irep = 1
    burp_out%ilev = 1
    
    ! deallocate
    Call BURP_Free(brp,iostat=error)
    Call BURP_Free(rep,iostat=error)
    Call BURP_Free(blk,iostat=error)
    
  end function chm_read_burp

!-------------------------------------------------------------------------------------------

  subroutine alloc_burp(burp,nrep,nlev,ndim)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Allocates memory for structure struct_chm_burp to hold BURP file information
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_burp), intent(inout) :: burp
    integer, intent(in) :: ndim,nrep,nlev
    
    if (ndim.eq.1.or.ndim.eq.2) then
       burp%ndim = ndim
    else
       call abort3d("alloc_burp: Invalid BURP data structure dimension.")
    end if

    if (ndim.eq.1) then
       allocate(burp%data1d(nrep,nlev))
    else if (ndim.eq.2) then
       allocate(burp%data2d(nrep,nlev,nlev))
    end if

    allocate(burp%lat(nrep),burp%lon(nrep))
    allocate(burp%date(nrep),burp%time(nrep))

  end subroutine alloc_burp

!-------------------------------------------------------------------------------------------

  subroutine dealloc_burp(burp)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Deallocates memory for structure struct_chm_burp
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_burp), intent(inout) :: burp
    
    if (associated(burp%data1d)) deallocate(burp%data1d)
    if (associated(burp%data2d)) deallocate(burp%data2d)
    if (associated(burp%lat))    deallocate(burp%lat)
    if (associated(burp%lon))    deallocate(burp%lon)
    if (associated(burp%date))   deallocate(burp%date)
    if (associated(burp%time))   deallocate(burp%time)

  end subroutine dealloc_burp

!-------------------------------------------------------------------------------------------

  function chm_get_burp_element(burp,zlat,zlon,idate,itime) result(element)
! 
!   Purpose: Returns element of array from burp%data. The returned element is the one
!            that matches the lon, lat, date, and time from the argument list to that stored
!            in the burp structure.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!
!  Input 
!           burp          struct_chm_burp instance
!           zlat          latitude
!           zlon          longitude
!           idate         date YYYYMM
!           itime         time HHMM
!
!  Output
!           element       retrieved element from burp%data
!-------------------------------------------------------------------------------------------

    type(struct_chm_burp), intent(inout) :: burp
    real(8), intent(in) :: zlat,zlon
    integer, intent(in) :: idate,itime
    real(8) :: element
    
    ! find burp%irep,burp%ilev for current observation
    call chm_set_burp_position(burp,zlat,zlon,idate,itime)
    
    ! get element from data array at current position
    element = burp%data1d(burp%irep,burp%ilev)
    
    ! increment position in data array
    if (burp%irep.eq.burp%nrep .and. burp%ilev.eq.burp%nlev) then
       burp%irep = 1
       burp%ilev = 1
    else
       burp%ilev=burp%ilev+1
       
       if (burp%ilev.gt.burp%nlev) then
          burp%ilev=1
          burp%irep=burp%irep+1
       end if
    end if

  end function chm_get_burp_element

!-------------------------------------------------------------------------------------------

  function chm_get_burp_array2d(burp,zlat,zlon,idate,itime,nlev) result(array)
! 
!   Purpose: Returns element of array from burp%data. The returned element is the one
!            that matches the lon, lat, date, and time from the argument list to that stored
!            in the burp structure.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!
!  Input 
!           burp          struct_chm_burp instance
!           zlat          latitude
!           zlon          longitude
!           idate         date YYYYMM
!           itime         time HHMM
!
!  Output
!           element       retrieved element from burp%data
!-------------------------------------------------------------------------------------------

    type(struct_chm_burp), intent(inout) :: burp
    real(8), intent(in) :: zlat,zlon
    integer, intent(in) :: idate,itime,nlev
    real(8) :: array(nlev,nlev)
    
    ! find burp%irep,burp%ilev for current observation
    call chm_set_burp_position(burp,zlat,zlon,idate,itime)
    
    ! get element from data array at current position
    array = burp%data2d(burp%irep,:,:)
    
    ! increment position in data array
    if (burp%irep.eq.burp%nrep) then
       burp%irep = 1
    else
       burp%irep=burp%irep+1
    end if

  end function chm_get_burp_array2d

!-------------------------------------------------------------------------------------------

  subroutine chm_set_burp_position(burp,zlat,zlon,idate,itime)
! 
!   Purpose: Sets the position variables in struct_chm_burp (burp%irep, burp%ilev)
!            to reference the BURP record that matches the input parameters. 
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!  Input 
!           burp          struct_chm_burp instance
!           zlat          latitude
!           zlon          longitude
!           idate         date YYYYMM
!           itime         time HHMM
!
!  Output
!           element       retrieved element from burp%data
!-------------------------------------------------------------------------------------------

    type(struct_chm_burp), intent(inout) :: burp
    real(8), intent(in) :: zlat,zlon
    integer, intent(in) :: idate,itime
    integer :: i

    i=0
    
    ! search for required irep if current position doesn't match lat,lon,date,time
    do while (.not. equal_real(burp%lon(burp%irep),zlon) .or. .not. equal_real(burp%lat(burp%irep),zlat) .or. &
              idate.ne.burp%date(burp%irep) .or. itime.ne.burp%time(burp%irep) )
       burp%irep=burp%irep+1
       if (burp%irep.gt.burp%nrep) burp%irep=1
       burp%ilev=1
       if (i.gt.burp%nrep) CALL ABORT3D('chm_set_burp_position: BURP file data could not be retrieved.')
       i=i+1
    end do

  end subroutine chm_set_burp_position

!-----------------------------------------------------------------------------------------
!------------------- Miscellaneous utilities functions and routines ----------------------

  function stnid_equal(id1,id2) result(same)
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!           M. Sitwell, Feb 2015
!           - Code set as a function.
!
! Purpose: Compares STNID values allowing for * and blanks in id1 as wildcards
!
!-----------------------------------------------------------------------------------------    

    implicit none

    logical :: same
    CHARACTER(len=*), intent(in) :: id1,id2
    integer :: ilen1,ilen2,ji

    same=.false.
    ilen1=len_trim(id1)
    ilen2=len_trim(id2)            
    IF (ilen1.le.ilen2) THEN          
       same = .TRUE.
       DO ji=1,ilen1
          IF ( id1(ji:ji).ne.'*' .AND. id2(ji:ji).ne.id1(ji:ji) ) THEN
             same = .FALSE.
             exit
          END IF
       END DO
    END IF
    
  end function stnid_equal
 
           
!-------------------------------------------------------------------------------------------

  subroutine chm_adj_model_bndry(zModAlt,zStnAlt,ztop,zbot,ptop,pbot)
!
! Author  : Y. Rochon  Feb 2015
! Revision: 
!
! Purpose: Set allowed top and bottom boundaries based on model 
!          for vertical range.
!
!          Called from filt_topoChm in flterobs_mod.ftn90.
!
!-----------------------------------------------------------------------------------------    

  implicit none

  real(8), intent(in)    :: zModAlt,zStnAlt
  real(8), intent(inout) :: ztop,zbot
  real(8), intent(inout) :: ptop,pbot
  
  real(8), parameter :: zinc=400.0   ! 400 m allowance beyond input (same as weather variables)
  real(8), parameter :: pinc=5000.0  ! 50 hPa allowance at sfc beyond input.
  
  ! Set geopotential height boundaries.
      
  if (zStnAlt .gt. zModAlt) then
      zbot = zStnAlt - zinc
  else
      zbot = zModAlt - zinc
  endif
  ztop=ztop + zinc
  
  ! Set pressure boundaries.
      
  ptop = ptop*(1.0-pinc/pbot)
  pbot = pbot + pinc
    
  end subroutine chm_adj_model_bndry
            
!-------------------------------------------------------------------------------------------
  subroutine chm_get_stringId(cstringin,nobslev,CList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from a list of accumulating character 
!            strings (e.g. stnids).
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!
!   Input:
!
!       Nmax            Max allowed dimension.
!       NListSize       Input number of identified IDs (must be >=0 and <=Nmax)
!       CList           Input list of accumulated character strings
!                       for uni and multi-level data.
!       cstringin       Input character string
!       nobslev         Number of elements in profile associated to cstringin.
!
!   Output:
!
!       NListSize       Updated number of identified IDs
!       CList           Updated list of accumulated character strings
!       elemId          Index of cstringin within CList_chm
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,nobslev
    integer, intent(inout) :: NListSize
    integer, intent(out)   :: elemId
    character(len=*), intent(in)     :: cstringin
    character(len=*),  intent(inout) :: CList(Nmax)
  
    integer :: i
    character(len=120) :: cstring
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_stringId: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       if (nobslev.eq.1) then 
          cstring=trim(cstringin)//'U'
          do i=1,NListSize
             if (cstring.eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       else 
          cstring=trim(cstringin)       
          do i=1,NListSize
             if (cstring.eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       end if
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        if (nobslev.eq.1) then
           CList(NListSize)=trim(cstringin)//'U'
        else
           CList(NListSize)=trim(cstringin)
        end if
    end if
    
  end subroutine chm_get_stringId

!-------------------------------------------------------------------------------------------
  subroutine chm_get_Id(id,IdList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from list of accumulating integer IDs.
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!
!   Input:
!
!       Nmax         Max allowed dimension.
!       NListSize    Input number of IDs (must be >=0 and <=Nmax)
!       IdList       Input list of accumulated IDs.
!       id           Input id for individual obs
!
!   Output:
!
!       NListSize    Updated number of IDs
!       IdList       Updated list of accumulated IDs.
!       elemId       Index of id within List
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,id
    integer, intent(inout) :: NListSize,IdList(Nmax)
    integer, intent(out)   :: elemId
  
    integer :: i
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_Id: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       do i=1,NListSize
          if (id.eq.IdList(i)) then
              elemId=i
              exit
          end if
       end do
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        IdList(NListSize)=id
    end if
    
  end subroutine chm_get_Id

!-------------------------------------------------------------------------------------------

  subroutine resize_1d_real(arr,dim1)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
    implicit none

    real(8), pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    real(8), pointer :: tmp(:)

    allocate(tmp(dim1))

    tmp = arr(1:dim1)
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_1d_real
!-------------------------------------------------------------------------------------------

  subroutine resize_1d_int(arr,dim1)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
     
    implicit none

    integer, pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    integer, pointer :: tmp(:)

    allocate(tmp(dim1))

    tmp = arr(1:dim1)
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_1d_int

!-------------------------------------------------------------------------------------------
  
  subroutine resize_2d_real(arr,dim1,dim2)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Resize 2D array
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:)
    integer, intent(in) :: dim1,dim2
    real(8), pointer :: tmp(:,:)

    allocate(tmp(dim1,dim2))

    tmp = arr(1:dim1,1:dim2)
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_2d_real

!-------------------------------------------------------------------------------------------
  
  subroutine resize_3d_real(arr,dim1,dim2,dim3)
!
! Author  : M. Sitwell  May 2015
! Revision: 
!
! Purpose: Resize 3D array
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:,:)
    integer, intent(in) :: dim1,dim2,dim3
    real(8), pointer :: tmp(:,:,:)

    allocate(tmp(dim1,dim2,dim3))

    tmp = arr(1:dim1,1:dim2,1:dim3)
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_3d_real

!-------------------------------------------------------------------------------------------
  
  logical function equal_real(r1,r2)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Check if two reals are equal (up to a small difference of 1E-5) 
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: r1,r2
    
    equal_real = abs(r1-r2) .le. 1E-5
    
  end function equal_real

!---------------------------------------------------------------------------------------
  
  subroutine chm_dealloc_info(info)
!
! Author  : M. Sitwell  May 2015
!
! Purpose: Deallocates struct_chm_info instance
!
!---------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_info), intent(inout) :: info

    if (allocated(info%stnids))       deallocate(info%stnids)
    if (allocated(info%bfr))          deallocate(info%bfr)
    if (allocated(info%brp))          deallocate(info%brp)
    if (allocated(info%vco))          deallocate(info%vco)
    if (allocated(info%n_lat))        deallocate(info%n_lat)
    if (allocated(info%ibegin))       deallocate(info%ibegin)
    if (allocated(info%n_lvl))        deallocate(info%n_lvl)
    if (allocated(info%rak))          deallocate(info%rak)
    if (allocated(info%vlayertop))    deallocate(info%vlayertop)
    if (allocated(info%vlayerbottom)) deallocate(info%vlayerbottom)
    if (allocated(info%lat))          deallocate(info%lat)

  end subroutine chm_dealloc_info

!-------------------------------------------------------------------------------------------

  function chm_convert_z_to_pressure(altitude,rgz_mod,press_mod,nlev,nlev_mod,lat,success) result(press)
!
! Author   : M. Sitwell, May 2015
!          
! Purpose: Converts an array of geopotential heights to pressures. Uses linear interpolation
!          in log(p).
!
! Arguments:
!
!   Input
!     altitude      altitudes to convert to pressures (m)
!     rgz_mod       geopotential heights on model levels (m), assumed to be in decending order
!     press_mod     pressure on model levels, assumed to be in ascending order
!     nlev          length of altitude array
!     nlev_mod      number of model levels
!     lat           latitude (rad)
!
!   Output
!     press         rz converted to pressures
!
!----------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: altitude(nlev),rgz_mod(nlev_mod),press_mod(nlev_mod),lat
    integer, intent(in) :: nlev,nlev_mod
    logical, intent(inout) :: success(nlev)
    real(8) :: press(nlev),rgz(nlev)
    integer :: ilev,ilev_mod

    ! Convert altitudes to geopotential heights
    rgz = chm_convert_z_to_gz(altitude,lat,nlev)

    do ilev=1,nlev

       ! Check if height is above or below model boundaries
       if ( rgz(ilev).gt.rgz_mod(1) .or. rgz(ilev).lt.rgz_mod(nlev_mod) ) then
          success(ilev)=.false.
       end if

       if (success(ilev)) then

          ! Find model layers directly above and below rgz(ilev).
          ! After exit of loop we will have 
          ! rgz_mod(ilev_mod) >= rgz(ilev) > rgz_mod(ilev_mod+1)
          do ilev_mod=1,nlev_mod-1
             if ( rgz(ilev).le.rgz_mod(ilev_mod) .and. &
                  rgz(ilev).gt.rgz_mod(ilev_mod+1) ) exit
          end do
          
          ! Linear interpolation in gz,log(p)
          press(ilev) = press_mod(ilev_mod+1) * (press_mod(ilev_mod)/press_mod(ilev_mod+1))**( &
               (rgz(ilev)-rgz_mod(ilev_mod+1))/(rgz_mod(ilev_mod)-rgz_mod(ilev_mod+1)) )

       else
          press(ilev) = 0.0
       end if

    end do

  end function chm_convert_z_to_pressure

!----------------------------------------------------------------------------------------

  function chm_convert_z_to_gz(altitude,lat,nlev) result(rgz)
!
! Author   : M. Sitwell, June 2015
!          
! Purpose: Converts altitudes to geopotential heights. Uses the Helmert formula to
!          parameterize the latitude dependence (see J.A. Dutton 1976). At an altitude
!          of 50 km, the altitude and geopotential height differ by around 0.2-0.5 km,
!          depending on the latitude.
!
! Arguments:
!
!   Input
!     altitude      altitudes (m)
!     lat           latitude (rad)
!
!   Output
!     rgz           geopotential heights (m)
!
!----------------------------------------------------------------------------------------
  
    use earthconstants_mod
    
    implicit none

    real(8), intent(in) :: altitude(nlev),lat
    integer, intent(in) :: nlev
    real(8) :: rgz(nlev)

    rgz = (RG/9.8) * (1.-2.64D-03*cos(2.*lat)+5.9D-6*cos(2.*lat)**2) * RA*altitude/(RA+altitude)

  end function chm_convert_z_to_gz


!--------------------------- Routines for observation operators ----------------------------

  subroutine chm_obsoperators(n_modlvl,rvalinc,rval,rtt,pressmodlvl,rgz,kmode,varName, &
                varno,cstnid,idate,ihhmm,ivco,nobslev, &
                robslev,ixtr,iass,rlat,rlon,iconstituent_id,success,rmhx)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!           Ping Du, Mar 2015
!           - Finalization of Ht*grad contribution (case(3))
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           M. Sitwell, ARQI/AQRD, May 2015
!           - Added vertical interpolation operator
!           M. Sitwell, ARQI/AQRD, June 2015
!           - Changed calculation of HBH^T to forgo calculating off-diagonal elements
!             of the final product
!
! Purpose: Apply obs operator for indicated obs data. 
!
!          Usable as
!
!                 - general (potentially non-linear) simulation operator (kmode=0)
!                 - determination of sqrt(diag(H*B*H^T)) (kmode=1)
!                 - tangent linear operator (kmode=2)
!                 - linear adjoint operator (kmode=3)
!
! Further changes required for generalization 
!
! 1) Add layer average operators.
! 2) Complete testing for use of avg kernels
! 3) Add option to include use of obs error correlation matrix for kmode=2,3
!
! Arguments:
!
!   Input
!
!     n_modlvl  Number of model (or increment field) vertical levels
!     varno     BUFR descriptor element for obs units.
!     rval      Trial field column 
!     rtt       Temperature array (Kelvin)
!     pressmodlvl  Pressure array (Pascal; kg/(m s^2))
!     rgz       Geopotential (m^2/s^2, for conversion of obs altitudes to pressure when needed)
!          
!     kmode     0 for non-linear/linear model in assimilation
!                 Actually, all models included are currently linear
!               1 for determination of sqrt(diag(H*B*H^T))
!               2 for tangent linear model
!               3 for adjoint model 
!     varName   Variable/obs nomvar
!     cstnid    Obs STNID
!     idate     YYYYMMDD (date of obs)
!     ihhmm     HHMM (time of obs)
!     ivco      Index of vertical coord type for obs
!               1 - Altitudes (m)
!               2 - Pressure (Pa)
!               3 - Channel index
!               4 - not provided with obs (normally for total column values)
!     nobslev   Size of obs profile
!     robslev   pressure value of observation (OBS_PPP)
!     ixtr      Flag indicating if obs within the model vertical coord range (.ne.0 for no) 
!               Can be modified internally - hence intent(inout) - even though
!               these changes will not be needed outside this routine.
!     iass      Flag indicating if obs is to be assimilated (.ne.1 for no)
!     rlat      Latitude of obs profile (radians)
!     rlon      Longitue of obs profile (radians)
!     iconstituent_id BUFR code element of Table 08046 identifyin the constituent.
!
!   Inout
!
!     rmhx      H(x) element value when kmode=0 (out).
!               sqrt(diag(H*B*H^T)) when kmode=1 (out).
!               Hx increment element value when kmode=2 (out).
!               R**-1 (Hdx-d) when kmode=3 (in).
!
!     rvalinc   Increment, trial field, or sigma column when kmode<3 (in).
!               Not needed/used as input when kmode=1.
!               Expected to be equal to rval when kmode=0
!               Adjoint product when kmode=3 (out).
!
!     rval      Scaled or transformed analysis field on increment/analysis grid
!               (only when kmode>=2; needed only by chm_genoper at the moment)
!
!     success   Indicates if the observation was successfully assimilated
!
! Comments:
!
!     A. Does not yet account for potential future applications of obs 
!        vertical correlation matrices.
!        
!-------------------------------------------------------------------------------------------

  use earthconstants_mod

  implicit none

! Declarations

! I/O arguments: obs space variables
    
  character(len=*), intent(in) :: varName
  character(len=*), intent(in) :: cstnid
  integer, intent(in) :: varno, ivco, kmode 
  integer, intent(in) :: nobslev
  integer, intent(in) :: idate,ihhmm
  integer, intent(in) :: iconstituent_id,iass(nobslev)
  integer, intent(inout) :: ixtr(nobslev)
  real(8), intent(in) :: robslev(nobslev),rlat,rlon
  logical, intent(out) :: success(nobslev)

! I/O arguments: model space profile data and others
    
  integer, intent(in) :: n_modlvl
  real(8), intent(in) :: pressmodlvl(n_modlvl)
  real(8), intent(in) :: rtt(n_modlvl),rgz(n_modlvl)
  real(8), intent(inout) :: rval(n_modlvl),rvalinc(n_modlvl), rmhx(nobslev)

! Structure to hold observation operator information

  type(struct_chm_obsoperators) :: chm_obsoper

! Local variables
  
  real(8) :: press_obs(nobslev),zwork(n_modlvl),unit_conversion(n_modlvl),rsig(n_modlvl,2)
  integer :: iobslev,iavgkern
  real(8), allocatable :: avg_kern(:,:)
  logical :: apply_genoper,lget_rsig

! Allocate memory for chm_obsoper
  allocate(chm_obsoper%modelvarcolumn(n_modlvl))
  allocate(chm_obsoper%vlayertop(nobslev))
  allocate(chm_obsoper%vlayerbottom(nobslev))
  allocate(chm_obsoper%vweights(n_modlvl,n_modlvl))
  allocate(chm_obsoper%zh(nobslev,n_modlvl))
  allocate(chm_obsoper%zhp(nobslev,n_modlvl))
  allocate(chm_obsoper%vmodpress(n_modlvl+1))
  allocate(chm_obsoper%lvl_top(nobslev))
  allocate(chm_obsoper%lvl_bot(nobslev))

! Initialize to zero 
  chm_obsoper%modelvarcolumn(:)=0.0     
  chm_obsoper%vweights(:,:)=0.0D0
  chm_obsoper%zh(:,:)=0.0D0
  chm_obsoper%zhp(:,:)=0.0D0
  chm_obsoper%lvl_top(:)=1
  chm_obsoper%lvl_bot(:)=n_modlvl
  
! Initialize success of calculation
  success = ixtr.eq.0 .and. iass.eq.1


! Apply unit conversion
  select case(kmode)
  case(3)
     ! Apply unit conversion later - near end of chm_*_operator routines
     rvalinc(:)=0.0
  case(0,2)
     ! Convert the field in model space 
     call chm_convert_units(chm_obsoper,n_modlvl,rvalinc,rval,rtt,pressmodlvl,varno,iconstituent_id,kmode)
  case(1)
     ! Save the conversion factor in <unit_conversion>
     unit_conversion(:) = 1.0
     call chm_convert_units(chm_obsoper,n_modlvl,unit_conversion,rval,rtt,pressmodlvl,varno,iconstituent_id,kmode)
     unit_conversion = chm_obsoper%modelvarcolumn
  end select
       
! Determine if layer boundaries are assigned to this data source.
! If so, obtain them for use in this routine. 
! Routine provides chm_obsoper%layer_identified,
!                  chm_obsoper%vlayertop(nobslev), 
!                  chm_obsoper%vlayerbottom(nobslev) 
 
  call chm_get_layer_boundaries(cstnid,varno,ivco,nobslev,pressmodlvl(1), &
       pressmodlvl(n_modlvl),chm_obsoper%layer_identified,chm_obsoper%vlayertop, &
       chm_obsoper%vlayerbottom)
            
! Identify observation operator based on observation units and presence or
! not of layer boundaries

  if (chm_checkfor_integlayer(varno)) then
      if (.not.chm_obsoper%layer_identified) then
        write(*,*)   '----------------------------------------------------------'
        write(*,*)   'STNID, BUFR index, nobslev: ',cstnid,' ',varno,nobslev
        call abort3d('chm_obsoperators: Required layer boundaries not available!')
      else
        ! Vertical integration operator
        chm_obsoper%modelIndex=3
      end if
  else if (chm_obsoper%layer_identified) then
      ! Layer averaging operator
      chm_obsoper%modelIndex=2
  else
      ! Vertical interpolation operator
      chm_obsoper%modelIndex=1
  end if  


! Indicates if the generalized innovation operator is to be applied.

  apply_genoper = kmode.ge.2 .and. chm_ngenoper.eq.1 .and. &
       (chm_obsoper%modelIndex.eq.2 .or. chm_obsoper%modelIndex.eq.3)


! Convert observation vertical coordinate value(s) to pressure if needed

  select case(ivco)
  case(1)
     ! Convert altitude to pressure
     ! Note: factor of RG in 'rgz/RG' is to convert geopotential to geopotential height
     select case(chm_obsoper%modelIndex)
     case(1)
        press_obs = chm_convert_z_to_pressure(robslev,rgz/RG,pressmodlvl,nobslev,n_modlvl,rlat,success)
     case(2,3)
        chm_obsoper%vlayertop = chm_convert_z_to_pressure(chm_obsoper%vlayertop,rgz/RG,pressmodlvl,nobslev,n_modlvl,rlat,success)
        chm_obsoper%vlayerbottom = chm_convert_z_to_pressure(chm_obsoper%vlayerbottom,rgz/RG,pressmodlvl,nobslev,n_modlvl,rlat,success)
     end select
  case(2)
     ! Pressure, no conversion needed
     if (chm_obsoper%modelIndex.eq.1) press_obs=robslev 
  case(4)
     ! No actions taken
  case default
     write(*,*) "chm_obsoperators: ivco = ",ivco
     call abort3d("chm_obsoperators: vertical coordinate type (ivco) not available for this operator.")
  end select

! Determine if averaging kernel is to be applied

  iavgkern = chm_find_avgkern(cstnid,varno,nobslev)

! Apply appropriate core observation operator
   
  select case(chm_obsoper%modelIndex)
  case(1)

!    Vertical interpolation operator

     call chm_vert_interp_operator(chm_obsoper,n_modlvl,pressmodlvl,nobslev,press_obs,iavgkern,ixtr,success)
     
!  case(2)

!    Layer averaging operator

!     call chm_layer_avg_operator  ! see 3dvar_chem routine ch_vavg

   case(3)

!    Layer integration operator

     call chm_layer_integ_operator(chm_obsoper,n_modlvl,pressmodlvl,nobslev,iavgkern,ixtr,success)

  end select

! Apply averaging kernel if requested

  if (iavgkern.gt.0) then

     allocate(avg_kern(nobslev,nobslev))
     
     call chm_get_avgkern(iavgkern,nobslev,rlat,rlon,idate,ihhmm,avg_kern)
     chm_obsoper%zh = matmul(avg_kern,chm_obsoper%zh)
     if (apply_genoper) chm_obsoper%zhp = matmul(avg_kern,chm_obsoper%zhp)

     deallocate(avg_kern)

  end if

! Apply generalized innovation operator if requested

  if (apply_genoper) call chm_genoper(chm_obsoper,rval,rlat,rlon,n_modlvl,nobslev,kmode,varName,success)

! Finalize required quantities depending on kmode
   
  select case(kmode)

  case(0,2)
!
!     Finalize non-linear/linear operator step
!
      do iobslev=1,nobslev
        if (success(iobslev)) then
           rmhx(iobslev)=dot_product(chm_obsoper%zh(iobslev,chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev)), &
                                 chm_obsoper%modelvarcolumn(chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev)))
        end if
      end do

  case(1)
!
!    Compute sqrt(diag(H*B*H^T))
!
     
     ! Apply unit conversion to observation operator
     do iobslev=1,nobslev
        chm_obsoper%zh(iobslev,:) = unit_conversion * chm_obsoper%zh(iobslev,:)
     end do

     lget_rsig=.TRUE.
     do iobslev=1,nobslev
        if (success(iobslev)) then
           call chm_corvert_mult(varName,chm_obsoper%zh(iobslev,:),rmhx(iobslev),chm_obsoper%lvl_top(iobslev), & 
                chm_obsoper%lvl_bot(iobslev),1,n_modlvl,1,.TRUE.,rlat,lget_rsig,3,rsig) ! get h*B*h^T
           lget_rsig=.FALSE.
           rmhx(iobslev) = sqrt(rmhx(iobslev))  ! save as sqrt(h*B*h^T)
        else
           rmhx(iobslev) = 0.0
        end if
     end do

  case(3)
!
!     Ht*grad contribution from adjoint of tangent linear model.
!
      rvalinc(:)=0.0
      do iobslev=1,nobslev
        if (success(iobslev)) then
           zwork(:)=0.0D0
           zwork(chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev))= &
                rmhx(iobslev)*chm_obsoper%zh(iobslev,chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev))
                
           call chm_convert_units(chm_obsoper,n_modlvl,zwork,rval,rtt,pressmodlvl,varno,iconstituent_id,4)
           
           rvalinc(chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev))= &
                rvalinc(chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev)) + &
                chm_obsoper%modelvarcolumn(chm_obsoper%lvl_top(iobslev):chm_obsoper%lvl_bot(iobslev))
        end if
      end do
      
  end select

! Deallocate chm_obsoper arrays

  deallocate(chm_obsoper%modelvarcolumn)
  deallocate(chm_obsoper%vlayertop,chm_obsoper%vlayerbottom)
  deallocate(chm_obsoper%vweights,chm_obsoper%zh,chm_obsoper%zhp,chm_obsoper%vmodpress)
  deallocate(chm_obsoper%lvl_top,chm_obsoper%lvl_bot)

  end subroutine chm_obsoperators

!-------------------------------------------------------------------------------------------

  logical function chm_checkfor_integlayer(varno)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose: Idenitfy if of obs is a vertically integrated consitutent measurement,
!
! ---------------------------------------------------------------------------------------
  
  implicit none
  integer, intent(in) :: varno
 
  if (varno.eq.15198.or.varno.eq.15001.or.varno.eq.15005.or.varno.eq.15045.or. &
      varno.eq.15020.or.varno.eq.15021.or.varno.eq.15200.or. &
      varno.eq.15009.or.varno.eq.15012) then
      
      chm_checkfor_integlayer=.true.     
  else
      chm_checkfor_integlayer=.false.
  end if
  
  end function chm_checkfor_integlayer
   
!-------------------------------------------------------------------------------------------

  subroutine chm_convert_units(chm_obsoper,ntrlev,rvalinc,rval,rtt,rpp,varno,iconstituent_id,kmode)
!
! Author  : Y. Rochon and Y. Yang, June 2005 to June 2011
!           - Pre-EnVar version
! Revision: 
!           Ping Du, CDMA,Jan 2015
!           - Adapted for the EnVar
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!
! Purpose: Set unit conversion factor and model variable transformations 
!          for consistency of Hx units with obs units.  
!
!          For H2O, there are preliminary conversions related to transforming
!          ln(q) to vmr and/or its TLM equivalent.
! 
! Further changes required for generalization 
!
! 1) May ultimately have two versions, with one called outside the minimization section. 
! 2) Adapt to model variable units other than vmr.
!
! Arguments:
!
!   Input
!
!     varno     BUFR descriptor element for obs units.
!     iconstituent_id  BUFR constituent ID.
!     ntrlev    Dimension of rvalinc,rval,rtt,rpp
!     rvalinc   Increment field or trial field. 
!     rval      Trial field value. 
!     rtt       Temperature array (Kelvin)
!     rpp       Pressure array (Pascal; kg/(m s^2))
!
!     kmode     This flag has two uses.
!
!               1: For H2O, it directs conversions related to 'ln(q) to vmr'
!                   0 for rvalinc=rval = model column
!                   1 for rvalinc=sigma and rval = model column
!                   2 for rvalinc=dx and rval = model column
!                   3 applied same as 2 for the ln(q) conversion to vmr
!                   4 Same as 2 and or but the conversion to rval has already been done.
!               
!               2: For linear unit conversion:
!                  Conversion applied when kmode=2,3, this depending on the BUFR element.
!                  This conversion for rval only needed for chm_genoper
!                  and when the variation in vertical must account for
!                  unit changes involving pressure and or temperature.
!                  Only the relative variation in the vertical matters as opposed
!                  to the absolute values and so the conversion is not applied for
!                  all BUFR elements.
!
!   Output
!
!     chm_obsoper%modelvarcolumn:  Scaled or transformed increment or trial field profile.
!
!     rval      Scaled or transformed analysis field on increment/analysis grid
!               (only when kmode=2,3 and for some BUFR elements)
!
!  Other
!
!     chm_amu(iconstituent_id)  Molecular mass of constituent (g/mol). 
!
! Comments:
!
!     A. Standard model/analysis species field provided as volumetric mixing 
!        ratio (vmr). Conversion to vmr is to applied when this is not the case. 
!        As this is hardcoded, any changes in analysis variable must
!        be reflected by correspondingly modifying this module.
!
!     B. Unit conversion factor is calculated in chm_convert_units
!        from the following factors:
!          (1) physical constants
!          (2) parameters related to a particular species such as molecular
!              mass
!          (3) variables such as T and P from background field at each
!              iteration
!
!     Coefficients related to unit conversion
!
!        conv=1.E5                 ! m to 1e-5m (=1DU)
!        rho_stp=1.293             ! air density at STP (1.293 kg/m^3)
!        RG=9.807                  ! Acceleration due to gravity (m/s^2)
!        MPC_AVOGADRO_R8           ! Avogadro's number. 6.023E23 molecules/mole
!        PC_MOLAR_MASS_DRY_AIR_R8  ! Dry air molecular mass. 28.9644 g/mole
!        MPC_RGAS_IDEAL_R8         ! Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
!      C. List should be revised following changes to the 'tableburp' file.
!
! ---------------------------------------------------------------------------------------

  use earthconstants_mod
  use MathPhysConstants_mod
  
  implicit none
  integer, intent(in) :: ntrlev,kmode,varno,iconstituent_id
  real(8), intent(in) :: rtt(ntrlev),rpp(ntrlev)
  type(struct_chm_obsoperators), intent(inout) :: chm_obsoper
  real(8), intent(inout)  :: rval(ntrlev),rvalinc(ntrlev)

! Declaration of local variables
  integer :: jk
  real(8) :: conv, zcoef
  real(8), parameter :: rho_stp=1.293  !kg/m^3
  real(8), save :: zval1(100),zval2(100)
!
  if (iconstituent_id.eq.1) then
!
!     Since the data is for H2O (iconstituent_id=1), then a conversion from the 
!     incremental variable LQ (ln q) must be performed. 
!     Then a variable transformation to vmr is performed.
!
!     First apply exponential or its TLM equivalent to get specific humidity q
!
      if (kmode.ge.2) then  ! TLM of exponential
!
!         dx = x dlnx, with lnx = rval, dlnx=rvalinc
!         Note: x=rval when kmode>3
!
          if (kmode.le.3) then
             rval(:)=exp(rval(:))
             zval1(1:ntrlev)=rval(:)
             if (kmode.ne.3) rvalinc(:) = zval1(1:ntrlev)*rvalinc(:)
          else
!
!            zval1 should be the same as previously transformed in an earlier 
!            call with kmode=3 (see above the 'else').
!
             rvalinc(:) = zval1(1:ntrlev)*rvalinc(:)
          end if
      else
          if (kmode.eq.0) then  
!
!            Converts LQ to HU or ln(x) to x
!
             rvalinc(:)=exp(rvalinc(:))
          else
!
!            Converts dLQ to dHU or dln(x) to dx 
!
!x           dx = x dlnx, with lnx = rval, dlnx=rvalinc
!            dx = x dlnx, with x = rval, dlnx=rvalinc
!                 
!x            rval(:)=exp(rval(:)) 
             rvalinc(:)= rval(:)*rvalinc(:)
          end if
      end if
!
!     Convert specific humidity to mass mixing ratio (or mass mixing ratio increment)
!
      if (kmode.ge.2) then
         if (kmode.le.3) THEN
!
!           Apply tangent linear of r=q/(1-q):
!
!           dr = dq/(1-q)^2
!
            do jk=1,ntrlev
               conv=rval(jk)
               if (conv.gt.0.8) then
                  write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q exceeds 0.8 at',conv
                  conv=0.8
               else if (conv.lt.-1.D-5) then
                  write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q less than -1E-5 at ',conv
                  conv=-1.D-5
               end if
               if (kmode.ne.3) rvalinc(jk)=rvalinc(jk)/(1.0-conv)**2
               zval2(jk)=rval(jk)
               rval(jk) = rval(jk)/(1.0-conv)
            end do
         else
!
!            rval (zval2) should be the same as previously transformed in an earlier 
!            call with kmode=3 (see above the 'else').
!            
             rvalinc(:)=rvalinc(:)/(1.0-zval2(1:ntrlev))**2
         end if
      else
         do jk=1,ntrlev
            conv=rval(jk)   
            if (conv.gt.0.8) then
               write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q exceeds 0.8 at',conv
               conv=0.8
            else if (conv.lt.-1.D-5) then
               write(*,*) 'CHM_CONVERT_UNITS: WARNING - Q less than -1E-5 at ',conv
               conv=-1.D-5
            end if
            rvalinc(jk)=rvalinc(jk)/(1.0-conv)**2
         end do
      end if
!
!     Mass mixing ratio to volume mixing ratio conversion
!
      if (kmode.ne.3) rvalinc(:)=rvalinc(:)*MPC_MOLAR_MASS_DRY_AIR_R8/chm_amu(iconstituent_id)
  end if
!
! Identify unit conversion factor and variable conversion
! assuming model variable is in vmr.

  if (kmode.eq.3) then
!
!     Apply conversion only to rval (if needed)
!
      zcoef=1.0
      select case (varno)
      case(15023,15027,15194,15195,15223) 
!
!        For conversion from vmr to kg/m^3
!     
         zcoef = zcoef*chm_amu(iconstituent_id)/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         rval(:)=rval(:)*rpp(:)/rtt(:)*zcoef
!
      case(15199,15003,15010) 
!     
!        For conversion from vmr to partial pressure (PA)
!
         rval(:)=rval(:)*rpp(:)*zcoef
!
      case(15230,15022) 
!
!        For conversion from vmr to molecules/m^3
!        RDCJ: Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
         zcoef = zcoef*MPC_AVOGADRO_R8/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         rval(:)=rval(:)*rpp(:)/rtt(:)*zcoef
!         
      end select
      return
  end if
!  
! Apply conversion to incrrement-related profile (and rval if needed)
!
  zcoef=1.0
  select case (varno)
      case(15198,15001,15005,15045) 
!
!        For conversion of vmr*dP integral to DU
!
         conv=1.E5              ! m to 1e-5m (=1DU)
         zcoef = zcoef/RG/rho_stp*conv
         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
      case(15009,15012)
!
!        For conversion of vmr*dP integral to molecules/m^2
!
         conv=1.E3         ! 1.E3 g/kg
!                          ! required for conversion of PC_MOLAR_MASS_DRY_AIR_R8 from g/mol
!                          ! to kg/mol
         zcoef = zcoef*MPC_AVOGADRO_R8*conv/MPC_MOLAR_MASS_DRY_AIR_R8/RG
         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
      case(15020,15021,15200) 
!
!        For conversion of vmr*dP integral to kg/m^2
!
         zcoef = zcoef*chm_amu(iconstituent_id)/MPC_MOLAR_MASS_DRY_AIR_R8/RG
         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
      case(15023,15027,15194,15195,15223) 
!
!        For conversion from vmr to kg/m^3
!     
         zcoef = zcoef*chm_amu(iconstituent_id)/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)/rtt(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) rval(:)=rval(:)*rpp(:)/rtt(:)*zcoef
!
      case(15199,15003,15010) 
!     
!        For conversion from vmr to partial pressure (PA)
!
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) rval(:)=rval(:)*rpp(:)*zcoef
!
      case(15230,15022) 
!
!        For conversion from vmr to molecules/m^3
!        RDCJ: Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
         zcoef = zcoef*MPC_AVOGADRO_R8/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)/rtt(:)*zcoef
         if (kmode.eq.2.or.kmode.eq.3) rval(:)=rval(:)*rpp(:)/rtt(:)*zcoef
!
      case(15026,15008,15197,15208) 
!
!        Observation in molecules/molecules by volume (vmr).
!        No conversion needed.
!     
         zcoef = zcoef*1.0D0
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*zcoef
!
      case(15024,15196,12001,15055,15062)
!
!        Do nothing
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)
!
      case(15192,15011) 
!
!        Code to be revised when actually applied for the first time
!        according to model field units.
!
         write(*,*) 'CHM_CONVERT_UNITS: Obs conversion not yet defined.',varno
         call abort3d('CHM_CONVERT_UNITS')
!
      case default 
!
         write(*,*) 'CHM_CONVERT_UNITS: Unknown obs units ',varno
         call abort3d('CHM_CONVERT_UNITS')
         
  end select

  end subroutine chm_convert_units

!---------------------------------------------------------------------------------------

  subroutine chm_layer_integ_operator(chm_obsoper,n_modlvl,pressmodlvl,nobslev,iavgkern,ixtr,success)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input of ixtr and iavgkern
!
! Purpose:  Perform layer integration and calculations.
!
! Arguments:
!
!  Input 
!
!     n_modlvl     number of model levels
!     pressmodlvl  pressure on model levels
!     nobslev      number of observations
!     ixtr         Flag indicating if obs outside model vertical range
!                  0 for no.
!     iavgkern     Flag indicating if average kernels are to be applied 
!                  afterwards using the output of this routine.
!                  0 for no. If not 0, then products for all obs elements
!                  are needed instead of only those for valid obs elements.
!
!  InOut
!
!     chm_obsoper  observation operator object
!     success      success of integration
!     ixtr         Modified ixtr as needed.
!
!-----------------------------------------------------------------------------------------

  implicit none

  integer, intent(in) :: n_modlvl,nobslev,iavgkern
  integer, intent(inout) :: ixtr(nobslev)
  real(8), intent(in) :: pressmodlvl(n_modlvl)
  logical, intent(inout) :: success(nobslev)
  type(struct_chm_obsoperators), intent(inout) :: chm_obsoper

  integer :: ij,iobslev

! Conduct initial setup for vertical integration components

  call chm_vertintg_setup(chm_obsoper,pressmodlvl,n_modlvl)

! Ensure that each layer is within model vertical range.
  
  do iobslev=1,nobslev
     
      if (chm_obsoper%vlayerbottom(iobslev).lt.chm_obsoper%vlayertop(iobslev)) then
         success(1:nobslev)=.false.
         write(*,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',chm_obsoper%vlayertop(iobslev), chm_obsoper%vlayerbottom(iobslev)
         write(*,*) 'chm_layer_integ_operator: Entire profile skipped over.'
         return
      else if (chm_obsoper%vlayerbottom(iobslev).lt.pressmodlvl(1)*1.01 .or. &  
           chm_obsoper%vlayertop(iobslev).gt.pressmodlvl(n_modlvl)*0.99) then
         success(iobslev)=.false.
         if (chm_obsoper%vlayerbottom(iobslev).lt.pressmodlvl(1)*1.01) then
            ixtr(iobslev)=1
         else
            ixtr(iobslev)=2
         end if 
         write(*,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',chm_obsoper%vlayertop(iobslev), chm_obsoper%vlayerbottom(iobslev)
         cycle
      end if
      if (chm_obsoper%vlayerbottom(iobslev).gt.pressmodlvl(n_modlvl)*0.999) chm_obsoper%vlayerbottom(iobslev)=pressmodlvl(n_modlvl)*0.999
      if (chm_obsoper%vlayertop(iobslev).lt.pressmodlvl(1)*1.001) chm_obsoper%vlayertop(iobslev)=pressmodlvl(1)*1.001

  end do
       
  ! Calculate vertical integration components for specified obs layer.

  call chm_vertintg(chm_obsoper,n_modlvl,nobslev,iavgkern,ixtr,success)
   
  end subroutine chm_layer_integ_operator

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg_setup(chm_obsoper,pressmod,n_modlvl)
!
! Author  : Y. Rochon, (ARQI/AQRD), Ping Du (CMDA), and M. Sitwell (ARQI/AQRD) Feb 2015.
!           - Based Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!
! Purpose:  Preliminary calcs for producing components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
!           This includes:
!
!                    - Setting of model layer boundaries
!                    - Determining integration weights associated to
!                      second order Lagrangian interpolation.
!
!           Layer boundaries are taken as mid-point between eta levels in lnP
!           coordinate. Layer values are set to be the values interpolated
!           to the mid-point in P within the various layers. Interpolation
!           in P is done quadratically. 
!
! Arguments:
!
!  Input   
!           n_modlvl          -- # of vertical levels
!           pressmod          -- pressures at model levels
!
!  Output  
!           chm_obsoper%vmodpress(n_modlvl+1) -- Model layer boundaries given that pressmod are
!                                                taken at mid-layer values.
!           chm_obsoper%vweights(n_modlvl,n_modlvl)   -- Second order Lagrangian interp integration weights
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      integer, intent(in) :: n_modlvl
      real(8), intent(in) :: pressmod(n_modlvl)
      type(struct_chm_obsoperators), intent(inout) :: chm_obsoper
!
!*    Declaration of local variables
!
      integer   :: jk
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3
!
!*    Determine P boundaries of analysis layers and save weights for
!     use in setting innovation operator array.
!
!     N.B.: Boundaries of layers set to mid-point of model levels
!      
!     Calculate layer boundaries
!
      chm_obsoper%vmodpress(1)=pressmod(1)
      chm_obsoper%vmodpress(n_modlvl+1)= pressmod(n_modlvl)
!
      DO JK = 2, n_modlvl
         chm_obsoper%vmodpress(jk)=sqrt(pressmod(jk-1)*pressmod(jk))
      END DO
!
!     Interpolation to mid-layer level in P using
!     second degree Lagrangian interpolator.
!     N.B.: Integration is w.r.t. P
!
!     Calculating for jk=1
!
      zp1= pressmod(1)
      zp2= pressmod(2)
      zp3= pressmod(3)
      zp = (chm_obsoper%vmodpress(2)+chm_obsoper%vmodpress(1))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      chm_obsoper%vweights(1,1)=zr1
      chm_obsoper%vweights(2,1)=zr2
      chm_obsoper%vweights(3,1)=zr3
!
      DO JK=2,n_modlvl-1
         zp1=pressmod(jk-1)
         zp2=pressmod(jk)
         zp3=pressmod(jk+1)
         zp=(chm_obsoper%vmodpress(jk+1)+chm_obsoper%vmodpress(jk))/2.0
         zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
         zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
         zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
         chm_obsoper%vweights(jk-1,jk)=zr1
         chm_obsoper%vweights(jk,jk)=zr2
         chm_obsoper%vweights(jk+1,jk)=zr3
      ENDDO
!
!     Calculating  for jk=n_modlvl
!
      zp1= pressmod(n_modlvl-2)
      zp2= pressmod(n_modlvl-1)
      zp3= pressmod(n_modlvl)
      zp = (chm_obsoper%vmodpress(n_modlvl+1)+chm_obsoper%vmodpress(n_modlvl))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      chm_obsoper%vweights(n_modlvl-2,n_modlvl)=zr1
      chm_obsoper%vweights(n_modlvl-1,n_modlvl)=zr2
      chm_obsoper%vweights(n_modlvl,n_modlvl)=zr3
!
  end subroutine chm_vertintg_setup 

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg(chm_obsoper,n_modlvl,nobslev,iavgkern,ixtr,success)
!
! Author  : Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!           Ping Du and Y. Rochon, Jan-Feb 2015
!           - Adapted for the EnVar
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!
! Purpose:  Calculate components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
! Arguments:
!
!  Input   
!           n_modlvl              -- # of model vertical levels
!           nobslev               -- # of obs vertical levels
!           chm_obsoper%vweights  -- See routine chm_vertintg_setup
!           chm_obsoper%vmodpress
!           success               -- Logical indicating if calc are to be performed.
!           ixtr                  -- Flag indicating if obs outside model vertical range
!                                    0 for no.
!           iavgkern              -- Flag indicating if average kernels are to be applied 
!                                    afterwards using the output of this routine.
!                                    0 for no. If not 0, then products for all obs elements
!                                    are needed instead of only those for valid obs elements.
!
!  Output  
!           chm_obsoper%zh(nobslev,n_modlvl)  -- Initial innovation model array 
!                                                (other than conversion constants)
!           chm_obsoper%zhp(nobslev,n_modlvl) -- Part of innovation operator not 
!                                                related to resolution
!
!-----------------------------------------------------------------------------------------
      implicit none

      integer, intent(in) :: n_modlvl,nobslev,iavgkern,ixtr(nobslev)
      type(struct_chm_obsoperators), intent(inout) :: chm_obsoper
      logical, intent(in) :: success(nobslev)

      integer, parameter :: ivweights=2  ! Order of Lagrangian interpolation.
!
!*    Declaration of local variables
!
      integer   :: J,JK,ILMAX2,ILMIN2
      integer   :: ILMIN, ILMAX, iobslev
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3, ptop, pbtm


      do iobslev=1,nobslev

         if (success(iobslev).or.(ixtr(iobslev).eq.0.and.iavgkern.ne.0)) then

            ptop = chm_obsoper%vlayertop(iobslev)
            pbtm = chm_obsoper%vlayerbottom(iobslev)
         
!*          Find the range of vertical levels over which to perform the integration
!           and set innovation operator ZH over this range.

            ilmin=1
            ilmax=n_modlvl
            if (ptop.le.chm_obsoper%vmodpress(1)*1.01.and.pbtm.ge.chm_obsoper%vmodpress(n_modlvl+1)*0.99) then
!
!             Total column integration part
!
               do jk = 1,n_modlvl
                  do j=max(1,jk-ivweights),min(n_modlvl,jk+ivweights)
                     chm_obsoper%zh(iobslev,jk)=chm_obsoper%zh(iobslev,jk)+(chm_obsoper%vmodpress(j+1) &
                         -chm_obsoper%vmodpress(j))*chm_obsoper%vweights(jk,j)
                     chm_obsoper%zhp(iobslev,jk)=chm_obsoper%zhp(iobslev,jk)+chm_obsoper%vweights(jk,j)
                  end do
               end do
               
            else
!
!              Partial column integration part (special treatment at boundaries)
!
!              Identify analysis layer boundaries just within obs layer.
!
               ilmin = chm_igetmodlev(ptop, chm_obsoper%vmodpress, 'top', n_modlvl+1)
               ilmax = chm_igetmodlev(pbtm, chm_obsoper%vmodpress, 'btm', n_modlvl+1)
               
               if (ilmin.eq.ilmax+1) then
!
!                 Entire obs layer within one analysis layer
!
                  j=ilmin
                  if (j.lt.3) j=3
                  if (j.gt.n_modlvl) j=n_modlvl
                  zp1=chm_obsoper%vmodpress(j-2)
                  zp2=chm_obsoper%vmodpress(j-1)
                  zp3=chm_obsoper%vmodpress(j)
                  zp=(ptop+pbtm)/2.0
                  zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                  zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                  zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)

                  chm_obsoper%zh(iobslev,j-2)=(pbtm-ptop)*zr1
                  chm_obsoper%zh(iobslev,j-1)=(pbtm-ptop)*zr2
                  chm_obsoper%zh(iobslev,j)=(pbtm-ptop)*zr3
                  chm_obsoper%zhp(iobslev,j-2)=zr1
                  chm_obsoper%zhp(iobslev,j-1)=zr2
                  chm_obsoper%zhp(iobslev,j)=zr3
                  ilmin=j-2
                  ilmax=j
                  
               else
!
!                 Determine terms from the inner layers (excluding the lower and upper
!                 boundary layers when these layers not covering entire analyses layers)
!
                  if (pbtm.ge.chm_obsoper%vmodpress(n_modlvl)*0.99) then
                     ilmax2=n_modlvl
                  else
                     ilmax2=ilmax-1
                  end if
                  if (ptop.le.chm_obsoper%vmodpress(1)*1.01) then
                     ilmin=1
                     ilmin2=ilmin
                  else
                     ilmin2=ilmin
                  end if
                  if (ilmin2.le.ilmax2) then
                     do jk = ilmin2,ilmax2
                        do j=max(1,jk-ivweights),min(n_modlvl,jk+ivweights)
                           chm_obsoper%zh(iobslev,jk)=chm_obsoper%zh(iobslev,jk)+(chm_obsoper%vmodpress(j+1) &
                               -chm_obsoper%vmodpress(j))*chm_obsoper%vweights(jk,j)
                           chm_obsoper%zhp(iobslev,jk)=chm_obsoper%zhp(iobslev,jk)+chm_obsoper%vweights(jk,j)
                        end do
                     end do
                  end if
!
!                 Determine terms from the lower and upper boundary layers
!                 when these layers do not cover entire analyses layers.
!
                  if (pbtm.lt.chm_obsoper%vmodpress(n_modlvl)*0.99) then
                     
                     j=ilmax+1
                     if (j.gt.n_modlvl) j=n_modlvl
                     if (j.lt.3) j=3
                     zp1=chm_obsoper%vmodpress(j-2)
                     zp2=chm_obsoper%vmodpress(j-1)
                     zp3=chm_obsoper%vmodpress(j)
                     zp=(chm_obsoper%vmodpress(ilmax)+pbtm)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     chm_obsoper%zh(iobslev,j-2)=chm_obsoper%zh(iobslev,j-2)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr1
                     chm_obsoper%zh(iobslev,j-1)=chm_obsoper%zh(iobslev,j-1)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr2
                     chm_obsoper%zh(iobslev,j)=chm_obsoper%zh(iobslev,j)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr3
                     chm_obsoper%zhp(iobslev,j-2)=chm_obsoper%zhp(iobslev,j-2)+zr1
                     chm_obsoper%zhp(iobslev,j-1)=chm_obsoper%zhp(iobslev,j-1)+zr2
                     chm_obsoper%zhp(iobslev,j)=chm_obsoper%zhp(iobslev,j)+zr3
                     ilmax=j
                  
                  end if
                  
                  if (ptop.gt.chm_obsoper%vmodpress(1)*1.01) then
                     
                     j=ilmin-1
                     if (j.lt.1) j=1
                     if (j.gt.n_modlvl-2) j=n_modlvl-2
                     zp1= chm_obsoper%vmodpress(j)
                     zp2= chm_obsoper%vmodpress(j+1)
                     zp3= chm_obsoper%vmodpress(j+2)
                     zp = (chm_obsoper%vmodpress(ilmin)+ptop)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     chm_obsoper%zh(iobslev,j)=chm_obsoper%zh(iobslev,j)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr1
                     chm_obsoper%zh(iobslev,j+1)=chm_obsoper%zh(iobslev,j+1)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr2
                     chm_obsoper%zh(iobslev,j+2)=chm_obsoper%zh(iobslev,j+2)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr3
                     chm_obsoper%zhp(iobslev,j)=chm_obsoper%zhp(iobslev,j)+zr1
                     chm_obsoper%zhp(iobslev,j+1)=chm_obsoper%zhp(iobslev,j+1)+zr2
                     chm_obsoper%zhp(iobslev,j+2)=chm_obsoper%zhp(iobslev,j+2)+zr3
                     ilmin=j
                     if (ilmax.lt.j+2) ilmax=j+2
                     
                  end if
                  if (ilmin.gt.ilmax-2) ilmin=ilmax-2
               end if
            end if

            chm_obsoper%lvl_top(iobslev)=ilmin
            chm_obsoper%lvl_bot(iobslev)=ilmax
            
         else
            chm_obsoper%zh(iobslev,:) = 0.0D0
            chm_obsoper%zhp(iobslev,:) = 0.0D0
            
            chm_obsoper%lvl_top(iobslev)=1
            chm_obsoper%lvl_bot(iobslev)=1
         end if

      end do

  end subroutine chm_vertintg

!-----------------------------------------------------------------------------------------

  subroutine chm_vert_interp_operator(chm_obsoper,nmodlev,pres_mod,nobslev,pres_obs,iavgkern,ixtr,success)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!           - Based on ch_vprof from 3DVAR-CHEM by Y. Rochon July 2005
!
! Revision:
!           Y.J. Rochon, ARQI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!
! Purpose:  Interpolation to point in profile. Uses piecewise linear vertical
!           interpolation in log(Pressure).
!
! Arguments:
!
!  Input
!
!       pres_mod        pressure on model levels, assumed to be in ascending order
!       pres_obs        pressure on observation levels
!       nmodlev         number of models levels
!       nobslev         number of observation levels
!       ixtr            Flag indicating if obs outside model vertical range
!                       0 for no.
!       iavgkern        Flag indicating if average kernels are to be applied 
!                       afterwards using the output of this routine.
!                       0 for no. If not 0, then products for all obs elements
!                       are needed instead of only those for valid obs elements.
!
!  Output
!
!       chm_obsoper%zh  interpolation coefficients
!       success         success of interpolation
!       ixtr            Modified ixtr as needed.
!
! Comments:  Current implementation searches for index of nearest model level. This step
!            is redundant since this information is already save in obsSpaceData in OBS_LYR.
!            This step is repeated so that the routines in chem_mod are more independent
!            of the rest of the EnVar code. If it is desired to skip this redundant step,
!            the content of the OBS_LYR column could be passed to chm_obsoperators and
!            subsequentially to this subroutine.
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: nmodlev, nobslev, iavgkern
    integer, intent(inout) :: ixtr(nobslev)
    real(8), intent(in) :: pres_mod(nmodlev), pres_obs(nobslev)
    type(struct_chm_obsoperators), intent(inout) :: chm_obsoper
    logical, intent(inout) :: success(nobslev)
    integer :: iobslev,jmodlev

    do iobslev=1,nobslev

       ! check if obs is above or below model boundaries
       if ( pres_obs(iobslev).lt.pres_mod(1) .or. &
            pres_obs(iobslev).gt.pres_mod(nmodlev) ) then
          success(iobslev)=.false.
          if (pres_obs(iobslev).lt.pres_mod(1)) then
              ixtr(iobslev)=1
          else
              ixtr(iobslev)=2
          end if 
       end if

       if (success(iobslev).or.(ixtr(iobslev).eq.0.and.iavgkern.ne.0)) then

          ! Find model layers directly above and below obs.
          ! After exit of loop, the obs will be between model
          ! levels jmodlev and jmodlev+1.
          do jmodlev=1,nmodlev-1
             if ( pres_obs(iobslev).ge.pres_mod(jmodlev) .and. &
                  pres_obs(iobslev).lt.pres_mod(jmodlev+1) ) then
                exit
             end if
          end do

          ! Set interpolation weights
          chm_obsoper%zh(iobslev,jmodlev+1) = LOG(pres_obs(iobslev)/pres_mod(jmodlev)) &
                                            / LOG(pres_mod(jmodlev+1)/pres_mod(jmodlev))
          chm_obsoper%zh(iobslev,jmodlev) = 1.0D0 - chm_obsoper%zh(iobslev,jmodlev+1)

          ! set range of nonzero elements for model vertical levels
          chm_obsoper%lvl_top(iobslev) = jmodlev
          chm_obsoper%lvl_bot(iobslev) = jmodlev+1

       else
          chm_obsoper%lvl_top(iobslev) = 1
          chm_obsoper%lvl_bot(iobslev) = 1
       end if

    end do

  end subroutine chm_vert_interp_operator

!-----------------------------------------------------------------------------------------

  integer function chm_igetmodlev(rpress, rppobs, topbtm, ntotlev)

!
!  Author: Y. Yang    May 2004
!
!  Revisions:
!             Y.J. Rochon, ARQI/MSC May 2005 - May 2007, Feb 2015
!             - Changes to form and comments
!
!  Purpose: Get the vertical level index for the pressure in rppobs
!           within obs layer and nearest specified obs layer boundary.
!
!  Arguments:
!
!              rpress : pressure value in Pascal
!              rppobs : profile of pressure at obs. location
!              topbtm : indicating whether we are looking for top or bottom
!                       presure
!              ntotlev: total number of levels of rppobs
!
!-----------------------------------------------------------------------------------------
      implicit none
 
      integer, intent(in) :: ntotlev
      real(8), intent(in) :: rpress, rppobs(ntotlev)
      character(len=*), intent(in) :: topbtm
      
      integer     :: ilev1, ilev2
      integer     :: jk
!
!     Find the model levels adjacent to pressure level rpress
!
!     Default values
!
      if (rpress .lt. 0.) then
        if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
             chm_igetmodlev = ntotlev
        endif
        if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
             chm_igetmodlev = 1
        endif
                                                       
      endif
!
      ilev1=0
      ilev2=1
      do jk=1,ntotlev
         if (rpress.gt.rppobs(jk)) then
           ilev1=jk
           ilev2=jk+1
         else
           exit
         endif
      enddo
!
!     Find the model level index
!
!     If we are looking for top level, the index is the level immediately 
!     below. if looking for bottom level, the index is the one immediately 
!     above.
!
      if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
           chm_igetmodlev=ilev1
      else if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
           chm_igetmodlev=ilev2
      endif
!
      if (chm_igetmodlev .lt. 1) chm_igetmodlev=1
      if (chm_igetmodlev .gt. ntotlev) chm_igetmodlev=ntotlev
!     
  end function chm_igetmodlev 
!-----------------------------------------------------------------------------------------

  subroutine chm_genoper(chm_obsoper,rval,rlat,rlon,n_modlvl,nobslev,kmode,varName,success)
!
! Author  : Y. Rochon, April 2015
!           - From pre-EnVar version of Nov 2004.
!
! Revision: 
!
! Purpose:  Set generalized innovation operator for integral or layer avg obs.
!           Relevant only for 3D incremental fields.
!           This version is intended to vertically distribute the obs increments 
!           proportionally to the background state. See commments section for 
!           details.
!
! Arguments:
!
!  Input   
!           n_modlvl          -- # of model vertical levels
!           nobslev           -- # of obs vertical levels
!           chm_obsoper%zh, zhp   -- See routine chm_vertintg_setup
!           varName           -- Variable name
!           kmode             -- Index specifying if content to be applied,
!                                i.e. if kmode >1.
!           rval              -- State profile at obs location.
!           rlat              -- Obs latitude.
!           rlon              -- Obs longitude.
!           success           -- Logical indicating if calc are to be performed.
!
!  Output  
!           chm_obsoper%zh(n_modlvl)  -- a*w: Final innovation model array 
!                                        (other than conversion constants)
!           chm_obsoper%zhp(n_modlvl) -- w (see comments section)
!
! Comments:
!
!     (1) This routine prepares an alternative innovation operator g, called
!     the generalized innovation operator, to take the place of the
!     innovation (TLM) operator h (row of zh). The operator g is
!     specified as:
!
!            g = a*w
!
!     where the modified innovation operator 'w' can be set as:
!
!            w= P[ (h'x)^T ] *  B^{-1}     
!
!     with  h' is the part of h which excludes resolution dependence
!              (only/mostly contains the physics part of h; zhp),
!           x is the state profile rval
!           P is a window cutoff operator (sets small values to zero), and
!           B is the original/initial total "vertical" covariance matrix (in 2D)
!         
!
!     and 'a' is a proportionality constant ensuring that the innovation
!             increment remains unchanged for the 1D case in the absence
!             of other obs., i.e.,
!
!                 a^2 = (h*B*h^T)(w*B*w^T)^{-1},
!
!     Application of the state profile x (rval) is to make the
!     increment profile be more proportional to the state profile.
!
!     The presence of B^{-1} is to negate the weight re-distribution from the later 
!     application of B in grad(Jo).
!
!     While dx is provided to the obs operator, the minimization is done for
!     dx/sigma where sigma is the background error std. dev. in B and so C (correlation matrix)
!     is used instead of B in the minimization. Moreover, the transformation from dx/sigma 
!     to dx is done outside the forward model operators (at the spectral to physical space 
!     transformation step). For this reason, the expression for w should technically be replaced by
! 
!            w= P[ (h'x/sigma^2)^T ] *  C^{-1}             (Option 1 below)
!
!     still with
!
!            a^2 = (h*B*h^T)(w*B*w^T)^{-1}
! 
!     The presence of C^{-1} does/can give difficulty to the iterative variational 
!     minimization. It can result in oscillations in the increment profile depending on
!     where the iterations are stopped. Moreover, if the spectral space C matrix is for 
!     non-seperable vertical and horizontal correlations, there will be oscillations 
!     due to inconstencies between the total inverse vertical correlation C^{-1} in physical space 
!     and the inverse vertical correlation matrix for each spectral wavenumber.
!
!     As alternatives, one can completely omit the role of  C^{-1} from w, i.e.
!
!            w= P[ (h'x/sigma^2)^T ]                        (Option 3)
!
!      or use the following substitute to approximate the role of C^{-1} in approximatily
!      negating the weight re-distribution from later application of C in grad(Jo), i.e.
!
!            w(i)= P[ (h'x/sigma^2)^T ]_i / sum(C(:,i))     (Option 2 - preferred)
!
!     (2) The matrices B and B^{-1} are the total error covariance matrix (in physical space)
!     and its inverse with the related error correlation matrices 'corvert' and 'corverti' 
!     provided from 'bmatrixchem_mod.ftn90'.
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      character(len=*), intent(in) :: varName
      integer, intent(in) :: n_modlvl,nobslev,kmode
      type(struct_chm_obsoperators), intent(inout) :: chm_obsoper
      logical, intent(in) :: success(nobslev)
      real(8), intent(in) :: rlat,rval(n_modlvl),rlon
!
!     Declaration of local variables
!
      real(8), parameter :: pwin=0.01
      integer  :: iobslev
      logical  :: lstart,lrgsig
      real(8)  :: zwbw(1),zhbh(1),za,work(n_modlvl)
      real(8)  :: zmin,rsig(n_modlvl,2)
   
      if (kmode.le.1) return

      lstart=.true. 
      lrgsig=.true. 
      do iobslev=1,nobslev
           
         if (.not.success(iobslev)) cycle   
!          
!        First determine background error std. dev. and determine/estimate h*B*h^T. 
!        Done first to acquire 'rsig' at the same time!
!
         call chm_corvert_mult(varName,chm_obsoper%zh(iobslev,1:n_modlvl),zhbh, &
                  chm_obsoper%lvl_top(iobslev),chm_obsoper%lvl_bot(iobslev),1,n_modlvl,1, &
                  lrgsig,rlat,lstart,3,rsig)

         lstart=.false.         
!
!        Begin preparation of the new innovation operator w (=new zhp)
!
         if (nobslev.eq.1.and.chm_obsoper%lvl_top(iobslev).eq.1.and. &
            chm_obsoper%lvl_bot(iobslev).eq.n_modlvl) then
            
!           Treat as total column obs. Here, zhp would be approx. equal
!           to 1 except for the near-end points of the model vertical domain,
!           the latter due to the discretized domain. Not using zhp avoids this
!           discretization issue from weakly affecting results at the boundaries.
!
            work(1:n_modlvl)=rval(1:n_modlvl)/rsig(1:n_modlvl,1) 
         else 

!           Account for localized obs function (e.g. partial columns, Jacobians. For Jacobians,
!           zhp must also be independent of the model layer thicknesses.)
            work(1:n_modlvl)=chm_obsoper%zhp(iobslev,1:n_modlvl)*rval(1:n_modlvl)/rsig(1:n_modlvl,1) 
         end if

!        Apply cutoff (apply to zhp*rval/rsig instead of the resultant zh)
!        Resultant outside cutoff region should be zhp*rval/rsig/rsig.
 
         zmin=pwin*maxval(abs(work(1:n_modlvl)))
         where (abs(work(1:n_modlvl)).lt.zmin) 
             work(1:n_modlvl)=0.0D0 
         elsewhere        
             work(1:n_modlvl)=work(1:n_modlvl)/rsig(1:n_modlvl,1)
         endwhere
!
!        Application of C^{-1} or substitute (for negating the weight impact of the
!        later application of C in finalizing grad(Jo). Option 2 is favoured.
!  
!        Option 1: Application of C^{-1}
!         call chm_corvert_mult(varName,work(1:n_modlvl),chm_obsoper%zhp(iobslev,1:n_modlvl), &
!                  chm_obsoper%lvl_top(iobslev),chm_obsoper%lvl_bot(iobslev),1,n_modlvl,n_modlvl, &
!                  .false.,rlat,lstart,-1)
!
!        Option 2: Application of 1/sum(C(:,j)) to approximately negate the weight re-distribution from C
!                  in the calc of grad(Jo).

         call chm_corvert_mult(varName,work(1:n_modlvl),chm_obsoper%zhp(iobslev,1:n_modlvl), &
                  chm_obsoper%lvl_top(iobslev),chm_obsoper%lvl_bot(iobslev),1,n_modlvl,n_modlvl, &
                  .false.,rlat,lstart,0)
!
!        Option 3: Just skip over consideration attempt at negating the weight re-distribution from C.
!         chm_obsoper%zhp(iobslev,1:n_modlvl)=work(1:n_modlvl)
!
!        Determine proportionality factor 'a' = (h*B*h^T)(w*B*w^T)^{-1}
!
!        Determine/estimate w*B*w^T 
!
         call chm_corvert_mult(varName,chm_obsoper%zhp(iobslev,1:n_modlvl),zwbw, &
                   chm_obsoper%lvl_top(iobslev),chm_obsoper%lvl_bot(iobslev),1,n_modlvl,1, &
                   lrgsig,rlat,lstart,3,rsig)
!
!        Set proportionality factor 'a'
!
         za=sqrt(zhbh(1)/zwbw(1))
!         if (abs(rlat*180./3.1415-78.).lt.2.0.and.abs(rlon*180./3.1415-185.).lt.2.0) then
!             write(6,*) 'ZA  ',rlat*180.0/3.1415,rlon*180.0/3.1415,za,zhbh(1),zwbw(1)
!             write(6,*) 'rval',rval(1:n_modlvl)
!             write(6,*) 'rval',rsig(1:n_modlvl,1)
!             write(6,*) 'ZH  ',chm_obsoper%zh(iobslev,1:n_modlvl)
!             write(6,*) 'ZHP ',chm_obsoper%zhp(iobslev,1:n_modlvl)*za
!         end if
!
!        Set final innovation operator
!
         chm_obsoper%zh(iobslev,1:n_modlvl)=chm_obsoper%zhp(iobslev,1:n_modlvl)*za
!
      end do
  
  end subroutine chm_genoper
!-----------------------------------------------------------------------------------------

  subroutine chm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                              lrgsig,rlat,lstart,itype,rsig)
!
! Author  : Y. Rochon, April 2015
!
! Revision: 
!
! Purpose: Multiplication with covariance matrix(ces) C=corvert (itype>0) or their 
!          inverse CI=corverti (itype<0).
!
!          Given A=rmat_in (=input)
!
!          itype       Output
!          -----       ------
!            0          D(i,j)=A(i,j)/sum(C(1:n,i))
!            1          A*C
!            2          C*A
!            3          A*C*A^T
!           -1          A*CI
!           -2          CI*A
!           -3          A*CI*A^T
!
! Arguments:
!
!  Input
!
!           varName              -- Variable name
!           rmat_in(ndim1,ndim2) -- Input matrix/vector A (see comments sections)
!           lvl_top(ndim1)       -- Top level of non-zero values in rmat_in
!           lvl_bot(ndim1)       -- Bottom level of non-zero values in rmat_in
!           ndim1,ndim2          -- Matrix dimensions
!                                   ndim1 to be 1 one 1D input vectors
!           ndim3                -- Expected output dimension.
!                                   =ndim1 for itype= +/-3
!                                   =ndim2 otherwise
!           lrgsig               -- Index to indicate if rgsig to be included as part of C or CI below.
!           rlat                 -- Input latitude (radians).
!           itype                -- Type of operator (see above). 
!           lstart               -- Logical indicating if local initiliation if std. dev. required 
!                                   for given obs location. 
!           rsig(ndim2,2)        -- Background error std. dev. at obs locations.
!                                   Must be provided when lstart=.false. and lrgsig=.true.    
!
!  Output:
!
!           rmat_out(ndim1,ndim2) -- Output matrix/vector (see comments sections)
!           rsig(ndim2,2)         -- Background error std. dev. at obs locations 
!                                    Set/provided when lstart.eq.true.   
!
! Comments:
!
! (A) If rmat_in is a 1-D vector, then 
!     
!     for cases +/- 2, one should have set ndim2=1 and ndim1=vector-length.
!     for cases +/- 1,3, one should have set ndim1=1 and ndim2=vector-length.
!
! (B) Revisions required whem LAM and ensembles cases become available.
!
!-----------------------------------------------------------------------------------------
      use bmatrixchem
 
      implicit none
      character(len=*), intent(in) :: varName
      logical, intent(in)    :: lstart,lrgsig
      integer, intent(in)    :: ndim1,ndim2,ndim3,itype
      integer, intent(in)    :: lvl_top(ndim1),lvl_bot(ndim1)
      real(8), intent(in)    :: rmat_in(ndim1,ndim2),rlat
      real(8), intent(out)   :: rmat_out(ndim1,ndim3)
      real(8), intent(inout), optional :: rsig(ndim2,2)
   
      integer :: nsize
      real(8) :: rsig_local(ndim2,2)
      
      rsig_local(:,:)=0.0D0
      rmat_out(:,:)=0.0D0
  
!     Set background error std. dev. if needed.

      if (lstart) then
!
!        Get background error standard deviations
!        Applicability tests within b*chm_getsigma.
!
         call bchm_getsigma(varName,ndim2,rlat,rsig_local(:,1),nsize)   
!         call blamchm_getsigma(varName,ndim2,rlat,rsig_local(:,1),nsize)      
         if (nsize.ne.ndim2) then
             write(6,*) 'NSIZE, NDIM2: ',nsize,ndim2
             call abort3d('CHM_corvert_mult: Inconsistent size')
         end if

!         call benschm_getsigma(varName,ndim2,rlat,rsig_local(:,2),nsize)      
!         if (nsize.eq.ndim2) then
!             write(6,*) 'NSIZE, NDIM2: ',nsize,ndim2
!             call abort3d('CHM_corvert_mult: Inconsistent size')
!         end if

          if (present(rsig)) rsig(:,:)=rsig_local(:,:)
      else     
          if (.not.present(rsig).and.lrgsig) &
              call abort3d('CHM_corvert_mult: Missing rsig')
          rsig_local(:,:)=rsig(:,:)
      end if
      
!     Apply operation related to static background error covariance/correlation matrix.
!     Applicability tests within b*chm_corvert_mult.

      call bchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                             lrgsig,itype,rsig_local(:,1))
!      call blamchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                             lrgsig,itype,rsig_local(:,1))

!     Apply operation related to ensemble-based background error covariance/correlation matrix.
!     Applicability test within benschm_corvert_mult.

!      call benschm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                                lrgsig,itype,rsig_local(:,2))

  end subroutine chm_corvert_mult
!-----------------------------------------------------------------------------------------

end module chem_mod
