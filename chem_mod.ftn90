!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_mod
!
! PURPOSE:
!    Repository of obs space structures, arrays, and routines specific to the 
!    CH chemical constituents family and constituent observations.
!
!    Main content (public routines):
!
!       - Public routines
!         "chm_read_obs_err_stddev,chm_get_obs_err_stddev,chm_dealloc_obs_err_stddev":
!         Routines and strucure for setting of obs error std. dev. used in
!        'observation_erreurs_mod.ftn90'. 
!
!       - Public routine "chm_obsoperators": Applies observation operators. 
!
!       - Public routine "chm_setup": Routines and structure for setting and assignment 
!         of observation layer top and bottom levels (and averaging kernel matrices - tbc). 
!         See 'preproc.ftn90' and 'chm_obsoperators'. 
!
!       - Public routines: "chm_adj_model_bndry,chm_get_stringId,chm_get_ID": Routines for use 
!         in filtering out obs based on model vertical boundaries. See 'filterobs_mod.ftn90'. 
!
! COMMENT:
!
!    This module can be expanded to contain other constituent related info
!    or routines.
!
! Author  : Y.J Rochon - ARQI/AQRD, 2014
!
! Revisions:
!           M. Sitwell, ARQI/AQRD, Feb 2015
!           - Created struct_chm_info and struct_chm_std structures for storing
!             information read from ascii/burp file and removal of earlier structure.
!
!----------------------------------------------------------------------------------
   
  implicit none
  private

! public procedures
! -----------------

  public :: chm_setup,chm_dealloc_obs_err_stddev,chm_read_obs_err_stddev, &
            chm_get_obs_err_stddev
  public :: chm_obsoperators,chm_adj_model_bndry,chm_get_stringID,chm_get_ID

  type :: struct_chm_std
     !
     ! Structure for holding observation std information
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block 
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                            (may be adjusted after input)
     !  std_type               Index of setup approach (used in combination with
     !                            nstd_brp_chm)
     !                         For nstd_brp_chm value 0 or 1, 
     !                         0: std1 or BURP file vales (sigma)
     !                         1: min(std3,max(std2,std1_chm*ZVAL))
     !                                                   or
     !                            max(std2(ISTNID),xstd_std1_chm(ILEV)*sigma)
     !                         2: sqrt(std2**2+(std1*ZVAL)**2))
     !                                                   or
     !                                              not applicable
     !  ibegin                 Position index of start of data for given
     !                         sub-family in the arrays std1,levels,lat
     !  n_lvl                  Number of vertical levels
     !  levels                 Vertical levels (in coordinate of sub-family data)
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !  std1                   See std_type for usage
     !  std2                   See std_type for usage
     !  std3                   See std_type for usage     

     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),std_type(:),n_lat(:)
     integer, allocatable :: brp(:),ibegin(:),n_lvl(:)
     real(8), allocatable :: std1(:),std2(:),std3(:)
     real(8), allocatable :: levels(:),lat(:)

  end type struct_chm_std
  
  type :: struct_chm_info
     !  Information arrays retrieved from obsinfo_chm regarding vertical levels 
     !  or averaging kernels
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                             (may be adjusted after input)
     !  vco                    Vertical coordinate type (1, 2, or 3, see bufr_read_mod)
     !
     !  ibegin                 Position index of start of data for given
     !                         sub-family.
     !  n_lvl                  Number of vertical levels
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !
     !  vlayertop              Layer top 
     !  vlayerbottom           Layer bottom
     !  rak                    Averaging kernel matrices
     
     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),brp(:)
     integer, allocatable :: vco(:),n_lat(:)
     integer, allocatable :: ibegin(:),n_lvl(:)
     real(8), allocatable :: rak(:),vlayertop(:),vlayerbottom(:)
     real(8), allocatable :: lat(:)
  
  end type struct_chm_info

  type :: struct_chm_obsoperators  
  
     !  Structure holding work variables for observation operators
     !     
     !  Variable               Description
     !  --------               -----------
     !  modelIndex             Obs operator index
     !                         0 - vertical interpolator
     !                         1 - layer averaging
     !                         2 - layer integration
     !  layer_identified       .true. if a layer (with identified layer boundaries)
     !                         .false if layer boundaries are not available.
     !  modelvarcolumn         Field or increment column at observation location
     !                         with necessary unit conversions.
     !  vmodpress              Model layer boundaries taken as middle between model level
     !  vlayertop              Layer top (final work values in Pa)
     !  vlayerbottom           Layer bottom (final work values in Pa)
     !  vh                     Second order Lagrangian interp integration weights
     !  zh                     Initial innovation model array (other than conversion constants)
     !  zhp                    Part of innovation operator not related to resolution.
     
     integer :: modelIndex
     logical :: layer_identified
     real(8), allocatable :: vlayertop(:),vlayerbottom(:),vmodpress(:)      
     real(8), allocatable :: modelvarcolumn(:),zh(:,:),zhp(:,:),vh(:,:)

  end type struct_chm_obsoperators

  type(struct_chm_info) :: chm_layers
  type(struct_chm_info) :: chm_avgkern
  type(struct_chm_std)  :: chm_std
  type(struct_chm_obsoperators) :: chm_obsoper

contains

!------------------------------- Setup called from "preproc" ---------------------------

  subroutine chm_setup
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: M. Sitwell, Feb 2015
!            - Removed references to earlier structure
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData.
!
!----------------------------------------------------------------------------------------

  implicit none
  
  write(*,*) 'Begin chm_setup'
     
!------------------------ Top and bottom layer boundaries ------------------------
  
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_read_layers
      
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_layers

!--------------------------- Averaging kernel matrices ------------------------
   
! Read averaging kernel matrices
  
! call chm_avgkern
  
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_avgkern

  write(*,*) 'Completed chm_setup'
  
  end subroutine chm_setup

!-----------------------------------------------------------------------------------------
!--------------------- Routines related to layer top & bottom levels----------------------

  subroutine chm_read_layers
!
! Author   : Y. Rochon, ARQI/AQRD, Dec 2014 
!            - Partially based on oer_read_obs_erreurs_conv.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Feb 2015
!            - Renaming of routine and removal of lines no longer required.
!          
! Purpose: Read and store top and bottom layer boundaries for CH sub-families
!
! Comments:
!
! A) The option of reading from BURP files is TBD. This will change the approach in allocating
!    the arrays size as the sizes will become dependent on the number of related obs for
!    which the BURP files will need to be read.
!----------------------------------------------------------------------------------------

  use bufr

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_layers%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_layers: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_layers%stnids(chm_layers%n_stnid))
  allocate(chm_layers%vco(chm_layers%n_stnid))
  allocate(chm_layers%brp(chm_layers%n_stnid),chm_layers%ibegin(chm_layers%n_stnid))
  allocate(chm_layers%bfr(chm_layers%n_stnid),chm_layers%n_lvl(chm_layers%n_stnid))
  allocate(chm_layers%vlayertop(isize),chm_layers%vlayerbottom(isize))
 
  chm_layers%bfr(:)=0
  chm_layers%vco(:)=0
  chm_layers%brp(:)=0
  chm_layers%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_layers%n_stnid
    chm_layers%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_layers%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%bfr(jelm),chm_layers%vco(jelm),  &
       chm_layers%brp(jelm),chm_layers%n_lvl(jelm)  
    
    if (icount+chm_layers%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_layers%n_lvl(jelm).ge.1) then   
       do jlev=1,chm_layers%n_lvl(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_layers%vlayertop(icount),chm_layers%vlayerbottom(icount)
       end do
    end if

!    if (chm_layers%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_layers


!-----------------------------------------------------------------------------------------

  subroutine chm_get_layer_boundaries(cstnid,ivnm,ivco,nlev,default_top,default_bottom,lfound,layertop,layerbottom)
!
! Author  : M. Sitwell, Y. Rochon, Feb 2015
! Revision: 
!
! Purpose: Return layer boundaries for an observation. Combination of STNID, BUFR element
!          and number of vertical levels to determine association to the observations.
!          Default values for top and bottom layers for total column measurements are to
!          be provided.
!
! Inputs:
!   - cstnid          station id
!   - ivnm            BUFR descriptor element
!   - ivco            type of vertical coordinate (see burp_read_mod.ftn90 for definitions)
!   - nlev            number of levels in the observation
!   - default_top     default value for top layer for total column measurement
!   - default_bottom  default value for bottom layer for total column measurement
!
! Outputs:
!   - lfound          Logical being .true. if layer boundaries found.
!   - layertop        top layer values
!   - layerbottom     bottom layer values
! ---------------------------------------------------------------------------------------

    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in)           :: ivnm,ivco,nlev
    real(8), intent(in)           :: default_top,default_bottom
    real(8), intent(out)          :: layertop(nlev),layerbottom(nlev)
    logical, intent(inout)        :: lfound
    integer                       :: ISTNID,JN,start_index
    logical                       :: iset


    ! Find stnid with same number of vertical levels, and same BUFR element
    ! Note: * in cinfo_stndi_chm stands for a wildcard
          
    ISTNID=0
    lfound=.false.

    DO JN=1,chm_layers%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_layers%stnids(JN) as wildcards
       iset = stnid_equal(chm_layers%stnids(JN),CSTNID)

       ! Check if number of levels, code, and vertical coordinate type are equal.
       ! If number of levels is one and no vertical coordinate provided in the obs file (i.e. IVCO=4;
       ! as for a total column measurement), then check of vertical coordinate type is disregarded.
       IF (iset) THEN
          IF ( ivnm.EQ.chm_layers%bfr(JN) .AND. NLEV.EQ.chm_layers%n_lvl(JN) .AND. &
              (IVCO.EQ.chm_layers%vco(JN).OR.IVCO.EQ.4) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

    IF ( ISTNID.EQ.0 .AND. chm_checkfor_integlayer(ivnm) ) THEN
       ! If integrated layer information not found
       if (nlev.eq.1) then
          lfound=.true.
          layertop(1) = default_top
          layerbottom(1) = default_bottom
       else
          CALL ABORT3D ('chm_get_layer_boundaries: Top and bottom of layers not found for STNID= ', CSTNID)
       end if
    ELSE
       lfound=.true.
       start_index = chm_layers%ibegin(ISTNID)
       layertop(:) = chm_layers%vlayertop(start_index:start_index+nlev-1)
       layerbottom(:) = chm_layers%vlayerbottom(start_index:start_index+nlev-1)  
    END IF

  end subroutine chm_get_layer_boundaries


!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_layers
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space.
!
! ---------------------------------------------------------------------------------------
  
!
! Deallocate temporary space used for the CH family
!
  if (chm_layers%n_stnid.gt.0) then
      deallocate(chm_layers%stnids)
      deallocate(chm_layers%n_lvl,chm_layers%ibegin)
      deallocate(chm_layers%bfr,chm_layers%brp,chm_layers%vco)
      deallocate(chm_layers%vlayertop,chm_layers%vlayerbottom)
  end if
 
  end subroutine chm_dealloc_layers

!-----------------------------------------------------------------------------------------
!-------------------- Routines related averaging kernel matrices -------------------------

  subroutine chm_read_avgkern
!
! Author   : Y. Rochon, ARQI/AQRD, Feb 2015 
!            - Initial framework only. 
!            - Actual reading code for averaging kernels not included as yet.
!
! Revisions: 
!          
! Purpose: Read and store averaging kernel matricesfor CH sub-families
!
!----------------------------------------------------------------------------------------

  use bufr

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_avgkern%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '--------------------------------------------------'
    WRITE(*,*)   'chm_read_avgkern: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '--------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_avgkern: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_avgkern%stnids(chm_avgkern%n_stnid))
  allocate(chm_avgkern%brp(chm_avgkern%n_stnid),chm_avgkern%ibegin(chm_avgkern%n_stnid))
  allocate(chm_avgkern%bfr(chm_avgkern%n_stnid),chm_avgkern%n_lvl(chm_avgkern%n_stnid))
!!  allocate(chm_avgkern%rak(isize)
 
  chm_avgkern%bfr(:)=0
  chm_avgkern%brp(:)=0
  chm_avgkern%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_avgkern%n_stnid
    chm_avgkern%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_avgkern%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%bfr(jelm),  &
       chm_avgkern%brp(jelm),chm_avgkern%n_lvl(jelm)  
    
    if (icount+chm_avgkern%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_avgkern%n_lvl(jelm).gt.1) then   
       do jlev=1,chm_avgkern%n_lvl(jelm)
          icount=icount+1
          
          ! Read averaging kernel matrix
          
!!          read(nulstat,*,iostat=ios,err=10,end=10)                 &
!!                 chm_avgkern%rak......
       end do
    end if

!    if (chm_avgkern%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_avgkern: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_avgkern

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_avgkern
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space.
!
!---------------------------------------------------------------------------------------
  
!
! Deallocate temporary space used for the CH family
!
  if (chm_avgkern%n_stnid.gt.0) then
      deallocate(chm_avgkern%stnids)
      deallocate(chm_avgkern%ibegin)
      deallocate(chm_avgkern%bfr,chm_avgkern%brp,chm_avgkern%n_lat)
      deallocate(chm_avgkern%rak,chm_avgkern%lat)
  end if
 
 
  end subroutine chm_dealloc_avgkern

!-----------------------------------------------------------------------------------------
!----------- Routines relevant to error std. dev. (observation_erreurs.ftn90) ------------

  subroutine chm_read_obs_err_stddev
!
!  s/r chm_read_obs_err_stddev - READ OBSERVATION ERROR OF CONSTITUENT DATA 
!
!  Author   : Y. Rochon, Nov 2014 
!             (initial part follows the format of oer_read_obs_erreurs_conv)
!  Revisions: 
!             M. Sitwell, Fdeb 2015
!             - Content formed as a separate routine called in oer_read_obs_erreurs_chm.
!          
! Purpose: Read and store observation error std. dev. as needed for CH family obs.
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_std%n_stnid=0
!
! CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists) then
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! chm_read_obs_err_stddev: obsinfo_chm not available.   '
    WRITE(*,*) 'WARNING! Default CH family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
    return
  ENDIF
!
! Read observation error std dev. from file obsinfo_chm for constituent data
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_obs_err_stddev: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

! Read error standard deviations for constituents if available.
! (CH family; ozone and others)
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:12))).ne.'SECTION I:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space

  read(nulstat,*,iostat=ios,err=10,end=10) chm_std%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_std%stnids(chm_std%n_stnid))
  allocate(chm_std%std_type(chm_std%n_stnid),chm_std%n_lat(chm_std%n_stnid))
  allocate(chm_std%brp(chm_std%n_stnid),chm_std%ibegin(chm_std%n_stnid))
  allocate(chm_std%bfr(chm_std%n_stnid),chm_std%n_lvl(chm_std%n_stnid))
  allocate(chm_std%std1(isize),chm_std%std2(chm_std%n_stnid),chm_std%std3(chm_std%n_stnid))
  allocate(chm_std%levels(isize),chm_std%lat(isize))
 
  chm_std%bfr(:)=0
  chm_std%brp(:)=0
  chm_std%std_type(:)=0
  chm_std%n_lvl(:)=1
  chm_std%n_lat(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_std%n_stnid
    chm_std%ibegin(jelm)=icount+1

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! Read STNID (* as wildcard)    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_std%stnids(jelm) 

!   Read (1) BUFR element,
!        (2) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (3) Index specifying OER setup method,
!        (4) Number of vertical levels
!        (5) Number of latitudes
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_std%bfr(jelm),chm_std%brp(jelm),  &
       chm_std%std_type(jelm), chm_std%n_lvl(jelm), chm_std%n_lat(jelm),  &
       chm_std%std2(jelm), chm_std%std3(jelm)

    if (chm_std%n_lvl(jelm).lt.1) chm_std%n_lvl(jelm)=1
    if (chm_std%n_lat(jelm).lt.1) chm_std%n_lat(jelm)=1
    
    if (icount+chm_std%n_lvl(jelm)*chm_std%n_lat(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_obs_err_stddev: PROBLEM READING OBSERR STD DEV.')    
    end if

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Read one value only (independent of level and latitude)
       
       icount=icount+1
       read(nulstat,*,iostat=ios,err=10,end=10) chm_std%std1(icount)

    else if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on latitude only
       
!      Read reference latitudes (must be in order of increasing size)
       
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
!      Read OER-related values
  
       read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%std1(icount+1:icount+chm_std%n_lat(jelm))

       icount=icount+chm_std%n_lat(jelm)

    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Value dependent on vertical level only
      
       do jlev=1,chm_std%n_lvl(jelm)
          icount=icount+1
          
!         Read vertical level and OER-related value.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%levels(icount),chm_std%std1(icount)

       end do
   
    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on vertical level and latitude 
       
!      Read reference latitudes (must be in order of increasing size)
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
!       write(*, '(10X,20F9.3)') chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
       do jlev=1,chm_std%n_lvl(jelm)
          
!         Read vertical level and OER-related lat-dependent values.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                   &
                 chm_std%levels(icount+jlev),                           &
                 chm_std%std1(icount+(jlev-1)*chm_std%n_lat(jelm)+1:icount+jlev*chm_std%n_lat(jelm))

       end do
       icount=icount+chm_std%n_lat(jelm)*chm_std%n_lvl(jelm)
    end if
  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_obs_err_stddev: PROBLEM READING OBSERR STD DEV.')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_obs_err_stddev

!-----------------------------------------------------------------------------------------

  subroutine chm_obs_err_stddev_index(CSTNID,NLEV,ITYP,ZLAT,ISTNID,JINT)
!
!  s/r chm_set_obs_err_stddev_index - Returns the station ID and latitude 
!                                     indices corresponding to a measurement
!
!  Author   : M. Sitwell Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!             
!  Revisions: 
!
!----------------------------------------------------------------------------------------

    use bufr
    
    implicit none

    character(len=*), intent(in) :: CSTNID
    integer, intent(in)           :: NLEV,ITYP
    real(8), intent(in)           :: ZLAT
    integer, intent(out)          :: ISTNID,JINT
    integer                       :: JN,ilen1,ilen2,ji,ibegin
    logical                       :: iset


 ! Important: Combination of STNID, BUFR element and number of vertical levels
 !            to determine association to the observations.

 !            Find stnid with same number of vertical levels and same BUFR element.
 !            Note: * in cstd_stndi_chm stands for a wildcard
                
    ISTNID=0
    DO JN=1,chm_std%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_std%stnids(JN) as wildcards
       iset = stnid_equal(chm_std%stnids(JN),CSTNID)
                   
       IF (iset) THEN
          IF (NLEV .EQ. chm_std%n_lvl(JN) .AND. &
               ITYP .EQ. chm_std%bfr(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF

    END DO

    IF (ISTNID.EQ.0) THEN
       WRITE(*,'(1X,"Error std. dev. for STNID= ",A10," not found. Set to 5%.")') &
            CSTNID
    ELSE
       ! IF (chm_std%brp(ISTNID).NE.0) THEN
       
       !   Read initial error standard deviations from obs BURP file.
       !   Dimension must be equivalent to NLEV
       ! ...
       
       ! sigma(:) = ...
       
       ! END IF

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN

          ! Find latitude index for interpolation.
          ! Assuming increasing latitudes in chm_std%lat

          ibegin=chm_std%ibegin(ISTNID)-1
          IF (ZLAT .GE. chm_std%lat(ibegin+chm_std%n_lat(ISTNID))) THEN
             JINT=chm_std%n_lat(ISTNID)+1
          ELSE
             DO JINT=1,chm_std%n_lat(ISTNID)
                IF (ZLAT .LE. chm_std%lat(ibegin+JINT) ) exit
             END DO
          END IF
                                           
       END IF
    END IF

  end subroutine chm_obs_err_stddev_index

!----------------------------------------------------------------------------------------

  function chm_get_obs_err_stddev(CSTNID,NLEV,ITYP,ZLAT,ZVAL,ZLEV,IFIRST) result(obs_err_stddev) 
!
!  s/r chm_set_obs_err_stddev - Returns the observational error std for a CH family measurement
!
!  Author   : M. Sitwell, ARQI/AQRD, Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!
!  Revisions: 
!
!----------------------------------------------------------------------------------------

    implicit none
    
    character(len=*), intent(in) :: CSTNID
    real(8), intent(in) :: ZVAL,ZLEV,ZLAT
    integer, intent(in) :: NLEV,ITYP
    logical, intent(in)  :: IFIRST

    real(8)  :: obs_err_stddev 
       
    real(8)  :: wgt,zwb
    integer  :: ibegin,ILEV,JN
    integer, save  :: ISTNID,JINT


    ! If this call is for the first level for this measurement, get
    ! the station ID and latitude indices corresponding to this measurement
    if (ifirst) call chm_obs_err_stddev_index(CSTNID,NLEV,ITYP,ZLAT,ISTNID,JINT)


    ! Identify level if needed
                   
    IF (ISTNID .EQ. 0) THEN
       
       ! Set error standard deviations as 5% default value.       
       obs_err_stddev = 0.05D0*ZVAL
       
    ELSE
             
       IF (chm_std%n_lvl(ISTNID) .GT. 1) THEN
                  
          ! Find nearest vertical level (no interpolation)
                 
          zwb=1.E10
          ibegin=chm_std%ibegin(ISTNID)-1
          DO JN=1,chm_std%n_lvl(ISTNID)
             IF (zwb .GT. abs(ZLEV-chm_std%levels(ibegin+JN)) ) THEN
                ILEV=JN
                zwb=abs(ZLEV-chm_std%levels(ibegin+JN))
             END IF
          END DO
          ILEV=ibegin+(ILEV-1)*chm_std%n_lat(ISTNID)+1
       ELSE
          ILEV=chm_std%ibegin(ISTNID)     
       END IF

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN
                
          ! Apply interpolation

          ILEV=ILEV+JINT-1
          ibegin=chm_std%ibegin(ISTNID)-1
          IF (JINT.EQ.1.OR.JINT.GT.chm_std%n_lat(ISTNID)) THEN
             wgt=chm_std%std1(ILEV)
          ELSE
             wgt=(chm_std%std1(ILEV-1)*(chm_std%lat(ibegin+JINT)-ZLAT)+ &
                  chm_std%std1(ILEV)*(ZLAT-chm_std%lat(ibegin+JINT-1)))/ &
                  (chm_std%lat(ibegin+JINT)-chm_std%lat(ibegin+JINT-1))
          END IF
       ELSE
          wgt=chm_std%std1(ILEV)                
       END IF
                                         
       IF (chm_std%brp(ISTNID).EQ.0) THEN
               
          ! Set error standard deviations from scratch using content of
          ! previously read content of the "obsinfo_chm" file.
                
          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
             obs_err_stddev = wgt
          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
             obs_err_stddev = min(chm_std%std3(ISTNID),max(chm_std%std2(ISTNID),wgt*ZVAL))
          ELSE IF (chm_std%std_type(ISTNID) .EQ. 2) THEN
             obs_err_stddev = sqrt(chm_std%std2(ISTNID)**2+(wgt*ZVAL)**2)
          ELSE 
!             IF (INDEX_BODY.EQ.IDATA)  &
!                  WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
!                  chm_std%std_type(ISTNID) , CSTNID
             WRITE(*,'(1X,"EOR setup type ",I3," is not recognized.")')     &
                  chm_std%std_type(ISTNID)
          END IF

       ELSE
          
!                  Adjust error standard deviations read from BURP file if requested.
!                     
!          IF (chm_std%std_type(ISTNID).EQ. 0) THEN
!             obs_err_stddev = sigma(INDEX_BODY-IDATA+1)
!          ELSE IF (chm_std%std_type(ISTNID).EQ. 1) THEN
!             obs_err_stddev = max(chm_std%std2(ISTNID),wgt*sigma(INDEX_BODY-IDATA+1))
!          ELSE 
!             IF (INDEX_BODY.EQ.IDATA)  &
!                  WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
!                  chm_std%std_type(ISTNID) , CSTNID
!          END IF
!       END IF
              
       END IF
    END IF

  end function chm_get_obs_err_stddev

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_obs_err_stddev
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for observation errors for the CH family
!
!---------------------------------------------------------------------------------------
  
  if (chm_std%n_stnid.gt.0) then
      deallocate(chm_std%stnids)
      deallocate(chm_std%n_lvl,chm_std%std_type,chm_std%ibegin)
      deallocate(chm_std%bfr,chm_std%brp,chm_std%n_lat)
      deallocate(chm_std%std1,chm_std%std2,chm_std%std3)
      deallocate(chm_std%levels,chm_std%lat)
  end if
  
  end subroutine chm_dealloc_obs_err_stddev

!-----------------------------------------------------------------------------------------
!------------------- Miscellaneous utilities functions and routines ----------------------

  function stnid_equal(id1,id2) result(same)
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!           M. Sitwell, Feb 2015
!           - Code set as a function.
!
! Purpose: Compares STNID values allowing for * and blanks in id1 as wildcards
!
!-----------------------------------------------------------------------------------------    

    implicit none

    logical :: same
    CHARACTER(len=*), intent(in) :: id1,id2
    integer :: ilen1,ilen2,ji

    same=.false.
    ilen1=len_trim(id1)
    ilen2=len_trim(id2)            
    IF (ilen1.le.ilen2) THEN          
       same = .TRUE.
       DO ji=1,ilen1
          IF ( id1(ji:ji).ne.'*' .AND. id2(ji:ji).ne.id1(ji:ji) ) THEN
             same = .FALSE.
             exit
          END IF
       END DO
    END IF
    
  end function stnid_equal
 
           
!-------------------------------------------------------------------------------------------

  subroutine chm_adj_model_bndry(zModAlt,zStnAlt,ztop,zbot,ptop,pbot)
!
! Author  : Y. Rochon  Feb 2015
! Revision: 
!
! Purpose: Set allowed top and bottom boundaries based on model 
!          for vertical range.
!
!          Called from filt_topoChm in flterobs_mod.ftn90.
!
!-----------------------------------------------------------------------------------------    

  implicit none

  real(8), intent(in)    :: zModAlt,zStnAlt
  real(8), intent(inout) :: ztop,zbot
  real(8), intent(inout) :: ptop,pbot
  
  real(8), parameter :: zinc=400.0   ! 400 m allowance beyond input (same as weather variables)
  real(8), parameter :: pinc=5000.0  ! 50 hPa allowance at sfc beyond input.
  
  ! Set geopotential height boundaries.
      
  if (zStnAlt .gt. zModAlt) then
      zbot = zStnAlt - zinc
  else
      zbot = zModAlt - zinc
  endif
  ztop=ztop + zinc
  
  ! Set pressure boundaries.
      
  ptop = ptop*(1.0-pinc/pbot)
  pbot = pbot + pinc
    
  end subroutine chm_adj_model_bndry
            
!-------------------------------------------------------------------------------------------
  subroutine chm_get_stringId(cstringin,nobslev,CList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from a list of accumulating character 
!            strings (e.g. stnids).
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!
!   Input:
!
!       Nmax            Max allowed dimension.
!       NListSize       Input number of identified IDs (must be >=0 and <=Nmax)
!       CList           Input list of accumulated character strings
!                       for uni and multi-level data.
!       cstringin       Input character string
!       nobslev         Number of elements in profile associated to cstringin.
!
!   Output:
!
!       NListSize       Updated number of identified IDs
!       CList           Updated list of accumulated character strings
!       elemId          Index of cstringin within CList_chm
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,nobslev
    integer, intent(inout) :: NListSize
    integer, intent(out)   :: elemId
    character(len=*), intent(in)     :: cstringin
    character(len=*),  intent(inout) :: CList(Nmax)
  
    integer :: i
    character(len=120) :: cstring
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_stringId: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       if (nobslev.eq.1) then 
          cstring=trim(cstringin)//'U'
          do i=1,NListSize
             if (cstring.eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       else 
          cstring=trim(cstringin)       
          do i=1,NListSize
             if (cstring.eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       end if
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        if (nobslev.eq.1) then
           CList(NListSize)=trim(cstringin)//'U'
        else
           CList(NListSize)=trim(cstringin)
        end if
    end if
    
  end subroutine chm_get_stringId

!-------------------------------------------------------------------------------------------
  subroutine chm_get_Id(id,IdList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from list of accumulating integer IDs.
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!
!   Input:
!
!       Nmax         Max allowed dimension.
!       NListSize    Input number of IDs (must be >=0 and <=Nmax)
!       IdList       Input list of accumulated IDs.
!       id           Input id for individual obs
!
!   Output:
!
!       NListSize    Updated number of IDs
!       IdList       Updated list of accumulated IDs.
!       elemId       Index of id within List
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,id
    integer, intent(inout) :: NListSize,IdList(Nmax)
    integer, intent(out)   :: elemId
  
    integer :: i
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_Id: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       do i=1,NListSize
          if (id.eq.IdList(i)) then
              elemId=i
              exit
          end if
       end do
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        IdList(NListSize)=id
    end if
    
  end subroutine chm_get_Id

!-------------------------------------------------------------------------------------------
!--------------------------- Routines for observation operators ----------------------------

  subroutine chm_obsoperators(n_modlvl,rvalinc,rval,rtt,pressmodlvl,rgz,kmode,varName, &
                ivnm,cstnid,idate,ihhmm,ivco,nobslev,icount,iobslev, &
                robslev,rlat,rlon,iconstituent_id,success,rmhx)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           Ping Du, CDMA,Jan 2015
!           - Adapted for the EnVar
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!
! Purpose: Apply obs operator for indicated obs data. 
!
!          Usable as
!
!                 - general (non-linear) simulation operator (kmode=0)
!                 - tangent linear operator for error std. dev. conversion (kmode=1)
!                 - tangent linear operator (kmode=2)
!                 - Linear adjoint operator (kmode=3)
!
! Further changes required for generalization 
!
! 0) Use more descriptive variables for most I/O arguments.
! 1) Add point and layer average operators.
! 2) Add GENOPER option
! 3) Add use of avg kernels
! 4) Add consideration of other kmode cases.
!
! Arguments:
!
!   Input (to be completed)
!
!     ivnm      BUFR descriptor element for obs units.
!     rvalinc   Increment, trial field, or sigma column when kmode<3.
!               Expected to be equal to rval when kmode=0
!     rval      Trial field column 
!     rtt       Temperature array (Kelvin)
!     rpp       Pressure array (Pascal; kg/(m s^2))
!     rgz       Geopotential altitudes (for conversion of obs altitudes to pressure when needed)
!     kmode     0 for non-linear model in assimilation
!               1 for tangent linear model applied for error std.dev. conversion
!               2 for tangent linear model
!               3 for adjoint model 
!   
!   Output (to be completed)
!
!     rmhx      H(x) element value when kmode=0.
!               Hsigma Converted error std. dev. estimate  when kmode=1.
!               Hx increment element value when kmode=2.
!               Not relevant when kmode=3. 
!     rvalinc   Adjoint product when kmode=3. Not changed otherwise.
!
!     rval      Scaled or transformed analysis field on increment/analysis grid
!               (only when kmode=2; used as work array only)
!
! Comments:
!
!     A. Does not account for potential future applications of obs 
!        vertical correlation matrices that would be applied when iobslev=nobslev.
!        
!-------------------------------------------------------------------------------------------
  implicit none

! Declarations

! I/O arguments: obs space variables
    
  character(len=*), intent(in) :: varName
  character(len=*), intent(in) :: cstnid
  integer, intent(in) :: ivnm, ivco, kmode 
  integer, intent(in) :: iobslev, nobslev
  integer, intent(in) :: idate,ihhmm
  integer, intent(in) :: iconstituent_id,icount
  real(8), intent(in) :: robslev,rlat,rlon
  logical, intent(out) :: success

! I/O arguments: model space profile data and others
    
  integer, intent(in) :: n_modlvl
  real(8), intent(in) :: pressmodlvl(n_modlvl)
  real(8), intent(in) :: rtt(n_modlvl),rgz(n_modlvl)
  real(8), intent(inout) :: rval(n_modlvl),rvalinc(n_modlvl),rmhx

! Local variables
  
  real(8) :: vlayertop,vlayerbot,vpressure
  
! Initialization: steps to be applied once per profile

  if (icount.eq.1) then

!    Set work array to hold increment/trial profiles with needed unit (kmode.ne.3) or
!    output for adjoint contribution (kmode=3)

     if (allocated(chm_obsoper%modelvarcolumn)) deallocate(chm_obsoper%modelvarcolumn)
     allocate(chm_obsoper%modelvarcolumn(n_modlvl))
     chm_obsoper%modelvarcolumn(:)=0.0

!    Apply unit conversion (apply later - near end of chm_*_operator routines - when kmode=3)
     
     if (kmode.eq.3) then
         rvalinc(:)=0.0
     else
        call chm_convert(n_modlvl,rvalinc,rval,rtt,pressmodlvl,ivnm,kmode)
     end if
       
!    Determine if layer boundaries are assigned to this data source.
!    If so, obtain them for use in this routine. 
!    Provides chm_obsoper%layer_identified,
!             chm_obsoper%vlayertop(nobslev), 
!             chm_obsoper%vlayerbottom(nobslev) 
!
 
     if (allocated(chm_obsoper%vlayertop))   &
         deallocate(chm_obsoper%vlayertop,chm_obsoper%vlayerbottom)
     allocate(chm_obsoper%vlayertop(nobslev))
     allocate(chm_obsoper%vlayerbottom(nobslev))

     call chm_get_layer_boundaries(cstnid,ivnm,ivco,nobslev,pressmodlvl(1), &
          pressmodlvl(n_modlvl),chm_obsoper%layer_identified,chm_obsoper%vlayertop, &
          chm_obsoper%vlayerbottom)
!     chm_obsoper%layer_identified=.false.
!     if (nobslev.eq.1) then
!        chm_obsoper%layer_identified=.true.
!        chm_obsoper%vlayertop(1)=pressmodlvl(1)
!        chm_obsoper%vlayerbottom(1)=pressmodlvl(n_modlvl)
!     else  
!       success=.false.
!       return
!     end if
            
!    Identify observation operator based on observation units and presence or
!    not of layer boundaries

     if (chm_checkfor_integlayer(ivnm)) then
        if (.not.chm_obsoper%layer_identified) then
           write(*,*)   '----------------------------------------------------------'
           write(*,*)   'STNID, BUFR_index, nobslev: ',cstnid,' ',ivnm,nobslev
           call abort3d('chm_obsoperators: Required layer boundaries not available!')
        else
           ! Vertical integration operator
           chm_obsoper%modelIndex=3
        end if
     else if (chm_obsoper%layer_identified) then
        ! Layer averaging operator
        chm_obsoper%modelIndex=2
      else
        ! Vertical interpolation operator
        chm_obsoper%modelIndex=1
     end if
     
  end if

! Convert observation vertical coordinate value(s) to pressure if needed 
! and provide values to this routine.

!   if (ivco.ne.2) then 
!     call chm_convert2pressure(ivco,robslev,chm_obsoper%layer_identified,chm_obsoper%vlayertop(iobslev), &
!                            chm_obsoper&vlayerbottom(iobslev),vpressure, &
!                            vlayertop,vlayerbot...)  ! see 3dvar_chem routine ch_vobs_to_p.
!
!   else
       if (chm_obsoper%modelIndex.eq.2.or.chm_obsoper%modelIndex.eq.3) then
          vlayertop=chm_obsoper%vlayertop(iobslev)
          vlayerbot=chm_obsoper%vlayerbottom(iobslev)
       else
          vpressure=robslev 
       end if
!   end if

! Apply appropriate core observation operator
   
!  select case(chm_obsoper%modelIndex)
!
!     case(1)

!        Vertical interpolation operator

!         call chm_vert_interp_operator  ! see 3dvar_chem routine ch_vprof

!     case(2)

!        Layer averaging operator

!         call chm_layer_avg_operator  ! see 3dvar_chem routine ch_vavg

!     case(3)

!        Layer integration operator

         call chm_layer_integ_operator(n_modlvl,rvalinc,rval,rtt,pressmodlvl, &
                kmode,ivnm,icount,nobslev,iobslev,vlayertop,vlayerbot, &
                iconstituent_id,success,rmhx)

!  end select

  end subroutine chm_obsoperators

!-------------------------------------------------------------------------------------------

  logical function chm_checkfor_integlayer(ivnm)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose: Idenitfy if of obs is a vertically integrated consitutent measurement,
!
! ---------------------------------------------------------------------------------------
  
  implicit none
  integer, intent(in) :: ivnm
 
  if (ivnm.eq.15198.or.ivnm.eq.15001.or.ivnm.eq.15005.or.ivnm.eq.15045.or. &
      ivnm.eq.15020.or.ivnm.eq.15021.or.ivnm.eq.15200.or. &
      ivnm.eq.15009.or.ivnm.eq.15012) then
      
      chm_checkfor_integlayer=.true.     
  else
      chm_checkfor_integlayer=.false.
  end if
  
  end function chm_checkfor_integlayer
   
!-------------------------------------------------------------------------------------------

  subroutine chm_convert(ntrlev,rvalinc,rval,rtt,rpp,ivnm,kmode)
!
! Author  : Y. Rochon and Y. Yang, June 2005 to June 2011
!           - Pre-EnVar version
! Revision: 
!           Ping Du, CDMA,Jan 2015
!           - Adapted for the EnVar
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!
! Purpose: Set unit conversion factor and model variable transformations 
!          for consistency of Hx units with obs units.  
! 
! Further changes required for generalization 
!
! 1) Need to allow input of PTRMOLWT molecular mass according to constituent.
! 2) Generalize for use in both non-linear and linear models.
! 3) Ultimately have new version that is called outside the minimization section.
! 4) Adapt to model variable units other than vmr.
!
! Arguments:
!
!   Input
!
!     ivnm      BUFR descriptor element for obs units.
!     ntrlev    Dimension of rvalinc,rval,rtt,rpp
!     rvalinc   Increment field or trial field. 
!     rval      Trial field value. 
!     rtt       Temperature array (Kelvin)
!     rpp       Pressure array (Pascal; kg/(m s^2))
!     kmode     0 for non-linear model in assimilation
!               1 for tangent linear model applied for error std.dev. conversion
!               2 for tangent linear model
!               3 for adjoint model 
!   
!     PTRMOLWT: Molecular mass of constituent (g/mol).  - Use 'iconstituent_id' (see above and BUFR_NECHM_* in bufr_mod.ftn90) to identify weight 
!
!   Output
!
!     chm_obsoper%modelvarcolumn:  Scaled or transformed increment or trial field profile.
!
!     rval      Scaled or transformed analysis field on increment/analysis grid
!               (only when kmode=2)
!
!
! Comments:
!
!     A. Standard model/analysis species field provided as volumetric mixing 
!        ratio (vmr). Conversion to vmr is applied when this is not the case. 
!        As this is hardcoded, any changes in analysis variable must
!        be reflected by correspondingly modifying this module.
!
!     B. Unit conversion factor is calculated in chm_convert
!        from the following factors:
!          (1) physical constants
!          (2) parameters related to a particular species such as molecular
!              mass previously read from BURP obs file and stored in obsSpaceData
!          (3) variables such as T and P from background field at each
!              iteration
!
!     Coefficients related to unit conversion
!
!        conv=1.E5                 ! m to 1e-5m (=1DU)
!        rho_stp=1.293             ! air density at STP (1.293 kg/m^3)
!        RG=9.807                  ! Acceleration due to gravity (m/s^2)
!        MPC_AVOGADRO_R8           ! Avogadro's number. 6.023E23 molecules/mole
!        PC_MOLAR_MASS_DRY_AIR_R8  ! Dry air molecular mass. 28.9644 g/mole
!        MPC_RGAS_IDEAL_R8         ! Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
!      C. List should be revised following changes to the 'tableburp' file.
!
! ---------------------------------------------------------------------------------------

  use earthconstants_mod
  use MathPhysConstants_mod
  
  implicit none
  integer, intent(in) :: ntrlev,kmode,ivnm
  real(8), intent(in) :: rtt(ntrlev),rpp(ntrlev),rvalinc(ntrlev)
  real(8), intent(inout)  :: rval(ntrlev)

! Declaration of local variables
  real(8)     :: conv, zcoef
  real(8), parameter :: rho_stp=1.293  !kg/m^3
!  PTRMOLWT =      !Molecular mass of constituent (g/mol) 

! Identify unit conversion factor and variable conversion
! assuming model variable is in vmr.

  zcoef=1.0
  select case (ivnm)
     case(15198,15001,15005,15045) 
!
!        For conversion of vmr*dP integral to DU
!
         conv=1.E5              ! m to 1e-5m (=1DU)
         zcoef = zcoef/RG/rho_stp*conv
         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
     case(15009,15012)
!
!        For conversion of vmr*dP integral to molecules/m^2
!
         conv=1.E3         ! 1.E3 g/kg
!                          ! required for conversion of PC_MOLAR_MASS_DRY_AIR_R8 from g/mol
!                          ! to kg/mol
         zcoef = zcoef*MPC_AVOGADRO_R8*conv/MPC_MOLAR_MASS_DRY_AIR_R8/RG
         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
     case(15020,15021,15200) 
!
!        For conversion of vmr*dP integral to kg/m^2
!
!         zcoef = zcoef*PTRMOLWT/MPC_MOLAR_MASS_DRY_AIR_R8/RG
!         chm_obsoper%modelvarcolumn(:)=rvalinc(:)*zcoef
!
     case(15023,15027,15194,15195,15223) 
!
!        For conversion from vmr to kg/m^3
!     
!        zcoef = zcoef*PTRMOLWT/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
!         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)/rtt(:)*zcoef
!         if (kmode.eq.2) rval(:)=rval(:)*rpp(:)*zcoef
!
     case(15199,15003,15010) 
!     
!        For conversion from vmr to partial pressure (PA)
!
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)*zcoef
         if (kmode.eq.2) rval(:)=rval(:)*rpp(:)*zcoef
!
     case(15230,15022) 
!
!        For conversion from vmr to molecules/m^3
!        RDCJ: Dry air constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
         zcoef = zcoef*MPC_AVOGADRO_R8/MPC_RGAS_IDEAL_R8
!
!        Apply temperature and pressure at observation level.
!
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*rpp(:)/rtt(:)*zcoef
         if (kmode.eq.2) rval(:)=rval(:)*rpp(:)/rtt(:)*zcoef
!
     case(15026,15008,15197,15208) 
!
!        Observation in molecules/molecules by volume (vmr).
!        No conversion needed.
!     
         zcoef = zcoef*1.0D0
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)*zcoef
!
     case(15024,15196,12001,15055,15062)
!
!        Do nothing
         chm_obsoper%modelvarcolumn(:) = rvalinc(:)
!
     case(15192,15011) 
!
!        Code to be revised when actually applied for the first time
!        according to model field units.
!
         write(*,*) 'CHM_CONVERT: Obs conversion not yet defined.',ivnm
         call abort3d('CHM_CONVERT')
!
     case default 
!
         write(*,*) 'CHM_CONVERT: Unknown obs units ',ivnm
         call abort3d('CHM_CONVERT')
         
  end select

  end subroutine chm_convert

!---------------------------------------------------------------------------------------

  subroutine chm_layer_integ_operator(n_modlvl,rvalinc,rval,rtt,pressmodlvl, &
                kmode,ivnm,icount,nobslev,iobslev,vlayertop,vlayerbot, &
                iconstituent_id,success,rmhx)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015 (not completed - remains to be generalized)
!
! Revision: 
!           Ping Du, Mar 2015
!           - Finalization of Ht*grad contribution (case(3))
!
! Purpose:  Perform layer integration and calculations according kmode.
!
! Arguments:
!
!  Input (to be completed)  
!           iobslev           -- Index level in obs profile
!
!  Output (to be completed)
!  
!-----------------------------------------------------------------------------------------

  implicit none

  integer, intent(in) :: n_modlvl,icount,nobslev,kmode,iobslev,ivnm
  integer, intent(in) :: iconstituent_id
  real(8), intent(in) :: rtt(n_modlvl),pressmodlvl(n_modlvl)
  real(8), intent(inout) :: rval(n_modlvl),rvalinc(n_modlvl),rmhx
  real(8), intent(inout) :: vlayerbot,vlayertop
  logical, intent(inout) :: success

  integer :: ij
  real(8) :: zwork(n_modlvl)

! Conduct initial setup for vertical integration components

  if (icount.eq.1) call chm_vertintg_setup(pressmodlvl,n_modlvl,nobslev)

! Ensure that layer is within model vertical range.
  
  success=.true.
  if (vlayerbot.lt.pressmodlvl(1)*1.01.or.vlayertop.gt.pressmodlvl(n_modlvl)*0.99) then
     success=.false.
     write(*,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',vlayertop, vlayerbot
     return
  end if
  if (vlayerbot.gt.pressmodlvl(n_modlvl)*0.999) vlayerbot=pressmodlvl(n_modlvl)*0.999
  if (vlayertop.lt.pressmodlvl(1)*1.001) vlayertop=pressmodlvl(1)*1.001
       
! Calculate vertical integration components for specified obs layer.

  call chm_vertintg(vlayertop,vlayerbot,n_modlvl,iobslev)

! Apply averaging kernel if requested
!
! if ... call ...
!
! Apply generalized innovation operator if requested
!
! if ... call ...
!
! Finalize required quantities depending on kmode
   
  select case(kmode)
!
    case(0,1,2)
!
!       Finalize non-linear/linear operator step
!
        rmhx=dot_product(chm_obsoper%zh(iobslev,:),chm_obsoper%modelvarcolumn(:))
!
    case(3)
!
!       Ht*grad contribution from adjoint of tangent linear model.
!
        zwork(:)= rmhx*chm_obsoper%zh(iobslev,:)
        call chm_convert(n_modlvl,zwork,rval,rtt,pressmodlvl,ivnm,kmode)
        rvalinc(:)=rvalinc(:) + chm_obsoper%modelvarcolumn(:)       
!
  end select
   
  end subroutine chm_layer_integ_operator

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg_setup(pressmod,knflev,nobslev)
!
! Author  : Y. Rochon (ARQI/AQRD) and Ping Du (CMDA), Feb 2015.
!           - Based Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!           M. Sitwell (ARQI/AQRD), Mar 2015.
!           - Use of nobslev in space allocation.
!           
!
! Purpose:  Preliminary calcs for producing components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
!           This includes:
!
!                    - Allocation of work arrays
!                    - Setting of model layer boundaries
!                    - Determining integration weights associated to
!                      second order Lagrangian interpolation.
!
!           Layer boundaries are taken as mid-point between eta levels in lnP
!           coordinate. Layer values are set to be the values interpolated
!           to the mid-point in P within the various layers. Interpolation
!           in P is done quadratically. 
!
! Arguments:
!
!  Input   
!           knflev            -- # of vertical levels
!           pressmod          -- pressures at model levels
!           nobslev           -- Obs profile dimension.
!
!  Output  
!           chm_obsoper%zh(knflev)  -- Initial innovation model array 
!                                      (other than conversion constants)
!                                      Initialized to zero.
!           chm_obsoper%zhp(knflev) -- Part of innovation operator not 
!                                      related to resolution
!                                      Initialized to zero.
!           chm_obsoper%vmodpress(knflev+1) -- Model layer boundaries given that pressmod are
!                                              taken at mid-layer values.
!           chm_obsoper%vh(knflev,knflev)   -- Second order Lagrangian interp integration weights
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      integer, intent(in) :: knflev,nobslev
      real(8), intent(in) :: pressmod(knflev)
!
!*    Declaration of local variables
!
      integer   :: jk
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3
!
!*    Determine P boundaries of analysis layers and save weights for
!     use in setting innovation operator array.
!
!     N.B.: Boundaries of layers set to mid-point of model levels
!
      ! Allocation of work arrays
         
      if (allocated(chm_obsoper%vh)) deallocate(chm_obsoper%vh,chm_obsoper%zh,chm_obsoper%zhp,chm_obsoper%vmodpress)
      allocate(chm_obsoper%vh(knflev,knflev))
      allocate(chm_obsoper%zh(nobslev,knflev))
      allocate(chm_obsoper%zhp(nobslev,knflev))
      allocate(chm_obsoper%vmodpress(knflev+1))
!      
!     Initialize to zero  
!
      chm_obsoper%vh(:,:)=0.0D0
      chm_obsoper%zh(:,:)=0.0D0
      chm_obsoper%zhp(:,:)=0.0D0

!     Calculate layer boundaries
!
      chm_obsoper%vmodpress(1)=pressmod(1)
      chm_obsoper%vmodpress(knflev+1)= pressmod(knflev)
!
      DO JK = 2, KNFLEV
         chm_obsoper%vmodpress(jk)=sqrt(pressmod(jk-1)*pressmod(jk))
      END DO
         
!     Interpolation to mid-layer level in P using
!     second degree Lagrangian interpolator.
!     N.B.: Integration is w.r.t. P
!
!     Calculating for jk=1
!
      zp1= pressmod(1)
      zp2= pressmod(2)
      zp3= pressmod(3)
      zp = (chm_obsoper%vmodpress(2)+chm_obsoper%vmodpress(1))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      chm_obsoper%vh(1,1)=zr1
      chm_obsoper%vh(2,1)=zr2
      chm_obsoper%vh(3,1)=zr3
!
      DO JK=2,knflev-1
         zp1=pressmod(jk-1)
         zp2=pressmod(jk)
         zp3=pressmod(jk+1)
         zp=(chm_obsoper%vmodpress(jk+1)+chm_obsoper%vmodpress(jk))/2.0
         zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
         zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
         zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
         chm_obsoper%vh(jk-1,jk)=zr1
         chm_obsoper%vh(jk,jk)=zr2
         chm_obsoper%vh(jk+1,jk)=zr3
      ENDDO
!
!     Calculating  for jk=knflev
!
      zp1= pressmod(knflev-2)
      zp2= pressmod(knflev-1)
      zp3= pressmod(knflev)
      zp = (chm_obsoper%vmodpress(knflev+1)+chm_obsoper%vmodpress(knflev))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      chm_obsoper%vh(knflev-2,knflev)=zr1
      chm_obsoper%vh(knflev-1,knflev)=zr2
      chm_obsoper%vh(knflev,knflev)=zr3
!
      end subroutine chm_vertintg_setup 

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg(ptop,pbtm,knflev,iobslev)
!
! Author  : Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!           Ping Du and Y. Rochom, Jan-Feb 2015
!           - Adapated for the EnVar
!
! Purpose:  Calculate components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
!           Calculations are for the specific observation layer 'iobslev'.
!
! Arguments:
!
!  Input   
!           knflev            -- # of vertical levels
!           ptop              -- obs top - level pressure (in Pascal)
!           pbtm              -- obs bottom -level pressure (in Pascal)
!           iobslev           -- Index level in obs profile
!           chm_obsoper%vh    -- See routine chm_vertintg_setup
!           chm_obsoper%vmodpress
!
!  Output  
!           chm_obsoper%zh(knflev)  -- Initial innovation model array 
!                                      (other than conversion constants)
!           chm_obsoper%zhp(knflev) -- Part of innovation operator not 
!                                      related to resolution
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      integer, intent(in) :: knflev,iobslev
      real(8), intent(in) :: ptop, pbtm  
       
      integer, parameter :: ivh=2  ! Order of Lagrangian interpolation.
!
!*    Declaration of local variables
!
      integer   :: J,JK,ILMAX2,ILMIN2
      integer   :: ILMIN, ILMAX
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3
!
!*    Find the range of vertical levels over which to perform the integration
!     and set innovation operator ZH over this range.
!
      ilmin=1
      ilmax=knflev
      if (ptop.le.chm_obsoper%vmodpress(1)*1.01.and.pbtm.ge.chm_obsoper%vmodpress(knflev+1)*0.99) then
!
!        Total column integration part
!
         do jk = 1,knflev
            do j=max(1,jk-ivh),min(knflev,jk+ivh)
               chm_obsoper%zh(iobslev,jk)=chm_obsoper%zh(iobslev,jk)+(chm_obsoper%vmodpress(j+1)-chm_obsoper%vmodpress(j))*chm_obsoper%vh(jk,j)
               chm_obsoper%zhp(iobslev,jk)=chm_obsoper%zhp(iobslev,jk)+chm_obsoper%vh(jk,j)
            end do
         end do
!
      else
!
!        Partial column integration part (special treatment at boundaries)
!
!        Identify analysis layer boundaries just within obs layer.
!
         ilmin = chm_igetmodlev(ptop, chm_obsoper%vmodpress, 'top', knflev+1)
         ilmax = chm_igetmodlev(pbtm, chm_obsoper%vmodpress, 'btm', knflev+1)
!
         if (ilmin.eq.ilmax+1) then
!
!           Entire obs layer within one analysis layer
!
            j=ilmin
            if (j.lt.3) j=3
            if (j.gt.knflev) j=knflev
            zp1=chm_obsoper%vmodpress(j-2)
            zp2=chm_obsoper%vmodpress(j-1)
            zp3=chm_obsoper%vmodpress(j)
            zp=(ptop+pbtm)/2.0
            zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
            zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
            zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
!
            chm_obsoper%zh(iobslev,j-2)=(pbtm-ptop)*zr1
            chm_obsoper%zh(iobslev,j-1)=(pbtm-ptop)*zr2
            chm_obsoper%zh(iobslev,j)=(pbtm-ptop)*zr3
            chm_obsoper%zhp(iobslev,j-2)=zr1
            chm_obsoper%zhp(iobslev,j-1)=zr2
            chm_obsoper%zhp(iobslev,j)=zr3
            ilmin=j-2
            ilmax=j
!
         else
!
!           Determine terms from the inner layers (excluding the lower and upper
!           boundary layers when these layers not covering entire analyses layers)
!
            if (pbtm.ge.chm_obsoper%vmodpress(knflev)*0.99) then
               ilmax2=knflev
            else
               ilmax2=ilmax-1
            end if
            if (ptop.le.chm_obsoper%vmodpress(1)*1.01) then
               ilmin=1
               ilmin2=ilmin
            else
               ilmin2=ilmin
            end if
            if (ilmin2.le.ilmax2) then
               do jk = ilmin2,ilmax2
                  do j=max(1,jk-ivh),min(knflev,jk+ivh)
                     chm_obsoper%zh(iobslev,jk)=chm_obsoper%zh(iobslev,jk)+(chm_obsoper%vmodpress(j+1)-chm_obsoper%vmodpress(j))*chm_obsoper%vh(jk,j)
                     chm_obsoper%zhp(iobslev,jk)=chm_obsoper%zhp(iobslev,jk)+chm_obsoper%vh(jk,j)
                  end do
               end do
            end if
!
!           Determine terms from the lower and upper boundary layers
!           when these layers do not cover entire analyses layers.
!
            if (pbtm.lt.chm_obsoper%vmodpress(knflev)*0.99) then
!
               j=ilmax+1
               if (j.gt.knflev) j=knflev
               if (j.lt.3) j=3
               zp1=chm_obsoper%vmodpress(j-2)
               zp2=chm_obsoper%vmodpress(j-1)
               zp3=chm_obsoper%vmodpress(j)
               zp=(chm_obsoper%vmodpress(ilmax)+pbtm)/2.0
               zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
               zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
               zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
!
               chm_obsoper%zh(iobslev,j-2)=chm_obsoper%zh(iobslev,j-2)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr1
               chm_obsoper%zh(iobslev,j-1)=chm_obsoper%zh(iobslev,j-1)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr2
               chm_obsoper%zh(iobslev,j)=chm_obsoper%zh(iobslev,j)+(pbtm - chm_obsoper%vmodpress(ilmax))*zr3
               chm_obsoper%zhp(iobslev,j-2)=chm_obsoper%zhp(iobslev,j-2)+zr1
               chm_obsoper%zhp(iobslev,j-1)=chm_obsoper%zhp(iobslev,j-1)+zr2
               chm_obsoper%zhp(iobslev,j)=chm_obsoper%zhp(iobslev,j)+zr3
               ilmax=j
!
            end if
!
            if (ptop.gt.chm_obsoper%vmodpress(1)*1.01) then
!
               j=ilmin-1
               if (j.lt.1) j=1
               if (j.gt.knflev-2) j=knflev-2
               zp1= chm_obsoper%vmodpress(j)
               zp2= chm_obsoper%vmodpress(j+1)
               zp3= chm_obsoper%vmodpress(j+2)
               zp = (chm_obsoper%vmodpress(ilmin)+ptop)/2.0
               zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
               zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
               zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
!
               chm_obsoper%zh(iobslev,j)=chm_obsoper%zh(iobslev,j)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr1
               chm_obsoper%zh(iobslev,j+1)=chm_obsoper%zh(iobslev,j+1)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr2
               chm_obsoper%zh(iobslev,j+2)=chm_obsoper%zh(iobslev,j+2)+(chm_obsoper%vmodpress(ilmin)-ptop)*zr3
               chm_obsoper%zhp(iobslev,j)=chm_obsoper%zhp(iobslev,j)+zr1
               chm_obsoper%zhp(iobslev,j+1)=chm_obsoper%zhp(iobslev,j+1)+zr2
               chm_obsoper%zhp(iobslev,j+2)=chm_obsoper%zhp(iobslev,j+2)+zr3
               ilmin=j
               if (ilmax.lt.j+2) ilmax=j+2
!
            end if
            if (ilmin.gt.ilmax-2) ilmin=ilmax-2
         end if
      end if
!
      end subroutine chm_vertintg 

!-----------------------------------------------------------------------------------------

  integer function chm_igetmodlev(rpress, rppobs, topbtm, ntotlev)

!
!  Author: Y. Yang    May 2004
!
!  Revisions:
!             Y.J. Rochon, ARQI/MSC May 2005 - May 2007, Feb 2015
!             - Changes to form and comments
!
!  Purpose: Get the vertical level index for the pressure in rppobs
!           within obs layer and nearest specified obs layer boundary.
!
!  Arguments:
!
!              rpress : pressure value in Pascal
!              rppobs : profile of pressure at obs. location
!              topbtm : indicating whether we are looking for top or bottom
!                       presure
!              ntotlev: total number of levels of rppobs
!
!-----------------------------------------------------------------------------------------
      implicit none
 
      integer, intent(in) :: ntotlev
      real(8), intent(in) :: rpress, rppobs(ntotlev)
      character(len=*), intent(in) :: topbtm
      
      integer     :: ilev1, ilev2
      integer     :: jk
!
!     Find the model levels adjacent to pressure level rpress
!
!     Default values
!
      if (rpress .lt. 0.) then
        if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
             chm_igetmodlev = ntotlev
        endif
        if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
             chm_igetmodlev = 1
        endif
                                                       
      endif
!
      ilev1=0
      ilev2=1
      do jk=1,ntotlev
         if (rpress.gt.rppobs(jk)) then
           ilev1=jk
           ilev2=jk+1
         else
           exit
         endif
      enddo
!
!     Find the model level index
!
!     If we are looking for top level, the index is the level immediately 
!     below. if looking for bottom level, the index is the one immediately 
!     above.
!
      if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
           chm_igetmodlev=ilev1
      else if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
           chm_igetmodlev=ilev2
      endif
!
      if (chm_igetmodlev .lt. 1) chm_igetmodlev=1
      if (chm_igetmodlev .gt. ntotlev) chm_igetmodlev=ntotlev
!     
  end function chm_igetmodlev 
!-----------------------------------------------------------------------------------------

end module chem_mod
