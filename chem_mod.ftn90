!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

! chm_obsspace_mod:  The module chm_obsspace_mod must be used in conjuction with
!                  ObsSpaceData_mod.
! 
!
#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chm_obsspace_mod
!
! PURPOSE:
!    Read, store, and associate information related to constituent observations
!    which are not included in ObsSpaceData_mod. This information is
!    made available within the 'chm_ObsSpace' structure (type struct_obs_chm).
!    The association of information within 'chm_obsspace' to specific observations 
!    is done through an index array within 'chm_obsspace'. 
!
!    The content of chm_ObsSpace is relevant only to the constituent 
!    observation operators.
!
! COMMENT:
!
!    Ths module could be expanded to contain other constituent related info
!    or routines (e.g. unit conversions)
!
! Author  : Y.J Rochon - ARQI, 2014
!
! Revisions:
!
!----------------------------------------------------------------------------------

    use MathPhysConstants_mod
    use obsSpaceData_mod
    use codtyp_mod
    use bufr
   
   implicit none
    private

!   public procedures
!   -----------------

    public :: chm_obsspace_setup
  
!
!   Position indices of content within header (index) array struct_obs_chm%header
!   Content of struct_obs_chm%header mostly provides location of relevant content 
!   within struct_obs_chm%*.
!
!  CHM report location index in ObsSpaceData (association to OBS_RLN but for CH family obs only)
   integer, parameter, public :: OBSTR_RLN = 1 
   
!  Start location in storage arrays containing layer top and bottom levels.
!  Index location set to 0 if not relevant.
   integer, parameter, public :: OBSTR_PPP = OBSTR_RLN+1
                                                  
!  Start location in storage array containing averaging kernel matrix.
!  Index location set to 0 if not relevant.
   integer, parameter, public :: OBSTR_NAK = OBSTR_PPP
   
   integer, parameter, public :: OBSTR_SIZE=OBSTR_NAK
                                                  
!  This type contains the information arrays of the chm_obsspace module. 
!  Content:
!        obsindex(:)    Association of obs index to header array content 
!                       Also, struct_obs_chm%header(OBSTR_RLN,obsindex(j))=j 
!        header(:,:)    Index given by (OBSTR_*,obsindex(:))
!        vtp(:)         Top of layer. Start index given by header(OBSTR_PPP,obsindex(:)) 
!        vbt(:)         Bottom of layer. Start index given by header(OBSTR_PPP,obsindex(:)) 
!        avgkern(:,:,:) Averaging kernel matrices. (:,:,header(OBSTR_NAK,obsindex(:))
!        numHead        Number of header elements

   type, public :: struct_obs_chm
      integer, dimension(:),        pointer :: obsindex 
      integer, dimension(:,:),      pointer :: header    
      real(OBS_REAL), dimension(:), pointer :: vtp,vbt
      real(OBS_REAL), dimension(:,:,:), pointer :: avgkern
      integer :: numHead     
   end type struct_obs_chm

!  Information arrays retrieved from obsinfo_chm to produce content of
!  struct_obs_chm
!
!  Variable               Description
!  --------               -----------
!  ninfo_stnid_chm         Number of sub-families (identified via STNIDs)
!  cinfo_stnid_chm         sub-families (STNIDs; * are wild cards)
!  ninfo_bfr_chm           BUFR/BURP element in data block
!  ninfo_brp_chm           0: Set entirely from the ascii file being read. No 
!                            initial values read from BURP files
!                         1: Initial values in obs BURP files 
!                            (may be adjusted after input)
!  ninfo_vco_chm           Vertical coordinate type (1, 2, or 3, see bufr_read_mod)

!  ninfo_ibegin_chm        Position index of start of data for given
!                         sub-family.
!  ninfo_lvl_chm           Number of vertical levels
!  xinfo_vtp_chm           Layer top 
!  xinfo_vbt_chm           Layer bottom
  
!  ninfo_lat_chm           Number of latitudes
!  xinfo_lat_chm           Latitudes (degrees; ordering in increasing size)
!  xinfo_rak_chm           Averaging kernel matrices
! 
  integer ::  ninfo_stnid_chm
  character(len=12), allocatable :: cinfo_stnid_chm(:)
  integer, allocatable :: ninfo_bfr_chm(:),ninfo_brp_chm(:)
  integer, allocatable :: ninfo_vco_chm(:),ninfo_lat_chm(:)
  integer, allocatable :: ninfo_ibegin_chm(:),ninfo_lvl_chm(:)
  real(8), allocatable :: xinfo_rak_chm(:),xinfo_vtp_chm(:),xinfo_vbt_chm(:)
  real(8), allocatable :: xinfo_lat_chm(:)

contains

!-----------------------------------------------------------------------------------------

  subroutine chm_obsSpace_setup(lobsSpaceData,lobsSpaceCHM)
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: 
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData. Additional information incorporated in lobsSpaceCHM.
!
!----------------------------------------------------------------------------------------

  implicit none

  type(struct_obs) :: lobsSpaceData
  type(struct_obs_chm) :: lobsSpaceCHM

  integer :: index_header, idburp, icount

! Check for the presence of the TR family and count number of 
! corresponding observations

  icount=0
  do index_header = 1, obs_numheader(lobsSpaceData)
  
     idburp = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)

     if (obs_getFamily(lobsSpaceData,index_header).EQ.'CH'.and.   &
         (idburp.eq.codtyp_chemremote.or.idburp.eq.codtyp_cheminsitu)) &
             icount=icount+1
  end do 

  if (icount.eq.0) return
  
  write(*,*) 'Begin chm_obsspace_setup'
 
! Allocate space for header array
  
  allocate(lobsSpaceCHM%header(OBSTR_SIZE,icount)) 
  lobsSpaceCHM%numhead=icount  
        
! Allocate space for array used to associate to lobsSpaceData
   
  allocate(lobsSpaceCHM%obsindex(obs_numheader(lobsSpaceData)))

  write(*,*) 'Total and CHM number of obs: ',obs_numheader(lobsSpaceData),icount
  
!------------------------ Top and bottom layer boundaries ------------------------
  
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_obsspace_layers(lobsSpaceCHM)
  
! Fill lobsSpaceCHM with above info for associated lobsSpaceData observations for the TR family.
  
  call chm_obsSpace_layers_fill(lobsSpaceData,lobsSpaceCHM)
  
! Deallocate space
  
  call chm_obsSpace_layers_deallocate 

!--------------------------- Averaging kernel matrices ------------------------
   
! Read averaging kernel matrices
  
! call chm_obsSpace_avgkern(lobsSpaceCHM)
  
! Fill lobsSpaceCHM with above info for associated lobsSpaceData observations for the TR family.
  
! call chm_obsSpace_avgkern_fill(lobsSpaceData,lobsSpaceCHM)

! Deallocate space
  
! call chm_obsSpace_avgkern_deallocate 


  write(*,*) 'Completed chm_obsspace_setup'
  
  end subroutine chm_obsSpace_setup

!-----------------------------------------------------------------------------------------

  subroutine chm_obsSpace_layers(lobsSpaceCHM)
!
! Author   : Y. Rochon, Dec 2014 
!
! Revisions: 
!          
! Purpose: Read top and bottom layer boundaries for CH sub-families.
!
!----------------------------------------------------------------------------------------

  implicit none

  type(struct_obs_chm) :: lobsSpaceCHM
  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  ninfo_stnid_chm=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (LnewExists )then
!    WRITE(*,*) '---------------------------------------------------------------'
!    WRITE(*,*) 'obsSpaceCHm_layers: read info from obsinfo_chm                  '
!    WRITE(*,*) '---------------------------------------------------------------'
  else
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! read_obs_error_chm: obsinfo_chm not available.          '
    WRITE(*,*) 'WARNING! Default CH family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('obsSpaceCHM_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

!  write(*, '(A)') ' '
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
!  write(*,'(A)') ligne   
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
!      write(*, '(A)') ligne   
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) ninfo_stnid_chm
!  write(*, '(I6)') ninfo_stnid_chm
  read(nulstat,*,iostat=ios,err=10,end=10) isize
!  write(*, '(I8)') isize

  allocate(cinfo_stnid_chm(ninfo_stnid_chm))
  allocate(ninfo_vco_chm(ninfo_stnid_chm))
  allocate(ninfo_brp_chm(ninfo_stnid_chm),ninfo_ibegin_chm(ninfo_stnid_chm))
  allocate(ninfo_bfr_chm(ninfo_stnid_chm),ninfo_lvl_chm(ninfo_stnid_chm))
  allocate(xinfo_vtp_chm(isize),xinfo_vbt_chm(isize))
  allocate(lobsSpaceCHM%vtp(isize),lobsSpaceCHM%vbt(isize))
 
  ninfo_bfr_chm(:)=0
  ninfo_vco_chm(:)=0
  ninfo_brp_chm(:)=0
  ninfo_lvl_chm(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,ninfo_stnid_chm
    ninfo_ibegin_chm(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
!    write(*, '(A)') ligne 

!   Read STNID (* as wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) cinfo_stnid_chm(jelm) 
!    write(*, '(A9)') cinfo_stnid_chm(jelm)

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) ninfo_bfr_chm(jelm),ninfo_vco_chm(jelm),  &
       ninfo_brp_chm(jelm),ninfo_lvl_chm(jelm)  
!    write(*, '(2X,I5,4I4)') ninfo_bfr_chm(jelm),ninfo_vco_chm(jelm), &
!       ninfo_brp_chm(jelm),ninfo_lvl_chm(jelm)
    
    if (icount+ninfo_lvl_chm(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_obsSpace_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
!    write(*, '(A)') ligne 
    
    if (ninfo_lvl_chm(jelm).ge.1) then   
       do jlev=1,ninfo_lvl_chm(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 xinfo_vtp_chm(icount),xinfo_vbt_chm(icount)
!          write(*, *) xinfo_vtp_chm(icount),xinfo_vbt_chm(icount)
          lobsSpaceCHM%vtp(icount)=xinfo_vtp_chm(icount)
          lobsSpaceCHM%vbt(icount)=xinfo_vbt_chm(icount)
       end do
    else 
       icount=icount+1
       ninfo_lvl_chm(jelm)=1
       if (ninfo_vco_chm(jelm).eq.2) then
          xinfo_vtp_chm(icount)=1.0
          xinfo_vbt_chm(icount)=120000.
          lobsSpaceCHM%vtp(icount)=xinfo_vtp_chm(icount)
          lobsSpaceCHM%vbt(icount)=xinfo_vbt_chm(icount)
       else if (ninfo_vco_chm(jelm).eq.1) then
          xinfo_vtp_chm(icount)=70000.   ! 70 km
          xinfo_vbt_chm(icount)=0.0      !  0 km
          lobsSpaceCHM%vtp(icount)=xinfo_vtp_chm(icount)
          lobsSpaceCHM%vbt(icount)=xinfo_vbt_chm(icount)
       end if
    end if
  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_obsSpace_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_obsSpace_layers

!-----------------------------------------------------------------------------------------

  subroutine chm_obsspace_layers_fill(lobsSpaceData,lobsSpaceCHM)
!
! Author  : Y. Rochon, Dec 2014.
!
! Revision: M. Sitwell Jan 2015
!             - When comparing a record with info in ascii file, allowed for arbitrary
!               ordering of code 8090 within a block of data so that it gives the correct
!               number of data elements (i.e. not counting the 8090 codes)
!             - When matching observation from lobsSpaceData to lobsSpaceCHM to set vertical
!               levels, the check of vertical coordinate type is disregarded if number of levels
!               is one and the value of OBS_PPP is less than 0 (to indicate default value), as would
!               be the case for a total column measurement.
!          
! Purpose: Store observation information in lobsSpaceCHM and create associtation
!          to observation in lobsSpaceData.
!
!          Info to specify: top and bottom of partial/total column measurements
!
! Comment:
!
! Vertical levels will be given by
!
!     lobsSpaceCHM%vtp(i1:i2)   ! Layer top
!     lobsSpaceCHM%vbt(i1:i2)   ! Layer bottom
!
!     where
!
!          i1=lobsSpaceCHM%header(OBSTR_PPP,lobsSpaceCHM%obsindex(INDEX_HEADER))
!          i2=i1+obs_headElem_i(lobsSpaceData,OBS_NLV,INDEX_HEADER)-1
!
!--------------------------------------------------------------------------------------

  implicit none

  type(struct_obs)    :: lobsSpaceData
  type(struct_obs_chm) :: lobsSpaceCHM

  integer :: JN, JI, INDEX_HEADER, IDATA, IDATEND, IDBURP
  integer :: ILEV,ISTNID,IBEGIN,IVCO,ITYP,ITYP2
  integer :: ielem,icodtyp,ilen1,ilen2,iset,icount
  real*8  :: ZLEV

  CHARACTER(len=2)  :: CFAM
  CHARACTER(len=12) :: CSTNID
  
  if (ninfo_stnid_chm.eq.0) return
  

  icount=0
  DO INDEX_HEADER = 1, obs_numheader(lobsSpaceData)

     CFAM    = obs_getFamily(lobsSpaceData,INDEX_HEADER)
     IDBURP  = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
     
     IF (CFAM.EQ.'CH'.AND.(IDBURP.EQ.codtyp_chemremote.OR.IDBURP.EQ.codtyp_cheminsitu)) THEN

           IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,INDEX_HEADER)
           ILEV    = obs_headElem_i(lobsSpaceData,OBS_NLV,INDEX_HEADER)
           CSTNID  = obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER)
           
           ITYP    = obs_bodyElem_i(lobsSpaceData,OBS_VNM,IDATA)
           IVCO    = obs_bodyElem_i(lobsSpaceData,OBS_VCO,IDATA)
           ZLEV    = obs_bodyElem_r(lobsSpaceData,OBS_PPP,IDATA)

           ! Subtract the number of occurances of code 8090 from number of levels
           do ji=0,ilev-1
                 if (obs_bodyElem_i(lobsSpaceData,OBS_VNM,IDATA+ji).eq.8090) then
                    ilev = ilev-1
                 end if
           end do

           
!          Important: Combination of STNID, BUFR element and number of vertical levels
!                     to determine association to the observations.

!          Find stnid with same number of vertical levels, and same BUFR element
!          Note: * in cinfo_stndi_chm stands for a wildcard
          
           ISTNID=0
           DO JN=1,ninfo_stnid_chm

!               First compare STNID values allowing for * and blanks in 
!               cinfo_stnid_chm(JN) as wildcards
                ilen1=len_trim(cinfo_stnid_chm(JN))
                ilen2=len_trim(CSTNID)            
                IF (ilen1.le.ilen2) THEN          
                    iset=1
                    DO ji=1,ilen1
                       IF (cinfo_stnid_chm(JN)(ji:ji).ne.'*'.AND.   &
                          CSTNID(ji:ji).ne.cinfo_stnid_chm(JN)(ji:ji)) THEN
                           iset=0
                           exit
                       END IF
                    END DO
                END IF
 
                ! Check if number of levels, code, and vertical coordinate type are equal.
                ! If number of levels is one and there is no value set for OBS_PPP (as for
                ! a total column measurement), the check of vertical coordinate type is disregarded.
                IF (iset.eq.1) THEN
                   IF ( ITYP .EQ. ninfo_bfr_chm(JN) .AND. &
                        ( (ILEV .EQ. ninfo_lvl_chm(JN) .AND. (IVCO.EQ.ninfo_vco_chm(JN).OR.IVCO.EQ.4)) .OR. &
                          (ILEV .EQ. 1 .AND. ZLEV .LE. 0.) ) &
                      ) THEN
                      ISTNID=JN
                      exit
                   END IF
                END IF 
                
                IF (ISTNID.NE.0) THEN
                   !   IF (ninfo_brp_chm(ISTNID).NE.0) THEN
               
                      !   Read from obs BURP file.
                      !   Dimension must be equivalent to ILEV
                      ! ...
                   
                      ! ...
                   
                   !   END IF
                END IF
       
           END DO

           icount=icount+1
           lobsSpaceCHM%obsindex(index_header)=icount        
           lobsSpaceCHM%header(OBSTR_RLN,icount)=index_header


           ! Set the starting position for the record in the arrays vtp,vbt
           IF (ISTNID.EQ.0) THEN
               IF (ityp.eq.15198.or.ityp.eq.15020) THEN
                  CALL ABORT3D ('obsSpaceCHM_layers_fill: Top and bottom of layers not found for STNID=' // CSTNID)
               END IF
               lobsSpaceCHM%header(OBSTR_PPP,icount)=0
           ELSE
               if (IVCO.eq.4) call obs_bodySet_i(lobsSpaceData,OBS_VCO,IDATA, &
                                      ninfo_vco_chm(ISTNID))
               lobsSpaceCHM%header(OBSTR_PPP,icount)=ninfo_ibegin_chm(ISTNID)           
           END IF 
         
     END IF 
  END DO 
  
  end subroutine chm_obsspace_layers_fill

!-----------------------------------------------------------------------------------------

  subroutine chm_obsspace_layers_deallocate
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space.
!
! ---------------------------------------------------------------------------------------
  
!
! Deallocate temporary space used for the CH family
!
  if (ninfo_stnid_chm.gt.0) then
      deallocate(cinfo_stnid_chm)
      deallocate(ninfo_lvl_chm,ninfo_ibegin_chm)
      deallocate(ninfo_bfr_chm,ninfo_brp_chm,ninfo_vco_chm)
      deallocate(xinfo_vtp_chm,xinfo_vbt_chm)
  end if
 
 
  end subroutine chm_obsspace_layers_deallocate

!-----------------------------------------------------------------------------------------

  subroutine chm_obsSpace_avgkern_deallocate
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space.
!
!---------------------------------------------------------------------------------------
  
!
! Deallocate temporary space used for the CH family
!
  if (ninfo_stnid_chm.gt.0) then
      deallocate(cinfo_stnid_chm)
      deallocate(ninfo_ibegin_chm)
      deallocate(ninfo_bfr_chm,ninfo_brp_chm,ninfo_lat_chm)
      deallocate(xinfo_rak_chm,xinfo_lat_chm)
  end if
 
 
  end subroutine chm_obsSpace_avgkern_deallocate

!-----------------------------------------------------------------------------------------


end module chm_obsspace_mod
