!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_mod
!
! Module managers: Mike Sitwell and Yves Rochon (ARQI/AQRD)
!
! PURPOSE:
!    Repository of obs space structures, arrays, and routines specific to the 
!    CH chemical constituents family and constituent observations.
!
!    Main content (public routines):
!
!       - Public routines
!         "chm_read_obs_err_stddev,chm_get_obs_err_stddev,chm_dealloc_obs_err_stddev":
!         Routines and strucure for setting of obs error std. dev. used in
!         'observation_erreurs_mod.ftn90'. 
!
!       - Public routine "chm_obsoperators": Applies observation operators. 
!
!       - Public routine "chm_setup": Routines and structure for setting and assignment 
!         of observation layer top and bottom levels (and averaging kernel matrices - tbc). 
!         See 'preproc.ftn90' and 'chm_obsoperators'. 
!
!       - Public routines: "chm_get_stringId,chm_get_ID": Routines for use 
!         in filtering out obs based on model vertical boundaries. See 'filterobs_mod.ftn90'.
!
!       - Public routine chm_diagn_only: Identify if data is to be assimilated or only used
!         for independent verifications.
!
!       - Public routine chm_comboIDlist: Provide list of fixed or accumulated stnid, 
!         (stnid,varno) or (stnid,varno,multi/uni-level) combinations. For use in
!         in obsspacediag_mod.ftn90.
!
!       - Public routine "chm_get_col_boundary": Provides column boundary pressure pressure levels
!         at obs locations (could be set as tropopause, PBL, or static value). Relevant only for
!         assimilation of total column measurements. Public routines "chm_add_col_boundary" and
!         "chm_retrieve_col_boundary" provide a means of storing and retrieving this value, respectively.
!
!       - Public routine "chm_convert_z_to_pressure".
!
!       - Public routines "chm_apply_bounds" and "chm_apply_transform" applied to analysis increment fields.
!
!       - Public routine "chm_apply_2dfieldr4_transform" applied to 2D field variable transformation if requested.
!
!       - Public routine "chm_varnumFromVarname" to obtain the BUFR varno corresponding to
!         to the constituent.
!
!       - Public routine "chm_update_obsfile" to make any desired changes/additions
!         to the CH family reports of the observation file content before the final update
!         to the observation file(s).
!
!       - Public routines "chm_obsspace_diagn_*" for preparation and output of postproc diagnostics.
!         Output placed in 'obsspace_diagn_filename'.
!
! COMMENT:
!
!    This module can be expanded to contain other constituent related info
!    or routines.
!
! Author  : Y.J Rochon - ARQI/AQRD, 2014
!
! Revisions:
!           M. Sitwell, ARQI/AQRD, Feb 2015
!           - Created struct_chm_info and struct_chm_std structures for storing
!             information read from ascii/burp file and removal of earlier structure.
!           M. Sitwell and Y. Rochon, ARQI/AQRD, Aug 2015
!           - Created struct_config (M. Sitwell) following specification of related
!             variables (Y. Rochon) for reading in routine chm_read_misc.
!           M. Sitwell and Y. Rochon, ARQI/AQRD Aug 2015 to Aug 2016
!           - Various changes and additions
!           
!
!----------------------------------------------------------------------------------
   
  implicit none
  private

! public procedures
! -----------------

  public :: chm_setup,chm_dealloc_obs_err_stddev,chm_read_obs_err_stddev, &
            chm_get_obs_err_stddev,chm_convert_z_to_pressure
  public :: chm_obsoperators,chm_get_stringID,chm_get_ID,stnid_equal
  public :: chm_diagn_only,chm_comboIDlist,chm_required_field
  public :: chm_apply_bounds,chm_get_col_boundary
  public :: chm_add_col_boundary,chm_retrieve_col_boundary
  public :: chm_varnumFromVarName,chm_open_messagefile
  public :: chm_update_obsfile
  public :: chm_obsspace_diagn_alloc,chm_obsspace_diagn_init,chm_obsspace_diagn_dealloc
  public :: chm_obsspace_diagn_add,chm_obsspace_diagn_MPIreduce,chm_obsspace_diagn_print
! Public procedures for variable transformations
  public :: chm_apply_transform_array4d,chm_apply_2dfieldr4_transform

! public variables and types
! --------------------------

  public :: chm_constituents_size,struct_chm_obsoperators,struct_chm_diagn

! module constants
! -----------------
  integer, parameter :: chm_cfg_size=100           ! max size of config arrays
  integer, parameter :: chm_constituents_size=30   ! max size of constituents arrays
                                                   ! = max allowed value of "iconstituent_id" for Table 08046.
                                                   ! Value to be increased as needed up to a max of 6999 as values
                                                   ! > 7000 (and less 0) are assumed assigned to non-constituent fields  
  integer, parameter :: code_len=40                ! Max string size for code in struct_chm_obsdata.
                                                   ! Minimum required size:
                                                   ! 22 (lat/long and time coord) + 9 (stnid) = 31

! module interfaces
! -----------------

  ! interface for resizing arrays
  interface resize
     module procedure resize_1d_real
     module procedure resize_1d_int
     module procedure resize_1d_str
     module procedure resize_2d_real
     module procedure resize_3d_real
  end interface resize

  ! interface for conversion to a left-justified string (useful for calls to abort3d)
  interface str
     module procedure int2str
     module procedure float2str
  end interface str

  ! interface for generating obsdata loctime codes from (lat,long,date,hhmm)
  interface obsdata_get_loctime_code
     module procedure obsdata_get_loctime_code_i
     module procedure obsdata_get_loctime_code_r
  end interface obsdata_get_loctime_code

! module structures
! -----------------

  type :: struct_chm_std
     !
     ! Structure containing information retrieved from file obsinfo_chm for holding 
     ! observation std dev information
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block 
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files 
     !                            (may be adjusted after input)
     !                         2: Initial values in obs BURP files for variable number
     !                            of vertical levels (for error std deviations only)
     !  std_type               Index of setup approach (used in combination with
     !                            nstd_brp_chm)
     !                         For nstd_brp_chm value 0 or 1, 
     !                         0: std1 or BURP file vales (sigma)
     !                         1: max(std3,std2*ZVAL)  if brp=0
     !                            max(std3,std2*sigma) otherwise
     !                         2: sqrt(std3**2+(std2*ZVAL)**2))  if brp=0
     !                            sqrt(std3**2+(std2*sigma)**2)) otherwise
     !                         3: min(std3,max(std2,std1_chm*ZVAL)) if brp=0
     !                            min(std3,max(std2,std1_chm*sigma))  otherwise
     !                         4: sqrt(std2**2+(std1*ZVAL)**2))  if brp=0 
     !                            sqrt(std2**2+(std1*sigma)**2)) otherwise
     !  ibegin                 Position index of start of data for given
     !                         sub-family in the arrays std1,levels,lat
     !  n_lvl                  Number of vertical levels (max number when brp=2)
     !  levels                 Vertical levels (in coordinate of sub-family data)
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !  std1                   See std_type for usage (dependent on vertical level)
     !  std2                   See std_type for usage (independent of vertical level)
     !  std3                   See std_type for usage (independent of vertical level)

     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),std_type(:),n_lat(:)
     integer, allocatable :: brp(:),ibegin(:),n_lvl(:)
     real(8), allocatable :: std1(:),std2(:),std3(:)
     real(8), allocatable :: levels(:),lat(:)

  end type struct_chm_std
  
  type :: struct_chm_info
     !  Information arrays retrieved from file obsinfo_chm regarding vertical levels 
     !  or averaging kernels
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files for constant number
     !                            of vertical levels (may be adjusted after input)
     !  vco                    Vertical coordinate type (1, 2, or 3, see bufr_read_mod)
     !
     !  ibegin                 Position index of start of data for given
     !                         sub-family.
     !  n_lvl                  Number of vertical levels 
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !
     !  vlayertop              Layer top 
     !  vlayerbottom           Layer bottom
     !  rak                    Averaging kernel matrices
     
     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),brp(:)
     integer, allocatable :: vco(:),n_lat(:)
     integer, allocatable :: ibegin(:),n_lvl(:)
     real(8), allocatable :: rak(:),vlayertop(:),vlayerbottom(:)
     real(8), allocatable :: lat(:)
  
  end type struct_chm_info

  type :: struct_chm_obsoperators  
  
     !  Structure holding work variables for observation operators
     !     
     !  Variable               Description
     !  --------               -----------
     !  nobslev                Number of observations in the profile
     !  nmodlev                Number of model levels in the column
     !  varno                  BUFR descriptor element for obs units
     !  constituent_id         BUFR code element of local GRIB Table 08046 identifying the constituent
     !                         (similar to BUFR Table 08043)
     !  modelIndex             Obs operator index
     !                         0 - vertical interpolator
     !                         1 - layer averaging
     !                         2 - layer integration
     !  layer_identified       .true. if a layer (with identified layer boundaries)
     !                         .false if layer boundaries are not available.
     !  vmodpress              Model layer boundaries taken as middle between model level
     !  vlayertop              Layer top (final work values in Pa)
     !  vlayerbottom           Layer bottom (final work values in Pa)
     !  vweights               Second order Lagrangian interp integration weights
     !  zh                     Initial innovation model array (other than conversion constants)
     !  zhp                    Part of innovation operator not related to resolution.
     !  lvl_top                Top level of non-zero values in zh
     !  lvl_bot                Bottom level of non-zero values in zh
     !  trial                  Trial (background) profile at observation location
     !  tt                     Temperature profile on model levels (Kelvin)
     !  hu                     Specific humidity 
     !  gz                     Geopotential height on model levels (m)
     !  pp                     Pressure on model levels (Pa)
     !  lat                    Latitude of observation (radians)
     !  lon                    Longitude of observation (radians)
     !  obslev                 Observation profile level values (OBS_PPP)
     !  varName                Variable/obs nomvar
     !  stnid                  Observation station ID
     !  date                   YYYYMMDD (date of obs)
     !  hhmm                   HHMM (time of obs)
     !  obs_index              Observation index
     !                         Note: Depending on the data of interest, the index of a required array element or 
     !                               profile associated to an observation can be identified from (lat,long,date,hhmm,
     !                               optional task-dependent identifier if needed) or obs_index. 
     !                               The latter is for associations of data identified within
     !                               processing of individual CPUs. Each of the two index identifiers is represented 
     !                               by the unique character string identifier 'code' of struct_chm_obsdata
     !                               (e.g. see obsdata_get_loctime_code_r for use of (lat,long,date,hhmm)).
     !  vco                    Index of vertical coord type for obs
     !                           1 - Altitudes (m)
     !                           2 - Pressure (Pa)
     !                           3 - Channel index
     !                           4 - not provided with obs. Obs is for total column values.
     !                           5 - not provided with obs. Obs is a surface point value.
     !  iavgkern               Integer indicating if averaging kernels are to be applied. Value
     !                         of zero indicates no averaging kernel to be applied. Non-zero value
     !                         indicates index in chm_avgkern,chm_burp_avgkern arrays.
     !  apply_genoper          Indicates if the generalized observation operator should be applied
     !  column_bound           Boudary imporsed on a column measurement
     !  dtransform             Derivative for any transform that needs to be applied to a profile
     
     integer :: nobslev,nmodlev,modelIndex,constituent_id,vco,varno,date,hhmm,iavgkern,obs_index
     logical :: layer_identified,apply_genoper
     real(8) :: lat,lon,column_bound
     character(len=12) :: stnid
     character(len=4)  :: varName
     real(8), allocatable :: vlayertop(:),vlayerbottom(:),vmodpress(:),tt(:),gz(:),pp(:)
     real(8), allocatable :: zh(:,:),zhp(:,:),vweights(:,:),obslev(:),dtransform(:),hu(:)
     real(8), pointer     :: trial(:)
     integer, allocatable :: lvl_top(:),lvl_bot(:)

  end type struct_chm_obsoperators

  type :: struct_chm_obsdata

     !  Structure storing information associated to observations such
     !  as BURP file reports (irep) either retrieved from BURP files 
     !  themselves or from other sources.  
     !     
     !  Variable               Description
     !  --------               -----------
     !  ndim                   number of dimensions of the data arrays
     !                         (i.e. ndim=1 for std and ndim=2 for averaging kernels)
     !  nrep                   number of reports or observations
     !  dim1                   first array dimension for each  report/observation
     !  dim2                   second array dimension for each  report/observation (only relevant for ndim=2)
     !  data1d                 obs data of dimension (dim1,nrep)
     !  data2d                 obs data of dimension (dim1,dim2,nrep)
     !  irep                   current report position
     !  code                   unique character string for identifying the report/observation
     !
     !  Follow-up to be made: modify dim1 and dim2 as pointer arrays dependent on irep
     !
     
     real(8), pointer :: data1d(:,:),data2d(:,:,:)
     character(len=code_len), pointer :: code(:)
     integer :: ndim,nrep,dim1,dim2,irep
  
  end type struct_chm_obsdata

  type :: struct_chm_griddata

     !  Structure storing gridded fields 
     !     
     !  Variable               Description
     !  --------               -----------
     !  field2d                Gridded 2 field
     !  field3d                Gridded 3 field (lon,lat,vlev)
     !  nlat                   number of latitudes
     !  nlon                   number of longitudes
     !  nlev                   number of vertical levels
     !  lat,lon                grid lat,lon in radians
     !  vlev                   vertical levels
     !  ivkind                 Index of vertical coordinate type. Defintion may vary according to source.
     !                         For fields read for RPN files and use of convip:
     !                             0: P is in height [m] (metres) with respect to sea level 
     !                             1: P is in sigma [sg] (0.0 -> 1.0) 
     !                             2: P is in pressure [mb] (millibars) 
     !                             3: P is in an arbitrary code 
     !                             4: P is in height [M] (metres) with respect to ground level 
     !                             5: P is in hybrid coordinates [hy] 
     !                             6: P is in theta [th] 
     !                         For use with obs                      
     
     real(8), pointer :: field2d(:,:),field3d(:,:,:),lat(:),lon(:),vlev(:)
     integer :: nlev,nlon,nlat,ivkind
  
  end type struct_chm_griddata

  type :: struct_chm_diagn

     ! Structure for storing observation-space diagnostic arrays
     !
     ! Real arrays indexed by (lat,lon,lev,stat), where stat=1 for RMS and stat=2 for mean for all except Jo_stats.
     ! For Jo_stats, stat=1 is Jo for x=x_analysis and stat=2 is Jo for x=x_background.
     ! The array counts is indexed by (lat,lon,lev).
     ! The array status_count is indexed (lat,lon,lev,status), where the status number ranges from 0 to 2.
     !     
     !  Variable               Description
     !  --------               -----------
     !  OmP_stats              obs - background statistics
     !  OmA_stats              obs - analysis statistics
     !  obs_stats              observation statistics
     !  Jo_stats               cost function statistics
     !  diagR_stats            Elements for the calc of time_mean{[(O-P)-mean(O-P)][(O-A)-mean(O-A)]} 
     !                         (with each O-P and O-A difference divided by sigma_obs)
     !                         for scaling factor adjustments of obs std. dev via the Desroziers approach.
     !  diagHPHT_stats         Elements for the calc of time_mean{[(O-P)-mean(O-P)][[(O-P)-mean(O-P)]-[(O-A)-mean(O-A)]]}
     !                         (with each O-P and O-A difference divided by sqrtHPHT)
     !                         for scaling factor adjustments of background std. dev. in obs space via the Desroziers approach.
     !  counts                 number of observations in a (lat,lon,lev) bin
     !  nlat                   number of latitude levels
     !  nlon                   number of longitude levels
     !  nlev                   number of vertical levels
     !  nbin                   total number of (lat,lon,lev) bins
     !  nstat                  number of different statistics types
     !  nstatus                indicates the number of observations with a certain status,
     !                         with status values denoting:
     !                           0 - observation has been rejected and not included for diagnostics
     !                           1 - observation has been assimilated
     !                           2 - observation has been used for diagnostics only (not assimilated)
     !  deltaLat               latitude bin size (deg)
     !  deltaLon               longitude bin size (deg)
     !  deltaLogPressure       vertical bin size in log(pressure)
     !  allow_print_summary    indicates is printing of summary diagnostics is allowed
     !  assim_mode             indicates if assimilation was performed for this dataset

     real(8), allocatable :: OmP_stats(:,:,:,:),OmA_stats(:,:,:,:),obs_stats(:,:,:,:),Jo_stats(:,:,:,:)
     real(8), allocatable :: diagR_stats(:,:,:,:),diagHPHT_stats(:,:,:,:)
     integer, allocatable :: counts(:,:,:),nstatus(:,:,:,:)
     
     integer :: nlev,nlat,nlon,nbin,nstat
     real(8) :: deltaLat,deltaLon,deltaLogPressure
     logical :: allow_print_summary,assim_mode

  end type struct_chm_diagn

  type :: struct_config
     
     !  Structure to store general config information.
     !     
     !  Variable               Description
     !  --------               -----------
     !  generalized_operator   Flag indicatting if generalized observation operator should be used 
     !                         and selection of approach
     !
     !                            <=0: not applied
     !                            1: use trial field xb for mass weighted increment distribution
     !                            2: use a combination of the difference of an external reference xc 
     !                               and the trial field xb, i.e. mass weighted increment distribution 
     !                               as a(xc-xb) + b*xc where a and b depend on the size of 
     !                               sum[(xc-xb)/sig(xb)]^2 over the profile.
     !
     !  assim_num              Number of combinations (stnid, bufr element, multi/uni-level) 
     !                         identified for obs to be assimilated. All others will not
     !                         be assimilated. OmP and OmA diagnostics and output
     !                         will still be produced for non-assimilated datasets.
     !                         (see routines chm_diagn_only, oonl_chm in obsoperators_mod.ftn90)
     !
     !                           <0:  all are to be assimilated
     !                            0:  none are to be assimilated
     !                           >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
     !
     !  assim_varno            Bufr elements of obs sets for assimilation. A value of
     !                         0 implies that all are to be used.
     !
     !  assim_stnid            Stnids of obs sets for assimilation. '*' denote wild cards
     !       
     !  assim_nlev             0:  multi-level and uni-level
     !                         1:  uni_level
     !                         >1: multi-level 
     !
     !  diagn_pressmin         Bottom of top layer for diagnostics (in Pa).
     !
     !  diagn_save             Logical indicating gridded diagnostics are to be saved
     !                         in an ascii file in addition to overall diagnostics. 
     !                         (see routine chm_obsspace_diagnostic)
     !
     !  amu                    Molecular mass of constituents in g/moles (needed for unit conversions)
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent.
     !
     !  tropo_mode             Integer indicating if special treatment is to be given to the troposphere
     !                         when assimilating total column measurements. Values indicate
     !                           0:  No special treatment given (default)
     !                           1:  Values of the adjoint model above obsoper%column_bound set to zero.
     !                               If specified, generalized innovation operator only applied below
     !                               obsoper%column_bound in the tangent linear model.
     !                           2:  Values of tangent linear model and adjoint model above 
     !                               obsoper%column_bound set to zero.
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent. Relevant for total column measurements only.
     !                         
     !  tropo_bound            Integer indicating which column top value to use if tropo_mode is non-zero.
     !                           0: Use fixed value of tropo_column_top
     !                           1: Use model determination of tropopause
     !                           2: Use model determination of PBL
     !                         Options 1 and 2 will default to the value set in tropo_column_top if the model
     !                         derived column top could not be determined. Relevant for total column measurements only.
     !             
     !  tropo_column_top       Default value to use for the column boundary (in Pa). Array index refers to BUFR code
     !                         element of Table 08046 (obsoper%constituent_id) identifying the constituent. 
     !                         Relevant for total column measurements only.
     !
     !  obsdata_maxsize        Max allowed size of work arrays (in terms of number of obs) associated to
     !                         ordered observation indices
     !
     !  low_cutoff             min value allowed for increments prior to storage in rebm expressed as a fraction
     !                         of the background field (generally < 1)
     !
     !  high_cutoff            max value allowed for increments prior to storage in rebm expressed as a multiple
     !                         of the background field (generally > 1)
     !
     !  transform              Index specifying form of analysis increment (and related adjoint operation)
     !                         0: no transformation (dx given input trial field denoted as x)
     !                         1: dlnx
     !
     !  message_filename       File name for file containing various messages and warnings related to chemical
     !                         constituents that are not included in the listing file.
     !
     !  obsspace_diagn_filename  File name for file containing obs space diagnostics related to chemical
     !                           constituents.
     !
     
     logical :: diagn_save
     integer :: generalized_operator(0:chm_constituents_size)
     integer :: assim_num,tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
     integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size)
     integer :: obsdata_maxsize 
     integer :: transform(0:chm_constituents_size)
     real(8) :: diagn_pressmin
     real(8) :: amu(0:chm_constituents_size),tropo_column_top(0:chm_constituents_size)
     real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)
     character(len=9) :: assim_stnid(chm_cfg_size)
     character(len=50) :: message_filename,obsspace_diagn_filename 

  end type struct_config

  type(struct_chm_info) :: chm_layers
  type(struct_chm_info) :: chm_avgkern
  type(struct_chm_std)  :: chm_std
  type(struct_config)   :: chm_config

! Array of pointers to hold std's/averaging kernels read from BURP file.
! Note: Ideally, these should be an element in the 'struct_chm_std' /
! 'struct_chm_info' derived types, but currently this results
! in an internal compiler error.

  type(struct_chm_obsdata), allocatable :: chm_burp_std(:),chm_burp_avgkern(:)

! Arrays for integration upper boundary of retrieved total column measurements 
  type(struct_chm_obsdata) :: chm_column_boundary

! Arrays to contain the calculated concentration-weighted effective temperature
! associated to total column data. It will be stored in the observation file.
  type(struct_chm_obsdata) :: chm_efftemp

! Arrays for background error std. dev.
  type(struct_chm_obsdata) :: chm_sigma_trial

! Arrays containing input reference fields and also reference fields 
! interpolated to obs locations

  type(struct_chm_obsdata)  :: chm_ref_trial
  type(struct_chm_griddata) :: chm_ref_fields(0:chm_constituents_size,2)

! Unit number for chm_config%message_filename
  integer :: chm_message_unit

contains

!---------------------------- Setup called from "preproc/suobs" -------------------------

  subroutine chm_setup(datestamp)
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: M. Sitwell, Feb 2015
!            - Removed references to earlier structure
!            Y. Rochon, Dec 2015
!            - Added call to chm_read_ref_fields and related optional input
!              'datestamp'
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData.
!
!----------------------------------------------------------------------------------------
  
  implicit none

  integer, intent(in), optional :: datestamp

  write(*,*) 'Begin chm_setup'

! Read miscellaneous flags and constants 

  call chm_read_misc
      
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_read_layers
      
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_layers
   
! Read averaging kernel matrices
  
  call chm_read_avgkern
  
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_avgkern
  
 ! Read reference (e.g. climatological) fields
  
  if (present(datestamp)) then
     call chm_read_ref_fields(datestamp)
  else
     call chm_read_ref_fields
  end if

! Allocation of chm_efftemp done in chm_setup instead of obsdata_add_data1d
! to ensure allocation is done for all processors, including those without associated data.
! This is to ensure that rpn_comm_allgather will work in routine obsdata_MPIGather.

  if (.not.associated(chm_efftemp%data1d)) then
      call obsdata_alloc(chm_efftemp,chm_config%obsdata_maxsize,dim1=1)
      chm_efftemp%nrep=0
  end if

  write(*,*) 'Completed chm_setup'
  
  end subroutine chm_setup

!------------------------------------------------------------------------------------

  subroutine chm_read_misc
!
! Author   : Y. Rochon, ARQI/AQRD, Apr 2015 
!
! Purpose: Read and store miscellaneous flags and constants.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Aug 2015
!            - Incorporated input fields in chm_config
!            Y. Rochon, ARQI/AQRD, Sept 2015
!            - Added reading of variables related to options for attributing only 
!              tropospheric portion of the increment to total column observations
!            M. Sitwell, ARQI/AQRD, Oct 2015
!            - Moved amu from obsinfo_chm to namelist namchem    
!
! Output:
!
!   Read from NAMCHEM namelist
!
!        genoper             If generalized observation operator should be used and selection of approach
!                            <=0: not applied
!                            1: use trial field xb for mass weighted increment distribution
!                            2: use a combination of the difference of an external reference xc 
!                               and the trial field xb, i.e. mass weighted increment distribution 
!                               as a(xc-xb) + b*xc where a and b depend on the size of 
!                               sum[(xc-xb)/sig(xb)]^2 over the profile.
!
!        diagn_num           Prescribed (starting) number of (stnid, bufr, nlev) for the diagnostics calc
!
!        diagn_stnid         Prescribed (starting) list of stnid (with *s as needed) for the diagnostics calc
!                            with '*' denoting wild cards
!
!        diagn_varno         Prescribed (starting) list of bufr elments for the diagnostics calc
!
!        diagn_unilev        Prescribed (starting) list of logicals indicating uni-level obs for the diagnostics calc
!
!        diagn_pressmin      Bottom of top layer for diagnostics (in Pa).
!
!        diagn_save          Logical indicating gridded diagnostics are to be saved
!                            in an ascii file in addition to overall diagnostics. 
!
!        diagn_nset          Integer indicating grouping of diagnostics with
!                            1: group by stnid
!                            2: group by (stnid,bufr)
!                            3: group by (stnid,bufr,nlev)
!
!        diagn_all           Logical indicating if all combinations specified by diagn_nset are to be
!                            used in diagnostics or only those specified by the diagn_* arrays
!
!        assim_num           Number combinations (stnid, bufr element, multi/uni-level) 
!                            identified for assimilation. All others will not
!                            be assimilated. OmP and OmA diagnostics and output
!                            will still be produced for non-assimilated datasets.
!                         
!                            <0:  all are to be assimilated
!                             0:  none are to be assimilated
!                            >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
!
!        assim_varno         Bufr elements of obs sets for assimilation. A value of
!                            0 implies that all are to be used.
!
!        assim_stnid         Stnids of obs sets for assimilation. '*' denote wild cards
!
!        assim_nlev           0:  multi-level and uni-level
!                             1:  uni_level
!                            >1: multi-level 
!
!        tropo_mode          Integer indicating if special treatment is to be given to the troposphere
!                            when assimilating total column measurements. Values indicate
!                             0:  No special treatment given (default)
!                             1:  Values of the adjoint model above obsoper%column_bound set to zero.
!                                 If specified, generalized innovation operator only applied below
!                                 obsoper%column_bound in the tangent linear model.
!                             2:  Values of tangent linear model and adjoint model above
!                                 obsoper%column_bound set to zero.
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent. Relevant for total column measurements only.
!
!        tropo_bound         Integer indicating which column top value to use if tropo_mode is non-zero.
!                              0: Use fixed value of tropo_column_top
!                              1: Use model determination of tropopause
!                              2: Use model determination of PBL
!                            Options 1 and 2 will default to the value set in tropo_column_top if the model
!                            derived column top could not be determined. Relevant for total column measurements only.
!                         
!        tropo_column_top    Default value to use for the column boundary (in Pa). Array index refers to BUFR code
!                            element of Table 08046 (iconstituent_id) identifying the constituent.
!                            Relevant for total column measurements only.
!
!        amu                 Molecular mass  of constituents in g/moles (needed for unit conversions)
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent.
!
!       obsdata_maxsize      Max allowed size of work arrays (in terms of number of obs) associated to
!                            ordered observation indices
!
!       low_cutoff           min value allowed for increments prior to storage in rebm expressed as a fraction
!                            of the background field (generally < 1)
!
!       high_cutoff          max value allowed for increments prior to storage in rebm expressed as a multiple
!                            of the background field (generally > 1)
!
!       transform            Index specifying form of analysis increment (and related adjoint operation)
!                              0: no transformation (dx given input trial field denoted as x)
!                              1: dlnx
!
!       message_filename     File name for file containing various messages and warnings related to chemical
!                            constituents that are not included in the listing file.
!
!       message_unit         Unit number corresponding to message_filename
!
!       obsspace_diagn_filename 
!                            File name for file containing obs space diagnostics related to chemical constituents.
!
!---------------------------------------------------------------------------------------- 
 
  use mpi_mod, only: mpi_myid

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JELM, nulstat, ios, isize, nulnam, i
  integer :: genoper(0:chm_constituents_size)
  
  character(len=128) :: ligne  
  character(len=10)  :: namfile 

  integer :: assim_num,diagn_num,diagn_nset,obsdata_maxsize
  integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size)
  integer :: diagn_varno(chm_cfg_size),tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
  character(len=9) :: assim_stnid(chm_cfg_size),diagn_stnid(chm_cfg_size)
  logical :: diagn_save,diagn_all,diagn_unilev(chm_cfg_size)
  real(8) :: diagn_pressmin,tropo_column_top(0:chm_constituents_size)
  real(8) :: amu(0:chm_constituents_size)
  real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)
  integer :: transform(0:chm_constituents_size)
  character(len=50) :: message_filename,obsspace_diagn_filename

  EXTERNAL FNOM,FCLOS

  namelist /namchem/ genoper, &
                     assim_num,assim_stnid,assim_varno,assim_nlev,     &
                     diagn_num,diagn_stnid,diagn_varno,diagn_unilev,   &
                     diagn_save,diagn_all,diagn_nset,diagn_pressmin,   &
                     tropo_mode,tropo_bound,tropo_column_top,amu,      &
                     low_cutoff,high_cutoff,transform,obsdata_maxsize, &
                     message_filename,obsspace_diagn_filename

  
  ! Default NAMCHEM values
  
  genoper(:)=0
  obsdata_maxsize=90000
  low_cutoff(:)=0.1
  high_cutoff(:)=10.0
  transform(:)=0
  
  assim_num=-1  
  assim_stnid(:)='*********'
  assim_varno(:)=0
  assim_nlev(:)=0
 
  diagn_save=.false.
  diagn_all=.true. 
  diagn_pressmin=10.  !  0.1 hPa
  diagn_nset=2
  diagn_num=0
  diagn_stnid(:)='*********'
  diagn_varno(:)=0
  diagn_unilev(:)=.false.

  tropo_mode(:) = 0
  tropo_bound(:) = 0
  tropo_column_top(:) = 0.0

  message_filename = 'chem_message_'
  obsspace_diagn_filename ='obsspace_diag_CH_'
  
  amu(:) = -1.0
  amu(0) = 48.0    ! Molecular mass in g/mole for O3
  amu(1) = 18.02   ! H2O
  amu(2) = 16.04   ! CH4
  amu(3) = 44.01   ! CO2
  amu(4) = 28.01   ! CO
  amu(5) = 46.01   ! NO2
  amu(6) = 44.01   ! N2O
  amu(7) = 30.03   ! HCHO=Formaldehyde
  amu(8) = 64.06   ! SO2
  amu(9) = 17.03   ! NH3
  amu(11) = 30.0   ! NO
  amu(26) = 1.0    ! PM2.5 - Not applicable
  amu(27) = 1.0    ! PM10  - Not applicable

  ! Read from namelist file NAMCHEM

  namfile=trim("flnml")
  nulnam=0
  ierr=FNOM(nulnam,namfile,'R/O',0)

  read(nulnam,nml=namchem,iostat=ios)
  if (ios.lt.-4.or.ios.gt.0) then 
     call abort3d('chm_read_misc: Error in reading NAMCHEM namelist. iostat = ' // trim(str(ios)) )
  else if (mpi_myid.eq.0) then
     write(*,nml=namchem)   
  end if
  
  ierr=FCLOS(nulnam)      
  
  ! Set config values

  chm_config%generalized_operator(:) = genoper(:)
  chm_config%assim_num = assim_num
  chm_config%assim_varno = assim_varno
  chm_config%assim_stnid = assim_stnid
  chm_config%assim_nlev = assim_nlev 
  chm_config%diagn_pressmin = diagn_pressmin
  chm_config%diagn_save = diagn_save
  chm_config%tropo_mode = tropo_mode
  chm_config%tropo_bound = tropo_bound
  chm_config%tropo_column_top = tropo_column_top
  chm_config%amu = amu
  chm_config%obsdata_maxsize = obsdata_maxsize
  chm_config%low_cutoff = low_cutoff
  chm_config%high_cutoff = high_cutoff
  chm_config%transform = transform
  chm_config%message_filename = message_filename
  chm_config%obsspace_diagn_filename = obsspace_diagn_filename
  
  ! Initialize chm_comboIDlist and add (stnid,varno) pairs from the namelist

  call chm_comboIdlist(initialize=.true., nset=diagn_nset, all_combos=diagn_all)
  do jelm=1,diagn_num
     call chm_comboIdlist(stnid_add=diagn_stnid(jelm), varno_add=diagn_varno(jelm), unilev_add=diagn_unilev(jelm))
  end do

  end subroutine chm_read_misc

!-----------------------------------------------------------------------------------------
!--------------------- Routines related to layer top & bottom levels----------------------

  subroutine chm_read_layers
!
! Author   : Y. Rochon, ARQI/AQRD, Dec 2014 
!            - Partially based on oer_read_obs_erreurs_conv.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Feb 2015
!            - Renaming of routine and removal of lines no longer required.
!          
! Purpose: Read and store top and bottom layer boundaries for CH sub-families
!
! Comments:
!
! A) The option of reading from BURP files is TBD. This will change the approach in allocating
!    the arrays size as the sizes will become dependent on the number of related obs for
!    which the BURP files will need to be read.
!----------------------------------------------------------------------------------------

  use bufr

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS
  
! Initialization

  chm_layers%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_layers: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_layers%stnids(chm_layers%n_stnid))
  allocate(chm_layers%vco(chm_layers%n_stnid))
  allocate(chm_layers%brp(chm_layers%n_stnid),chm_layers%ibegin(chm_layers%n_stnid))
  allocate(chm_layers%bfr(chm_layers%n_stnid),chm_layers%n_lvl(chm_layers%n_stnid))
  allocate(chm_layers%vlayertop(isize),chm_layers%vlayerbottom(isize))
 
  chm_layers%bfr(:)=0
  chm_layers%vco(:)=0
  chm_layers%brp(:)=0
  chm_layers%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_layers%n_stnid
    chm_layers%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_layers%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%bfr(jelm),chm_layers%vco(jelm),  &
       chm_layers%brp(jelm),chm_layers%n_lvl(jelm)  
    
    if (icount+chm_layers%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_layers%n_lvl(jelm).ge.1) then   
       do jlev=1,chm_layers%n_lvl(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_layers%vlayertop(icount),chm_layers%vlayerbottom(icount)
       end do
    end if

!    if (chm_layers%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_layers

!-----------------------------------------------------------------------------------------

  subroutine chm_get_layer_boundaries(cstnid,varno,ivco,nlev,default_top,default_bottom, &
                                      lfound,layertop,layerbottom)
!
! Author  : M. Sitwell, Y. Rochon, Feb 2015
! Revision: 
!
! Purpose: Return layer boundaries for an observation. Combination of STNID, BUFR element
!          and number of vertical levels to determine association to the observations.
!          Default values for top and bottom layers for total column measurements are to
!          be provided.
!
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - ivco            type of vertical coordinate (see burp_read_mod.ftn90 or
!                     routine chm_obsoperators for definitions)
!   - nlev            number of levels in the observation
!   - default_top     default value for top layer for total column measurement
!   - default_bottom  default value for bottom layer for total column measurement
!
! Outputs:
!   - lfound          Logical being .true. if layer boundaries found.
!   - layertop        top layer values
!   - layerbottom     bottom layer values
! ---------------------------------------------------------------------------------------

    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in)           :: varno,ivco,nlev
    real(8), intent(in)           :: default_top,default_bottom
    real(8), intent(out)          :: layertop(nlev),layerbottom(nlev)
    logical, intent(inout)        :: lfound
    integer                       :: ISTNID,JN,start_index
    logical                       :: iset


    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0
    lfound=.false.

    DO JN=1,chm_layers%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_layers%stnids(JN) as wildcards
       iset = stnid_equal(chm_layers%stnids(JN),CSTNID)

       ! Check if number of levels, code, and vertical coordinate type are equal.
       ! If number of levels is one and no vertical coordinate provided for total column measurement (i.e. IVCO.eq.4),
       ! then check of vertical coordinate type is disregarded afterwards.
       IF (iset) THEN
          IF ( varno.EQ.chm_layers%bfr(JN) .AND. NLEV.EQ.chm_layers%n_lvl(JN) .AND. &
              (IVCO.EQ.chm_layers%vco(JN).OR.IVCO.EQ.4) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

    IF (ISTNID.EQ.0) THEN
       ! If integrated layer information not found, if a total column measurement
       ! set to defaults, else do nothing

       if (chm_checkfor_integlayer(varno) .and. nlev.eq.1) then          
          lfound=.true.
          layertop(1) = default_top
          layerbottom(1) = default_bottom
       end if

    ELSE
       ! layer information has been found in ascii file
       lfound=.true.
       start_index = chm_layers%ibegin(ISTNID)
       layertop(:) = chm_layers%vlayertop(start_index:start_index+nlev-1)
       layerbottom(:) = chm_layers%vlayerbottom(start_index:start_index+nlev-1)  
    END IF

  end subroutine chm_get_layer_boundaries


!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_layers
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for layer info
!
! ---------------------------------------------------------------------------------------

    implicit none

    if (chm_layers%n_stnid.eq.0) return

    call chm_dealloc_info(chm_layers)
 
  end subroutine chm_dealloc_layers

!-----------------------------------------------------------------------------------------
!-------------------- Routines related averaging kernel matrices -------------------------
  
  subroutine chm_read_avgkern
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Revision: 
!
! Purpose:  Read averaging kernels from ascii file and BURP file if specified in ascii file
!
! Comments:
!
! - Filename 'brpch' currently hardcoded should ideally be the filename for the CH family 
!   identified from the list of input filenames.
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the averaging kernel information from the ascii file
    call chm_read_avgkern_ascii

    ! set size of BURP file array
    allocate(chm_burp_avgkern(chm_avgkern%n_stnid))

    ! read from BURP file
    do istnid=1,chm_avgkern%n_stnid
       if (chm_avgkern%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_avgkern(istnid) = chm_read_burp('brpch', chm_avgkern%stnids(istnid), &
               15044, chm_avgkern%n_lvl(istnid), 2, 14, 'DATA', match_nlev=.true.)
          
       end if
    end do

  end subroutine chm_read_avgkern

!----------------------------------------------------------------------------------------

  subroutine chm_read_avgkern_ascii
!
! Author   : Y. Rochon, M. Sitwell, ARQI/AQRD, Feb 2015 
!            - Currently implemented for only one latitude band
!
! Revisions: 
!          
! Purpose: Read and store averaging kernel matricesfor CH sub-families
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_avgkern%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '--------------------------------------------------'
    WRITE(*,*)   'chm_read_avgkern_ascii: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '--------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_avgkern_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:14))).ne.'SECTION III:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_avgkern%stnids(chm_avgkern%n_stnid))
  allocate(chm_avgkern%brp(chm_avgkern%n_stnid),chm_avgkern%ibegin(chm_avgkern%n_stnid))
  allocate(chm_avgkern%bfr(chm_avgkern%n_stnid),chm_avgkern%n_lvl(chm_avgkern%n_stnid))
  allocate(chm_avgkern%rak(isize))
 
  chm_avgkern%bfr(:)=0
  chm_avgkern%brp(:)=0
  chm_avgkern%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=1
  STNIDLOOP: do jelm=1,chm_avgkern%n_stnid
    chm_avgkern%ibegin(jelm)=icount

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_avgkern%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Flag indication if avgkern provided from this ascii file or
!            to be read from the BURP file,
!        (3) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%bfr(jelm),  &
       chm_avgkern%brp(jelm),chm_avgkern%n_lvl(jelm)  
    
    if (icount+chm_avgkern%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! disregard data section if values to be specified in BUFR file
    if (chm_avgkern%brp(jelm).eq.1) cycle STNIDLOOP
    
    if (chm_avgkern%n_lvl(jelm).gt.1) then   
       do jlev=1,chm_avgkern%n_lvl(jelm)

          iend=icount+chm_avgkern%n_lvl(jelm)-1

          ! Read averaging kernel matrix   
          read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%rak(icount:iend)

          icount=iend+1

       end do
    end if

 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_avgkern_ascii: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_avgkern_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_avgkern
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for averaging kernels
!
!---------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    if (chm_avgkern%n_stnid.eq.0) return

    if (allocated(chm_burp_avgkern)) then
       do istnid=1,chm_avgkern%n_stnid
          if (chm_avgkern%brp(istnid).eq.1) call obsdata_dealloc(chm_burp_avgkern(istnid))
       end do
       deallocate(chm_burp_avgkern)
    end if

    call chm_dealloc_info(chm_avgkern)
  
  end subroutine chm_dealloc_avgkern

!-----------------------------------------------------------------------------------------

  function chm_find_avgkern(cstnid,varno,nlev) result(ISTNID)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Finds the averaging kernel for an observation if one is specified. Returns 0 if
!          either not found or not specified. Combination of STNID, BUFR element and number
!          of vertical levels to determine association to the observations.
!          
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - nlev            number of levels in the observation
!
! Returns:
!   - ISTNID          Index of averaging kernel in chm_avgkern if found. Zero indicates
!                     averaging kernel not found.
! ---------------------------------------------------------------------------------------
    
    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in) :: varno,nlev
    integer :: ISTNID,JN
    logical :: iset

    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0

    DO JN=1,chm_avgkern%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_avgkern%stnids(JN) as wildcards
       iset = stnid_equal(chm_avgkern%stnids(JN),CSTNID)

       ! Check if number of levels and BUFR code are equal.
       IF (iset) THEN
          IF ( varno.EQ.chm_avgkern%bfr(JN) .AND. NLEV.EQ.chm_avgkern%n_lvl(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

  end function chm_find_avgkern

!-----------------------------------------------------------------------------------------

  subroutine chm_get_avgkern(istnid,nlev,zlat,zlon,idate,itime,avg_kern)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Return averaging kernel for an observation.
!
! Inputs:
!   istnid          index of averaging kernel in chm_avgkern
!   nlev            number of observation levels
!   idate           YYYYMMDD
!   itime           HHMM
!
! Outputs:
!   avg_kern        the averaging kernel
!---------------------------------------------------------------------------------------

    implicit none

    integer, intent(in)  :: istnid,nlev,idate,itime
    real(8), intent(in)  :: zlat,zlon
    real(8), intent(out) :: avg_kern(nlev,nlev)
    integer :: start_index,end_index

    if (istnid.gt.0 .and. istnid.le.chm_avgkern%n_stnid) then
       
       if (chm_avgkern%brp(istnid).eq.0) then
          ! get averaging kernel from ascii file
          start_index = chm_avgkern%ibegin(ISTNID)
          end_index = nlev*(start_index+nlev-1)
          avg_kern = RESHAPE(chm_avgkern%rak(start_index:end_index),(/nlev,nlev/),ORDER =(/2,1/))
       else
          ! get averaging kernel from BURP file
          avg_kern = obsdata_get_array2d(chm_burp_avgkern(istnid), obsdata_get_loctime_code(zlon,zlat,idate,itime))
       end if

    else
       call abort3d("chm_get_avgkern: Invalid station ID index.")
    end if

  end subroutine chm_get_avgkern

!-----------------------------------------------------------------------------------------
!-------------------------- Routines related to gridded reference fields  ----------------
  
  subroutine chm_read_ref_fields(datestamp)
!
! ****** NOT TESTED *********
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose:  Read reference fields as directed by the content of the ascii file obsinfo_chm.
!           Fields are provided in RPN/fst files specified in the obsinfo_chm file (with path and filename)
!
!           Reference fields can be in a separate RPN file with name provided by obsinfo_chm or in
!           monthly static background stats file (glbchemcov or bgcov; see 'isrc' below).
!
! Comments:
!
!     - Fields assumed to be of the same units as those of the corresponding input trial fields
!
!-----------------------------------------------------------------------------------------

    use varNameList_mod
    use MathPhysConstants_mod
    
    implicit none

    integer, intent(in), optional :: datestamp
    
    character(len=128) :: fname
    character(len=4) :: varName
    character(len=12) :: etiket
    integer :: i,id,nd,j,ndim,ijour,imonth,iday,itime,isrc
    real(8) :: day
    integer, external :: newdate
   
    integer, external :: FNOM, FCLOS
    integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
    logical :: LExists
    
    logical, parameter :: linterp=.true.
    
    integer :: ni, nj, nkeys, kind
    real(8), allocatable :: array1(:,:,:),array2(:,:,:),lvls(:),xlat(:),xlong(:) ! Allocated in chm_fst_read
  
    character (len=128) :: ligne

!   Initialize dimensions to zero

    chm_ref_fields(:,:)%nlon=0
    chm_ref_fields(:,:)%nlat=0
    chm_ref_fields(:,:)%nlev=1
    
    inquire(FILE='obsinfo_chm',EXIST=LExists)
    IF (.not.LExists )then
      WRITE(*,*)   '-----------------------------------------------------'
      WRITE(*,*)   'chm_read_ref_fields: COULD NOT FIND FILE obsinfo_chm!'
      WRITE(*,*)   '-----------------------------------------------------'
      return
    ENDIF

!   Check for file names containing ref fields

    NULSTAT=0
    IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
    IF ( IERR .EQ. 0 ) THEN
       open(unit=nulstat, file='obsinfo_chm', status='OLD')
    ELSE
       CALL ABORT3D('chm_read_ref_fields: COULD NOT OPEN FILE obsinfo_chm!')
    ENDIF

    ios=0
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    do while (trim(adjustl(ligne(1:14))).ne.'SECTION IV:') 
       read(nulstat,'(A)',iostat=ios,err=10,end=11) ligne
    end do    
    
!   Read number of constituents with associated input file(s)
   
    read(nulstat,*,iostat=ios,err=10,end=10) ndim
    if (ndim.le.0) go to 10
    
!   Initialization

    if (linterp.and.present(datestamp)) then
       ierr = newdate(datestamp,ijour,itime,-3)
       if (ierr<0) then
          Write(*,*) "Invalid datestamp ",datestamp,ijour,itime,ierr
          call abort3d('chm_read_ref_fields')
       endif
       imonth = MOD(ijour/100,100)
       iday = MOD(ijour,100)
       day=iday+itime*1.0D-8
       if (day.gt.15.) then
          day=day-15.0
       else
          day=day+15.0
       end if
    endif
    
!   Get needed fields for each file(s)

    do i=1,ndim 

!      Read id,nd,isrc. id: constituent code; nd: number of sets; 1 or 2;
!      isrc: 1 for fname being in obsinfo_chm, 0 for glbchemcov (or bgcov if glbchemcov not present) 
       
       read(nulstat,*,iostat=ios,err=10,end=10)
       read(nulstat,*,iostat=ios,err=10,end=10) id,nd,isrc    
       varName=vnl_varnameFromVarnum(0,id)

       if (isrc.eq.1) then
          read(nulstat,*,iostat=ios,err=10,end=10) fname
       else
         inquire(file='./glbchemcov',exist=LExists)
         if (LExists) then
            fname='./glbchemcov'
         else
            inquire(file='./bgcov',exist=LExists)
            if(LExists) then
              fname='./bgcov'
            else               
               call abort3d('chm_read_ref_fields: did not find file.')
            end if
          end if
       end if
       
       do j=1,nd
          read(nulstat,*,iostat=ios,err=10,end=10) etiket             
                           
          call chm_read_fst(trim(fname),varName,imonth,-1,etiket,ni,nj,array1,.true.,xlat,xlong,nkeys,lvls,kind)

          if (j.eq.1) then
              chm_ref_fields(id,1)%nlon=ni
              chm_ref_fields(id,1)%nlat=nj
              chm_ref_fields(id,1)%nlev=nkeys
              chm_ref_fields(id,1)%ivkind=kind   
                         
              allocate(chm_ref_fields(id,1)%field3d(ni,nj,nkeys))
              allocate(chm_ref_fields(id,1)%vlev(nkeys),chm_ref_fields(id,1)%lon(ni),chm_ref_fields(id,1)%lat(nj))
              
              chm_ref_fields(id,1)%lat(1:nj)=xlat(1:nj)*MPC_RADIANS_PER_DEGREE_R8
              chm_ref_fields(id,1)%lon(1:ni)=xlong(1:ni)*MPC_RADIANS_PER_DEGREE_R8
              where (chm_ref_fields(id,1)%lon(1:ni).lt.0.0) chm_ref_fields(id,1)%lon(1:ni)=2.0*MPC_PI_R8 + &
                                                            chm_ref_fields(id,1)%lon(1:ni)
              chm_ref_fields(id,1)%vlev(1:nkeys)=lvls(1:nkeys)              
          else
              chm_ref_fields(id,2)%nlon=ni
              chm_ref_fields(id,2)%nlat=nj
              chm_ref_fields(id,2)%nlev=nkeys
              chm_ref_fields(id,2)%ivkind=kind

              allocate(chm_ref_fields(id,2)%field3d(ni,nj,nkeys))
              allocate(chm_ref_fields(id,2)%vlev(nkeys),chm_ref_fields(id,2)%lon(ni),chm_ref_fields(id,2)%lat(nj))
              
              chm_ref_fields(id,2)%lat(1:nj)=xlat(1:nj)*MPC_RADIANS_PER_DEGREE_R8
              chm_ref_fields(id,2)%lon(1:ni)=xlong(1:ni)*MPC_RADIANS_PER_DEGREE_R8
              where (chm_ref_fields(id,2)%lon(1:ni).lt.0.0) chm_ref_fields(id,2)%lon(1:ni)=2.0*MPC_PI_R8 + &
                                                            chm_ref_fields(id,2)%lon(1:ni)
              chm_ref_fields(id,2)%vlev(1:nkeys)=lvls(1:nkeys)
          end if

          if (.not.linterp .or. (.not.present(datestamp))) then

             if (j.eq.1) then 
                 chm_ref_fields(id,1)%field3d(:,:,:) = array1(:,:,:)
             else
                 chm_ref_fields(id,2)%field3d(:,:,:) = array1(:,:,:)
             end if

          else

!            Following for interpolation as a function of days from mid-months.
             
             if (iday.gt.15) then
                 if (imonth.eq.12) then
                    call chm_read_fst(trim(fname),varName,1,-1,etiket,ni,nj,array2,.false.,xlat,xlong,nkeys,lvls,kind)
                else
                   call chm_read_fst(trim(fname),varName,imonth+1,-1,etiket,ni,nj,array2,.false.,xlat,xlong,nkeys,lvls,kind)
                end if
          
!               Linearly interpolate in time (approximately - assumes 30 day months)

                if (j.eq.1) then              
                   chm_ref_fields(id,1)%field3d(:,:,:) = (array1(:,:,:)*(30.0-day)+array2(:,:,:)*day)/30.0
                else
                   chm_ref_fields(id,2)%field3d(:,:,:) = (array1(:,:,:)*(30.0-day)+array2(:,:,:)*day)/30.0
                end if
             
             else if (iday.le.15) then
                if (imonth.eq.1) then
                   call chm_read_fst(trim(fname),varName,12,-1,etiket,ni,nj,array2,.false.,xlat,xlong,nkeys,lvls,kind)
                else
                   call chm_read_fst(trim(fname),varName,imonth-1,-1,etiket,ni,nj,array2,.false.,xlat,xlong,nkeys,lvls,kind)
                end if

!               Linearly interpolate in time (approximately - assumes 30 day months)

                if (j.eq.1) then
                   chm_ref_fields(id,1)%field3d(:,:,:) = (array2(:,:,:)*(30.0-day)+array1(:,:,:)*day)/30.0
                else
                   chm_ref_fields(id,2)%field3d(:,:,:) = (array2(:,:,:)*(30.0-day)+array1(:,:,:)*day)/30.0
                end if
             
             end if
          
          end if
 
          if (allocated(array1)) deallocate(array1)
          if (allocated(array2)) deallocate(array2)   
                 
       end do
    end do 
     
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_ref_fields: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    
    
  end subroutine chm_read_ref_fields
  
!-----------------------------------------------------------------------------------------
  
  subroutine chm_read_fst(fname,varName,iip2,iip3,etiketi,ni,nj,array,lgrid,xlat,xlong,nkeys,lvls,kind)
!
! ****** NOT TESTED *********
!
! Author  : Y. Rochon, ARQI/AQRD, Nov 2015
!
! Revision: 
!
! Purpose:  Read specified field from standard RPN/fst file.
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: iip2,iip3
    character(len=*), intent(in) :: varName,fname,etiketi
    logical, intent(in) :: lgrid
    integer, intent(out) :: ni, nj, nkeys, kind
    real(8), intent(out), allocatable :: array(:,:,:),lvls(:),xlat(:),xlong(:)

    integer, external :: fnom,fclos,fstouv,fstfrm,fstinl,fstlir,fstluk,fstprm
    
    real(4) :: lvl_r4
    
    logical :: Exists
    character(len=1) :: string
     
    integer, parameter :: iun=0
    integer :: i,ier

    integer, parameter :: maxkeys=1000
    integer :: keys(maxkeys),ini,inj,nk
    integer :: dateo, deet, npas, nbits, datyp
    integer :: ip1, ip2, ip3, swa, lng, dltf, ubc
    integer :: extra1, extra2, extra3
    integer :: ig1, ig2, ig3, ig4  
    character*1 clgrtyp
    character*2 cltypvar
    character*4 nomvar
    character*12 cletiket
    real(4), allocatable :: buffer(:,:)
    
!   Open file
    
    inquire(file=trim(fname),exist=Exists)
    if(.not.Exists) then
      write(*,*) 'File missing=',fname
      call abort3d('chm_read_fst_field: did not find file.')
    else
      ier=fnom(iun,trim(fname),'RND+OLD+R/O',0)
      ier=fstouv(iun,'RND+OLD')
    end if

!   Find reports in file for specified varName and iip3.

    ier = fstinl(iun,ni,nj,nk,-1,etiketi,-1,iip2,iip3,'',varName,keys,nkeys,maxkeys) 

    if(ier.lt.0.or.nkeys.eq.0) then
      write(*,*) 'Search field missing ',varName, ' from file ',fname
      call abort3d('chm_read_fst_field: did not find field.')
    else if (nk.gt.1) then
      write(*,*) 'Unexpected size nk ',nk,' for ',varName,' of file ',fname 
      call abort3d('chm_read_fst_field')      
    end if

    if (lgrid) then

!      Get lat and long if available.

       allocate(xlat(nj),xlong(ni),buffer(ni*nj,1))
       xlat(:)=-999.
       xlong(:)=-999.

       ier = fstprm(keys(1),dateo, deet, npas, ni, nj, nk, nbits,    &         
                    datyp, ip1, ip2, ip3, cltypvar, nomvar, cletiket, &
                    clgrtyp, ig1, ig2, ig3,                           &
                    ig4, swa, lng, dltf, ubc, extra1, extra2, extra3)  
    
       if (ni.gt.1) then
          ier=fstlir(buffer,iun,ni,inj,nk,ig1,ig2,ig3,'','>>')
          if (ier.ge.0) xlong(:)=buffer(1:ni,1) 
       end if
       if (nj.gt.1) then
          ier=fstlir(buffer,iun,ini,nj,nk,ig1,ig2,ig3,'','^^')
          if (ier.ge.0) xlat(:)=buffer(1:nj,1)     
       end if
       deallocate(buffer)
    
    end if 
    
!   Get field and vertical coordinate
    
    allocate(array(ni,nj,nkeys),buffer(ni,nj),lvls(nkeys))
   
    do i=1,nkeys
       ier=fstluk(buffer,keys(i),ni,nj,nk)
       array(:,:,i)=buffer(:,:)
      
       ier = fstprm(keys(i),dateo, deet, npas, ni, nj, nk, nbits,    &         
                    datyp, ip1, ip2, ip3, cltypvar, nomvar, cletiket, &
                    clgrtyp, ig1, ig2, ig3,                           &
                    ig4, swa, lng, dltf, ubc, extra1, extra2, extra3)  
               
       call convip(ip1,lvl_r4,kind,-1,string,.false.)
       lvls(i)=lvl_r4
    end do
    
    deallocate(buffer)
    
    ier=fstfrm(iun)  
    ier=fclos(iun)  

  end subroutine chm_read_fst

!----------------------------------------------------------------------------------------

  subroutine chm_set_reference_obsdata(obsoper)
!
! ***** NOT TESTED *****
!
! Author   : Y. Rochon, ARQI/AQRD May 2016
!
! Purpose: Determine and store reference profile at obs location if needed by
!          the observation operators.
!
! Arguments:
!
!   Input
!
!      obsoper%constituent_id  Constituent id
!      obsoper%nmodlev         Number of model levels for variables other than uu and vv
!      obsoper%pressmod        Model pressure array
!      obsoper%tt              Model temperature (Kelvin)
!      obsoper%gz              Model geopotential height (m)
!      obsoper%hu              Specific humidity 
!      obsoper%lat             Latitude (rad)
!      obsoper%lon             Longitude (rad)
!
!   Output
!
!      chem_ref_obsdata        Reference profile structure
!
!   Comments
! 
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsoperators), intent(inout) :: obsoper
       
    integer :: i,istart,id
    real(8) :: tropo_press, refprof(obsoper%nmodlev),refprof2(obsoper%nmodlev),dt
    real(8), allocatable :: pressrefin(:)
    logical, allocatable :: lsuccess(:)
    
    if (obsoper%constituent_id.lt.0.or.obsoper%constituent_id.gt.chm_constituents_size) return

    id=obsoper%constituent_id
    
    if (chm_config%generalized_operator(id).le.1) return           
    if (chm_ref_fields(id,1)%nlat.eq.0) return
    
    ! Set vertical levels of reference.
    ! Convert to pressure coordinate if needed.
    
    if (allocated(pressrefin)) deallocate(pressrefin)
    allocate(pressrefin(chm_ref_fields(id,1)%nlev))
    pressrefin(:)=chm_ref_fields(id,1)%vlev(1:chm_ref_fields(id,1)%nlev)

    if (allocated(lsuccess)) deallocate(lsuccess)
    allocate(lsuccess(chm_ref_fields(id,1)%nlev))
    lsuccess(:)=.true.
    
    if (chm_ref_fields(id,1)%ivkind.eq.2) then
        pressrefin(:)=pressrefin(:)*100. ! Conversion from hPa to Pa.
    else if (chm_ref_fields(id,1)%ivkind.eq.0) then
        where (pressrefin.lt.obsoper%gz(obsoper%nmodlev)) pressrefin=obsoper%gz(obsoper%nmodlev)
        pressrefin(:) = chm_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                        chm_ref_fields(id,1)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
    else if (chm_ref_fields(id,1)%ivkind.eq.4) then
        pressrefin(:)=pressrefin(:) + obsoper%gz(obsoper%nmodlev)
        pressrefin(:) = chm_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                        chm_ref_fields(id,1)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
    else if (chm_ref_fields(id,1)%ivkind.eq.1) then
        pressrefin(:)=pressrefin(:)*obsoper%pp(obsoper%nmodlev) ! Convert from sigma to Pa   
    else
       write(*,*) 'Vertical coordinate kind is ',chm_ref_fields(id,1)%ivkind
       call abort3d('chm_get_reference_obsdata: Cannot handle vertical coordinate of this kind.')
    end if
    
    ! Interpolate to obs lat/long location and model level

    call chm_trilin(chm_ref_fields(id,1)%field3d,pressrefin, &
                    chm_ref_fields(id,1)%nlon,chm_ref_fields(id,1)%nlat,chm_ref_fields(id,1)%nlev, &
                    chm_ref_fields(id,1)%lon,chm_ref_fields(id,1)%lat,obsoper%lon,obsoper%lat, &
                    refprof,obsoper%pp,obsoper%nmodlev)
    
    if (chm_ref_fields(id,2)%nlat.gt.0.and.chm_ref_fields(id,2)%nlon.gt.0.and.chm_ref_fields(id,2)%nlev.gt.0) then
        
        if (any(obsoper%tt.le.0.0)) call abort3d('chm_get_reference_obsdata: Missing TT for determining tropopause pressure')
        
        ! Get second reference field (for troposphere)
        
        tropo_press=-1.0
        
        if (all(obsoper%hu.ge.0.0D0)) then
           tropo_press=chm_get_tropopause(obsoper%nmodlev,obsoper%pp,obsoper%tt,obsoper%gz,hu=obsoper%hu)
        else
           tropo_press=chm_get_tropopause(obsoper%nmodlev,obsoper%pp,obsoper%tt,obsoper%gz)
         end if

        if (tropo_press.gt.0) then
            
           ! Set vertical levels of reference.
           ! Convert to pressure coordinate if needed
 
           if (allocated(pressrefin)) deallocate(pressrefin)
           allocate(pressrefin(chm_ref_fields(id,2)%nlev))    
           pressrefin(:)=chm_ref_fields(id,2)%vlev(1:chm_ref_fields(id,2)%nlev)

           if (allocated(lsuccess)) deallocate(lsuccess)
           allocate(lsuccess(chm_ref_fields(id,2)%nlev))
           lsuccess(:)=.true.

           if (chm_ref_fields(id,2)%ivkind.eq.2) then
               pressrefin(:)=pressrefin(:)*100. ! Conversion from hPa to Pa.
           else if (chm_ref_fields(id,2)%ivkind.eq.0) then
               where (pressrefin.lt.obsoper%gz(obsoper%nmodlev)) pressrefin=obsoper%gz(obsoper%nmodlev)
               pressrefin(:) = chm_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                               chm_ref_fields(id,2)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
           else if (chm_ref_fields(id,2)%ivkind.eq.4) then
               pressrefin(:)=pressrefin(:) + obsoper%gz(obsoper%nmodlev)
               pressrefin(:) = chm_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                               chm_ref_fields(id,2)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
           else if (chm_ref_fields(id,2)%ivkind.eq.1) then
               pressrefin(:)=pressrefin(:)*obsoper%pp(obsoper%nmodlev) ! Convert from sigma to Pa        
           else 
               write(*,*) 'Vertical coordinate kind is ',chm_ref_fields(id,2)%ivkind
               call abort3d('chm_get_reference_obsdata: Cannot handle vertical coordinate of this kind.')
           end if
      
           ! Interpolate to obs lat/long and model levels

           call chm_trilin(chm_ref_fields(id,2)%field3d,pressrefin, &
                    chm_ref_fields(id,2)%nlon,chm_ref_fields(id,2)%nlat, &
                    chm_ref_fields(id,2)%nlev,chm_ref_fields(id,2)%lon, &
                    chm_ref_fields(id,2)%lat,obsoper%lon,obsoper%lat,refprof2,obsoper%pp,obsoper%nmodlev)
    
        end if

        ! Combine with upper level profile
       
        do i=obsoper%nmodlev,3,-1
           if (obsoper%pp(i).lt.tropo_press) exit
           refprof(i)=refprof2(i)            
        end do
        istart=i
             
        ! Apply linear combination of four levels just above the tropopause
        
        do i=istart,max(2,istart-3),-1
            dt=(istart+1.0-i)/5.0
            refprof(i)=dt*refprof2(i) + (1.0-dt)*refprof(i)
        end do
                    
    end if 

    if (allocated(pressrefin)) deallocate(pressrefin)
    if (allocated(lsuccess)) deallocate(lsuccess) 

    ! ------- Save in chm_ref_trial ---------
       
    if (.not.associated(chm_ref_trial%data1d)) then
       call obsdata_alloc(chm_ref_trial, chm_config%obsdata_maxsize, dim1=obsoper%nmodlev)
       chm_ref_trial%nrep = 0
    end if

    ! Here, nrep will count the number of filled elements in the data arrays
    chm_ref_trial%nrep = chm_ref_trial%nrep+1 

    if (chm_ref_trial%nrep.gt.chm_config%obsdata_maxsize) &
         call abort3d('chm_get_ref_obsdata: Reach max size of array ' // trim(str(chm_config%obsdata_maxsize)) )
  
    ! The obsoper%obs_index (header index) serves as the unique locator code 
    write(chm_ref_trial%code(chm_ref_trial%nrep),'(I22)') obsoper%obs_index

    ! Save profile in chm_ref_trial
    
    chm_ref_trial%data1d(:,chm_ref_trial%nrep) = refprof(:)

  end subroutine chm_set_reference_obsdata

!-------------------------------------------------------------------------------------------

  subroutine chm_trilin(field,vlev,nlong,nlat,nlev,xlong,xlat,plong,plat,vprof,vlevout,nlevout)
!
! Author:  Y. Rochon, Nov 2015
!
! Purpose: Approximate trilinear interpolation from a 3D field to a profile at (plong,plat).
!          Proper trilinear interpolation (i.e. conducting vertical interpolation for all 
!          lat-long points involved in the interpolation) not essential here.
!
! Arguments:
!
!   Input
!      
!     field(nlong,nlat,nlev)  3D field
!     nlong         number or latitudes
!     nlat          number of longitudes
!     nlev          number of vertical levels
!     xlong         longitudes (radians)
!     xlat          latitudes (radians)
!     vlev          vertical levels of input field (in pressure)
!     plat          target latitude (radian)
!     plong         target longitude (radians) 
!     nlevout       Number of target vertical levels
!     vlevout       Target vertical levels (in pressure)
!
!   Output
!
!     vprof(nlev)   Profile at (plong,plat) 
!
!-------------------------------------------------------------------------------------------  

    use MathPhysConstants_mod

    implicit none

    integer, intent(in) :: nlong,nlat,nlev,nlevout
    real(8), intent(in) :: field(nlong,nlat,nlev),vlev(nlev),xlong(nlong),xlat(nlat),plong,plat
    real(8), intent(in) :: vlevout(nlevout)
    real(8), intent(out) :: vprof(nlevout)
    
    real(8) :: lnvlev(nlev),lnvlevout(nlevout),plong2
    integer :: ilev,ilon,ilat,i,j

    real(8) :: DLDX, DLDY, DLDP, DLW1, DLW2, DLW3, DLW4

    ! Find near lat/long grid points
    
    plong2=plong
    if (plong2.lt.0.0) plong2=2.D0*MPC_PI_R8 + plong2
    do ilon=2,nlong
       if  (xlong(ilon-1).lt.xlong(ilon)) then
           if (plong2.ge.xlong(ilon-1).and.plong2.le.xlong(ilon)) exit
       else 
           ! Assumes this is a transition between 360 to 0 (if it exists). Skip over.
       end if
    end do
    ilon=ilon-1
       
    do ilat=2,nlat
       if (plat.le.xlat(ilat)) exit
    end do
    ilat=ilat-1
    
    ! Set lat/long interpolation weights
    
    DLDX = (plong - xlong(ilon))/(xlong(ilon+1)-xlong(ilon))
    DLDY = (plat - xlat(ilat))/(xlat(ilat+1)-xlat(ilat))

    DLW1 = (1.d0-DLDX) * (1.d0-DLDY)
    DLW2 =       DLDX  * (1.d0-DLDY)
    DLW3 = (1.d0-DLDX) *       DLDY
    DLW4 =       DLDX  *       DLDY

    ! Set vertical interpolation weights (assumes pressure vertical coordinate)
    
    lnvlevout(:)=log(vlevout(:))    
    lnvlev(:)=log(vlev(:))    
!    lnvlev(:) = DLW1 * log(vlev(ilon,:,ilat)) &
!               + DLW2 * log(vlev(ilon+1,:,ilat)) &
!               + DLW3 * log(vlev(ilon,:,ilat+1)) &
!               + DLW4 * log(vlev(ilon+1,:,ilat+1)) 
         
    ilev=1
    do i = 1, nlevout
       do j=ilev,nlev          
          if (lnvlevout(i).lt.lnvlev(j)) exit    ! assumes both lnvlevout and lnvlev increase with increasing index value
       end do
       ilev=j-1
       if (ilev.lt.1) then
          ilev=1
       else if (ilev.ge.nlev) then
           ilev=nlev-1
       end if
       
       DLDP = (lnvlev(ilev+1)-lnvlevout(i))/(lnvlev(ilev+1)-lnvlev(ilev))
          
       vprof(i) = DLDP* (DLW1 * field(ilon,ilev,ilat) &
                       + DLW2 * field(ilon+1,ilev,ilat) &
                       + DLW3 * field(ilon,ilev,ilat+1) &
                       + DLW4 * field(ilon+1,ilev,ilat+1)) &
         + (1.d0-DLDP)* (DLW1 * field(ilon,ilev+1,ilat) &
                       + DLW2 * field(ilon+1,ilev+1,ilat) &
                       + DLW3 * field(ilon,ilev+1,ilat+1) &
                       + DLW4 * field(ilon+1,ilev+1,ilat+1))                               
    end do
        
  end subroutine chm_trilin

!-----------------------------------------------------------------------------------------
!----------- Routines relevant to error std. dev. (observation_erreurs.ftn90) ------------

  subroutine chm_read_obs_err_stddev
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
!
! Revision: 
!
! Purpose:  Read observation errors from ascii file and BURP file if specified in ascii file
!
! Comments:
!
! - Filename 'brpch' currently hardcoded should ideally be the filename for the CH family 
!   identified from the list of input filenames.
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the error std. dev. information from the ascii file
    call chm_read_obs_err_stddev_ascii

    ! set size of BURP file std array
    allocate(chm_burp_std(chm_std%n_stnid))

    ! read from BURP file
    do istnid=1,chm_std%n_stnid
       if (chm_std%brp(istnid).ge.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_std(istnid) = chm_read_burp('brpch', chm_std%stnids(istnid), &
               chm_std%bfr(istnid), chm_std%n_lvl(istnid), 1, 14, 'DATA',       &
               match_nlev=chm_std%brp(istnid).eq.1 )

       end if
    end do

  end subroutine chm_read_obs_err_stddev

!----------------------------------------------------------------------------------------

  subroutine chm_read_obs_err_stddev_ascii
!
! Author   : Y. Rochon, Nov 2014 
!             (initial part follows the format of oer_read_obs_erreurs_conv)
! Revisions: 
!             M. Sitwell, Feb 2015
!             - Content formed as a separate routine called in oer_read_obs_erreurs_chm.
!          
! Purpose: Read and store observation error std. dev. as needed for CH family obs.
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_std%n_stnid=0
!
! CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists) then
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! chm_read_obs_err_stddev: obsinfo_chm not available.   '
    WRITE(*,*) 'WARNING! Default CH family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
    return
  ENDIF
!
! Read observation error std dev. from file obsinfo_chm for constituent data
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL ABORT3D('chm_read_obs_err_stddev_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

! Read error standard deviations for constituents if available.
! (CH family; ozone and others)
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:12))).ne.'SECTION I:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space

  read(nulstat,*,iostat=ios,err=10,end=10) chm_std%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize
  
  allocate(chm_std%stnids(chm_std%n_stnid))
  allocate(chm_std%std_type(chm_std%n_stnid),chm_std%n_lat(chm_std%n_stnid))
  allocate(chm_std%brp(chm_std%n_stnid),chm_std%ibegin(chm_std%n_stnid))
  allocate(chm_std%bfr(chm_std%n_stnid),chm_std%n_lvl(chm_std%n_stnid))
  allocate(chm_std%std1(isize),chm_std%std2(chm_std%n_stnid),chm_std%std3(chm_std%n_stnid))
  allocate(chm_std%levels(isize),chm_std%lat(isize))
 
  chm_std%bfr(:)=0
  chm_std%brp(:)=0
  chm_std%std_type(:)=0
  chm_std%n_lvl(:)=1
  chm_std%n_lat(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  STNIDLOOP: do jelm=1,chm_std%n_stnid
    chm_std%ibegin(jelm)=icount+1

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! Read STNID (* as wildcard)    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_std%stnids(jelm) 
    
!   Read (1) BUFR element,
!        (2) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (3) Index specifying OER setup method,
!        (4) Number of vertical levels
!        (5) Number of latitudes
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_std%bfr(jelm),chm_std%brp(jelm),  &
       chm_std%std_type(jelm), chm_std%n_lvl(jelm), chm_std%n_lat(jelm),  &
       chm_std%std2(jelm), chm_std%std3(jelm)

    if (chm_std%n_lvl(jelm).lt.1) chm_std%n_lvl(jelm)=1
    if (chm_std%n_lat(jelm).lt.1) chm_std%n_lat(jelm)=1
    
    if (icount+chm_std%n_lvl(jelm)*chm_std%n_lat(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    ! disregard data section if not needed
    if (chm_std%std_type(jelm).eq.1.or.chm_std%std_type(jelm).eq.2.or.(chm_std%brp(jelm).ge.1.and.chm_std%std_type(jelm).eq.0)) &
         cycle STNIDLOOP 

    if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Read one value only (independent of level and latitude)
       
       icount=icount+1
       read(nulstat,*,iostat=ios,err=10,end=10) chm_std%std1(icount)

    else if (chm_std%n_lvl(jelm).eq.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on latitude only
       
!      Read reference latitudes (must be in order of increasing size)
       
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
!      Read OER-related values
  
       read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%std1(icount+1:icount+chm_std%n_lat(jelm))

       icount=icount+chm_std%n_lat(jelm)

    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).eq.1) then
    
!      Value dependent on vertical level only
      
       do jlev=1,chm_std%n_lvl(jelm)
          icount=icount+1
          
!         Read vertical level and OER-related value.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_std%levels(icount),chm_std%std1(icount)

       end do
   
    else if (chm_std%n_lvl(jelm).gt.1.and.chm_std%n_lat(jelm).gt.1) then
    
!      Value dependent on vertical level and latitude 
       
!      Read reference latitudes (must be in order of increasing size)
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
!       write(*, '(10X,20F9.3)') chm_std%lat(icount+1:icount+chm_std%n_lat(jelm))
      
       do jlev=1,chm_std%n_lvl(jelm)
          
!         Read vertical level and OER-related lat-dependent values.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                   &
                 chm_std%levels(icount+jlev),                           &
                 chm_std%std1(icount+(jlev-1)*chm_std%n_lat(jelm)+1:icount+jlev*chm_std%n_lat(jelm))

       end do
       icount=icount+chm_std%n_lat(jelm)*chm_std%n_lvl(jelm)
    end if
 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('chm_read_obs_err_stddev_ascii: PROBLEM READING OBSERR STD DEV.')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_obs_err_stddev_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)
!
!  s/r chm_set_obs_err_stddev_index - Returns the station ID and latitude 
!                                     indices corresponding to a measurement
!
!  Author: M. Sitwell Feb 2015 
!            - Content moved from code originally in oer_fill_obs_erreurs.
!             
!  Revisions:
!      M. Sitwell, May 2016
!       - Added chm_std%brp = 2 option
!
!----------------------------------------------------------------------------------------
   
    implicit none

    character(len=*), intent(in)  :: CSTNID
    integer, intent(in)           :: NLEV,VARNO
    real(8), intent(in)           :: ZLAT
    integer, intent(out)          :: ISTNID,JINT
    integer                       :: JN,ilen1,ilen2,ji,ibegin

 !  Important: Combination of STNID, BUFR element and number of vertical levels
 !             to determine association to the observations.

 !             Find stnid with same number of vertical levels and same BUFR element.
 !             Note: * in chm_std%stnids stands for a wildcard
     
    ISTNID=0
    DO JN=1,chm_std%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_std%stnids(JN) as wildcards

       IF (stnid_equal(chm_std%stnids(JN),CSTNID)) THEN
          IF ( (NLEV.EQ.chm_std%n_lvl(JN) .OR. chm_std%brp(JN).eq.2) .AND. VARNO.EQ.chm_std%bfr(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF

    END DO

    IF (ISTNID.EQ.0) THEN
       call abort3d('chm_obs_err_stddev_index: Error std. dev. for STNID ' // trim(CSTNID) // &
                    ' is unavailable. Check section I of file obsinfo_chm.')
    ELSE

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN

          ! Find latitude index for interpolation.
          ! Assuming increasing latitudes in chm_std%lat

          ibegin=chm_std%ibegin(ISTNID)-1
          IF (ZLAT .GE. chm_std%lat(ibegin+chm_std%n_lat(ISTNID))) THEN
             JINT=chm_std%n_lat(ISTNID)+1
          ELSE
             DO JINT=1,chm_std%n_lat(ISTNID)
                IF (ZLAT .LE. chm_std%lat(ibegin+JINT) ) exit
             END DO
          END IF
                                           
       END IF       
    END IF         

  end subroutine chm_obs_err_stddev_index

!----------------------------------------------------------------------------------------

  function chm_get_obs_err_stddev(CSTNID,NLEV,VARNO,ZLAT,ZLON,IDATE,ITIME,ZVAL,ZLEV,ILEV,IFIRST) result(obs_err_stddev) 
!
!  s/r chm_set_obs_err_stddev - Returns the observational error std for a CH family measurement
!
!  Author   : M. Sitwell, ARQI/AQRD, Feb 2015 
!             - Content moved from code originally in oer_fill_obs_erreurs.
!             Y. Rochon, ARQI/AQDRD, Aug 2016
!             - Updated cases
!
!  Revisions:
!
!  Input
!    cstnid        station ID
!    nlev          number of levels
!    varno         BUFR number
!    zlat          latitude
!    zlon          longitude
!    idate         date in YYYYMMDD format
!    itime         time in HHMM format
!    zval          observation values
!    zlev          vertical coordinate value
!    ilev          observation number in the profile
!    ifirst        logical indicating if first call for a profile
!
!----------------------------------------------------------------------------------------

    implicit none
   
    character(len=*), intent(in) :: CSTNID
    real(8), intent(in) :: ZVAL,ZLEV,ZLAT,ZLON
    integer, intent(in) :: NLEV,VARNO,IDATE,ITIME,ILEV
    logical, intent(in) :: IFIRST
    real(8)  :: obs_err_stddev 

    real(8) :: wgt,zwb,sigma
    integer :: ibegin,JLEV,JN,stat

    integer, save :: ISTNID,JINT

    ! If this call is for the first level for this measurement, get
    ! the station ID and latitude indices corresponding to this measurement
    if (ifirst) call chm_obs_err_stddev_index(CSTNID,NLEV,VARNO,ZLAT,ISTNID,JINT)                  
    
            
    ! Get weighting of error std. dev. if required

    if (chm_std%std_type(ISTNID).gt.2 .or. &
       (chm_std%brp(ISTNID).eq.0 .and. chm_std%std_type(ISTNID).eq.0) ) then

       IF (chm_std%n_lvl(ISTNID) .GT. 1) THEN
                 
          ! Find nearest vertical level (no interpolation)
                 
          zwb=1.E10
          ibegin=chm_std%ibegin(ISTNID)-1
          DO JN=1,chm_std%n_lvl(ISTNID)
             IF (zwb .GT. abs(ZLEV-chm_std%levels(ibegin+JN)) ) THEN
                JLEV=JN
                zwb=abs(ZLEV-chm_std%levels(ibegin+JN))
             END IF
          END DO
          JLEV=ibegin+(JLEV-1)*chm_std%n_lat(ISTNID)+1
       ELSE
          JLEV=chm_std%ibegin(ISTNID)
       END IF

       IF (chm_std%n_lat(ISTNID) .GT. 1) THEN
                
          ! Apply interpolation

          JLEV=JLEV+JINT-1
          ibegin=chm_std%ibegin(ISTNID)-1
          IF (JINT.EQ.1.OR.JINT.GT.chm_std%n_lat(ISTNID)) THEN
             wgt=chm_std%std1(JLEV)
          ELSE
             wgt=(chm_std%std1(JLEV-1)*(chm_std%lat(ibegin+JINT)-ZLAT)+ &
                  chm_std%std1(JLEV)*(ZLAT-chm_std%lat(ibegin+JINT-1)))/ &
                  (chm_std%lat(ibegin+JINT)-chm_std%lat(ibegin+JINT-1))
          END IF
       ELSE
          wgt=chm_std%std1(JLEV)             
       END IF
         
    end if
             
    ! Set the error std. dev.
                   
    IF (chm_std%brp(ISTNID).EQ.0) THEN
               
       ! Set error standard deviations from scratch using content of
       ! previously read content of the "obsinfo_chm" file.
                
       select case(chm_std%std_type(ISTNID))
       case(0)
          obs_err_stddev = wgt
       case(1)
          obs_err_stddev = max(chm_std%std3(ISTNID),chm_std%std2(ISTNID)*ZVAL)
       case(2)
          obs_err_stddev = sqrt(chm_std%std3(ISTNID)**2+(chm_std%std2(ISTNID)*ZVAL)**2)
       case(3)
          obs_err_stddev = min(chm_std%std3(ISTNID),max(chm_std%std2(ISTNID),wgt*ZVAL))
       case(4)
          obs_err_stddev = sqrt(chm_std%std2(ISTNID)**2+(wgt*ZVAL)**2)
       case default
          call abort3d('chm_get_obs_err_stddev: std_type = ' // trim(str(chm_std%std_type(ISTNID))) // &
               ' for STNID = ' // trim(CSTNID) // ' is not recognized.')
       end select

    ELSE
          
       ! Adjust error standard deviations read from BURP file if requested.
       
       sigma = obsdata_get_element(chm_burp_std(istnid), obsdata_get_loctime_code(zlon,zlat,idate,itime), ilev, stat=stat)

       select case(stat)
       case(1)
          call abort3d("chm_get_obs_err_stddev: No reports available for STNID = " // trim(cstnid) // &
                       ", nlev = " // trim(str(nlev)) // ", varno = " // trim(str(varno)) )
       case(2)
          call abort3d("chm_get_obs_err_stddev: Report not found for STNID = " // trim(cstnid) // &
                       ", nlev = " // trim(str(nlev)) // ", varno = " // trim(str(varno)) )
       end select

       select case(chm_std%std_type(ISTNID))
       case(0)
          obs_err_stddev = sigma
       case(1)
          obs_err_stddev = max(chm_std%std3(ISTNID),chm_std%std2(ISTNID)*sigma)
       case(2)
          obs_err_stddev = sqrt(chm_std%std3(ISTNID)**2+(chm_std%std2(ISTNID)*sigma)**2)
       case(3)
          obs_err_stddev = min(chm_std%std3(ISTNID),max(chm_std%std2(ISTNID),wgt*sigma))
       case(4)
          obs_err_stddev = sqrt(chm_std%std2(ISTNID)**2+(wgt*sigma)**2)
       case default
          call abort3d('chm_get_obs_err_stddev: std_type = ' // trim(str(chm_std%std_type(ISTNID))) // &
               ' for STNID = ' // trim(CSTNID) // ' is not recognized.')
       end select
       
    END IF
    
  end function chm_get_obs_err_stddev

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_obs_err_stddev
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for observation errors for the CH family
!
!---------------------------------------------------------------------------------------
  
    implicit none

    integer :: istnid

    if (chm_std%n_stnid.eq.0) return
    
    if (allocated(chm_burp_std)) then
       do istnid=1,chm_std%n_stnid
          if (chm_std%brp(istnid).ge.1) call obsdata_dealloc(chm_burp_std(istnid))
       end do
       deallocate(chm_burp_std)       
    end if

    if (allocated(chm_std%stnids))   deallocate(chm_std%stnids)
    if (allocated(chm_std%n_lvl))    deallocate(chm_std%n_lvl)
    if (allocated(chm_std%std_type)) deallocate(chm_std%std_type)
    if (allocated(chm_std%ibegin))   deallocate(chm_std%ibegin)
    if (allocated(chm_std%bfr))      deallocate(chm_std%bfr)
    if (allocated(chm_std%brp))      deallocate(chm_std%brp)
    if (allocated(chm_std%n_lat))    deallocate(chm_std%n_lat)
    if (allocated(chm_std%std1))     deallocate(chm_std%std1)
    if (allocated(chm_std%std2))     deallocate(chm_std%std2)
    if (allocated(chm_std%std3))     deallocate(chm_std%std3)
    if (allocated(chm_std%levels))   deallocate(chm_std%levels)
    if (allocated(chm_std%lat))      deallocate(chm_std%lat)

  end subroutine chm_dealloc_obs_err_stddev

!-----------------------------------------------------------------------------------------
!------------------- BURP functions and routines -----------------------------------------

  function chm_read_burp(filename,stnid,varno,nlev,ndim,bkstp,block_type,match_nlev) result(burp_out)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Purpose:  Retrieve information from BURP file for CH family observations. Can retrieve
!           either 1D or 2D data from a report.
!           Note: Exponent BUFR data (i.e. data with BUFR number 8090) will only be applied
!                 to 1D data.
!
! Revision:  M. Sitwell, ARQI/AQRD, May 2015
!            - Modified to read both 1D and 2D data from a report
!            Y. Rochon, ARQI/AQRD, May 2016
!            - Updated to increment 'icount' only if varno is also found in addition
!              stnid, nlev, block_type and bkstp
!            M. Sitwell, ARQI/AQRD, June 2016
!            - Added match_nlev input argument
!
! Arguments:
!
!  Input
!           filename      BURP file name
!           stnid         station ID of observation
!           varno         BUFR code
!           nlev          number of levels in the observation
!           ndim          number of dimensions for the retrieved data in
!                         each report (e.g. ndim=1 for std, ndim=2 for
!                         averagine kernels) 
!           bkstp         bkstp number of requested block
!           block_type    block type indicated by the two rightmost bits
!                         of bknat. Valid values are 'DATA', 'INFO', '3-D',
!                         and 'MRQR'.
!           match_nlev    determines if the report matching criteria includes checking
!                         if the report number of levels is the same as the input
!                         argument nlev
!
!  Output 
!           burp_out      struct_chm_obsdata object
!
!  Comments:
!
!  - As burp_out is for a specific input stnid, burp_out%code only contains the (lat/long and
!    time coord.) with 22 characters.
!
!  - Exponent BUFR data (i.e. data with BUFR number 8090) will only be applied to 1D data.
!
!-----------------------------------------------------------------------------------------
    
    use burp_module

    implicit none

    character(len=*), intent(in) :: filename
    character(len=9), intent(in) :: stnid
    character(len=4), intent(in) :: block_type
    integer, intent(in)          :: ndim,varno,nlev,bkstp
    logical, intent(in)          :: match_nlev
    type(struct_chm_obsdata) :: burp_out

    character(len=9)  :: rep_stnid
    character(len=22) :: code
    type(burp_file)   :: brp
    type(burp_rpt)    :: rep
    type(burp_block)  :: blk
    integer           :: error,ref_rpt,nrep,ref_blk
    integer           :: ref_bkstp,nval,ivar,iexp,ilev,icount
    integer           :: date,time,ilat,ilon,iele,nele,icol
    real(8)           :: val,exponent

    ! initialize burp file, report, and block
    Call BURP_Init(brp, iostat=error)
    Call BURP_Init(rep, iostat=error)
    Call BURP_Init(blk, iostat=error)

    ! open the burp file
    Call BURP_New(brp, FILENAME=filename, MODE=FILE_ACC_READ, IOSTAT=error)
    
    if (error.ne.0) CALL ABORT3D('chm_read_burp: Could not open BURP file: ' // filename)

    ! get number of reports in file
    Call BURP_Get_Property(brp, NRPTS=nrep)

    ! allocate memory
    if (ndim.eq.1) then
       call obsdata_alloc(burp_out,nrep,dim1=nlev)
    else
       call obsdata_alloc(burp_out,nrep,dim1=nlev,dim2=nlev)
    end if
    
    icount = 0  ! counter of reports with same stnid, number of levels, and varno as input 
    ref_rpt = 0
    
    ! loop through reports    
    REPORTS: do

       ref_rpt = BURP_Find_Report(brp, REPORT=rep, SEARCH_FROM=ref_rpt, IOSTAT=error)

       if (ref_rpt<0) exit REPORTS
       
       call BURP_Get_Property(rep, STNID=rep_stnid, DATE=date, TEMPS=time, LATI=ilat, LONG=ilon) 

       if (.not.stnid_equal(stnid,rep_stnid)) cycle REPORTS

       ! loop through blocks
       ref_blk = 0
       BLOCKS: do
          
          ref_blk = BURP_Find_Block(rep, BLOCK=blk, SEARCH_FROM=ref_blk, IOSTAT=error)          
          if (ref_blk<0) exit BLOCKS
          
          call BURP_Get_Property(blk, NELE=nele, NVAL=nval, BKSTP=ref_bkstp, IOSTAT=error)
          
          if (.not.IS_Burp_Btyp(trim(block_type),BLOCK=blk) .or. bkstp.ne.ref_bkstp .or. (match_nlev.and.nval.ne.nlev)) cycle BLOCKS

          ivar = BURP_Find_Element(blk, ELEMENT=varno, IOSTAT=error)
          if (ivar.lt.0) cycle BLOCKS

          ! required block found if code reaches this point, retrieve data and store in burp_out
          
          if (nval.gt.nlev) call abort3d('chm_read_burp: number of levels in the report (' // trim(str(nval)) // &
                                         ') exceeds the specified maximum number of levels (' // trim(str(nlev)) // &
                                         ') for STNID ' // rep_stnid )

          icount=icount+1
          burp_out%code(icount) = obsdata_get_loctime_code(ilon,ilat,date,time)  ! this code is a unique identifier for this report

          if (ndim.eq.1) then
             ! retrieve 1D data

             iexp = BURP_Find_Element(blk, ELEMENT=8090, IOSTAT=error)
                
             if (iexp.lt.0) then
                ! No exponent found in block
                do ilev=1,nval                   
                   burp_out%data1d(ilev,icount) = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                end do
             else
                ! Apply exponent
                do ilev=1,nval                   
                   val = BURP_Get_Rval(blk, NELE_IND=ivar, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)                
                   exponent = BURP_Get_Rval(blk, NELE_IND=iexp, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                   burp_out%data1d(ilev,icount) = val * 10**exponent
                end do
             end if
                   
          else if (ndim.eq.2) then
             ! retrieve 2D data

             icol = 0
             do iele=1,nele
                ivar = BURP_Get_Element(blk, INDEX=iele, IOSTAT=error)
                if (ivar.eq.varno) then
                   icol = icol+1
                   do ilev=1,nval                  
                      burp_out%data2d(ilev,icol,icount) = BURP_Get_Rval(blk, NELE_IND=iele, NVAL_IND=ilev, NT_IND=1, IOSTAT=error)
                   end do
                end if
             end do

          end if

          exit BLOCKS
          
       end do BLOCKS
      
    end do REPORTS

    ! resize first dimension of data arrays from length of nrep to icount
    call resize(burp_out%code,icount)
    if (ndim.eq.1) then
       call resize(burp_out%data1d,nlev,icount)
    else if (ndim.eq.2) then
       call resize(burp_out%data2d,nlev,nlev,icount)
    end if

    burp_out%nrep = icount
    
    ! deallocate
    Call BURP_Free(brp,iostat=error)
    Call BURP_Free(rep,iostat=error)
    Call BURP_Free(blk,iostat=error)
    
  end function chm_read_burp

!-----------------------------------------------------------------------------------------

  subroutine chm_update_obsfile()
!
! Author   : Y. Rochon, June 2016 
! 
! Revisions:
!          
! Purpose: Update of CH family obs file when needed.
!          
!          Content can be augmented as needed.
!
!----------------------------------------------------------------------------------------
    use mpi_mod, only: mpi_myid
  
    implicit none
    
    integer :: ierr,nrep_modified,varno(1)

!   If needed, add effective temperature values in obs file for total column measurements

    call obsdata_MPIgather(chm_efftemp)
    
    if (chm_efftemp%nrep.gt.0.and.mpi_myid.eq.0) then
        varno(1)=12001
        nrep_modified = chm_update_burp('brpch',varno(1:max(1,chm_efftemp%dim2)),0,'INFO',chm_efftemp,multi='UNI') 
        write(*,*) 'chm_update_obsfiles: Added ',nrep_modified,' effective temperature values in the obs file.'
    end if 

  end subroutine chm_update_obsfile

!-----------------------------------------------------------------------------------------

  function chm_update_burp(filename,varno,bkstp,block_type,obsdata,stnid,multi) result(nrep_modified)
!
! Author  : Y. Rochon, ARQI/AQRD, June 2016
!           - Partly based on chm_read_burp by M. Sitwell.
!
! Revision: 
!          M. Sitwell, ARQI/AQRD, Aug 2016
!          - Modified to preserve order of reports.
!
! Purpose:  Add or modify information from BURP file in existing block and
!           for specified BUFR descriptor varno(s). 
!           Provided data can be either 1D or 2D data.
!
! Arguments:
!
!  Input
!           filename      BURP file name
!           varno         BUFR descriptors. Number of elements must be 
!                         max(1,obsdata%dim2)
!           bkstp         bkstp number of requested block
!           block_type    block type indicated by the two rightmost bits
!                         of bknat. Valid values are 'DATA', 'INFO', '3-D',
!                         and 'MRQR'.
!           obsdata       Input struct_chm_obsdata object for varno.
!           stnid         station ID (optional)
!                         if present, burp_in%code = (lat,long,date,time)
!                         otherwise, burp_in%code = (lat,long,date,time,stnid)
!           multi         Indicates in intended report are for 'UNI' or 'MULTI' level data (optional)
!
!
!  Output 
!           nrep_modified Number of modified reports
!
!  Comments:
!
!  - Currently assumes that all elements of varno(:) are distinct from each other.
!  - In blocks with new data to be added/modified, if the varno already exists in the block, the
!    new data will overwrite the existing varno data, otherwise will append the new data
!    to the block.
!
!-----------------------------------------------------------------------------------------
    
    use burp_module

    implicit none

    character(len=*), intent(in) :: filename
    character(len=4), intent(in) :: block_type
    type(struct_chm_obsdata), intent(inout) :: obsdata
    integer, intent(in) :: varno(:),bkstp
    
    character(len=*), intent(in), optional :: stnid,multi

    integer :: nrep_modified,ncount
    logical :: blk_found,encode_blk,convert_blk
    integer, parameter :: LNMX=100000

    character(len=9)  :: rep_stnid
    character(len=code_len) :: code
    type(burp_file)   :: brp
    type(burp_rpt)    :: rep,rep_new
    type(burp_block)  :: blk
    integer           :: error,ref_rpt,nrep,ref_blk,ndim,dim1,dim2
    integer           :: ref_bkstp,nval,ivar,ilev,istat
    integer           :: date,time,ilat,ilon,iele,nele,k
    integer, allocatable :: address(:)
    real(4), allocatable :: new_vals(:,:,:)
    logical, allocatable :: modify(:)
    
    ! Check presence of data to update
    if (obsdata%nrep.le.0) then
       write(*,*) 'chm_update_burp: Skipped due to absence of data to update.'
       return
    end if
    
    ! Identify dimensions for the input data    
    ndim=obsdata%ndim
    dim1=obsdata%dim1
    if (ndim.eq.1) then
       dim2=1
    else
       dim2=obsdata%dim2
    end if
    
    if (size(varno).lt.dim2) call abort3d('chm_update_burp: Number of BUFR elements not sufficient. ' // &
                                          trim(str(size(varno))) // ' vs ' // trim(str(dim2)))

    ! initialize burp file, report, and block system resources
    call BURP_Init(brp, iostat=error)
    call BURP_Init(rep, R2=rep_new, iostat=error)
    call BURP_Init(blk, iostat=error)

    ! open the burp file in append mode (to replace or add data in a block)
    call BURP_New(brp, FILENAME=filename, MODE=FILE_ACC_APPEND, IOSTAT=error)
    if (error.ne.0) call abort3d('chm_update_burp: Could not open BURP file: ' // filename)

    ! get number of reports in file
    call BURP_Get_Property(brp, NRPTS=nrep)

    allocate(address(nrep),modify(nrep),new_vals(dim1,dim2,nrep))
    address(:)=0
    modify(:)=.false.
    new_vals(:,:,:)=0.

    ! First loop through reports to identify addresses of original file as well as identify if new
    ! information should be included to that report.
    ! NOTE: The addresses of all reports have to be saved in their original order to ensure the
    !       order of the reports in the file is unchanged.
    ref_rpt=0
    ncount=0
    obsdata%irep=1
    REPORTS1: do

       ref_rpt = BURP_Find_Report(brp, REPORT=rep, SEARCH_FROM=ref_rpt, IOSTAT=error)
       if (ref_rpt<0) exit REPORTS1

       ncount=ncount+1
       address(ncount)=ref_rpt

       call BURP_Get_Property(rep, STNID=rep_stnid, DATE=date, TEMPS=time, LATI=ilat, LONG=ilon)

       if (rep_stnid(1:2).eq.'>>') cycle REPORTS1

       ! Set unique identifier for search from input data
       if (present(stnid)) then
          if (trim(rep_stnid).ne.stnid) cycle REPORTS1
          code = obsdata_get_loctime_code(ilon,ilat,date,time)
       else 
          code = trim(obsdata_get_loctime_code(ilon,ilat,date,time))//trim(rep_stnid)
       end if
       
       ! Determine if replacement/additional data likely present for this report
       if (dim1.eq.1.and.dim2.eq.1) then
          new_vals(1,1,ncount)=real(obsdata_get_element(obsdata,code,1,stat=istat))
       else if (dim2.eq.1) then
          new_vals(:,1,ncount)=real(obsdata_get_array1d(obsdata,code,stat=istat))
       else 
          new_vals(:,:,ncount)=real(obsdata_get_array2d(obsdata,code,stat=istat))
       end if

       if (istat.eq.0) modify(ncount) = .true.

    end do REPORTS1
    
    nrep_modified = count(modify)   ! number of reports with same code and, possibly, same number of obs data levels

    ! Generate new report
    Call BURP_New(rep_new, ALLOC_SPACE=10*LNMX, IOSTAT=error)

    
    ! second loop through reports to include the new information to the file    
    REPORTS2: do k=1,ncount
    
       call BURP_Get_Report(brp, REPORT=rep, REF=address(k), IOSTAT=error)
       
       ! Copy report header
       Call BURP_Copy_Header(TO=rep_new,FROM=rep)
       Call BURP_Init_Report_Write(brp,rep_new,IOSTAT=error)
               
       ! loop through blocks
       ref_blk = 0
       BLOCKS: do
          
          ref_blk = BURP_Find_Block(rep, BLOCK=blk, SEARCH_FROM=ref_blk, IOSTAT=error)          
          if (ref_blk<0) exit BLOCKS
          
          encode_blk = .false.
          convert_blk = .false.

          if (modify(k)) then

             call BURP_Get_Property(blk, NELE=nele, NVAL=nval, BKSTP=ref_bkstp, IOSTAT=error)

             blk_found = IS_Burp_Btyp(trim(block_type),BLOCK=blk) .and. bkstp.eq.ref_bkstp .and. dim1.eq.nval

             if (present(multi)) then 
                if (.not.IS_Burp_Btyp(trim(multi),BLOCK=blk)) blk_found = .false.
             end if
         
             if (blk_found) then
                ! Block to be modified has been found, add new data to block.
                ! If the varno is already in the block, the new data will overwrite the
                ! existing data, otherwise will append the new data to the block.

                do iele=1,dim2
                   ivar = BURP_Find_Element(blk, ELEMENT=varno(iele), IOSTAT=error)           
                   if (ivar.lt.0) then
                      ivar=nele+1
                      call BURP_Resize_Block(blk,ADD_NELE=1,IOSTAT=error)
                      call BURP_Set_Element(blk,NELE_IND=ivar,ELEMENT=varno(iele),IOSTAT=error)
                   end if
                
                   do ilev=1,nval 
                      call BURP_Set_Rval(blk,NELE_IND=ivar,NVAL_IND=ilev,NT_IND=1,RVAL=new_vals(ilev,iele,k),IOSTAT=error)                 
                   end do
                end do
        
                encode_blk = .true.
                convert_blk = .true.

             end if
          end if
             
          call BURP_Write_Block(rep_new, BLOCK=blk, ENCODE_BLOCK=encode_blk, CONVERT_BLOCK=convert_blk, IOSTAT=error)
         
       end do BLOCKS
       
       call BURP_Delete_Report(brp,rep,IOSTAT=error)
       call BURP_Write_Report(brp,rep_new,IOSTAT=error) 
  
    end do REPORTS2
        
    ! deallocate
    deallocate(address,modify,new_vals)
    Call BURP_Free(brp,iostat=error)
    Call BURP_Free(rep,R2=rep_new,iostat=error)
    Call BURP_Free(blk,iostat=error)
    
  end function chm_update_burp

!--------------------------------------------------------------------------------------------
!------------------- OBSDATA functions and routines -----------------------------------------

  subroutine obsdata_alloc(obsdata,nrep,dim1,dim2)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Allocates memory for structure struct_chm_obsdata to hold obs data file information.
!          If dim2 is specified, then the data array associated with each observation/report
!          will be 2D array. will be a 1D array if dim2 is not specified.
!
! Revision:
!     Y. Rochon and M. Sitwell  April 2016
!       - strucutre generalized for more types of observational data
!
! Input
!
!    obsdata      data structure to allocate
!    nrep         max number of associated observations/reports for data 
!    dim1         first dimension length of the array associated to each observation/report
!    dim2         second dimension length of the array associated to each observation/report (optional)
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsdata), intent(inout) :: obsdata
    integer, intent(in) :: nrep,dim1 
    integer, intent(in), optional :: dim2 
    
    obsdata%nrep = nrep
    obsdata%dim1 = dim1

    if (present(dim2)) then
       obsdata%dim2 = dim2
       obsdata%ndim = 2
       allocate(obsdata%data2d(dim1,dim2,nrep))
       obsdata%data2d(:,:,:) = 0.0D0
    else
       obsdata%dim2 = 0
       obsdata%ndim = 1
       allocate(obsdata%data1d(dim1,nrep))
       obsdata%data1d(:,:) = 0.0D0
    end if

    ! code is a character string assigned to each observation/report to uniquely identify it
    allocate(obsdata%code(nrep))
    
    ! obsdata%irep is a counter used to keep tract of position in the
    ! data arrays when extracting values via obsdata_get_array*.
    ! The value is initialized to one, pointing to the very first element.
    obsdata%irep = 1

  end subroutine obsdata_alloc

!-------------------------------------------------------------------------------------------

  subroutine obsdata_dealloc(obsdata)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Deallocates memory for structure struct_chm_obsdata
!
!---------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsdata), intent(inout) :: obsdata
    
    if (associated(obsdata%data1d)) deallocate(obsdata%data1d)
    if (associated(obsdata%data2d)) deallocate(obsdata%data2d)
    if (associated(obsdata%code))   deallocate(obsdata%code)

  end subroutine obsdata_dealloc

!-------------------------------------------------------------------------------------------

  function obsdata_get_element(obsdata,code,idim1,stat) result(element)
! 
!   Purpose: Returns element of array from obsdata 1D data array. The returned element is the
!            one with the specified identifying code.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!   Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!           idim1         position of element in the dim1 axis
!
!   Output
!           element       retrieved element from obsdata%data1d
!           stat          status code
!
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=*), intent(in)  :: code
    integer, intent(in) :: idim1
    integer, intent(out), optional :: stat

    real(8) :: element
    
    ! find obsdata%irep for current observation
    if (present(stat)) then
       call obsdata_set_index(obsdata,code,stat=stat)
       if (stat.ne.0) then
          element = 0.
          return
       end if
    else
       call obsdata_set_index(obsdata,code)
    end if

    ! get element from data array at current position
    element = obsdata%data1d(idim1,obsdata%irep)
    
    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep) then
       obsdata%irep = 1
    else
       obsdata%irep=obsdata%irep+1
    end if

  end function obsdata_get_element

!-------------------------------------------------------------------------------------------

  function obsdata_get_array1d(obsdata,code,stat) result(array)
! 
!   Purpose: Returns 1D data array from obsdata. The returned array is the one with the specified
!            identifying code.
!
!   Author: Y. Rochon, ARQI/AQRD, Nov 2015
!           - Largely a copy of obsdata_get_array2d by M. Sitwell
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!
!  Output
!           array        retrieved array from obsdata%data1d of dimension obsdata%dim1
!           stat         search success (0 - found; 1 = no data; 2 = not found)
!
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=*), intent(in) :: code
    integer, intent(out), optional :: stat
    real(8) :: array(obsdata%dim1)
    
    ! find obsdata%irep for current observation
    if (present(stat)) then
       call obsdata_set_index(obsdata,code,stat=stat)
       if (stat.ne.0) then
          array(:) = 0.
          return
       end if
    else
       call obsdata_set_index(obsdata,code)
    end if
    
    ! get element from data array at current position
    array = obsdata%data1d(:,obsdata%irep)
    
    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep) then
       obsdata%irep = 1
    else
       obsdata%irep=obsdata%irep+1
    end if

  end function obsdata_get_array1d

!-------------------------------------------------------------------------------------------

  function obsdata_get_array2d(obsdata,code,stat) result(array)
! 
!   Purpose: Returns 2D data array from obsdata. The returned array is the one with the specified
!            identifying code.
!
!   Author: M. Sitwell, ARQI/AQRD, April 2015
!    
!   Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           code          unique identifying code
!
!  Output
!           array        retrieved array from obsdata%data2d of dimension (obsdata%dim1,obsdata%dim2)
!           stat         search success (0 - found; 1 = no data; 2 = not found)
!
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=*), intent(in) :: code
    integer, intent(out), optional :: stat
    real(8) :: array(obsdata%dim1,obsdata%dim2)
    
    ! find obsdata%irep for current observation
    if (present(stat)) then
       call obsdata_set_index(obsdata,code,stat=stat)
       if (stat.ne.0) then
          array(:,:) = 0.
          return
       end if
    else
       call obsdata_set_index(obsdata,code)
    end if
    
    ! get elements from data array at current position
    array = obsdata%data2d(:,:,obsdata%irep)
    
    ! increment position in data array
    if (obsdata%irep.eq.obsdata%nrep) then
       obsdata%irep = 1
    else
       obsdata%irep=obsdata%irep+1
    end if

  end function obsdata_get_array2d

!-------------------------------------------------------------------------------------------

  subroutine obsdata_set_index(obsdata,code,stat)
! 
!  Purpose: Sets the position variable (irep) in struct_chm_obsdata to reference the record
!           that matches the input identifying code.
!
!  Author: Y. Rochon, ARQI/AQRD, Oct 2015
! 
!  Revisions:
!           M. Sitwell, April 2016
!             - Changed function to use unique character string
!
!  Input 
!           obsdata       struct_chm_obsdata instance
!           index         obs index
!
!  Output
!           obsdata%irep      current index position for the observation/report
!           stat              status of call (optional)
!                               0: no errors
!                               1: no reports available
!                               2: report not found
!
!  Comments:
!    - If the optional argument stat is provided and an error occurs, the error code will
!      be returned and the abort will not be called to allow for error handling.
! 
!-------------------------------------------------------------------------------------------

    type(struct_chm_obsdata), intent(inout) :: obsdata
    character(len=*), intent(in) :: code
    integer, intent(out), optional :: stat
    integer :: i
    
    if (obsdata%nrep.le.0) then
       if (present(stat)) then
          stat = 1
          return
       else
          call abort3d("obsdata_set_index: No reports available. Check for consistency between file obsinfo_chm, " // &
                       "input BURP file and input NAMBURP_FILTER_CHM* namelist.")
       end if
    end if

    i=0
 
    ! Search for matching identifier code
    do while (trim(obsdata%code(obsdata%irep)).ne.trim(code))
       obsdata%irep=obsdata%irep+1
       if (obsdata%irep.gt.obsdata%nrep) obsdata%irep=1
       if (i.gt.obsdata%nrep) then
          if (present(stat)) then
             stat = 2
             return
          else
             call abort3d("obsdata_set_index: Obs index not found for nrep = " // trim(str(obsdata%nrep)) // " and code = '" // code // "'")
          end if
       end if
       i=i+1       
    end do
          
    if (present(stat)) stat = 0
           
  end subroutine obsdata_set_index
    
!-------------------------------------------------------------------------------------------

  function obsdata_get_loctime_code_i(ilon,ilat,date,time) result(code)
! 
!  Purpose: Generates a unique 22 character code corresponding to lon,lat,date,time. To be
!           used for setting the unique identifier 'code' in struct_chm_obsdata. Can be
!           called under the interface obsdata_get_loctime_code.
!
!  Author: M. Sitwell, April 2016
!    
!  Input
!           ilon          longitude integer
!           ilat          latitude integer
!           date          date in YYYYMMDD
!           time          time in HHMM
!
!  Output
!           code          unique code
! 
!-------------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: ilon,ilat,date,time
    character(len=22)   :: code

    if (ilon.gt.0) then
       write(code(1:5),'(I5.5)') ilon
    else
       write(code(1:5),'(I5.5)') 36000 + ilon
    end if
    
    write(code(6:10),'(I5.5)') ilat
    write(code(11:18),'(I8.8)') date
    write(code(19:22),'(I4.4)') time

  end function obsdata_get_loctime_code_i

!-------------------------------------------------------------------------------------------

  function obsdata_get_loctime_code_r(lon,lat,date,time) result(code)
! 
!  Purpose: Generates a unique 22 character code corresponding to lon,lat,date,time. To be
!           used for setting the unique identifier 'code' in struct_chm_obsdata. Can be
!           called under the interface obsdata_get_loctime_code.
!
!  Author: M. Sitwell, April 2016
!    
!  Input
!           lon           longitude real (radians)
!           lat           latitude real (radians)
!           date          date in YYYYMMDD
!           time          time in HHMM
!
!  Output
!           code          unique code
! 
!-------------------------------------------------------------------------------------------
    
    use MathPhysConstants_mod

    implicit none

    real(8), intent(in) :: lon,lat
    integer, intent(in) :: date,time
    character(len=22)   :: code
    integer :: ilon,ilat
    
    ilon = nint(100*(lon/MPC_RADIANS_PER_DEGREE_R8))
    ilat = nint(100*(90. + lat/MPC_RADIANS_PER_DEGREE_R8))

    code = obsdata_get_loctime_code_i(ilon,ilat,date,time)

  end function obsdata_get_loctime_code_r

!----------------------------------------------------------------------------------------

  subroutine obsdata_add_data1d(obsdata,val,code,dim1)
!
! Author: Y. Rochon, ARQI/AQRD, June 2016
!         - Adapted from chm_add_col_boundary by M. Sitwell.
!
! Purpose: Add data value(s) to obsdata%data1d with associated identifier code.
!
! Arguments:

!  Input 
!           obsdata       struct_chm_obsdata instance
!           val           data array to store in obsdata%data1d
!           code          identifying code based on (lat,long,date,hhmm)
!           cstnid        station id identifying code (optional)
!           dim1          value() dimension (optional)
!
!  Output
!           obsdata       Updated obsdata 
! 
! Comments:
!
! - Retrieval of values from obsdata%data1d to be done via obsdata_get_element (or obsdata_get_array1d).
!
! - If obsdata allocation is required for all processors (such as for use later with obsdata_MPIGather), 
!   allocation and/or initialization of arrays needs to be done at a corresponding appropriate location 
!   outside the obs operations such as in chm_setup to ensure allocation is done for all processors, 
!   including those without associated data. This is to ensure that rpn_comm_allgather will work 
!   in routine obsdata_MPIGather.
!
!----------------------------------------------------------------------------------------

    implicit none 
    
    type(struct_chm_obsdata), intent(inout) :: obsdata
    real(8), intent(in) :: val(:)
    character(len=*), intent(in) :: code
    integer, intent(in), optional :: dim1

    if (.not.associated(obsdata%data1d)) then
      if (present(dim1)) then 
         call obsdata_alloc(obsdata,chm_config%obsdata_maxsize,dim1=dim1)
      else
         call obsdata_alloc(obsdata,chm_config%obsdata_maxsize,dim1=1)
      end if
      obsdata%nrep=0
    end if

    if (obsdata%dim1.gt.size(val)) &
         call abort3d('obsdata_add_data1d: Insufficient data values provided. ' // trim(str(size(val))) )
     
    ! nrep counts the number data values/profiles in the data arrays
    obsdata%nrep = obsdata%nrep+1 

    if (obsdata%nrep.gt.chm_config%obsdata_maxsize) &
         call abort3d('obsdata_add_data1d: Reach max size of array ' // trim(str(chm_config%obsdata_maxsize)) )
  
    ! Save unique code
    obsdata%code(obsdata%nrep)=trim(code)
    
    ! Save value(s)
    obsdata%data1d(1:obsdata%dim1,obsdata%nrep) = val(1:obsdata%dim1)
    
  end subroutine obsdata_add_data1d

!----------------------------------------------------------------------------------------
    
  subroutine obsdata_MPIgather(obsdata) 
!
! Author: Y. Rochon, ARQI/AQRD, June 2016
!
! Revisions:
!           M. AQRI/AQRD, Aug 2016
!           - obsdata set as InOut instead of having separate In and Out structures.
!
! Purpose: Gathers previously saved obsdata from all processors.
!
! Arguments
!      
!   InOut
!
!      obsdata      Local struct_chm_obsdata to become global
! 
!
! Comments:
!
! - Assumes obsdata%dim1 (and obsdata%dim2) the same over all processors.
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsdata), intent(inout) :: obsdata

    integer, allocatable :: nrep(:)
    character(len=code_len), allocatable :: code(:,:)  
    real(8), allocatable :: data1d(:,:,:),data2d(:,:,:,:)
    integer :: i,j,k,ierr,nproc,nrep_total

    character(len=*), parameter :: MPI_OBS_REAL="mpi_double_precision"
    
    ! Get values from all processors into (*,nproc) arrays where nproc is the number of processors

    ! Identify number of processors.
    call rpn_comm_size("GRID",nproc,ierr)
    
    allocate(nrep(nproc))

    nrep(:)=0
    call rpn_comm_allgather(obsdata%nrep,1,"MPI_INTEGER",nrep,1,"MPI_INTEGER","GRID",ierr)
    nrep_total=sum(nrep)
    if (nrep_total.eq.0) then
       deallocate(nrep)
       return
    end if
    
    if (nrep_total.gt.chm_config%obsdata_maxsize) &
         call abort3d('obsdata_MPIGather: Size exceeds chm_config%obsdata_maxsize of ' // trim(str(chm_config%obsdata_maxsize)) )
        
    allocate(code(chm_config%obsdata_maxsize,nproc))
    call allgather_string(obsdata%code,code,chm_config%obsdata_maxsize,code_len,nproc,"GRID",ierr)

    if (obsdata%ndim.eq.1) then
       allocate(data1d(obsdata%dim1,chm_config%obsdata_maxsize,nproc))
       call rpn_comm_allgather(obsdata%data1d,chm_config%obsdata_maxsize*obsdata%dim1,MPI_OBS_REAL, &
            data1d,chm_config%obsdata_maxsize*obsdata%dim1,MPI_OBS_REAL,"GRID",ierr)
    else       
       allocate(data2d(obsdata%dim1,obsdata%dim2,chm_config%obsdata_maxsize,nproc))
       call rpn_comm_allgather(obsdata%data2d,chm_config%obsdata_maxsize*obsdata%dim1*obsdata%dim2,MPI_OBS_REAL, &
            data2d,chm_config%obsdata_maxsize*obsdata%dim1*obsdata%dim2,MPI_OBS_REAL,"GRID",ierr)
    end if
  
    ! Concatenate values from all processors
         
    if (obsdata%ndim.eq.1) then      
       obsdata%nrep=0  
       do i=1,nproc
          if (nrep(i).gt.0) then
             obsdata%code(obsdata%nrep+1:obsdata%nrep+nrep(i))=code(1:nrep(i),i)
             obsdata%data1d(1:obsdata%dim1,obsdata%nrep+1:obsdata%nrep+nrep(i))= &
                         data1d(1:obsdata%dim1,1:nrep(i),i)
             obsdata%nrep=obsdata%nrep+nrep(i)
          end if
       end do
    else
       obsdata%nrep=0
       do i=1,nproc
          if (nrep(i).gt.0) then
             obsdata%code(obsdata%nrep+1:obsdata%nrep+nrep(i))=code(1:nrep(i),i)
             obsdata%data2d(1:obsdata%dim1,1:obsdata%dim2,obsdata%nrep+1:obsdata%nrep+nrep(i))= &
                         data2d(1:obsdata%dim1,1:obsdata%dim2,1:nrep(i),i)  
             obsdata%nrep=obsdata%nrep+nrep(i)
          end if
       end do    
    end if  
     
    deallocate(nrep,code)
    if (obsdata%ndim.eq.1) then 
        deallocate(data1d)
    else
        deallocate(data2d)
    end if 
     
  end subroutine obsdata_MPIgather
     
!-----------------------------------------------------------------------------------------
!------------------- Miscellaneous utilities functions and routines ----------------------

  subroutine chm_open_messagefile(unit)
! 
!  Purpose: Opens the file chm_message_filename.
!
!  Author: M. Sitwell, April 2016
!
!  Output
!           unit          unit number associated with chm_message_filename (optional)
!
!-------------------------------------------------------------------------------------------

    implicit none

    integer, intent(out), optional :: unit
    logical :: file_exists
    integer :: ier
    integer, external :: fnom
    character(len=20) :: mode
    
    inquire(file=chm_config%message_filename, exist=file_exists)
    
    chm_message_unit = 0

    if (file_exists) then
       mode = 'FTN+APPEND+R/W'
    else
       mode = 'FTN+R/W'
    end if

    !ier = fnom(chm_message_unit,chm_config%message_filename,trim(mode),0)
    ier = open_file(chm_message_unit,chm_config%message_filename,trim(mode))

    if (ier.ne.0) call abort3d('chm_open_messagefile: Error associating unit number')

    if (present(unit)) unit = chm_message_unit

  end subroutine chm_open_messagefile

!-------------------------------------------------------------------------------------------

  function open_file(unit,filename,mode) result(ier)
! 
!  Purpose: This is a temporary subroutine to open a file with fnom that is needed due to
!           a bug in fnom that does not allow an ascii file to be opened in 'APPEND' mode.
!
!  Author: M. Sitwell, Aug 2016
!
!-------------------------------------------------------------------------------------------

    implicit none

    integer, intent(inout) :: unit
    character(len=*) :: filename,mode
    integer :: ier
    character(len=10) :: position,action
    integer, external :: fnom

    if (index(mode,'APPEND').gt.0) then
       position = 'APPEND'
    else
       position = 'ASIS'
    end if
    
    if (index(mode,'R/W').gt.0) then
       action = 'READWRITE'
    else
       action = 'READ'
    end if

    ier = fnom(unit,filename,mode,0)

    close(unit=unit)
    open(unit=unit, file=filename, position=position, action=action)

  end function open_file
    
!-------------------------------------------------------------------------------------------

  function stnid_equal(id1,id2) result(same)
!
! Author  : Y. Rochon  Nov 2014
! Revision: 
!           M. Sitwell, Feb 2015
!           - Code set as a function.
!           Y. Rochon, July 2015
!           - Accounted for ilen1>ilen2 with the additional characters being *
!           M. Sitwell, Aug 2015
!           - Made function symmetric so that * is treated as a wildcard
!             for both arguments
!
! Purpose: Compares STNID values allowing for * as wildcards and trailing blanks 
!
! Input
!          id1         reference stnid
!          id2         stnid being verified
!
! Output
!
!          same        logical indicating if id1 and id2 match
!     
!-----------------------------------------------------------------------------------------    

    implicit none

    logical :: same
    CHARACTER(len=*), intent(in) :: id1,id2
    integer :: ilen1,ilen2,ji

    same=.true.
    ilen1=len_trim(id1)
    ilen2=len_trim(id2)  
              
    do ji=1,min(ilen1,ilen2)
       if ( id1(ji:ji).ne.'*' .and. id2(ji:ji).ne.'*' .and. id2(ji:ji).ne.id1(ji:ji) ) then
          same = .false.
          exit
       end if
    end do
    
    if (same.and.ilen1.gt.ilen2) then
       do ji=ilen2+1,ilen1
          if (id1(ji:ji).ne.'*') then
              same=.false.
              exit
          end if
       end do
    else if (same.and.ilen2.gt.ilen1) then
       do ji=ilen1+1,ilen2
          if (id2(ji:ji).ne.'*') then
              same=.false.
              exit
          end if
       end do
    end if
        
  end function stnid_equal
 
!-------------------------------------------------------------------------------------------

  character(len=20) function int2str(i)
!
! Author  : M. Sitwell Oct 2015
!
! Purpose: Function for integer to string conversion. Helpful when calling subroutine abort3d.
!
!-------------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: i
    
    write(int2str,*) i
    int2str = adjustl(int2str)
    
  end function int2str
            
!-------------------------------------------------------------------------------------------

  character(len=20) function float2str(x)
!
! Author:  M. Sitwell April 2016
!
! Purpose: Function for integer to string conversion. Helpful when calling subroutine abort3d.
!
!-------------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: x

    write(float2str,*) x
    float2str = adjustl(float2str)

  end function float2str

!-------------------------------------------------------------------------------------------

  subroutine chm_get_stringId(cstringin,nobslev,CList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from a list of accumulating character 
!            strings (e.g. stnids).
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!    
!   Revisions:
!            Y.J. Rochon, ARQI/AQRD, July 2015
!            - Account for wildcards (use if stnid_equal) when present.         
!
!   Input:
!
!       Nmax            Max allowed dimension.
!       NListSize       Input number of identified IDs (must be >=0 and <=Nmax)
!       CList           Input list of accumulated character strings
!                       for uni and multi-level data.
!       cstringin       Input character string
!       nobslev         Number of elements in profile associated to cstringin.
!
!   Output:
!
!       NListSize       Updated number of identified IDs
!       CList           Updated list of accumulated character strings
!       elemId          Index of cstringin within CList_chm
!        
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,nobslev
    integer, intent(inout) :: NListSize
    integer, intent(out)   :: elemId
    character(len=*), intent(in)     :: cstringin
    character(len=*),  intent(inout) :: CList(Nmax)
  
    integer :: i
    character(len=120) :: cstring
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_stringId: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       if (nobslev.eq.1) then 
          cstring=trim(cstringin)//'U'
          do i=1,NListSize
             if (trim(cstring).eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       else 
          cstring=trim(cstringin)       
          do i=1,NListSize
             if (trim(cstring).eq.trim(CList(i))) then
                 elemId=i
                 exit
             end if
          end do
       end if
       
       if (elemId.eq.0) then
          do i=1,NListSize
             if (stnid_equal(trim(CList(i)),trim(cstring))) then
                elemId=i
                exit
             end if
          end do
       end if
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        if (nobslev.eq.1) then
           CList(NListSize)=trim(cstringin)//'U'
        else
           CList(NListSize)=trim(cstringin)
        end if
    end if
    
  end subroutine chm_get_stringId

!-------------------------------------------------------------------------------------------

  subroutine chm_get_Id(id,IdList,NListSize,Nmax,elemId)

! 
!   Purpose: Get element ID from list of accumulating integer IDs.
!
!            Called by filt_topoChm in filterobs_mod.ftn90
!
!   Author: Y.J. Rochon, ARQI/AQRD, Feb 2015
!
!   Input:
!
!       Nmax         Max allowed dimension.
!       NListSize    Input number of IDs (must be >=0 and <=Nmax)
!       IdList       Input list of accumulated IDs.
!       id           Input id for individual obs
!
!   Output:
!
!       NListSize    Updated number of IDs 
!       IdList       Updated list of accumulated IDs.
!       elemId       Index of id within List
!     
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in)    :: Nmax,id
    integer, intent(inout) :: NListSize,IdList(Nmax)
    integer, intent(out)   :: elemId
  
    integer :: i
    
    elemId=0
    if (NListSize.gt.Nmax-1) then
       call abort3d('chm_get_Id: Dimension error, NListSize > Nmax-1.')     
    else if (NListSize.gt.0) then
       do i=1,NListSize
          if (id.eq.IdList(i)) then
              elemId=i
              exit
          end if
       end do
    end if

    if (elemID.eq.0) then
        NListSize=NListSize+1
        elemId=NListSize
        IdList(NListSize)=id
    end if
    
    
  end subroutine chm_get_Id

!-------------------------------------------------------------------------------------------

  subroutine chm_comboIdlist(stnid_add,varno_add,unilev_add,stnid_list,varno_list,unilev_list, &
                             num_elements,initialize,nset,gather_mpi,all_combos)
! 
!   Purpose: Provide list of fixed or accumulated stnid, (stnid,varno) or 
!            (stnid,varno,multi/uni-level) combinations to be used in searches.
!
!            Can be used for both single processor and  MPI mode, where 'gather_mpi' must be set
!            to .true. at some point for use with MPI.
!
!            Called from osd_chem_diagnmostics in file obspacediag_mod.ftn90.
!
!   Author: Y.J. Rochon, ARQI/AQRD, Aug 2015
!    
!   Revisions: M. Sitwell, ARQI/AQRD, Aug 2015
!              - Moved module variables required for this subroutine to local saved variables
!              - Merged MPI and non-MPI routines (although rpn_comm_* routines must be available 
!                at compilation even if not run in MPI mode)
!
!   Input:
!
!       stnid_add      stnid to add to stnid_list if part of unique set
!       varno_add      varno to add to varno_list if part of unique set
!       unilev_add     unilev logical to add to unilev_list if part of unique set
!       initialize     Initialize internal arrays and counters
!       gather_mpi     Gather all local MPI process and recompile unique lists
!
!   Inout:
!
!       nset           Integer indicating grouping of diagnostics. Input variable
!                      if initialize=.true., output variable otherwise.
!                      Values indicate
!                       1: group by stnid
!                       2: group by (stnid,bufr)
!                       3: group by (stnid,bufr,multi/uni-level)
!
!       all combos     Indicates if all combinations specified by nset are to
!                      be use, or only those specified in the namelist NAMCHEM
!                      Input variable if initialize=.true., output variable
!                      otherwise.
!
!   Output:
!
!       stnid_list     List of unique stnids
!       varno_list     List of unique varno
!       unilev_list    List of unique uni/multi-level identifications
!       num_elements   Number of unique elements in *_list arrrays
!
!-------------------------------------------------------------------------------------------
 
    implicit none
    
    integer, parameter :: nmax=100,stnid_len=9

    logical, intent(in), optional :: initialize,gather_mpi,unilev_add
    integer, intent(in), optional :: varno_add
    character(len=stnid_len), intent(in), optional :: stnid_add

    integer, intent(inout), optional :: nset
    logical, intent(inout), optional :: all_combos

    integer, intent(out), optional :: varno_list(nmax),num_elements
    character(len=stnid_len), intent(out), optional :: stnid_list(nmax)
    logical, intent(out), optional :: unilev_list(nmax)

    ! local arrays of unique values
    integer, save :: varno_unique(nmax)
    character(len=stnid_len), save :: stnid_unique(nmax)
    logical, save :: unilev_unique(nmax)
    
    ! global arrays of unique values
    integer, allocatable :: num_unique_all(:),varno_unique_all(:,:)
    character(len=stnid_len),allocatable :: stnid_unique_all(:,:)
    logical, allocatable :: unilev_unique_all(:,:)

    integer, save :: num_unique ! running count of number of unique elements
    integer, save :: iset=2
    logical, save :: lall_combos=.true.

    logical :: same,init
    integer :: i,j,nproc,iproc,ierr

    init=.false.
    if (present(initialize)) init = initialize

    
    ! Initialize internal arrays and counters
    if (init) then
       stnid_unique(:) = ''
       varno_unique(:) = 0
       unilev_unique(:) = .false.
       num_unique = 0
       if (present(nset)) iset = nset
       if (present(all_combos)) lall_combos = all_combos
    end if      


    ! Add new elements to internal arrays if not there already
    if (present(stnid_add)) then
      
       if (iset.ge.2 .and. (.not. present(varno_add))) call abort3d('chm_comboIdlist: varno_add must be present to add element for nset>=2.')
       if (iset.ge.3 .and. (.not. present(unilev_add))) call abort3d('chm_comboIdlist: unilev_add must be present to add element for nset>=3.')

       same = .false.

       do i=1,num_unique
          same = stnid_equal(stnid_add,stnid_unique(i))
          if (iset.ge.2) same = same .and. varno_add.eq.varno_unique(i)
          if (iset.ge.3) same = same .and. unilev_add.eqv.unilev_unique(i)
          if (same) exit
       end do

       if (.not.same) then
          num_unique=num_unique+1
          if (num_unique.gt.nmax) call abort3d("chm_comboIDlist: Max allowed dimension exceeded.")
          stnid_unique(num_unique) = stnid_add
          if (iset.ge.2) varno_unique(num_unique) = varno_add
          if (iset.ge.3) unilev_unique(num_unique) = unilev_add
       end if
    end if
        

    ! Gather unique arrays from each local mpi process and compile global unique arrays
    if (present(gather_mpi)) then
       if (gather_mpi) then

          call rpn_comm_size("GRID",nproc,ierr)

          allocate(num_unique_all(nproc))
          allocate(stnid_unique_all(nmax,nproc))
          if (iset.ge.2) allocate(varno_unique_all(nmax,nproc))
          if (iset.ge.3) allocate(unilev_unique_all(nmax,nproc))
          
          num_unique_all(:) = 0
          stnid_unique_all(:,:) = ''
          if (iset.ge.2) varno_unique_all(:,:) = 0
          if (iset.ge.3) unilev_unique_all(:,:) = .false.
          
          call rpn_comm_barrier("GRID",ierr)

          call rpn_comm_allgather(num_unique,1,"MPI_INTEGER",num_unique_all,1,"MPI_INTEGER","GRID",ierr)
          call allgather_string(stnid_unique,stnid_unique_all,nmax,stnid_len,nproc,"GRID",ierr)
          if (iset.ge.2) call rpn_comm_allgather(varno_unique,nmax,"MPI_INTEGER",varno_unique_all,nmax,"MPI_INTEGER","GRID",ierr)
          if (iset.ge.3) call rpn_comm_allgather(unilev_unique,nmax,"MPI_LOGICAL",unilev_unique_all,nmax,"MPI_LOGICAL","GRID",ierr)
          
          stnid_unique(:) = ''
          if (iset.ge.2) varno_unique(:) = 0
          if (iset.ge.3) unilev_unique(:) = .false.
          num_unique = 0
          
          ! Amalgamate unique lists
          do iproc=1,nproc
             do j=1,num_unique_all(iproc)

                same = .false.

                do i=1,num_unique
                   same = stnid_equal(stnid_unique_all(j,iproc),stnid_unique(i))
                   if (iset.ge.2) same = same .and. varno_unique_all(j,iproc).eq.varno_unique(i)
                   if (iset.ge.3) same = same .and. unilev_unique_all(j,iproc).eqv.unilev_unique(i)
                   if (same) exit
                end do
              
                if (.not.same) then
                   num_unique=num_unique+1
                   if (num_unique.gt.nmax) call abort3d("chm_comboIDlist: Max allowed dimension exceeded.")
                   stnid_unique(num_unique) = stnid_unique_all(j,iproc)
                   if (iset.ge.2) varno_unique(num_unique) = varno_unique_all(j,iproc)
                   if (iset.ge.3) unilev_unique(num_unique) = unilev_unique_all(j,iproc)
                end if
             end do
          end do

          deallocate(num_unique_all,stnid_unique_all)
          if (allocated(varno_unique_all)) deallocate(varno_unique_all)
          if (allocated(unilev_unique_all)) deallocate(unilev_unique_all)

       end if
    end if


    ! Return internal arrays (and other info) if requested
    if (present(varno_list)) varno_list = varno_unique
    if (present(stnid_list)) stnid_list = stnid_unique
    if (present(unilev_list)) unilev_list = unilev_unique
    if (present(num_elements)) num_elements = num_unique
    if (.not. init) then
       if (present(nset)) nset = iset
       if (present(all_combos)) all_combos = lall_combos
    end if
    
  end subroutine chm_comboIdlist

!-------------------------------------------------------------------------------------------

  subroutine allgather_string(str_list,str_list_all,nlist,nchar,nproc,comm,ierr)
! 
!   Purpose: Performs the MPI 'allgather' routine for an array of strings
!
!   Author:  Y. Rochom, ARQI/AQRD, July 2015
!
!   Revisions:  M. Sitwell, ARQI/AQRD, Aug 2015
!               - Code set as a subroutine
!-------------------------------------------------------------------------------------------

    implicit none

    character(len=nchar), intent(in) :: str_list(nlist)
    character(len=*), intent(in) :: comm
    integer, intent(in) :: nlist,nchar,nproc
    character(len=nchar), intent(out) :: str_list_all(nlist,nproc)
    integer, intent(out) :: ierr

    integer :: num_list(nlist*nchar),num_list_all(nlist*nchar,nproc)
    integer :: ilist,ichar,iproc
              
    ! Convert strings to integer sequences

    do ilist=1,nlist
       do ichar=1,nchar
          num_list((ilist-1)*nchar+ichar) = iachar(str_list(ilist)(ichar:ichar))
       end do
    end do

    ! Perform allgather with converted integer sequences

    call rpn_comm_allgather(num_list,nlist*nchar,"MPI_INTEGER",num_list_all,nlist*nchar,"MPI_INTEGER",comm,ierr)
       
    ! Convert integer sequences to stnid character strings
          
    do iproc=1,nproc
       do ilist=1,nlist
          do ichar=1,nchar
             str_list_all(ilist,iproc)(ichar:ichar) = achar(num_list_all((ilist-1)*nchar+ichar,iproc))
          end do
       end do
    end do

  end subroutine allgather_string

!-------------------------------------------------------------------------------------------

  logical function chm_diagn_only(cstnid,varno,nobslev)

! 
!   Purpose: Identify whether or not the obs set identified by 
!            the combination of (cstnidin, bufrin,nlevs) will be
!            be assimilated or used for independent verifications.
!
!   Author: Y.J. Rochon, ARQI/AQRD, July 2015
!    
!   Revisions:
!
!   Input:
!
!       cstnid           Input station id
!       varno            Obs BUFR number
!       nobslev          Number of levels
!
!   Output:
!
!       chm_diagn_only     Indicating if assimilation to be skipped but data
!                         is to be used for independent verifications after 
!                         assimilation/minimization.
!
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in) :: varno, nobslev
    character(len=*), intent(in) :: cstnid
  
    integer :: i,elemId
    
    chm_diagn_only=.false.
    if (chm_config%assim_num.eq.-1) return
    
    if (chm_config%assim_num.eq.0) then
       chm_diagn_only=.true.  ! will not be assimilated
    else if (chm_config%assim_num.gt.0) then
       elemId=0   
       do i=1,chm_config%assim_num
          if (stnid_equal(trim(chm_config%assim_stnid(i)),trim(cstnid))) then
             if (chm_config%assim_varno(i).eq.0.or.chm_config%assim_varno(i).eq.varno) then
                if (chm_config%assim_nlev(i).eq.0.or.(nobslev.eq.1.and.chm_config%assim_nlev(i).eq.1).or. &
                   (nobslev.gt.1.and.chm_config%assim_nlev(i).gt.1)) then
                    elemId=i
                    exit
                end if
             end if
          end if
       end do
       if (elemId.eq.0) chm_diagn_only=.true.   ! will not be assimilated
    end if
       
  end function chm_diagn_only

!-------------------------------------------------------------------------------------------

  subroutine resize_1d_real(arr,dim1)
!
! Author  : M. Sitwell  April 2015
! Revision: 
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
    implicit none

    real(8), pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    real(8), pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = 0.0D0
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_1d_real
!-------------------------------------------------------------------------------------------

  subroutine resize_1d_int(arr,dim1)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
     
    implicit none

    integer, pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    integer, pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = 0
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_1d_int

!---------------------------------------------------------------------------------------
  
  subroutine resize_1d_str(arr,dim1)
!
! Author  : M. Sitwell  April 2016
!
! Purpose: Resize 1D array
!
!---------------------------------------------------------------------------------------
     
    implicit none

    character(len=*), pointer, intent(inout) :: arr(:)
    integer, intent(in) :: dim1
    character(len=len(arr(1))), pointer :: tmp(:)
    integer :: dim1_in,d1

    dim1_in = size(arr)
    d1 = min(dim1_in, dim1)

    allocate(tmp(dim1))
    tmp(1:d1) = arr(1:d1)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1) = ""
    
    deallocate(arr)
    arr => tmp
    nullify(tmp)

  end subroutine resize_1d_str

!----------------------------------------------------------------------------------------
  
  subroutine resize_2d_real(arr,dim1,dim2)
!
! Author  : M. Sitwell  April 2015
!
! Purpose: Resize 2D array
!
! Revision: 
!           Y. Rochon Feb 2016
!           - Added option to increase array sizes
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:)
    integer, intent(in) :: dim1,dim2
    real(8), pointer :: tmp(:,:)
    integer :: dim1_in,dim2_in,d1,d2

    dim1_in = size(arr,dim=1)
    dim2_in = size(arr,dim=2)
    d1 = min(dim1_in, dim1)
    d2 = min(dim2_in, dim2)

    allocate(tmp(dim1,dim2))
    tmp(1:d1,1:d2) = arr(1:d1,1:d2)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1,:) = 0.0D0
    if (dim2.gt.dim2_in) tmp(:,d2+1:dim2) = 0.0D0
      
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_2d_real

!-----------------------------------------------------------------------------------------
  
  subroutine resize_3d_real(arr,dim1,dim2,dim3)
!
! Author  : M. Sitwell  May 2015
! Revision: 
!
! Purpose: Resize 3D array
!
!---------------------------------------------------------------------------------------

    implicit none

    real(8), pointer, intent(inout) :: arr(:,:,:)
    integer, intent(in) :: dim1,dim2,dim3
    real(8), pointer :: tmp(:,:,:)
    integer :: dim1_in,dim2_in,dim3_in,d1,d2,d3

    dim1_in = size(arr,dim=1)
    dim2_in = size(arr,dim=2)
    dim3_in = size(arr,dim=3)
    d1 = min(dim1_in, dim1)
    d2 = min(dim2_in, dim2)
    d3 = min(dim3_in, dim3)

    allocate(tmp(dim1,dim2,dim3))
    tmp(1:d1,1:d2,1:d3) = arr(1:d1,1:d2,1:d3)

    if (dim1.gt.dim1_in) tmp(d1+1:dim1,:,:) = 0.0D0
    if (dim2.gt.dim2_in) tmp(:,d2+1:dim2,:) = 0.0D0
    if (dim3.gt.dim3_in) tmp(:,:,d3+1:dim3) = 0.0D0
    
    deallocate(arr)

    arr => tmp
    
    nullify(tmp)

  end subroutine resize_3d_real

!---------------------------------------------------------------------------------------
  
  subroutine chm_dealloc_info(info)
!
! Author  : M. Sitwell  May 2015
!
! Purpose: Deallocates struct_chm_info instance
!
!---------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_info), intent(inout) :: info

    if (allocated(info%stnids))       deallocate(info%stnids)
    if (allocated(info%bfr))          deallocate(info%bfr)
    if (allocated(info%brp))          deallocate(info%brp)
    if (allocated(info%vco))          deallocate(info%vco)
    if (allocated(info%n_lat))        deallocate(info%n_lat)
    if (allocated(info%ibegin))       deallocate(info%ibegin)
    if (allocated(info%n_lvl))        deallocate(info%n_lvl)
    if (allocated(info%rak))          deallocate(info%rak)
    if (allocated(info%vlayertop))    deallocate(info%vlayertop)
    if (allocated(info%vlayerbottom)) deallocate(info%vlayerbottom)
    if (allocated(info%lat))          deallocate(info%lat)

  end subroutine chm_dealloc_info

!-----------------------------------------------------------------------------------

  subroutine chm_apply_transform_array4d(varName,bkgrnd_ptr,l_reverse,mode,incr_ptr)
!
! Author: Y. Rochon, Nov 2015
!
! Purpose: Apply transform (or its inverse) of 4D background field or increment field.
!          Called by chm_transform_final_increments in file chem_interface_mod.ftn90.
!
! Revisions:
!        M. Sitwell, April 2016
!          - Added input integer mode for selection of transform sub-type.
!          - Create new sub-function log_matrix from previous code for handling
!            negative values before taking the log. 
!
! Arguments:
!
!   In
!
!     varName          Field name (nomvar)
!     l_reverse        Reverse/inverse transformation
!     mode             selected sub-transformation type (defined for each transformation
!                      given in chm_config%transform)
!
!   InOut
!
!     bkgrnd_ptr       pointer to statevector for the background
!     incr_ptr         pointer to increment field
!
!-----------------------------------------------------------------------------------

    implicit none
    
    character(len=*), intent(in) :: varName
    integer, intent(in) :: mode
    logical, intent(in) :: l_reverse

    real(8), intent(inout), pointer :: bkgrnd_ptr(:,:,:,:)        
    real(8), intent(inout), pointer, optional :: incr_ptr(:,:,:,:)   

    integer :: iconstituent_id

    iconstituent_id = chm_varnumFromVarname(varName)
    if (iconstituent_id.lt.0.or.iconstituent_id.gt.chm_constituents_size) return
    
    write(*,'(A,I2,A,I2,A,A)') "chm_apply_transform_array4d: applying transform number ",chm_config%transform(iconstituent_id), &
         " with mode = ",mode," for field ",trim(varName)

    select case(chm_config%transform(iconstituent_id))
    case(0)
       return
    case(1)
    
       ! Transform lnx to/from x or dlnx to/from dx
       
       if (.not.present(incr_ptr).and.(mode.eq.1.or.mode.eq.2)) &
            call abort3d("chm_apply_transform_array4d: incr_ptr must be provided for mode = " // trim(str(mode)) )

       if (.not.l_reverse) then

          ! Forward transformation
              
          select case(mode)
          case(0)
             bkgrnd_ptr = log_matrix(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = log_matrix(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = log_matrix(bkgrnd_ptr+incr_ptr) - log_matrix(bkgrnd_ptr)           
          end select

       else
    
          ! Reverse transformation          
       
          select case(mode)
          case(0)
             bkgrnd_ptr = exp(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = exp(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = exp(bkgrnd_ptr+incr_ptr) - exp(bkgrnd_ptr)
          end select 
             
       end if

    case default
       call abort3d("chm_apply_transform_array4d: transform selection " // trim(str(chm_config%transform(iconstituent_id))) // " not currenly defined." )
    end select
    
  contains

    function log_matrix(mat)
    !
    ! Author: Y. Rochon, Nov 2015 (made into function by M. Sitwell)
    !
    ! Purpose: Helper function for taking the log of a matrix that might contain negative values.
    !          Places where negative values occur will be set as the log of the minimum positive
    !          value along the first (longitudinal) dimension.
    !
    !-----------------------------------------------------------------------------------

      implicit none

      real(8), intent(in) :: mat(:,:,:,:)
      real(8) :: log_matrix(size(mat,1),size(mat,2),size(mat,3),size(mat,4))

      integer :: j,k,m
      real(8) :: valmin

      do m=1,size(mat,4)
         do j=1,size(mat,3)
            do k=1,size(mat,2)

               valmin = minval(mat(:,k,j,m), mask=mat(:,k,j,m).gt.0.0)
               if (valmin.gt.1.E30) valmin=1.E-20

               where (mat(:,k,j,m).gt.0.0)
                  log_matrix(:,k,j,m) = log(mat(:,k,j,m))
               elsewhere
                  log_matrix(:,k,j,m) = log(valmin)
               end where
               
            end do
         end do
      end do

    end function log_matrix

  end subroutine chm_apply_transform_array4d
!-----------------------------------------------------------------------------------

  subroutine chm_apply_transform_array1d(varName,bkgrnd_ptr,l_reverse,mode,incr_ptr)
!
! Author: Y. Rochon, May 2016 (based on chm_apply_transform_array4d)
!
! Purpose: Apply transform (or its inverse) of background field or increment profiles.
!
! Revisions:
!
! Arguments:
!
!   In
!
!     varName          Field name (nomvar)
!     l_reverse        Reverse/inverse transformation
!     mode             selected sub-transformation type (defined for each transformation
!                      given in chm_config%transform)
!
!   InOut
!
!     bkgrnd_ptr       statevector profile
!     incr_ptr         increment profile
!
!-----------------------------------------------------------------------------------

    implicit none
    
    character(len=*), intent(in) :: varName
    integer, intent(in) :: mode
    logical, intent(in) :: l_reverse

    real(8), intent(inout) :: bkgrnd_ptr(:)        
    real(8), intent(inout), optional :: incr_ptr(:)   

    integer :: iconstituent_id

    iconstituent_id = chm_varnumFromVarname(varName)
    if (iconstituent_id.lt.0.or.iconstituent_id.gt.chm_constituents_size) return
    
    write(*,'(A,I2,A,I2,A,A)') "chm_apply_transform_array1d: applying transform number ",chm_config%transform(iconstituent_id), &
         " with mode = ",mode," for field ",trim(varName)

    select case(chm_config%transform(iconstituent_id))
    case(0)
       return
    case(1)
    
       ! Transform lnx to/from x or dlnx to/from dx
       
       if (.not.present(incr_ptr).and.(mode.eq.1.or.mode.eq.2)) &
            call abort3d("chm_apply_transform_array1d: incr_ptr must be provided for mode = " // trim(str(mode)) )

       if (.not.l_reverse) then

          ! Forward transformation
              
          select case(mode)
          case(0)
             bkgrnd_ptr = log(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = log(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = log(bkgrnd_ptr+incr_ptr) - log(bkgrnd_ptr)           
          end select

       else
    
          ! Reverse transformation          
       
          select case(mode)
          case(0)
             bkgrnd_ptr = exp(bkgrnd_ptr)
          case(1)
             bkgrnd_ptr = exp(bkgrnd_ptr+incr_ptr)
          case(2)
             incr_ptr = exp(bkgrnd_ptr+incr_ptr) - exp(bkgrnd_ptr)
          end select 
             
       end if

    case default
       call abort3d("chm_apply_transform_array1d: transform selection " // trim(str(chm_config%transform(iconstituent_id))) // " not currenly defined." )
    end select
    
  end subroutine chm_apply_transform_array1d

!-----------------------------------------------------------------------------------
 
    function chm_varnumFromVarName(varName) result(varNumber)
!
!   Author: Y.J. Rochon (ARQI), Jan. 2016
!
!   Revisions:
!
!   Purpose: Identifies varNumber from varName for use in assimilating obs in the CH family.
! 
!   IMPORTANT: varNumber is intended here to be associated to the field/variable (varName) and 
!   not the observation units (BUFR number stored as OBS_VNM in obsSpaceData).
!   In the assignments below, one varNumber is associated to each varName.
!
!   For NWP, there is a 1-1 association between sets of observation units and the variable(s).
!   This is not the case for chemical assimilation as the same units can be associated
!   to different obs fields. 
!     
!-----------------------------------------------------------------------------------
      use bufr
      implicit none
      character(len=*),  intent(in) :: varName
      integer    :: varNumber
      
      varNumber=0
      select case (varName)
      
      ! Weather variables (assumes one specific BUFR per varname (for other possible
      ! cases, see varnamelist_mod)
      
      case('UU')
        varNumber=BUFR_NEUU
      case('VV')
        varNumber=BUFR_NEVV
      case('TT')
        varNumber=BUFR_NETT
      case('GZ')
        varNumber=BUFR_NEDZ
      case('HU')
!       Use table 08046 value of varNumber instead of that used for NWP when handling 'CH' observations
!       as constituent obs.
!        varNumber=BUFR_NEHU  
        varNumber=BUFR_NECH_H2O
      case('P0')
        varNumber=BUFR_NEPS
      case('DW')
        varNumber=BUFR_NEDW

      ! Atmospheric constituents other that H2O
              
      case('O3','TO3')
        varNumber=BUFR_NECH_O3
      case('TH2O')
        varNumber=BUFR_NECH_H2O
      case('TCH4')
        varNumber=BUFR_NECH_CH4
      case('TCO2')
        varNumber=BUFR_NECH_CO2
      case('TCO','ECO')
        varNumber=BUFR_NECH_CO
      case('TNO2','ENO2')
        varNumber=BUFR_NECH_NO2
      case('TN2O')
        varNumber=BUFR_NECH_N2O
      case('TNO')
        varNumber=BUFR_NECH_NO
      case('HCHO','THCH','EHCH')
        varNumber=BUFR_NECH_HCHO
      case('SO2','TSO2','ESO2')
        varNumber=BUFR_NECH_HCHO
      case('NH3','TNH3','ENH3')
        varNumber=BUFR_NECH_NH3
      case('AF')
        varNumber=BUFR_NECH_PM25
      case('AC')
        varNumber=BUFR_NECH_PM10
        
      case default
         call abort3d('chm_varnumFromVarName: Unknown variable name ' // trim(varName) )
      end select

      if (varNumber.lt.7000.and.varNumber.gt.chm_constituents_size) then
         ! Assume NWP fields have varNumber >=7000 and so constituent fields are to have varNumber < 7000.
         call abort3d('chm_varnumFromVarName: chm_constituents_size less than ' // trim(str(varNumber)) // ' for ' // trim(varName) )         
      end if
      
    end function chm_varnumFromVarname

!-----------------------------------------------------------------------------------

  subroutine chm_apply_2dfieldr4_transform(iconstituent_id,varName,jlev,jstep,field,l_reverse)
!
! ****** NOT TESTED *********
!
! Author: Y. Rochon, Feb 2016
!
! Revisions:
!
! Purpose: Apply transform (or its inverse) of 2D field.
!          Called by routine readTrialField in file sugomobs.ftn90. 
!
! Arguments:
!
!   In
!
!     iconstituent_id BUFR code element of Table 08046 identifying the constituent.
!     varName         Field name (nomvar)
!     l_reverse       Reverse/inverse transformation if present.
!     jlev            vertical level index
!     jstep           Time step index
!
!   InOut
!
!     field           2D field
!
! Comments:
!
! 1. The EnVar assumes that the input background error covariances are provided
!    for the transformed field if a variable transformation is requested!
!
!-----------------------------------------------------------------------------------

    implicit none
    
    integer, intent(in) :: iconstituent_id,jlev,jstep
    character(len=*), intent(in) :: varName
    logical, intent(in), optional :: l_reverse

    real(4), intent(inout) :: field(:,:)            

    integer :: i,j,ier
    real(4) :: valmin
    integer, external :: fclos
    
    if (iconstituent_id.ge.0.and.iconstituent_id.le.chm_constituents_size) return
    
    if (chm_config%transform(iconstituent_id).eq.0) return
    
    ! Open output message file
    call chm_open_messagefile()

    write(chm_message_unit,*)
    
    if (chm_config%transform(iconstituent_id).eq.1) then

       ! Transform lnx to/from x or dlnx to/from dx
           
       if (.not.present(l_reverse)) then
       
          ! Forward transformation
 
          do j=1,size(field,2)
             valmin=minval(field(:,j),mask=field(:,j).gt.0.0)
             if (valmin.gt.1.E30) valmin=1.E-20
             do i=1,size(field,1) 
                if (field(i,j).lt.0.0) then
                   write(chm_message_unit,'(A,G9.2,A,A)') "Unexpected/undesired negative value of ",field(i,j), " for input field ",trim(varName)
                   write(chm_message_unit,'(A,3I4,A,I3,A,G9.2)')  "at location (",i,j,jlev,") and step ",jstep,". Value replaced by ",valmin,"."                    
                   field(i,j)=valmin
                end if
             end do
          end do
      
          field=log(field)
     
       else
    
          ! Reverse transformation          
       
          field=exp(field)
             
       end if 
   
    else
     
        call abort3d('chm_apply_2dfieldr4_transform: Transformation #' // trim(str(iconstituent_id)) // &
             ' for constituent ' // trim(str(iconstituent_id)) // " and variable name " // trim(varname) // &
             ' is not defined.')
    end if
    
    write(chm_message_unit,*) 
    ier=fclos(chm_message_unit)
 
  end subroutine chm_apply_2dfieldr4_transform

!-----------------------------------------------------------------------------------

  subroutine chm_apply_bounds(varName,bkgrnd_ptr,inc_ptr)
!
! Author: M. Sitwell Sept 2015
!         - Originally as chm_check_negative
!
! Revisions:
!            Y. Rochon, Nov 2015
!            - Modified to chm_apply_bounds
!
! Purpose: Checks for negative analysis values and if any negative values found will
!          modify the increment so that the analysis  is reset to low_cutoff*background
!          at these points. This check is done with fields of the same resolution as
!          the increment. Also applies upper bound.
!
!          Called by chm_transform_final_increments in file chem_interface_mod.ftn90.
!
! In
!
!    varName        Field name (nomvar)
!
! InOut
!
!   inc_prt          pointer to statevector for the increment
!   bkgrnd_prt       pointer to statevector for the background (with same resolution as the increment)
!
!-----------------------------------------------------------------------------------
    implicit none
    
    character(len=*), intent(in) :: varName

    real(8), intent(inout), pointer :: inc_ptr(:,:,:,:),bkgrnd_ptr(:,:,:,:)        
    logical, allocatable :: outside(:,:,:,:)

    integer :: iconstituent_id,nlow,nhigh,i1,i2,i3,i4,ier
    integer, external :: fclos
    
    iconstituent_id = chm_varnumFromVarname(varName)
    if (iconstituent_id.lt.0.or.iconstituent_id.gt.chm_constituents_size) return

    ! Open output file
    call chm_open_messagefile()
    
    allocate(outside(size(inc_ptr,1),size(inc_ptr,2),size(inc_ptr,3),size(inc_ptr,4)))

    if (chm_config%low_cutoff(iconstituent_id).ge.0.0) then

       ! Check if both background and analysis are negative. If so set the increment to force an analysis of zero at these locations
       outside = bkgrnd_ptr.lt.0.0 .and. bkgrnd_ptr+inc_ptr.lt.0.0
       nlow = count(outside)

       if (nlow.gt.0) then
          write(chm_message_unit,'(A,I7,A,A,A)') "chm_apply_bounds: ",nlow," negative background and analysis values were found for field ",trim(varName),"."
          write(chm_message_unit,'(A)') "Modifying the increment so the analysis is instead equal to zero at these locations."       
          write(chm_message_unit,'(A)') "JLON JLEV JLAT TSTEP   Background   Init. incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(chm_message_unit,'(4(I4,1X),2G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4),inc_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = -bkgrnd_ptr
          write(chm_message_unit,*)
       end if
            
       ! Check if the analysis is below the trial field cutoff. If so set analysis to this cut-off value at these locations.
       outside = bkgrnd_ptr+inc_ptr.lt.chm_config%low_cutoff(iconstituent_id)*bkgrnd_ptr .and. bkgrnd_ptr.ge.0.0
       nlow = count(outside)
            
       if (nlow.gt.0) then
          write(chm_message_unit,'(A,I7,A,F4.1,A,A,A)') "chm_apply_bounds: ",nlow," analysis values were found below the cut-off of ", &
               100*chm_config%low_cutoff(iconstituent_id), &
               "% of the trial field for field ",trim(varName),"."
          write(chm_message_unit,'(A)') "Modifying the increment so the analysis is instead equal to the lower bound cut-off value at these locations."
          write(chm_message_unit,'(A)') "JLON JLEV JLAT TSTEP   Background  Init. incr.  New incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(chm_message_unit,'(4(I4,1X),3G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4), &
                           inc_ptr(i1,i2,i3,i4),(chm_config%low_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = (chm_config%low_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr
       end if

    end if

    if (chm_config%high_cutoff(iconstituent_id).ge.0.0) then

       ! Check if the analysis is above the imposed upper bound. If so set analysis to this cut-off value at these locations.
       outside = bkgrnd_ptr+inc_ptr.gt.chm_config%high_cutoff(iconstituent_id)*bkgrnd_ptr .and. bkgrnd_ptr.ge.0.0
       nhigh = count(outside)
            
       if (nhigh.gt.0) then
          write(chm_message_unit,'(A,I7,A,F5.2,A,A,A)') "chm_apply_bounds: ",nhigh," analysis values were found above the cut-off of ", &
               chm_config%high_cutoff(iconstituent_id), &
               " times the trial field for field ",trim(varName),"."
          write(chm_message_unit,'(A)') "Modifying the increment so the analysis is instead equal to the upper bound cut-off value at these locations."
          write(chm_message_unit,'(A)') "JLON JLEV JLAT TSTEP   Background  Init.-incr.  New-incr."
          do i1=1,size(inc_ptr,1)
             do i2=1,size(inc_ptr,2)
                do i3=1,size(inc_ptr,3)
                   do i4=1,size(inc_ptr,4)
                      if (outside(i1,i2,i3,i4)) write(chm_message_unit,'(4(I4,1X),3G12.2)') i1,i2,i3,i4,bkgrnd_ptr(i1,i2,i3,i4), &
                           inc_ptr(i1,i2,i3,i4),(chm_config%high_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr(i1,i2,i3,i4)
                   end do
                end do
             end do
          end do
          where (outside) inc_ptr = (chm_config%high_cutoff(iconstituent_id)-1.0)*bkgrnd_ptr
       end if

    end if

    ier=fclos(chm_message_unit)
    deallocate(outside)

  end subroutine chm_apply_bounds
      
!-------------------------------------------------------------------------------------------

  function chm_convert_z_to_pressure(altitude,rgz_mod,press_mod,nlev,nlev_mod,lat,success) result(press)
!
! Author   : M. Sitwell, May 2015
!          
! Purpose: Converts an array of (geometric) altitudes to pressures. Uses linear interpolation
!          in log(p).
!
! Arguments:
!
!   Input
!     altitude      altitudes to convert to pressures (m)
!     rgz_mod       geopotential heights on model levels (m), assumed to be in decending order
!     press_mod     pressure on model levels, assumed to be in ascending order
!     nlev          length of altitude array
!     nlev_mod      number of model levels
!     lat           latitude (rad)
!
!   Output
!     press         converted pressures
!
!----------------------------------------------------------------------------------------

    implicit none

    real(8), intent(in) :: altitude(nlev),rgz_mod(nlev_mod),press_mod(nlev_mod),lat
    integer, intent(in) :: nlev,nlev_mod
    logical, intent(inout) :: success(nlev)
    real(8) :: press(nlev),rgz(nlev)
    integer :: ilev,ilev_mod

    ! Convert altitudes to geopotential heights
    rgz = chm_convert_z_to_gz(altitude,lat,nlev)

    do ilev=1,nlev

       ! Check if height is above or below model boundaries
       if ( rgz(ilev).gt.rgz_mod(1) .or. rgz(ilev).lt.rgz_mod(nlev_mod) ) then
          success(ilev)=.false.
       end if

       if (success(ilev)) then

          ! Find model layers directly above and below rgz(ilev).
          ! After exit of loop we will have 
          ! rgz_mod(ilev_mod) >= rgz(ilev) > rgz_mod(ilev_mod+1)
          do ilev_mod=1,nlev_mod-1
             if ( rgz(ilev).le.rgz_mod(ilev_mod) .and. &
                  rgz(ilev).gt.rgz_mod(ilev_mod+1) ) exit
          end do
          
          ! Linear interpolation in gz,log(p)
          press(ilev) = press_mod(ilev_mod+1) * (press_mod(ilev_mod)/press_mod(ilev_mod+1))**( &
               (rgz(ilev)-rgz_mod(ilev_mod+1))/(rgz_mod(ilev_mod)-rgz_mod(ilev_mod+1)) )

       else
          press(ilev) = 0.0
       end if

    end do

  end function chm_convert_z_to_pressure

!----------------------------------------------------------------------------------------

  function chm_convert_z_to_gz(altitude,lat,nlev) result(rgz)
!
! Author   : M. Sitwell, June 2015
!          
! Purpose: Converts altitudes to geopotential heights. Uses the Helmert formula to
!          parameterize the latitude dependence and uses analytical result of the
!          integral of \int g(z)dz for the altitude dependence (see J.A. Dutton 1976,
!          p.65). At an altitude of 50 km, the altitude and geopotential height
!          differ by around 0.2-0.5 km, depending on the latitude.
!
! Arguments:
!
!   Input
!     altitude      altitudes (m)
!     lat           latitude (rad)
!
!   Output
!     rgz           geopotential heights (m)
!
!----------------------------------------------------------------------------------------
  
    use earthconstants_mod
    
    implicit none

    real(8), intent(in) :: altitude(nlev),lat
    integer, intent(in) :: nlev
    real(8) :: rgz(nlev)

    rgz = (RG/9.8) * (1.-2.64D-03*cos(2.*lat)+5.9D-6*cos(2.*lat)**2) * RA*altitude/(RA+altitude)

  end function chm_convert_z_to_gz

!----------------------------------------------------------------------------------------

  function chm_get_col_boundary(iconstituent_id,nmodlev,pressmod,tt,gz,hu,uu,vv) result(bound_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!
! Purpose: Determine and store the boundary (e.g. tropopause or PBL) pressure levels if needed by
!          the observation operators.
!
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      iconstituent_id   BUFR code element of Table 08046 identifying the constituent.
!      nmodlev      Number of model levels for variables other than uu and vv
!      pressmod     Model pressure array
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (meters)
!      hu           Specific humidity 
!      uu           Model zonal wind component (m/s)
!      vv           Model meridional wind component (m/s)
!
!   Output
!
!      bound_press  Pressure level of boundary to be imposed
!
!   Comments
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: nmodlev,iconstituent_id
    real(8), intent(in) :: pressmod(nmodlev),tt(nmodlev),gz(nmodlev)
    real(8), optional, intent(in) :: uu(:),vv(:),hu(nmodlev)
   
    real(8) :: bound_press
    
    bound_press = -1.
    
    if (chm_config%tropo_mode(iconstituent_id).eq.0) return
   
    if (chm_config%tropo_bound(iconstituent_id).gt.0) then
       if (.not.all(tt.lt.0.) .and. .not.all(gz.lt.0.) ) then
    
          select case(chm_config%tropo_bound(iconstituent_id))
          case(1)
    
             ! Get tropopause pressure level
      
             if (present(hu)) then
                bound_press = chm_get_tropopause(nmodlev,pressmod,tt,gz,hu=hu)
             else
                bound_press = chm_get_tropopause(nmodlev,pressmod,tt,gz)
             end if
    
          case(2)
 
             ! Get PBL pressure level
      
             if (present(hu).and.present(uu).and.present(vv)) then
                bound_press = chm_get_pbl(nmodlev,pressmod,tt,gz,hu=hu,uu=uu,vv=vv) 
             else if (present(hu)) then
                bound_press = chm_get_pbl(nmodlev,pressmod,tt,gz,hu=hu)
             else if (present(uu).and.present(vv)) then
                bound_press = chm_get_pbl(nmodlev,pressmod,tt,gz,uu=uu,vv=vv) 
             end if
      
          case default
             call abort3d("chm_get_col_boundary: Unrecognized value for chm_config%tropo_bound of " // trim(str(chm_config%tropo_bound(iconstituent_id))) )
          end select
                                     
      end if     
    end if
      
    ! Use tropo_column_top value if tropo_bound=0 or model derived boundary was unsuccessful
    if (bound_press.lt.0.0) &
         bound_press = chm_config%tropo_column_top(iconstituent_id)
      
  end function chm_get_col_boundary
 
!----------------------------------------------------------------------------------------

  function chm_get_tropopause(nmodlev,pressmod,tt,gz,hu) result(tropo_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!            - Following consultation with Irena Paunova for water vapour based approach
!                                     with Sylive Gravel (and wikipedia) for temperature based approach
!          
! Purpose: Determines pressure level of tropopause. 
!          Final tropopause is taken as max pressure (lowest altitude) from the
!          water vapour and temperature based tropopauses.
!
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      nmodlev      Number of model levels
!      pressmod     Model pressure array (Pa)
!      hu           Model specific humidity 
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (m)
!
!   Output
!
!     tropo_press   Tropopause level in Pa
!             
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: nmodlev
    real(8), intent(in) :: pressmod(nmodlev),tt(nmodlev),gz(nmodlev)
    real(8), intent(in), optional :: hu(nmodlev)
   
    real(8) :: tropo_press
  
    integer :: itop,i,k,ilaps
    real(8) :: hu_ppmv1,hu_ppmv2,hu_ppmv3,xlaps,tropo_press_hu
    real(8), parameter :: press_min=6000.         ! Min tropoause pressure 60 hPa.; equivalent to ~ 20km
    real(8), parameter :: gz_min=6000.0           ! Min tropopause level in meters.
    real(8), parameter :: ppmv_threshold=10.0     
    real(8), parameter :: tgrad_threshold=0.002   ! degrees/m (2 degrees/km)
    real(8), parameter :: consth=0.160754938e+07  ! conversion from mass mixing ratio to ppmv;  1.0e+06 / (18.015/28.96)

    tropo_press=-1.0
    if (all(gz.lt.0.0))  call abort3d('chm_get_tropopause: Missing GZ for determining tropopause pressure')

!   Initialize tropopause pressure level using temperature gradient.
!   Thermal tropopause is defined as the lowest level (above gz_min) at which (1) the lapse rate decreases
!   to <= 2 C/km and (2) the average lapse rate between this level and all higher levels within 2 km are <= 2 C/km. 
!   Ref: International Meteorological Vocabulary (2nd ed.). Geneva: Secretariat of the World Meteorological
!        Organization. 1992. p. 636. ISBN 92-63-02182-1.
!   The second requirement, based on hu, may give levels that are to high (pressure too low) in the winter hemisphere.

    do itop=3,nmodlev
       if (pressmod(itop).ge.press_min) exit
    end do
    itop=itop-1
       
    do i=nmodlev,itop+1,-1
       if (gz(i)-gz(nmodlev).lt.gz_min) cycle
       xlaps=-(tt(i)-tt(i-1))/(gz(i)-gz(i-1))
       if (xlaps.le.tgrad_threshold) then
          ilaps=1
          do k=i-1,itop,-1
             if (gz(k)-gz(i).gt.2000.0) exit
             xlaps=xlaps-(tt(k)-tt(k-1))/(gz(k)-gz(k-1))
             ilaps=ilaps+1
          end do
          if (xlaps/ilaps.le.tgrad_threshold) exit
       end if
    enddo
    tropo_press=pressmod(i)
    
!   Improve on tropopause pressure levels using specific humidity if available,

    if (present(hu)) then
    
!      Use water vapour
      
       hu_ppmv1=0.0
       do i=itop,nmodlev

!         Convert specific humidity to ppmv mixing ratio.
!         First apply r=q/(1-q) to convert to mass mixing ratio.
!
          if (hu(i).le.0.8.and.hu(i).ge.0) then
               hu_ppmv2 = consth*hu(i)/(1.0-hu(i))
          else if (hu(i).gt.0.8) then
               hu_ppmv2 = consth*0.8/(1.0-0.8)
          else if (hu(i).lt.0.0) then
               hu_ppmv2 = 0.0
          end if

!         Check if transition point reached.
!         Added requirement that levels below also satisfy this condition.

          if (hu_ppmv2.ge.ppmv_threshold) then
             ilaps=1
             do k=i+1,nmodlev
                if (gz(i)-gz(k).gt.5000.0) exit
                if (hu(k).le.0.8.and.hu(k).ge.0) then
                   hu_ppmv3 = consth*hu(k)/(1.0-hu(k))
                else if (hu(k).gt.0.8) then
                   hu_ppmv3 = consth*0.8/(1.0-0.8)
                else
                   hu_ppmv3=0.0
                end if
                if (hu_ppmv3.lt.ppmv_threshold) ilaps=0
             end do
             if (ilaps.eq.1) exit
          end if
          hu_ppmv1=hu_ppmv2
       end do
       
       if (hu_ppmv2.ge.ppmv_threshold.and.ilaps.eq.1) then
       
!            Interpolate between levels
      
             if (abs(hu_ppmv2-hu_ppmv1).lt.0.1) hu_ppmv1=hu_ppmv2-0.1
!             tropo_press_hu=(log(pressmod(i))*(ppmv_threshold-hu_ppmv1)+ &
!                    log(pressmod(i-1))*(hu_ppmv2-ppmv_threshold)) &
!                   /(hu_ppmv2-hu_ppmv1)
!             tropo_press_hu=exp(tropo_press_hu)
             tropo_press_hu=pressmod(i)
             
             tropo_press=min(tropo_press,tropo_press_hu)
       else
          write(*,*) 'chm_get_tropopause: Level and specific humidity: ',itop,hu_ppmv2
          call abort3d('chm_get_tropopause: Specific humidity too small.')
       end if
                             
    end if
    
  end function chm_get_tropopause

!----------------------------------------------------------------------------------------

  function chm_get_pbl(nmodlev,pressmod,tt,gz,hu,uu,vv) result(pbl_press)
!
! Author   : Y. Rochon, ARQI/AQRD Oct 2015
!            - Following consultation with Amir Aliabadi, Shuzhan Ren and Saroja Polavarapu.
!            - RiB case based on original routine 'mixing_properties' by Chris Golaz (GFDL) 
!              and Sungsu Park(NCAR) provided by Shuzhan Ren.
!
! Purpose: Determines pressure level of planetary boundary layer using 
!          a first threshold of 0.5 for the bulk Richadson number (after Mahrt, 1981; 
!          requires availability of uu and vv). Threshold reduced to largest value
!          between 0.25 and 0.5 if first not satisfied. 
!
!          If not found with this approach, applies a variant of the Heffter approach 
!          described in Aliabadi et al (2016), with some local variation.
!
! References:
!
!  Aliabadi A.A., R.M. Staebler, J. de Grandpre, A. Zadra, and P.A.
!       Vaillancourt, 2016: Comparison of Estimated Atmospheric
!       Boundary Layer Mixing Height in teh Arctic and Southern Great
!       Plains under Statisticallt Stable Conditions: Experimental
!       and Numerical Aspects, Submitted to Atmosphere-Ocean (2015).
!  Mahrt, L. 1981: Modelling depth of the stable boundary-layer,
!       Bound-Lay. Meteorol., 21, 3-19
!  Heffter, J.L.,1980: Transport layer depth calculations, Second Joint Conference on Applications
!       of Air Pollution Meteorology, New Orleans, LA, 24-27 March 1980. American Meteorological
!       Society, Boston, MA.
!       
! Revisions: 
!          
! Arguments:
!
!   Input
!
!      nmodlev      Number of model levels for variables other than uu and vv
!      pressmod     Model pressure array (Pa)
!      tt           Model temperature (Kelvin)
!      gz           Model geopotential height (meters)
!      hu           Specific humidity
!      uu           Model zonal wind component (m/s)
!      vv           Model meridional wind component (m/s)
!
!   Output
!
!     pbl_press     PBL level in Pa
! 
!   Comments
!
!   A) Currently assumes (uu,vv) midlayer levels approximately at tt, gz, and hu levels
!      when size(uu).ne.nmodlev.
!
!----------------------------------------------------------------------------------------

    use earthconstants_mod

    implicit none

    integer, intent(in) :: nmodlev
    real(8), intent(in) :: pressmod(nmodlev),tt(nmodlev),gz(nmodlev)
    real(8), optional :: uu(:),vv(:),hu(nmodlev)
   
    real(8) :: pbl_press
  
    integer :: itop,i,id,igradmax,inv,iRiBmax
    real(8) :: RiB1,RiB2,RiBmax,zs,thetavs,thetavh(nmodlev),us,vs,uv,hus,huh,gradmax,grad
    real(8), parameter :: kappa = 287.04/1004.67  ! R/Cp
    real(8), parameter :: RiB_threshold=0.5, reduced=0.5 

!   Imposed min presssure of PBL height of 200 hPa (extreme; PBL height should normally be under 3km)
    real(8), parameter :: press_min=20000.  

    real(8) :: huw(nmodlev)

    pbl_press=-1.0
    
!   Set values for lowest prognostic level 

    i = nmodlev   
    
    if (all(gz.lt.0.0))  call abort3d('chm_get_pbl: Missing GZ for determining PBL pressure')

!   Convert hu to mass mixing ratio

    if (present(hu)) then
       huw(:)=hu(:)
    else
       huw(:)=0.0
    end if
    
    if (huw(i).le.0.8.and.huw(i).ge.0) then
        hus = huw(i)/(1.0-huw(i))
    else if (huw(i).gt.0.8) then
        hus = 0.8/(1.0-0.8)
    else if (huw(i).lt.0.0) then
        hus = 0.0
    end if
    zs = gz(i)*0.001
    
!   Potential virtual temperature at lowest prognostic level

    thetavs = tt(i)*(1.D5/pressmod(i))**kappa* (1.0 + 0.61*hus )
    thetavh(nmodlev)=thetavs

!   Set max vertical level

    do itop=2,nmodlev-1
       if (pressmod(itop).ge.press_min) exit
    end do

    RiB1=0.0
    RiB2=0.0
    RiBmax=0.0
    iRiBmax=0
    if (present(uu).and.present(vv)) then
       id=nmodlev-size(uu)
       if (id.gt.1.or.id.lt.0) then
          call abort3d('chm_get_pbl: Unexpected number of UV levels, nmodlev = ' // trim(str(nmodlev)) // ' , size(uu) = ' // trim(str(size(uu))) )    
       end if
       us = uu(size(uu))
       vs = vv(size(vv))
!      us,vs set to 0.0
!      us=0.0
!      vs=0.0

!      Calc RiB from near-surface to level attaining RiB_threshold

       do i=nmodlev-1,itop,-1
  
           if (huw(i).le.0.8.and.huw(i).ge.0) then
               huh = huw(i)/(1.0-huw(i))
           else if (huw(i).gt.0.8) then
               huh = 0.8/(1.0-0.8)
           else if (huw(i).lt.0.0) then
               huh = 0.0
           end if
           thetavh(i) = tt(i)*(1.D5/pressmod(i))**kappa* ( 1.0 + 0.61*huh )

           if (id.eq.0) then
               uv = max( (uu(i)-us)**2 + (vv(i)-vs)**2, 1.D-8 ) 
           else
!             Take layer midpoint values
              uv = max( ((uu(i)+uu(i-1))/2.0-us)**2 + ((vv(i)+vv(i-1))/2.0-vs)**2, 1.D-8 ) 
           end if
         
           RiB2 = grav * (thetavh(i)-thetavs) * (gz(i)*0.001-zs) / (thetavs*uv)
           if (RiBmax.lt.RiB2.and.RiB2.ge.reduced*RiB_threshold) then
              RiBmax=RiB2
              iRiBmax=i
           end if
           if (RiB2.ge.RiB_threshold) exit
           RiB1=RiB2
       end do
    else

!      Calc only theta
      
       do i=nmodlev-1,itop,-1
  
           if (huw(i).le.0.8.and.huw(i).ge.0) then
               huh = huw(i)/(1.0-huw(i))
           else if (huw(i).gt.0.8) then
               huh = 0.8/(1.0-0.8)
           else if (huw(i).lt.0.0) then
               huh = 0.0
           end if
           thetavh(i) = tt(i)*(1.D5/pressmod(i))**kappa* ( 1.0 + 0.61*huh )
       end do
    end if   
    
    if (RiB2.ge.RiB_threshold) then    
   
 !     Interpolate between levels

       pbl_press=(log(pressmod(i))*(RiB_threshold-RiB1)+ &
               log(pressmod(i+1))*(RiB2-RiB_threshold)) &
               /(RiB2-RiB1)
       pbl_press=exp(pbl_press)
    else if (RiBmax.ge.reduced*RiB_threshold) then
!      Apply to level with largest RiB between reduced*RiB_threshold and RiB_threshold
       pbl_press=pressmod(iRiBmax)
    else
    
!      Estimate PBL level using the Heffter conditions:
!      First find lowest inversion layer where dtheta>2K.
!      If found, assign mid of layer as PBL level. 
!      Otherwise, assign PBL level as that with largest
!      theta gradient.
       
       i=nmodlev-1
       do while (i.gt.itop) 
          !if (thetavh(i)-thetavh(i+1).gt.0.0) then
          if ((thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1)).ge.0.005) then
             ! Near bottom of inversion layer found
             inv=i+1
             i=i-1
             !do while (thetavh(i)-thetavh(i+1).gt.0.0.and.i.gt.itop) 
             do while ((thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1)).ge.0.005.and.i.gt.itop) 
                 i=i-1
             end do
             if ((thetavh(i+1)-thetavh(inv)).gt.2.0)  then
                ! Apply  midlayer as PBL
                pbl_press=sqrt(pressmod(i+1)*pressmod(inv))
                exit
             end if 
          else
             i=i-1
          end if
       end do
       if (pbl_press.le.0.0) then
          gradmax=-1.D30
          igradmax=nmodlev-1
          do i=nmodlev-1,itop,-1
             grad=(thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1))
             if (gradmax.lt.grad) then
                gradmax=(thetavh(i)-thetavh(i+1))/(gz(i)-gz(i+1))
                igradmax=i
                if (grad.ge.0.005) then ! Check next layer as well
                   if ((thetavh(i-1)-thetavh(i))/(gz(i-1)-gz(i)).ge.0.005) exit
                end if
            end if
          end do          
          pbl_press=pressmod(igradmax)
          ! write(*,*) 'chm_get_pbl: Warning2 - Max allowed altitude reached for. ',pbl_press,igradmax,gradmax,RiB2,iRiBmax,RiBmax
       !else
       !   write(*,*) 'chm_get_pbl: Warning1 - Max allowed altitude reached for. ',pbl_press,i,RiB2,iRiBmax,RiBmax     
       end if
    end if

  end function chm_get_pbl
      
!----------------------------------------------------------------------------------------
 
  subroutine chm_add_col_boundary(headerIndex,bound_press)
!
! Author: M. Sitwell, ARQI/AQRD, April 2016
!
! Purpose: Adds column boundary data to chm_column_boundary which can be retrieved later
!          using a header index.
! 
!----------------------------------------------------------------------------------------

    implicit none 
    
    integer, intent(in) :: headerIndex
    real(8), intent(in) :: bound_press
    
    if (.not.associated(chm_column_boundary%data1d)) then
       call obsdata_alloc(chm_column_boundary, chm_config%obsdata_maxsize, dim1=1)
       chm_column_boundary%nrep = 0
    end if

    ! In this case nrep will count the number of filled reps in the data arrays
    chm_column_boundary%nrep = chm_column_boundary%nrep+1 

    if (chm_column_boundary%nrep.gt.chm_config%obsdata_maxsize) &
         call abort3d('chm_add_col_boundary: Reach max size of array ' // trim(str(chm_config%obsdata_maxsize)) )
  
    ! Use the header number as the unique code for this obs data
    write(chm_column_boundary%code(chm_column_boundary%nrep),'(I22)') headerIndex

    chm_column_boundary%data1d(1,chm_column_boundary%nrep) = bound_press

  end subroutine chm_add_col_boundary

!----------------------------------------------------------------------------------------
    
  function chm_retrieve_col_boundary(headerIndex) result(bound_press)
!
! Author: M. Sitwell, ARQI/AQRD, April 2016
!
! Purpose: Retrieves previously saved column boundary data in chm_column_boundary from
!          the header index.
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: headerIndex
    real(8) :: bound_press
    character(len=22) :: code

    write(code,'(I22)') headerIndex
    
    bound_press = obsdata_get_element(chm_column_boundary,code,1)

  end function chm_retrieve_col_boundary

!----------------------------------------------------------------------------------------
 
  subroutine chm_add_sigma_trial(headerIndex,sigma)
!
! Author: Y. Rochon, ARQI/AQRD, May 2016 (based on chm_add_col_boundary by M. Sitwell)
!
! Purpose: Adds background sigma profiles (and inverse) to chm_sigma_trial which can be retrieved later
!          using a header index.
! 
!----------------------------------------------------------------------------------------

    implicit none 
    
    integer, intent(in) :: headerIndex
    real(8), intent(in) :: sigma(:,:)
    
    if (.not.associated(chm_sigma_trial%data2d)) then
       call obsdata_alloc(chm_sigma_trial, chm_config%obsdata_maxsize, dim1=size(sigma,dim=1), dim2=max(4,size(sigma,dim=2)))
       chm_sigma_trial%nrep = 0
    end if

    ! In this case nrep will count the number of filled reps in the data arrays
    chm_sigma_trial%nrep = chm_sigma_trial%nrep+1 

    if (chm_sigma_trial%nrep.gt.chm_config%obsdata_maxsize) &
         call abort3d('chm_sigma_trial: Reached max size of array ' // trim(str(chm_config%obsdata_maxsize)) )
  
    ! Use the header number as the unique code for this obs data
    write(chm_sigma_trial%code(chm_sigma_trial%nrep),'(I22)') headerIndex

    chm_sigma_trial%data2d(:,1:2,chm_sigma_trial%nrep) = sigma(:,1:2)

    where (sigma(:,1).gt.0.0D0)
       chm_sigma_trial%data2d(:,3,chm_sigma_trial%nrep) = 1.0D0/sigma(:,1)
    elsewhere
       chm_sigma_trial%data2d(:,3,chm_sigma_trial%nrep) = 0.0D0
    end where

    where (sigma(:,2).gt.0.0D0)
       chm_sigma_trial%data2d(:,4,chm_sigma_trial%nrep) = 1.0D0/sigma(:,2)
    elsewhere
       chm_sigma_trial%data2d(:,4,chm_sigma_trial%nrep) = 0.0D0
    end where

  end subroutine chm_add_sigma_trial

!----------------------------------------------------------------------------------------
    
  function chm_retrieve_sigma_trial(headerIndex) result(sigma)
!
! Author: Y. Rochon, ARQI/AQRD, May 2016 (based on chm_retrieve_col_boundary by M. Sitwell)
!
! Purpose: Retrieves previously saved background sigma profiles chm_sigma_trial from
!          the header index.
!
!----------------------------------------------------------------------------------------

    implicit none

    integer, intent(in) :: headerIndex
    real(8) :: sigma(chm_sigma_trial%dim1,chm_sigma_trial%dim2)
    character(len=22) :: code

    write(code,'(I22)') headerIndex
    
    sigma = obsdata_get_array2d(chm_sigma_trial,code)

  end function chm_retrieve_sigma_trial

!-----------------------------------------------------------------------------------------
!------------------- Observation-space diagnostic functions and routines -----------------

  subroutine chm_obsspace_diagn_alloc(obs_diagn,deltaLat,deltaLon,deltaPressure)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Allocates diagnostic arrays in obs_diagn.
!
! Revisions: 
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!          
! Arguments:
!
!   Input
!
!     deltaLat       latitude bin size in degrees
!     deltaLon       longitutde in degrees
!     deltaPressure  pressures bin size in Pa (approximate)
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn
    real(8), intent(in) :: deltaLat,deltaLon,deltaPressure
    
    integer :: nlev,nlat,nlon,nbin,nstat

    obs_diagn%deltaLat = deltaLat
    obs_diagn%deltaLon = deltaLon
    obs_diagn%deltaLogPressure = deltaPressure/1.0d5  ! set constant delta ln(P) bin

    nlat = floor(180.0d0/deltaLat)
    nlon = floor(360.0d0/deltaLon)

    ! Add a last unequal size bin if remainder is larger than one degree
    if (180.0d0-nlat*deltaLat.gt.1.) nlat = nlat+1
    if (360.0d0-nlon*deltaLon.gt.1.) nlon = nlon+1

    ! Set number of levels for a pressure coordinate in hPa to cover the range
    ! of 0.01*chm_config%diagn_pressmin (in hPa) to 1000 hPa for layers 2 to nlev-1. 
    ! Layer 1 covers all pressure levels <= 0.01*chm_config%diagn_pressmin hPa = top of layer 2,
    ! The bottom of layer nlev-1 is provided by press_bins(nlev).
    nlev = 2 + nint(log(1.0d5/chm_config%diagn_pressmin)/obs_diagn%deltaLogPressure) ! last index is for unilevel observations
    nbin = nlev*nlat*nlon

    ! Two different statistics held, stat=1 for RMS and stat=2 for mean
    nstat = 2

    obs_diagn%nlat = nlat
    obs_diagn%nlon = nlon
    obs_diagn%nlev = nlev
    obs_diagn%nbin = nbin
    obs_diagn%nstat = nstat

    if (.not. allocated(obs_diagn%OmP_stats)) allocate(obs_diagn%OmP_stats(nlat,nlon,nlev,nstat))
    if (.not. allocated(obs_diagn%OmA_stats)) allocate(obs_diagn%OmA_stats(nlat,nlon,nlev,nstat))
    if (.not. allocated(obs_diagn%obs_stats)) allocate(obs_diagn%obs_stats(nlat,nlon,nlev,nstat))
    if (.not. allocated(obs_diagn%Jo_stats))  allocate(obs_diagn%Jo_stats(nlat,nlon,nlev,nstat))
    if (.not. allocated(obs_diagn%counts))    allocate(obs_diagn%counts(nlat,nlon,nlev))
    if (.not. allocated(obs_diagn%nstatus))   allocate(obs_diagn%nstatus(nlat,nlon,nlev,0:2))
    if (.not. allocated(obs_diagn%diagR_stats))    allocate(obs_diagn%diagR_stats(nlat,nlon,nlev,3))
    if (.not. allocated(obs_diagn%diagHPHT_stats)) allocate(obs_diagn%diagHPHT_stats(nlat,nlon,nlev,3))

  end subroutine chm_obsspace_diagn_alloc

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagn_init(obs_diagn)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Initializes diagnostic arrays in obs_diagn.
!
! Revisions: 
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn

    obs_diagn%OmP_stats(:,:,:,:) = 0.0d0
    obs_diagn%OmA_stats(:,:,:,:) = 0.0d0
    obs_diagn%obs_stats(:,:,:,:) = 0.0d0
    obs_diagn%Jo_stats(:,:,:,:)  = 0.0d0
    obs_diagn%counts(:,:,:) = 0
    obs_diagn%nstatus(:,:,:,:) = 0
    obs_diagn%diagR_stats(:,:,:,:)    = 0.0d0
    obs_diagn%diagHPHT_stats(:,:,:,:) = 0.0d0

    obs_diagn%allow_print_summary = .false.
    obs_diagn%assim_mode = .false.

  end subroutine chm_obsspace_diagn_init

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagn_dealloc(obs_diagn)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Deallocates diagnostic arrays in obs_diagn.
!
! Revisions: 
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn

    deallocate(obs_diagn%OmP_stats,obs_diagn%OmA_stats,obs_diagn%obs_stats)
    deallocate(obs_diagn%Jo_stats,obs_diagn%counts,obs_diagn%nstatus)
    deallocate(obs_diagn%diagR_stats,obs_diagn%diagHPHT_stats)

  end subroutine chm_obsspace_diagn_dealloc

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagn_add(obs_diagn,lat,lon,pressure,OmP,obs,sigma_obs,nlev_obs,unilevel,status,OmA,sqrtHPHT)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Adds an observation to the diagnostic arrays in obs_diagn.
!
! Revisions:
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!          
! Arguments:
!
!   Input
!
!     lat            latitude in degrees
!     lon            longitutde in degrees
!     pressure       pressures of the profile (Pa)
!     OmP            obs - background
!     OmA            obs - analysis
!     obs            observations
!     Jo             cost function
!     sigma_obs      observation error standard deviation
!     sqrtHPHT       forecast error standard deviation in obs space
!     status         indicates status of the observations, with values denoting:
!                      0 - observation has been rejected and not included in diagnostics
!                      1 - observation has been assimilated
!                      2 - observation has been used for diagnostics only (not assimilated)
!                    only observations with status=1,2 will be added to the statistic arrays
!     nlev_obs       number of observations in the profile
!     unilevel       if the observation does not have a defined height coordinate
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn
    real(8), intent(in) :: lat,lon
    integer, intent(in) :: nlev_obs,status(nlev_obs)
    real(8), intent(in) :: pressure(nlev_obs),OmP(nlev_obs),obs(nlev_obs)
    real(8), intent(in) :: sigma_obs(nlev_obs)
    logical, intent(in) :: unilevel
    real(8), intent(in), optional :: OmA(nlev_obs),sqrtHPHT(nlev_obs)

    integer :: ilat,ilon,ilev,ilev_obs

    ! Put in first/list bin if lat,lon,level lower/higher than diagnostic range
    
    ilat = max(min(1 + floor((90.0d0+lat)/obs_diagn%deltaLat), obs_diagn%nlat), 1)
    ilon = max(min(1 + floor(lon/obs_diagn%deltaLon), obs_diagn%nlon), 1)

    LEVELS: do ilev_obs=1,nlev_obs
          
       if (unilevel) then
          ilev = obs_diagn%nlev  ! put unilevel data in last level index
       else
          ilev = max(min(2 + floor(log(pressure(ilev_obs)/chm_config%diagn_pressmin)/obs_diagn%deltaLogPressure), obs_diagn%nlev-1), 1)
       end if
       
       obs_diagn%nstatus(ilat,ilon,ilev,status(ilev_obs)) = obs_diagn%nstatus(ilat,ilon,ilev,status(ilev_obs)) + 1

       if (status(ilev_obs).eq.0) cycle LEVELS  ! skip adding of stats if the observation was rejected
   
       obs_diagn%counts(ilat,ilon,ilev) = obs_diagn%counts(ilat,ilon,ilev) + 1

       obs_diagn%OmP_stats(ilat,ilon,ilev,1) = obs_diagn%OmP_stats(ilat,ilon,ilev,1) + OmP(ilev_obs)**2
       obs_diagn%OmP_stats(ilat,ilon,ilev,2) = obs_diagn%OmP_stats(ilat,ilon,ilev,2) + OmP(ilev_obs)

       obs_diagn%obs_stats(ilat,ilon,ilev,1) = obs_diagn%obs_stats(ilat,ilon,ilev,1) + obs(ilev_obs)**2
       obs_diagn%obs_stats(ilat,ilon,ilev,2) = obs_diagn%obs_stats(ilat,ilon,ilev,2) + obs(ilev_obs)

       obs_diagn%Jo_stats(ilat,ilon,ilev,2)  = obs_diagn%Jo_stats(ilat,ilon,ilev,2)  + 0.5 * OmP(ilev_obs)**2 / sigma_obs(ilev_obs)**2

       if (present(OmA)) then

          obs_diagn%OmA_stats(ilat,ilon,ilev,1) = obs_diagn%OmA_stats(ilat,ilon,ilev,1) + OmA(ilev_obs)**2
          obs_diagn%OmA_stats(ilat,ilon,ilev,2) = obs_diagn%OmA_stats(ilat,ilon,ilev,2) + OmA(ilev_obs)
          obs_diagn%Jo_stats(ilat,ilon,ilev,1)  = obs_diagn%Jo_stats(ilat,ilon,ilev,1)  + 0.5 * OmA(ilev_obs)**2 / sigma_obs(ilev_obs)**2

          if (status(ilev_obs).eq.1) then

             obs_diagn%diagR_stats(ilat,ilon,ilev,1) = obs_diagn%diagR_stats(ilat,ilon,ilev,1) &
                + OmP(ilev_obs)*OmA(ilev_obs)/sigma_obs(ilev_obs)**2
             obs_diagn%diagR_stats(ilat,ilon,ilev,2) = obs_diagn%diagR_stats(ilat,ilon,ilev,2) &
                + OmP(ilev_obs)/sigma_obs(ilev_obs)
             obs_diagn%diagR_stats(ilat,ilon,ilev,3) = obs_diagn%diagR_stats(ilat,ilon,ilev,3) &
                + OmA(ilev_obs)/sigma_obs(ilev_obs)

             if (present(sqrtHPHT)) then
                if (sqrtHPHT(ilev_obs).gt.0.0) then
                   obs_diagn%diagHPHT_stats(ilat,ilon,ilev,1) = obs_diagn%diagHPHT_stats(ilat,ilon,ilev,1) &
                        + OmP(ilev_obs)*(OmP(ilev_obs)-OmA(ilev_obs))/sqrtHPHT(ilev_obs)**2
                   obs_diagn%diagHPHT_stats(ilat,ilon,ilev,2) = obs_diagn%diagHPHT_stats(ilat,ilon,ilev,2) &
                        + OmP(ilev_obs)/sqrtHPHT(ilev_obs)
                   obs_diagn%diagHPHT_stats(ilat,ilon,ilev,3) = obs_diagn%diagHPHT_stats(ilat,ilon,ilev,3) &
                        + (OmP(ilev_obs)-OmA(ilev_obs))/sqrtHPHT(ilev_obs)
                end if
             end if

          end if

       end if

    end do LEVELS

  end subroutine chm_obsspace_diagn_add

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagn_MPIreduce(obs_diagn)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Performs a MPI allreduce on diagnostic arrays in obs_diagn.
!
! Revisions:
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!
!----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn

    ! MPI global arrays
    real(8), allocatable :: OmP_global(:,:,:,:), OmA_global(:,:,:,:), obs_global(:,:,:,:), Jo_global(:,:,:,:)
    real(8), allocatable :: diagR_global(:,:,:,:), diagHPHT_global(:,:,:,:)
    integer, allocatable :: counts_global(:,:,:),nstatus_global(:,:,:,:)

    integer :: nlat,nlon,nlev,nstat,nbin,ierr

    nlat = obs_diagn%nlat
    nlon = obs_diagn%nlon
    nlev = obs_diagn%nlev
    nstat = obs_diagn%nstat
    nbin = obs_diagn%nbin

    ! Allocate memory for mpi global arrays
    allocate(OmP_global(nlat,nlon,nlev,nstat))
    allocate(OmA_global(nlat,nlon,nlev,nstat))
    allocate(obs_global(nlat,nlon,nlev,nstat))
    allocate(Jo_global(nlat,nlon,nlev,nstat))
    allocate(diagR_global(nlat,nlon,nlev,3))
    allocate(diagHPHT_global(nlat,nlon,nlev,3))
    allocate(counts_global(nlat,nlon,nlev))
    allocate(nstatus_global(nlat,nlon,nlev,0:2))
         
    ! Reduce from all mpi processes
    call rpn_comm_allreduce(obs_diagn%OmP_stats,OmP_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%OmA_stats,OmA_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%obs_stats,obs_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%Jo_stats,Jo_global,nbin*nstat,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%diagR_stats,diagR_global,nbin*3,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%diagHPHT_stats,diagHPHT_global,nbin*3,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%counts,counts_global,nbin,"MPI_INTEGER","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(obs_diagn%nstatus,nstatus_global,nbin*3,"MPI_INTEGER","MPI_SUM","GRID",ierr)

    ! save in struct_chm_diagn
    obs_diagn%OmP_stats = OmP_global
    obs_diagn%OmA_stats = OmA_global
    obs_diagn%obs_stats = obs_global
    obs_diagn%Jo_stats = Jo_global
    obs_diagn%diagR_stats = diagR_global
    obs_diagn%diagHPHT_stats = diagHPHT_global
    obs_diagn%counts = counts_global
    obs_diagn%nstatus = nstatus_global

    deallocate(OmP_global,OmA_global,obs_global,Jo_global,diagR_global,diagHPHT_global,counts_global,nstatus_global)

  end subroutine chm_obsspace_diagn_MPIreduce

!----------------------------------------------------------------------------------------

  subroutine chm_obsspace_diagn_print(obs_diagn,print_type,label,openfile)
!
! Author:  M. Sitwell, ARQI/AQRD June 2015
!          
! Purpose: Prints observation space diagnostics. If called with print_type = 'stats', the
!          printed statistics will be added to the total diagnostic arrays.
!
! Revisions: 
!           Y. Rochon ARQI/AQRD July 2015
!           - Further generalizations.
!           M. Sitwell ARQI/AQRD Aug 2016
!           - Cast as a separate subroutine
!          
! Arguments:
!
!   Input
!
!     print_type     Specifies which statistics to print, with possible values:
!                      'stats'  - prints statistics for the the arrays within obs_diagn
!                      'summary'- prints total statistics held in the saved variables
!                                 within this subrouine
!     label          label to print (only relevant if print_type = 'stats')
!     openfile       logical indicating if file chm_config%obsspace_diagn_filename is to be opened.
!
!----------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_diagn), intent(inout) :: obs_diagn
    character(len=*) :: print_type
    logical, intent(in), optional :: openfile
    character(len=256), intent(in), optional :: label

    integer, external :: fnom, fclos
    
    real(8) :: Jo_a,Jo_b
    real(8), save :: Jo_a_total=0.0d0, Jo_b_total=0.0d0
    integer, save :: counts_total=0

    integer :: ierr,unit,icount,nlat,nlon,nlev,ilev,ilat,ilon
    integer, allocatable :: ncounts(:)
    real(8), allocatable :: press_bins(:)
    logical :: fileout_exist,multilevel,unilevel
    character(len=20) :: mode
    
    select case(trim(print_type))
    case('stats','STATS')
                       
       ! Print observation-space statistics to listing file or to output file obspace_diag_filename.
             
       ! Open and append to output file if requested
             
       if (present(openfile)) then
          if (openfile) then 
             inquire(file=chm_config%obsspace_diagn_filename, exist=fileout_exist)
             unit = 0
             if (fileout_exist) then
                mode = 'FTN+APPEND+R/W'
             else
                mode = 'FTN+R/W'
             end if
             !ierr = fnom(unit,chm_config%obsspace_diagn_filename,trim(mode),0)
             ierr = open_file(unit,chm_config%obsspace_diagn_filename,trim(mode))  ! temporary bug fix, see comments in open_file subroutine
             if (ierr.ne.0) call abort3d('chm_obsspace_diagn_print: Error associating unit number')
          else
             unit=6
          end if
       else
          unit=6             
       end if
             
       if (present(label)) then
          write(unit,*)
          write(unit,*) trim(label)
       end if
                      
       if (any(obs_diagn%counts.gt.0)) then

          nlat = obs_diagn%nlat
          nlon = obs_diagn%nlon
          nlev = obs_diagn%nlev
          
          allocate(ncounts(nlev), press_bins(nlev+1))
          
          ! Pressure boundaries for each bin starting from a top layer with lower boundary of 0.01*config%diagn_pressmin (i=2) in hPa 
          ! and extending to the surface.
          
          press_bins(2:nlev-1) = (/ (0.01*chm_config%diagn_pressmin*exp((ilev-2)*obs_diagn%deltaLogPressure), ilev=2,nlev-1) /)
          press_bins(1) = 0.0d0
          press_bins(nlev) = 1200.0d0 ! set to pressure larger than the largest expected surface pressure.
          press_bins(nlev+1) = 0.0d0  ! set to zero for unilevel

          ! Total counts for each level 
          ncounts = sum(sum(obs_diagn%counts,dim=1),dim=1)
          counts_total = counts_total + sum(ncounts)

          ! Indicates if any multilevel or unilevel observations exist
          multilevel = any(obs_diagn%nstatus(:,:,1:nlev-1,:).gt.0)
          unilevel = any(obs_diagn%nstatus(:,:,nlev,:).gt.0)
          
          if (obs_diagn%assim_mode) then
              write(unit,*)
              write(unit,'(A)') "  Elements for calc of obs and background error standard deviation scaling factors via"
              write(unit,'(A)') "  the Desroziers approach can be found in the third and fourth blocks of statistics."
              write(unit,*)
          end if

          write(unit,*)
          write(unit,'(A)') " Global statistics"
          write(unit,'(A)') " -----------------"

          ! Multi-level data

          if (multilevel) then
            
             icount = sum(ncounts(1:nlev-1))
             
             if (icount.gt.0) then
                Jo_a = sum(obs_diagn%Jo_stats(:,:,1:nlev-1,1))
                Jo_b = sum(obs_diagn%Jo_stats(:,:,1:nlev-1,2))
                Jo_a_total = Jo_a_total + Jo_a
                Jo_b_total = Jo_b_total + Jo_b
             else
                Jo_a = 0.0d0
                Jo_b = 0.0d0
             end if
                    
             obs_diagn%allow_print_summary = .true.

             call print_Jo(unit,"Multi-level data:",Jo_a,Jo_b,icount)

             call print_stats(unit,obs_diagn,press_bins,1,nlat,1,nlon,1,nlev-1) 
             if (obs_diagn%assim_mode) call print_Desroziers(unit,obs_diagn,press_bins,1,nlat,1,nlon,1,nlev-1)
             
          end if
             
          ! Uni-level data
          
          if (unilevel) then
             
             if (ncounts(nlev).gt.0) then
                Jo_a = sum(obs_diagn%Jo_stats(:,:,nlev,1))
                Jo_b = sum(obs_diagn%Jo_stats(:,:,nlev,2))
                Jo_a_total = Jo_a_total + Jo_a
                Jo_b_total = Jo_b_total + Jo_b
             else
                Jo_a = 0.0d0
                Jo_b = 0.0d0
             end if

             obs_diagn%allow_print_summary = .true.

             call print_Jo(unit,"Uni-level data:",Jo_a,Jo_b,ncounts(nlev))
             
             call print_stats(unit,obs_diagn,press_bins,1,nlat,1,nlon,nlev,nlev) 
             if (obs_diagn%assim_mode) call print_Desroziers(unit,obs_diagn,press_bins,1,nlat,1,nlon,nlev,nlev)
             
          end if
                          
          deallocate(ncounts)
             
          ! Output lat,lon dependent averages to file if obsspace_diagn_filename is provided
          if (present(openfile)) then
             if (openfile.and.chm_config%diagn_save.and.(nlat.gt.1.or.nlon.gt.1)) then
                
                write(unit,*)
                write(unit,'(A)') " Lat-lon gridded statistics"
                write(unit,'(A)') " --------------------------"
                write(unit,*)
                write(unit,'(2X,3(A,I4))') "nlat = ",nlat," , nlon = ",nlon," , nlev = ",nlev
                write(unit,*)

                do ilat=1,nlat
                   do ilon=1,nlon
                      write(unit,'(2X,2(A,I6),3X,2(F8.1,A,F8.1))') "ilat = ",ilat," , ilon = ",ilon, &
                           (ilat-1.)*obs_diagn%deltaLat-90.," < lat < ",ilat*obs_diagn%deltaLat-90., &
                           (ilon-1.)*obs_diagn%deltaLon," < lon < ",ilon*obs_diagn%deltaLon
                      if (any(obs_diagn%nstatus(ilat,ilon,1:nlev-1,:).gt.0)) then
                         write(unit,*)
                         write(unit,'(A)') " Multi-level data:"
                         write(unit,*)
                         call print_stats(unit,obs_diagn,press_bins,ilat,ilat,ilon,ilon,1,nlev-1) 
                         if (obs_diagn%assim_mode) call print_Desroziers(unit,obs_diagn,press_bins,ilat,ilat,ilon,ilon,1,nlev-1)
                      else if (multilevel) then
                         write(unit,*)
                         write(unit,'(A)') " No multi-level data."
                         write(unit,*)
                      end if
                      if (any(obs_diagn%nstatus(ilat,ilon,nlev,:).gt.0)) then
                         write(unit,*)
                         write(unit,'(A)') " Uni-level data:"
                         write(unit,*)
                         call print_stats(unit,obs_diagn,press_bins,ilat,ilat,ilon,ilon,nlev,nlev) 
                         if (obs_diagn%assim_mode) call print_Desroziers(unit,obs_diagn,press_bins,ilat,ilat,ilon,ilon,nlev,nlev)
                      else if (unilevel) then
                         write(unit,*)
                         write(unit,'(A)') " No uni-level data."
                         write(unit,*)
                      end if
                   end do
                end do
                
             end if
          end if

          deallocate(press_bins)

       else
          write(unit,*)
          write(unit,*) "No data found for this combination."
          write(unit,*)
       end if
       
       if (present(openfile)) then
          if (openfile) ierr=fclos(unit)     
       end if
             
       call flush(6)
             
    case('summary','SUMMARY')

       if (.not.obs_diagn%allow_print_summary) then
          write(*,*) "chm_obsspace_diagn_print: allow_print_summary is set to false, no summary will be printed."
          return
       end if
          
       if (present(openfile)) then
          if (openfile) then 
             inquire(file=chm_config%obsspace_diagn_filename, exist=fileout_exist)
             unit = 0
             if (fileout_exist) then
                mode = 'FTN+APPEND+R/W'
             else
                mode = 'FTN+R/W'
             end if
             !ierr = fnom(unit,chm_config%obsspace_diagn_filename,trim(mode),0)
             ierr = open_file(unit,chm_config%obsspace_diagn_filename,trim(mode))  ! temporary bug fix, see comments in open_file subroutine
             if (ierr.ne.0) call abort3d('chm_obsspace_diagn_print: Error associating unit number')
          else
             unit=6
          end if
       else
          unit=6
       end if
            
       call print_Jo(unit,"Total cost function for CH observations:",Jo_a_total,Jo_b_total,counts_total)

       if (present(openfile)) then
          if (openfile) ierr=fclos(unit) 
       end if
    
    case default
       call abort3d("chm_obsspace_diagn_print: Invalid print_type select of " // trim(print_type) )
    end select

  
  contains
 
    !----------------------------------------------------------------------------------------

    subroutine print_Jo(unit,title,Jo_analysis,Jo_backgrnd,nobs)

      implicit none

      integer, intent(in) :: unit,nobs
      character(len=*), intent(in) :: title
      real(8), intent(in) :: Jo_analysis,Jo_backgrnd

      real(8) :: Jo_analysis_norm,Jo_backgrnd_norm

      if (nobs.gt.0) then
         Jo_analysis_norm = 2.*Jo_analysis/nobs
         Jo_backgrnd_norm = 2.*Jo_backgrnd/nobs
      else
         Jo_analysis_norm = 0.0d0
         Jo_backgrnd_norm = 0.0d0
      end if

      write(unit,*)
      write(unit,'(A)') " " // title
      write(unit,*)
      write(unit,'(A,F24.8,A,F24.8)') "   Jo(x_analysis) = ",Jo_analysis," ,   2*Jo(x_analysis)/N = ",Jo_analysis_norm
      write(unit,'(A,F24.8,A,F24.8)') "   Jo(x_backgrnd) = ",Jo_backgrnd," ,   2*Jo(x_backgrnd)/N = ",Jo_backgrnd_norm
      write(unit,'(A,I24)')           "                N = ",nobs
      write(unit,*)

    end subroutine print_Jo

    !----------------------------------------------------------------------------------------

    subroutine print_stats(unit,obs_diagn,pressure,ilat_start,ilat_end,ilon_start,ilon_end,ilev_start,ilev_end)

      implicit none

      type(struct_chm_diagn), intent(in) :: obs_diagn
      real(8), intent(in) :: pressure(obs_diagn%nlev+1)
      integer, intent(in) :: unit,ilat_start,ilat_end,ilon_start,ilon_end,ilev_start,ilev_end

      integer :: ilev,level,counts(obs_diagn%nlev),N_assim,N_diagn,N_rej
      real(8) :: pres1,pres2,jo_a,jo_b,jo_a_norm,jo_b_norm,obs_sum,obs_mean,obs_std,OmP_mean,OmP_rms,OmA_mean,OmA_rms
      logical :: skip(obs_diagn%nlev)

      skip(:) = .false.

      write(unit,'(A)') "  Layer     Pressure (hPa)      Counts (N)    N_assim    N_diagn      N_rej    Jo(O-A)     2*Jo(O-A)/N   Jo(O-P)     2*Jo(O-P)/N"
      write(unit,'(A)') "  -----     --------------      ----------    -------    -------      -----    -------     -----------   -------     -----------"

      do ilev=ilev_start,ilev_end

         counts(ilev) = sum(obs_diagn%counts(ilat_start:ilat_end,ilon_start:ilon_end,ilev))

         N_rej   = sum(obs_diagn%nstatus(ilat_start:ilat_end,ilon_start:ilon_end,ilev,0))
         N_assim = sum(obs_diagn%nstatus(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))
         N_diagn = sum(obs_diagn%nstatus(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2))

         skip(ilev) = counts(ilev).eq.0.and.N_rej.eq.0

         if (skip(ilev)) cycle

         if (ilev.lt.nlev) then
            pres1 = pressure(ilev)
            pres2 = pressure(ilev+1)
            level = ilev
         else
            pres1 = 0.0d0
            pres2 = 0.0d0
            level = 0
         end if
         
         jo_a = sum(obs_diagn%Jo_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))
         jo_b = sum(obs_diagn%Jo_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2))

         if (counts(ilev).eq.0) then
            jo_a_norm = 0.0d0
            jo_b_norm = 0.0d0
         else
            jo_a_norm = 2.*jo_a/counts(ilev)
            jo_b_norm = 2.*jo_b/counts(ilev)
         end if

         write(unit,'(2X, I3, 2(2X, F11.4), 4(2X,I9), 4(2X, ES11.4))') &
              level,pres1,pres2,counts(ilev),N_assim,N_diagn,N_rej,jo_a,jo_a_norm,jo_b,jo_b_norm

      end do
    
      write(unit,*)
      write(unit,'(A)') "  Layer     Pressure (hPa)        obs (mean)   obs (std)  rms(O-P)/<O>   <O-P>/<O>   rms(O-A)/<O>  <O-A>/<O>"
      write(unit,'(A)') "  -----     --------------        ----------   ---------  ------------   ---------   ------------  ---------"

      do ilev=ilev_start,ilev_end

         if (skip(ilev)) cycle

         if (ilev.lt.nlev) then
            pres1 = pressure(ilev)
            pres2 = pressure(ilev+1)
            level = ilev
         else
            pres1 = 0.0d0
            pres2 = 0.0d0
            level = 0
         end if
         
         if (counts(ilev).eq.0) then
            obs_mean = 0.0d0
            obs_std = 0.0d0
            OmP_rms = 0.0d0
            OmP_mean = 0.0d0
            OmA_rms = 0.0d0
            OmA_mean = 0.0d0
         else
            obs_sum = sum(obs_diagn%obs_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2))
            obs_mean = obs_sum / counts(ilev)
            obs_std = sqrt(max(0.0D0, sum(obs_diagn%obs_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))/counts(ilev) - (obs_sum/counts(ilev))**2 ))

            OmP_rms = sqrt(max(0.0D0, sum(obs_diagn%OmP_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1)) / counts(ilev) ))
            OmP_mean = sum(obs_diagn%OmP_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2)) / obs_sum
            
            OmA_rms = sqrt(max(0.0D0, sum(obs_diagn%OmA_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1)) / counts(ilev) ))
            OmA_mean = sum(obs_diagn%OmA_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2)) / obs_sum
         end if

         write(unit,'(2X, I3, 2(2X, F11.4), 6(2X, ES11.4))') &
              level,pres1,pres2,obs_mean,obs_std,OmP_rms,OmP_mean,OmA_rms,OmA_mean

      end do

      write(unit,*)

    end subroutine print_stats

    !----------------------------------------------------------------------------------------

    subroutine print_Desroziers(unit,obs_diagn,pressure,ilat_start,ilat_end,ilon_start,ilon_end,ilev_start,ilev_end)
      !
      ! Author:  Y. Rochon, ARQI/AQRD Aug 2016
      !          based on routine 'print_stats'
      !          
      ! Purpose: Prints elements contributing to the calc of scaling factors for observation and background
      !          error std. dev. based on the Desroziers approach.
      !
      ! Revisions: 
      ! 
      !---------------------------------------------------------------------------------------

      implicit none

      type(struct_chm_diagn), intent(in) :: obs_diagn
      real(8), intent(in) :: pressure(obs_diagn%nlev+1)
      integer, intent(in) :: unit,ilat_start,ilat_end,ilon_start,ilon_end,ilev_start,ilev_end

      integer :: ilev,level,N_assim(obs_diagn%nlev)
      real(8) :: pres1,pres2,sum_prod,sum_OmP,sum_OmA,sum_AmP,scaling
      
      N_assim(:) = 0

      write(unit,'(A)') "  Layer     Pressure (hPa)         N_assim   sum[(O-P)(O-A)/var(O)]  sum[(O-P)/sig(O)]  sum[(O-A)/sig(O)]  mean[(O-P)(O-A)/var(O)]-mean[(O-P)/sig(O)]*mean[(O-A)/sig(O)]"
      write(unit,'(A)') "  -----     --------------         -------   ----------------------  -----------------  -----------------  -------------------------------------------------------------"

      do ilev=ilev_start,ilev_end
         
         N_assim(ilev) = sum(obs_diagn%nstatus(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))

         if (N_assim(ilev).eq.0) cycle

         if (ilev.lt.nlev) then
            pres1 = pressure(ilev)
            pres2 = pressure(ilev+1)
            level = ilev
         else
            pres1 = 0.0d0
            pres2 = 0.0d0
            level = 0
         end if
         
         sum_prod = sum(obs_diagn%diagR_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))
         sum_OmP  = sum(obs_diagn%diagR_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2))
         sum_OmA  = sum(obs_diagn%diagR_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,3))

         scaling = sum_prod/N_assim(ilev) - sum_OmP*sum_OmA/N_assim(ilev)**2

         write(unit,'(2X, I3, 2(2X, F11.4), 2X, I9, 11X, ES11.4, 2(8X,ES11.4), 10X, ES11.4)') level,pres1,pres2,N_assim(ilev),sum_prod,sum_OmP,sum_OmA,scaling
            
      end do

      write(unit,*)
      write(unit,'(A)') "  Layer     Pressure (hPa)         N_assim   sum[(O-P)(A-P)/var(P)]  sum[(O-P)/sig(P)]  sum[(A-P)/sig(P)]  mean[(O-P)(A-P)/var(P)]-mean[(O-P)/sig(P)]*mean[(A-P)/sig(P)]"
      write(unit,'(A)') "  -----     --------------         -------   ----------------------  -----------------  -----------------  -------------------------------------------------------------"

      do ilev=ilev_start,ilev_end
         
         if (N_assim(ilev).eq.0) cycle

         if (ilev.lt.nlev) then
            pres1 = pressure(ilev)
            pres2 = pressure(ilev+1)
            level = ilev
         else
            pres1 = 0.0d0
            pres2 = 0.0d0
            level = 0
         end if
         
         sum_prod = sum(obs_diagn%diagHPHT_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,1))
         sum_OmP  = sum(obs_diagn%diagHPHT_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,2))
         sum_AmP  = sum(obs_diagn%diagHPHT_stats(ilat_start:ilat_end,ilon_start:ilon_end,ilev,3))

         scaling = sum_prod/N_assim(ilev) - sum_OmP*sum_AmP/N_assim(ilev)**2

         write(unit,'(2X, I3, 2(2X, F11.4), 2X, I9, 11X, ES11.4, 2(8X,ES11.4), 10X, ES11.4)') level,pres1,pres2,N_assim(ilev),sum_prod,sum_OmP,sum_AmP,scaling
            
      end do
         
      write(unit,*)

    end subroutine print_Desroziers

  end subroutine chm_obsspace_diagn_print

!-------------------------------------------------------------------------------------------
!--------------------------- Routines for observation operators ----------------------------

  subroutine chm_obsoperators(obsoper,model_col,obs_col,kmode,ixtr,success)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!           Ping Du, Mar 2015
!           - Finalization of Ht*grad contribution (case(3))
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           M. Sitwell, ARQI/AQRD, May 2015
!           - Added vertical interpolation operator
!           M. Sitwell, ARQI/AQRD, June 2015
!           - Changed calculation of HBH^T to forgo calculating off-diagonal elements
!             of the final product
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Modified input arguments so that most inputs are passed through obsoper
!
! Purpose: Apply obs operator for indicated obs data and condition.
!
!          Usable as
!
!                 - general (potentially non-linear) simulation operator (kmode=0)
!                 - determination of sqrt(diag(H*B*H^T)) (kmode=1)
!                 - tangent linear operator (kmode=2)
!                 - linear adjoint operator (kmode=3)
!
! Further changes required for generalization:
!
! 1) Add layer average operators.
! 2) Add AOD operators (summation over model layers).
! 3) Add option to include use of obs error correlation matrix for kmode=2,3 
!    (This may/will need to be done in oda_Hchm and odaHTchm where the division 
!     by sigma_obs is applied. A new chem_mod routine will be needed for this
!     operation - and others for reading the correlation matrices similarly to the
!     averaging kernels.)
!
! Arguments:
!
!   Input
!
!     kmode      0 for non-linear/linear model in assimilation (all models included are currently linear)
!                1 for determination of sqrt(diag(H*B*H^T))
!                2 for tangent linear model
!                3 for adjoint model 
!
!   Inout
!
!     obsoper    Structure that holds information needed by the observation operator
!
!     obs_col    Observation space input/output profile
!                  kmode     input/output       profile
!                  -----     ------------       -------
!                    0           out            H(xb)
!                    1           out            sqrt(diag(H*B*H^T))
!                    2           out            H*dx
!                    3           in             R**-1 (Hdx-d)
!
!     model_col  Model space input/output profile
!                  kmode     input/output       profile
!                  -----     ------------       -------
!                    0           in             xb
!                    1           not used       not used
!                    2           in             dx at obs location
!                    3           out            adjoint product H^T(...)
!
!     ixtr       Flag indicating if obs within the model vertical coord range (.ne.0 for no) 
!                Can be modified internally - hence intent(inout) - even though
!                these changes will not be needed outside this routine.
!
!     success   Indicates if the observation was successfully assimilated
!
! Comments:
!
!     - When kmode=0, call from chm_observation_operators passes model_col as a pointer to
!       obsoper%trial.
!     - Does not yet account for potential future applications of obs 
!        vertical correlation matrices.
!
!      - Potential specification of background error std. dev. (sigma_trial(:,2)) and correlation matrices 
!        for the ensemble-based and lam cases to be done when stats for these become in use with constituents.
!
!-------------------------------------------------------------------------------------------
  use bmatrixchem, ONLY : bchm_corvert, bchm_varnamelist, bchm_getsigma     
!!  use bmatrixchem, ONLY : bchm_getsigma
  
  implicit none

! Declarations

! Structure to hold observation operator information
    
  type(struct_chm_obsoperators), intent(inout) :: obsoper

! I/O arguments: obs space variables
    
  integer, intent(in) :: kmode 
  integer, intent(inout) :: ixtr(obsoper%nobslev)
  logical, intent(inout) :: success(obsoper%nobslev)

! I/O arguments: model space profile data and others

  real(8), intent(inout) :: model_col(obsoper%nmodlev), obs_col(obsoper%nobslev)

! Local variables
  
  real(8) :: press_obs(obsoper%nobslev),zwork(obsoper%nmodlev),unit_conversion(obsoper%nmodlev)
  real(8) :: sigma_trial(obsoper%nmodlev,2),temp_eff(1)
  integer :: iobslev,imodlev,jvar
  character(len=code_len) :: code
  real(8), allocatable :: avg_kern(:,:)
       
! Determine if layer boundaries are assigned to this data source.
! If so, obtain them for use in this routine. 
! Routine provides obsoper%layer_identified,
!                  obsoper%vlayertop(nobslev), 
!                  obsoper%vlayerbottom(nobslev) 
 
  call chm_get_layer_boundaries(obsoper%stnid,obsoper%varno,obsoper%vco, &
       obsoper%nobslev,obsoper%pp(1),obsoper%pp(obsoper%nmodlev), &
       obsoper%layer_identified,obsoper%vlayertop,obsoper%vlayerbottom)
            
! Identify observation operator based on observation units and presence or
! not of layer boundaries

  if (chm_checkfor_integlayer(obsoper%varno)) then
     if (.not.obsoper%layer_identified) then
        write(*,*)   '----------------------------------------------------------'
        write(*,*)   'STNID, BUFR index, nobslev: ',obsoper%stnid,' ',obsoper%varno,obsoper%nobslev
        call abort3d('chm_obsoperators: Required layer boundaries not available!')
     else
        ! Vertical integration operator
        obsoper%modelIndex=3
     end if
  else if (obsoper%layer_identified) then
      ! Layer averaging operator
     obsoper%modelIndex=4
  else if (obsoper%vco.eq.5.and.obsoper%nobslev.eq.1) then  
      ! Surface point (in-situ) measurement
      obsoper%modelIndex=2
  else    
      ! Vertical interpolation operator
     obsoper%modelIndex=1
  end if  

! Indicate if the generalized innovation operator is to be applied.

  obsoper%apply_genoper=.false.
  if (chm_config%generalized_operator(obsoper%constituent_id).gt.0 .and. kmode.ne.1 .and. &
       (obsoper%modelIndex.eq.3 .or. obsoper%modelIndex.eq.4)) then
       
      if (kmode.eq.0) then
          ! Set reference profile for use with generalized innovation operator when kmode>=2
          call chm_set_reference_obsdata(obsoper)
  
          ! Get background error std dev profile at obs locations
          sigma_trial(:,:)=0.D0
          call bchm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,1)) 
!!          call blamchm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,1)) 
!!          call benschm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,2)) 

          call chm_add_sigma_trial(obsoper%obs_index,sigma_trial)

      else if (kmode.ge.2) then
          obsoper%apply_genoper = .true.
      end if
  end if

! Apply unit conversion and any necessary (nonlinear) transformations (apply unit conversion later for kmode=3)

  call chm_transform_profile(obsoper, compute_dtransform=kmode.ne.0) ! transformations on obsoper%trial

  select case(kmode)
  case(0)
     ! Perform transformation and unit conversion on obsoper%trial.
     ! Note that model_col => obsoper%trial for kmode=0.
     call chm_convert_units(obsoper,obsoper%trial)
  case(1)
     ! Save the conversion factor in <unit_conversion>
     unit_conversion(:) = 1.0
     call chm_transform_profile(obsoper,unit_conversion)
     call chm_convert_units(obsoper,unit_conversion)
  case(2)
     call chm_transform_profile(obsoper,model_col)
     call chm_convert_units(obsoper,model_col)
  end select

  if (obsoper%apply_genoper) then
     ! Perform unit conversion on obsoper%trial when applying the generalized
     ! obs operator for kmode=2,3. Keep obsoper%trial in ug/kg in this case.
     call chm_convert_units(obsoper,obsoper%trial,ppb=.true.)
  end if

! Convert observation vertical coordinate value(s) to pressure if needed

  select case(obsoper%vco)
  case(1)
     ! Convert altitude to pressure
     select case(obsoper%modelIndex)
     case(1)
        press_obs = chm_convert_z_to_pressure(obsoper%obslev,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
     case(2,3)
        obsoper%vlayertop = chm_convert_z_to_pressure(obsoper%vlayertop,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
        obsoper%vlayerbottom = chm_convert_z_to_pressure(obsoper%vlayerbottom,obsoper%gz,obsoper%pp,obsoper%nobslev,obsoper%nmodlev,obsoper%lat,success)
     end select
  case(2)
     ! Pressure, no conversion needed
     if (obsoper%modelIndex.eq.1) press_obs = obsoper%obslev
  case(4,5)
     ! No actions taken
  case default
     call abort3d("chm_obsoperators: vertical coordinate type vco = " // trim(str(obsoper%vco)) // " not available for this operator.")
  end select

! Determine if averaging kernel is to be applied

  obsoper%iavgkern = chm_find_avgkern(obsoper%stnid,obsoper%varno,obsoper%nobslev)

! Apply appropriate core observation operator
   
  select case(obsoper%modelIndex)
  case(1)

!    Vertical interpolation operator

     call chm_vert_interp_operator(obsoper,press_obs,ixtr,success)

  case(2)

!    Surface point measurement

!    Set weight to unity for lowest model level.
     obsoper%zh(1,1:obsoper%nmodlev-1)=0.0
     obsoper%zh(1,obsoper%nmodlev) = 1.0

!    Set range of elements for model vertical levels
     obsoper%lvl_top(1) = obsoper%nmodlev
     obsoper%lvl_bot(1) = obsoper%nmodlev 
    
  case(3)
  
!    Layer integration operator

     call chm_layer_integ_operator(obsoper,ixtr,success,kmode)

!  case(4)

!    Layer averaging operator

!    call chm_layer_avg_operator  ! see 3dvar_chem routine ch_vavg

  end select
  
! Apply averaging kernel if requested

  if (obsoper%iavgkern.gt.0) then

     allocate(avg_kern(obsoper%nobslev,obsoper%nobslev))
     
     call chm_get_avgkern(obsoper%iavgkern,obsoper%nobslev,obsoper%lat,obsoper%lon,obsoper%date,obsoper%hhmm,avg_kern)
     obsoper%zh = matmul(avg_kern,obsoper%zh)
     if (obsoper%apply_genoper) obsoper%zhp = matmul(avg_kern,obsoper%zhp)

     deallocate(avg_kern)

  end if

! Apply generalized innovation operator if requested

  if (obsoper%apply_genoper) call chm_genoper(obsoper,kmode,success)

! Finalize required quantities depending on kmode
   
  select case(kmode)

  case(0,2)
!
!     Finalize non-linear/linear operator step
!
      do iobslev=1,obsoper%nobslev
        if (success(iobslev)) then
           obs_col(iobslev)=dot_product(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)), &
                                 model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)))
        end if
      end do

!     Calculate concentration-weighted effective temperature (for output purpose)

      if (kmode.eq.0) then 
         if ((obsoper%constituent_id.ge.0.and.obsoper%constituent_id.le.chm_constituents_size).and. &
            obsoper%modelIndex.eq.3.and.obsoper%nobslev.eq.1.and.obsoper%vco.eq.4.and.success(1)) then
            if (all(obsoper%tt.gt.0.0).and.obs_col(1).gt.0.0) then
                temp_eff(1)=dot_product(obsoper%zh(1,obsoper%lvl_top(1):obsoper%lvl_bot(1)), &
                        obsoper%tt(obsoper%lvl_top(1):obsoper%lvl_bot(1))*model_col(obsoper%lvl_top(1):obsoper%lvl_bot(1))) &
                        /obs_col(1)
                code = obsdata_get_loctime_code(obsoper%lon,obsoper%lat,obsoper%date,obsoper%hhmm) // obsoper%stnid
                call obsdata_add_data1d(chm_efftemp,temp_eff,code)
             end if
          end if
       end if
                       
  case(1)
!
!    Compute sqrt(diag(H*B*H^T))
!     
     ! Apply unit conversion to observation operator
     do iobslev=1,obsoper%nobslev
        obsoper%zh(iobslev,:) = unit_conversion * obsoper%zh(iobslev,:)
     end do

!    Get background error std dev profile at obs location
     sigma_trial(:,:)=0
     call bchm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,1)) 
!!      call blamchm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,1)) 
!!      call benschm_getsigma(obsoper%varName,obsoper%nmodlev,obsoper%lat,obsoper%lon,sigma_trial(:,2)) 

!
!    Identify variable position index in background error correlation matrices
!
     jvar=1
     do while (trim(bchm_varnamelist(jvar)).ne.'') 
        if (trim(bchm_varnamelist(jvar)).eq.trim(obsoper%varName)) exit
        jvar=jvar+1
     end do
     if (trim(bchm_varnamelist(jvar)).eq.'') call abort3d('chm_genoper: Correlation matrix not found for ' // trim(obsoper%varName) )

     do iobslev=1,obsoper%nobslev
        if (success(iobslev)) then
!!           call chm_corvert_mult(obsoper%varName,obsoper%zh(iobslev,:),obs_col(iobslev), &
!!                obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev, &
!!                1,.true.,3,sigma_trial) ! get h*B*h^T

           do imodlev=obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev)
               zwork(imodlev)=sum(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                         *bchm_corvert(imodlev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),jvar) &
                         *sigma_trial(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),1))*sigma_trial(imodlev,1)
           end do
           obs_col(iobslev)=sum(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                *zwork(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)))

           obs_col(iobslev) = sqrt(obs_col(iobslev))  ! save as sqrt(h*B*h^T)
        else
           obs_col(iobslev) = 0.0
        end if
     end do

  case(3)
!
!     H^T*grad contribution from adjoint of tangent linear model.
!
      model_col(:) = 0.0

      do iobslev=1,obsoper%nobslev
        if (success(iobslev)) then
           zwork(:)=0.0D0
            zwork(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) = &
                 obs_col(iobslev)*obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev))
                
            call chm_transform_profile(obsoper,zwork)
            call chm_convert_units(obsoper,zwork)
           
            model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) = &
                 model_col(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) + &
                 zwork(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev))
        end if
      end do

  end select

  end subroutine chm_obsoperators

!-------------------------------------------------------------------------------------------

  logical function chm_checkfor_integlayer(varno)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose: Identify if obs is a vertically integrated constituent measurement.
!
! ---------------------------------------------------------------------------------------
  
  implicit none
  integer, intent(in) :: varno
 
  if (varno.eq.15198.or.varno.eq.15001.or.varno.eq.15005.or.varno.eq.15045.or. &
      varno.eq.15020.or.varno.eq.15021.or.varno.eq.15200.or. &
      varno.eq.15009.or.varno.eq.15012) then
      
      chm_checkfor_integlayer=.true.     
  else
      chm_checkfor_integlayer=.false.
  end if
  
  end function chm_checkfor_integlayer
   
!-------------------------------------------------------------------------------------------

  subroutine chm_transform_profile(obsoper,increment_col,compute_dtransform)
!
!  Author: Y. Rochon, ARQI/AQRD, April 2016 (made into separate subroutine by M. Sitwell)
!
!  Purpose: Perform any required nonlinear transformations on a model-space profile.
!
!  Inout:
!   
!    obsoper              Contains basic information related to the observation operator
!    increment_col        Model-space increment profile to transform (optional)
!    compute_dtransform   Computes obsoper%dtransform (optional, only used when increment_col
!                         is not provided and default is true in this case)
!
!  Comments:
!    - If increment_col is not provided, transformations will be done on obsoper%trial. If
!      increment_col is provided, then transformations will done on increment_col only and will
!      not be done on obsoper%trial.
!    - When called with increment_col provided, it is assumed that obsoper%dtransform has
!      already been computed in a previous call.
!    - At some point may be merged with chm_apply_transform.
!
! ---------------------------------------------------------------------------------------

  use MathPhysConstants_mod
    
  implicit none

  type(struct_chm_obsoperators), intent(inout) :: obsoper
  real(8), intent(inout), optional  :: increment_col(obsoper%nmodlev)
  logical, intent(in), optional :: compute_dtransform

  logical :: comp_dtransform

  if (obsoper%constituent_id.lt.0) return
  if (chm_config%transform(obsoper%constituent_id).eq.0.and.trim(obsoper%varname).ne.'HU') return

  if (present(increment_col)) then

     increment_col = obsoper%dtransform * increment_col

  else

     if (present(compute_dtransform)) then
        comp_dtransform = compute_dtransform
     else
        comp_dtransform = .true.
     end if

     if (obsoper%constituent_id.eq.1.and.trim(obsoper%varname).eq.'HU') then

        ! Transformations for water vapor, converting from
        ! log of specific humidity LQ to volume mixing ratio

        ! Converts LQ=ln(q) to HU=q
        obsoper%trial = exp(obsoper%trial)
        where(obsoper%trial.gt.0.8) obsoper%trial = 0.8
        where(obsoper%trial.lt.-1.D-5) obsoper%trial = -1.D-5
        ! Converts specific humidity (q) to mass mixing ratio (rm) rm = q/(1-q)
        ! then from mass mixing ratio (rm) to volume mixing ratio (r) r = m_a/m_H2O rm
        obsoper%trial = obsoper%trial / (1.0-obsoper%trial) &
             * MPC_MOLAR_MASS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)
     
        ! For conversion of LQ increment (dlnq) to volume mixing ratio increment (dr) via mass mixing ratio (drm)
        ! drm = dq/(1-q)^2 = q*dlnq/(1-q)^2 = rm(rm+1) dlnq, dr = m_a/m_H2O drm = r(r*m_H2O/m_a + 1) dlnq
        if (comp_dtransform) obsoper%dtransform = obsoper%trial * &
             (obsoper%trial*chm_config%amu(obsoper%constituent_id)/MPC_MOLAR_MASS_DRY_AIR_R8 + 1.0)
     
     else if (chm_config%transform(obsoper%constituent_id).eq.1) then

        ! Transformations for ln(x) to x

        ! Converts ln(x) to x
        obsoper%trial = exp(obsoper%trial)
 
        ! For conversion of dlnx to dx, dx = x dlnx
        if (comp_dtransform) obsoper%dtransform = obsoper%trial

     else
     
        call abort3d('chm_transform_profile: Transformation #' // trim(str(chm_config%transform(obsoper%constituent_id))) // &
             ' for constituent ' // trim(str(obsoper%constituent_id)) // " and variable name " // trim(obsoper%varname) // &
             ' is not defined.')
        
     end if

  end if

  end subroutine chm_transform_profile

!-------------------------------------------------------------------------------------------

  subroutine chm_convert_units(obsoper,model_col,ppb)
!
! Author  : Y. Rochon and Y. Yang, June 2005 to June 2011
!          
! Revision: 
!           Ping Du, CDMA,Jan 2015
!           - Adapted for the EnVar
!           Y. Rochon, ARQI/AQRD, Feb. 2015
!           - Modifications of adaptations and update of BUFR elements
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Moved most of the inputs into obsoper
!           Y. Rochon, ARQI/AQRD, April 2016
!           - Added use of varName and consideration of ug/kg for model fields
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Moved nonlinear transformations into chm_transform_profile
!
! Purpose: Set unit conversion factor for consistency of Hx units with obs units.  
! 
! Further changes required for generalization 
!
! 1) May ultimately have two versions, with one called outside the minimization section. 
! 2) Conversion for surface emissions not included as yet (if any is needed)
!
! Arguments:
!
!   Input
!
!     obsoper         Contains basic information related to the observation operator
!     ppb             Logical indicating if model_col should be kept in ug/kg instead of
!                     the units dictated by the BUFR number (optional, .false. by default)
!
!   InOut
!
!     model_col       Model space profile to have its units changed
!
!  Other
!
!     chm_config%amu  Molecular mass of constituent (g/mol). 
!
! Comments:
!
!     A. Standard model/analysis species field provided as mass mixing 
!        ratio in ug/kg (ppb). Conversion to ppb is pplied when this is 
!        not the case except for AOD and surface emissions.
!        As this is hardcoded, any changes in analysis variable must
!        be reflected by correspondingly modifying this module.
!
!     B. Unit conversion factor is calculated in chm_convert_units
!        from the following factors:
!          (1) physical constants
!          (2) parameters related to a particular species such as molecular
!              mass
!          (3) variables such as T and P from background field at each
!              iteration
!
!     Coefficients related to unit conversion
!
!        rho_stp=1.293                     Air density at STP (1.293 kg/m^3)
!        RG=9.807 (=g)                     Acceleration due to gravity (m/s^2)
!        MPC_AVOGADRO_R8 = Na              Avogadro's number. 6.023E23 molecules/mole
!        MPC_MOLAR_MASS_DRY_AIR_R8 (m_air) Dry air molecular mass. 28.9644 g/mole
!        MPC_RGAS_IDEAL_R8 = R             Ideal gas constant. 8.341 J/mole/K  (J=kg m^2/s^2)
!
!                                            PV = nRT (n=number of moles)
!
!        MPC_RGAS_DRY_AIR_R8  = Rd         Dry air constant. 287.1 J/kg/K  (J=kg m^2/s^2)
!                                          = MPC_RGAS_IDEAL_R8 * 1000 g/km / MPC_MOLAR_MASS_DRY_AIR_R8
!
!                                            P=rho*Rd*T = [n*m_air*0.001 kg/g]*Rd*T
!                                                       = n*[m_air*0.001*Rd]*T
!                                                       = nRT
!
!      C. List should be revised following changes to the 'tableburp' file.
!
! ---------------------------------------------------------------------------------------

  use earthconstants_mod
  use MathPhysConstants_mod
  
  implicit none

  type(struct_chm_obsoperators), intent(inout) :: obsoper
  real(8), intent(inout) :: model_col(obsoper%nmodlev)
  logical, intent(in), optional :: ppb

! Declaration of local variables
  real(8) :: zcoef
  integer :: exp_P,exp_T
  logical :: ppb_out
  real(8), parameter :: rho_stp=1.293  ! kg/m^3

  if (obsoper%constituent_id.lt.0) return

  ! No conversion necessary for these BUFR numbers
  if (any( obsoper%varno .eq. (/ 15024,15196,12001,15055,15062 /)  )) return

  if (present(ppb)) then
     ppb_out = ppb
  else
     ppb_out = .false.
  end if
      
  zcoef = 1.
  exp_T = 0   ! exponent of multiplicative factor obsoper%tt
  exp_P = 0   ! exponent of multiplicative factor obsoper%pp

  ! Convert to ug/kg if not already in those units

  if (obsoper%varName(1:2).eq.'AF' .or. obsoper%varName(1:2).eq.'AC') then

     ! PM2.5 or PM10

     if (any(obsoper%varno .eq. (/ 15198,15001,15005,15045,15009,15012,15199,15003,15010,15230, &
          15022,15026,15008,15197,15208,1300 /) )) &
          call abort3d("chm_convert_units: BUFR # " // trim(str(obsoper%varno)) // " is not valid for PM" )

     ! Conversion from ug/m^3 to ug/kg  (scaling by Rd*T/P)
     zcoef = zcoef * MPC_RGAS_DRY_AIR_R8
     exp_T = exp_T+1 ! multiply by T
     exp_P = exp_P-1 ! divide by P

  else if (obsoper%varname(1:1).ne.'T') then

     ! Conversion from vmr to ug/kg

     zcoef = zcoef * 1.E9 * chm_config%amu(obsoper%constituent_id)/MPC_MOLAR_MASS_DRY_AIR_R8

  end if
  
  ! Convert from ug/kg to desired unit if ppb_out = .false.

  if (.not.ppb_out) then
     select case (obsoper%varno)
     case(15198,15001,15005,15045) 
      
        ! For conversion of ppb*dP integral to DU
        ! (integral in dP introduced later by the observation operator)
        !
        ! 1 DU equivalent to number density at STP for a column of 1E-5 m. 
        ! Number density at STP = Na*rho_stp/m_air.
        ! Hence 1 DU equivalent to Na*rho_stp/m_air * 1E-5 m (= 2.69E20 molecules/m^2)
        !
        ! Number of DU for gas = integral in Z of gas number density (over all altitudes) 
        !                        divided by [Na*rho_stp/m_air * 1E-5 m]   
        !                      = - integral in P of gas number density / [g*rho(air)] 
        !                        divided by [Na*rho_stp/m_air * 1E-5 m]   
        !          
        ! Number density of gas = Na*rho(gas)/m_gas 
        !                      
        ! Number of DU for gas = - integral in P of [rho(gas)/rho(air)]*1E5*/g/rho_stp*m_air/m_gas
        !                        = - integral in P of mass mixing ratio * [1E5*m_air/m_gas/g/rho_stp]
                           
        zcoef = zcoef * 1.E-4 * MPC_MOLAR_MASS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)/RG/rho_stp
        
     case(15009,15012)

        ! For conversion of ppb*dP integral to molecules/m^2
        ! (integral in dP introduced later by the observation operator)
        ! 
        ! integral in Z of number density = - integral in P of number density / [g*rho(air)] 
        !                                 = - integral in P of Na*[rho(gas)/rho(air)]/g/m_air
        
        zcoef = zcoef * 1.E-6 * MPC_AVOGADRO_R8/RG/chm_config%amu(obsoper%constituent_id)

     case(15020,15021,15200) 
        
        ! For conversion of ppb*dP integral to kg/m^2
        ! (integral in dP introduced later by the observation operator)
        ! 
        ! integral in Z of density = - integral in P of rho(gas) / [g*rho(air)] 
        !                          = - integral in P of [rho(gas)/rho(air)]/g

        zcoef = zcoef * 1.E-9 / RG
        
     case(15023,15027,15194,15195,15223)

        ! For conversion from ug/kg to kg/m^3
        !
        ! rho(gas) = mass mixing ratio * rho(air) = mass mixing ratio * P/Rd/T
        
        zcoef = zcoef * 1.E-9 / MPC_RGAS_DRY_AIR_R8
        exp_T = exp_T-1 ! divide by T
        exp_P = exp_P+1 ! multiply by P

     case(13001,13002) 

        ! For conversion from ug/kg to kg/kg
     
        zcoef = zcoef * 1.E-9 
     
     case(15199,15003,15010) 
     
        ! For conversion from ug/kg to partial pressure (PA)
        !
        ! parial pressure = P * vmr
        !                 = P * m_air/m_gas * mass mixing ratio
          
        zcoef = zcoef * 1.E-9 * MPC_MOLAR_MASS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)
        exp_P = exp_P+1 ! multiply by P

     case(15022)

        ! For conversion from ug/kg to molecules/m^3
        !
        ! Number density of gas = Na*rho(gas)/m_gas = Na*rho(air) * mass mixing ratio /m_gas
        !                       = Na * P/Rd/T * mass mixing ratio /m_gas
        
        zcoef = zcoef * 1.E-6 * MPC_AVOGADRO_R8/MPC_RGAS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)
        exp_T = exp_T-1 ! divide by T
        exp_P = exp_P+1 ! multiply by P

     case(15230)

        ! For conversion from ug/kg to mol/m^3
        !
        ! Mole density of gas = rho(gas)/m_gas = rho(air) * mass mixing ratio /m_gas
        !                       = P/Rd/T * mass mixing ratio /m_gas

        zcoef = zcoef * 1.E-6 /MPC_RGAS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)
        exp_T = exp_T-1 ! divide by T
        exp_P = exp_P+1 ! multiply by P

     case(15026,15008,15197,15208,1300) ! 1300 ??

        ! For conversion from ug/kg to vmr
           
        zcoef = zcoef * 1.E-9 * MPC_MOLAR_MASS_DRY_AIR_R8/chm_config%amu(obsoper%constituent_id)

     !case(15192,15011) 
           
        ! Code to be revised when actually applied for the first time
        ! according to model field units.
           
     case default 
        
        call abort3d('CHM_CONVERT_UNITS: Unknown obs units for varno = ' // trim(str(obsoper%varno)) )
         
     end select
  end if
  
  ! Apply constant scaling
  model_col = model_col * zcoef

  if (exp_T.ne.0) then
     if (any(obsoper%tt.le.0.)) call abort3d("CHM_CONVERT_UNITS: Missing valid temperature for conversion.")
     model_col = model_col * obsoper%tt**exp_T
  end if

  if (exp_P.ne.0) model_col = model_col * obsoper%pp**exp_P
  
  end subroutine chm_convert_units

!---------------------------------------------------------------------------------------
  function chm_required_field(varName,varno) result(needed)
!
! Author:  M. Sitwell Dec 2015 
!
! Purpose: Determines if the specifed field name is required somewhere in
!          in the observation operators for a particular observation type 
!
! Revisions:
!
! Arguments:
!
!   Input
!
!     varName   Name of field 
!     varno     BUFR descriptor element
!
!----------------------------------------------------------------------------------------

    implicit none

    character(len=*), intent(in) ::varName
    integer, intent(in) :: varno
    logical :: needed
    
    select case(trim(varName))
    case('TT')
 
       select case (varno)
       case(15023,15027,15194,15195,15223,15230,15022)
          needed = .true.
       case default
          needed = .false.
       end select
         
    case default
       needed = .false.
    end select

  end function chm_required_field

!---------------------------------------------------------------------------------------

  subroutine chm_layer_integ_operator(obsoper,ixtr,success,kmode)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input of ixtr and iavgkern
!           Y. Rochon ARQOI/AQRD, Sept 2015
!           - Added iconstituent_id, kmode, ... to varName and related option of producing
!             tropo increments from total column data.
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Many of the input arguments moved into obsoper
!
! Purpose:  Perform layer integration and calculations.
!
! Arguments:
!
!  Input 
!
!     ixtr         Flag indicating if obs outside model vertical range
!                  0 for no.
!     kmode        Observation model stage used to allow option of
!                  tropo increment determination from total column data when
!                  obsoper%column_bound > obsoper%vlayertop for
!                  nobslev=1. For kmode=3, calc only for region between
!                  obsoper%column_bound and surface. For kmode=2, split
!                  calc for model top to obsoper%column_bound and 
!                  obsoper%column_bound and surface.
!     iconstituent_id  BUFR constituent ID.
!
!  InOut
!
!     obsoper  observation operator object
!     success      success of integration
!     ixtr         Modified ixtr as needed.
!
!-----------------------------------------------------------------------------------------

  implicit none

  type(struct_chm_obsoperators), intent(inout) :: obsoper
  integer, intent(in) :: kmode
  integer, intent(inout) :: ixtr(obsoper%nobslev)
  logical, intent(inout) :: success(obsoper%nobslev)

  integer :: ij,iobslev
  real(8) :: vlayertop_ref,vlayerbottom_ref,lvl_bot_ref

! Conduct initial setup for vertical integration components

  call chm_vertintg_setup(obsoper)

! Ensure that each layer is within model vertical range.
  
  do iobslev=1,obsoper%nobslev
     
      if (obsoper%vlayerbottom(iobslev).lt.obsoper%vlayertop(iobslev)) then
         success(1:obsoper%nobslev)=.false.
         write(chm_message_unit,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',obsoper%vlayertop(iobslev), obsoper%vlayerbottom(iobslev), &
                                    '. Entire profile skipped over.'
         return
      else if (obsoper%vlayerbottom(iobslev).lt.obsoper%pp(1)*1.01 .or. &  
               obsoper%vlayertop(iobslev).gt.obsoper%pp(obsoper%nmodlev)*0.99) then
         success(iobslev)=.false.
         if (obsoper%vlayerbottom(iobslev).lt.obsoper%pp(1)*1.01) then
            ixtr(iobslev)=1
         else
            ixtr(iobslev)=2
         end if 
         write(chm_message_unit,*) 'chm_layer_integ_operator: WARNING. Layer top/bot value problem.',obsoper%vlayertop(iobslev), obsoper%vlayerbottom(iobslev)
         cycle
      end if
      if (obsoper%vlayerbottom(iobslev).gt.obsoper%pp(obsoper%nmodlev)*0.999) obsoper%vlayerbottom(iobslev)=obsoper%pp(obsoper%nmodlev)*0.999
      if (obsoper%vlayertop(iobslev).lt.obsoper%pp(1)*1.001) obsoper%vlayertop(iobslev)=obsoper%pp(1)*1.001
      
  end do

  ! Check for special treatment if chm_config%tropo_mode>=1, kmode=2,3, and nobslev=1 for
  ! column observations (obsoper%vco=4)  that extend to the surface.
   
  if (obsoper%nobslev.eq.1.and.kmode.ge.2.and.obsoper%vlayerbottom(1).gt.obsoper%pp(obsoper%nmodlev)*0.99.and. &
      obsoper%constituent_id.ge.0.and.obsoper%vco.eq.4) then

     if (obsoper%constituent_id.gt.chm_constituents_size) &
          call abort3d("chm_layer_integ_operator: Invalid constituent ID with value " // trim(str(obsoper%constituent_id)))
     
     vlayerbottom_ref=obsoper%vlayerbottom(1)
   
     if ( chm_config%tropo_mode(obsoper%constituent_id).ge.1 .and. obsoper%column_bound.gt.obsoper%vlayertop(1) ) then
        
        if (obsoper%iavgkern.ne.0) &
             call abort3d("chm_layer_integ_operator: Use of averaging kernels not possible with reduced range of increment profile.")
 
        if (kmode.eq.2.and.chm_config%tropo_mode(obsoper%constituent_id).eq.1) then
           
           ! When kmode=2, split calc in two. This is done due to difference in 
           ! calc at the interface region when producing zh and zhp. The tangent linear
           ! model in the lower region for kmode=2 must be consistent with 
           ! that associated to kmode=3.
           
           ! Start with bottom region in order to use correct zhp with chm_genoper
           ! when use of this operator is requested.
           
           vlayertop_ref=obsoper%vlayertop(1)

           obsoper%vlayertop(1) = obsoper%column_bound
                     
           call chm_vertintg(obsoper,ixtr,success)
           
           ! Apply generalized innovation operator if requested
           
           if (obsoper%apply_genoper) call chm_genoper(obsoper,kmode,success)
           
           obsoper%apply_genoper=.false.
           
           lvl_bot_ref=obsoper%lvl_bot(1)
            
           ! Reset top and bottom values for integration of the remaining region.
           ! The second integration provides the change in upper level contributions to the
           ! total column from the assimilation of other observations.
           
           obsoper%vlayertop(1)=vlayertop_ref
           obsoper%vlayerbottom(1)=obsoper%column_bound
        else
           ! Reset top new value. Restricts adjoint/tangent linear calcs to this reduced region.            
           obsoper%vlayertop(1)=obsoper%column_bound
        end if
      
     end if
  else
     vlayerbottom_ref=0.0
  end if
  
   ! Calculate vertical integration components for specified obs layer.

  call chm_vertintg(obsoper,ixtr,success)
   
  ! If chm_config%tropo_mode=1, reset original vertical range for the tangent
  ! linear operator 
  if (obsoper%nobslev.eq.1.and.kmode.eq.2.and.obsoper%constituent_id.ge.0.and.obsoper%vco.eq.4) then
      if (chm_config%tropo_mode(obsoper%constituent_id).eq.1.and.  &
         obsoper%column_bound.gt.obsoper%vlayertop(1).and. &
         vlayerbottom_ref.gt.obsoper%pp(obsoper%nmodlev)*0.99) then    

         obsoper%vlayerbottom(1)=vlayerbottom_ref
         obsoper%lvl_bot(1)=lvl_bot_ref
      end if
  end if
  
  end subroutine chm_layer_integ_operator

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg_setup(obsoper)
!
! Author  : Y. Rochon, (ARQI/AQRD), Ping Du (CMDA), and M. Sitwell (ARQI/AQRD) Feb 2015.
!           - Based on Pre-Envar version by Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!
! Revision: 
!
! Purpose:  Preliminary calcs for producing components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
!           This includes:
!
!                    - Setting of model layer boundaries
!                    - Determining integration weights associated to
!                      second order Lagrangian interpolation.
!
!           Layer boundaries are taken as mid-point between eta levels in lnP
!           coordinate. Layer values are set to be the values interpolated
!           to the mid-point in P within the various layers. Interpolation
!           in P is done quadratically. 
!
! Arguments:
!
!  Output  
!           obsoper%vmodpress(nmodlev+1)       -- Model layer boundaries given that pressmod are
!                                                 taken at mid-layer values.
!           obsoper%vweights(nmodlev,nmodlev)  -- Second order Lagrangian interp integration weights
!
!-----------------------------------------------------------------------------------------
      implicit none
      
      type(struct_chm_obsoperators), intent(inout) :: obsoper
!
!*    Declaration of local variables
!
      integer   :: jk
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3
!
!*    Determine P boundaries of analysis layers and save weights for
!     use in setting innovation operator array.
!
!     N.B.: Boundaries of layers set to mid-point of model levels
!      
!     Calculate layer boundaries
!
      obsoper%vmodpress(1)=obsoper%pp(1)
      obsoper%vmodpress(obsoper%nmodlev+1)= obsoper%pp(obsoper%nmodlev)
!
      DO JK = 2, obsoper%nmodlev
         obsoper%vmodpress(jk)=sqrt(obsoper%pp(jk-1)*obsoper%pp(jk))
      END DO
!
!     Interpolation to mid-layer level in P using
!     second degree Lagrangian interpolator.
!     N.B.: Integration is w.r.t. P
!
!     Calculating for jk=1
!
      zp1= obsoper%pp(1)
      zp2= obsoper%pp(2)
      zp3= obsoper%pp(3)
      zp = (obsoper%vmodpress(2)+obsoper%vmodpress(1))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      obsoper%vweights(1,1)=zr1
      obsoper%vweights(2,1)=zr2
      obsoper%vweights(3,1)=zr3
!
      DO JK=2,obsoper%nmodlev-1
         zp1=obsoper%pp(jk-1)
         zp2=obsoper%pp(jk)
         zp3=obsoper%pp(jk+1)
         zp=(obsoper%vmodpress(jk+1)+obsoper%vmodpress(jk))/2.0
         zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
         zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
         zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
         obsoper%vweights(jk-1,jk)=zr1
         obsoper%vweights(jk,jk)=zr2
         obsoper%vweights(jk+1,jk)=zr3
      ENDDO
!
!     Calculating  for jk=obsoper%nmodlev
!
      zp1= obsoper%pp(obsoper%nmodlev-2)
      zp2= obsoper%pp(obsoper%nmodlev-1)
      zp3= obsoper%pp(obsoper%nmodlev)
      zp = (obsoper%vmodpress(obsoper%nmodlev+1)+obsoper%vmodpress(obsoper%nmodlev))/2.0
      zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
      zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
      zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
      obsoper%vweights(obsoper%nmodlev-2,obsoper%nmodlev)=zr1
      obsoper%vweights(obsoper%nmodlev-1,obsoper%nmodlev)=zr2
      obsoper%vweights(obsoper%nmodlev,obsoper%nmodlev)=zr3
!
  end subroutine chm_vertintg_setup 

!-----------------------------------------------------------------------------------------

  subroutine chm_vertintg(obsoper,ixtr,success)
!
! Author  : Y. Rochon, Y. Yang and S. Ren, Nov 2004 to Dec 2012
!           - Pre-EnVar version
! Revision: 
!           Ping Du and Y. Rochon, Jan-Feb 2015
!           - Adapted for the EnVar
!           M. Sitwell, ARQI/AQRD, Mar 2015
!           - Modified to calculate whole profile within a single call
!           Y. Rochon ARQOI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!           M. Sitwell, ARQI/AQRD, April 2016
!           - Some input arguments moved into obsoper
!
! Purpose:  Calculate components required for vertical 
!           integration w.r.t. pressure to calculate partial (or total)
!           column value of model state profile or used for adjoint calc..
!
! Arguments:
!
!  Input   
!           obsoper%nmodlev       -- # of model vertical levels
!           obsoper%nobslev       -- # of obs vertical levels
!           obsoper%vweights      -- See routine chm_vertintg_setup
!           obsoper%vmodpress
!           success               -- Logical indicating if calc are to be performed.
!           ixtr                  -- Flag indicating if obs outside model vertical range
!                                    0 for no.

!
!  Output  
!           obsoper%zh(obsoper%nobslev,obsoper%nmodlev)  -- Initial innovation model array 
!                                                           (other than conversion constants)
!           obsoper%zhp(obsoper%nobslev,obsoper%nmodlev) -- Part of innovation operator not 
!                                                           related to resolution
!
!-----------------------------------------------------------------------------------------
      implicit none

      type(struct_chm_obsoperators), intent(inout) :: obsoper
      integer, intent(in) ::ixtr(obsoper%nobslev)
      logical, intent(in) :: success(obsoper%nobslev)

      integer, parameter :: ivweights=2  ! Order of Lagrangian interpolation.
!
!*    Declaration of local variables
!
      integer   :: J,JK,ILMAX2,ILMIN2
      integer   :: ILMIN, ILMAX, iobslev
      real(8)   :: zp, zp1, zp2, zp3, zr1, zr2, zr3, ptop, pbtm


      do iobslev=1,obsoper%nobslev

         if (success(iobslev).or.(ixtr(iobslev).eq.0.and.obsoper%iavgkern.ne.0)) then

            ptop = obsoper%vlayertop(iobslev)
            pbtm = obsoper%vlayerbottom(iobslev)
         
!*          Find the range of vertical levels over which to perform the integration
!           and set innovation operator ZH over this range.

            ilmin=1
            ilmax=obsoper%nmodlev
            if (ptop.le.obsoper%vmodpress(1)*1.01.and.pbtm.ge.obsoper%vmodpress(obsoper%nmodlev+1)*0.99) then
!
!             Total column integration part
!
               do jk = 1,obsoper%nmodlev
                  do j=max(1,jk-ivweights),min(obsoper%nmodlev,jk+ivweights)
                     obsoper%zh(iobslev,jk)=obsoper%zh(iobslev,jk)+(obsoper%vmodpress(j+1) &
                         -obsoper%vmodpress(j))*obsoper%vweights(jk,j)
                     obsoper%zhp(iobslev,jk)=obsoper%zhp(iobslev,jk)+obsoper%vweights(jk,j)
                  end do
               end do
               
            else
!
!              Partial column integration part (special treatment at boundaries)
!
!              Identify analysis layer boundaries just within obs layer.
!
               ilmin = chm_igetmodlev(ptop, obsoper%vmodpress, 'top', obsoper%nmodlev+1)
               ilmax = chm_igetmodlev(pbtm, obsoper%vmodpress, 'btm', obsoper%nmodlev+1)
               
               if (ilmin.eq.ilmax+1) then
!
!                 Entire obs layer within one analysis layer
!
                  j=ilmin
                  if (j.lt.3) j=3
                  if (j.gt.obsoper%nmodlev) j=obsoper%nmodlev
                  zp1=obsoper%vmodpress(j-2)
                  zp2=obsoper%vmodpress(j-1)
                  zp3=obsoper%vmodpress(j)
                  zp=(ptop+pbtm)/2.0
                  zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                  zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                  zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)

                  obsoper%zh(iobslev,j-2)=(pbtm-ptop)*zr1
                  obsoper%zh(iobslev,j-1)=(pbtm-ptop)*zr2
                  obsoper%zh(iobslev,j)=(pbtm-ptop)*zr3
                  obsoper%zhp(iobslev,j-2)=zr1
                  obsoper%zhp(iobslev,j-1)=zr2
                  obsoper%zhp(iobslev,j)=zr3
                  ilmin=j-2
                  ilmax=j
                  
               else
!
!                 Determine terms from the inner layers (excluding the lower and upper
!                 boundary layers when these layers not covering entire analyses layers)
!
                  if (pbtm.ge.obsoper%vmodpress(obsoper%nmodlev)*0.99) then
                     ilmax2=obsoper%nmodlev
                  else
                     ilmax2=ilmax-1
                  end if
                  if (ptop.le.obsoper%vmodpress(1)*1.01) then
                     ilmin=1
                     ilmin2=ilmin
                  else
                     ilmin2=ilmin
                  end if
                  if (ilmin2.le.ilmax2) then
                     do jk = ilmin2,ilmax2
                        do j=max(1,jk-ivweights),min(obsoper%nmodlev,jk+ivweights)
                           obsoper%zh(iobslev,jk)=obsoper%zh(iobslev,jk)+(obsoper%vmodpress(j+1) &
                               -obsoper%vmodpress(j))*obsoper%vweights(jk,j)
                           obsoper%zhp(iobslev,jk)=obsoper%zhp(iobslev,jk)+obsoper%vweights(jk,j)
                        end do
                     end do
                  end if
!
!                 Determine terms from the lower and upper boundary layers
!                 when these layers do not cover entire analyses layers.
!
                  if (pbtm.lt.obsoper%vmodpress(obsoper%nmodlev)*0.99) then
                     
                     j=ilmax+1
                     if (j.gt.obsoper%nmodlev) j=obsoper%nmodlev
                     if (j.lt.3) j=3
                     zp1=obsoper%vmodpress(j-2)
                     zp2=obsoper%vmodpress(j-1)
                     zp3=obsoper%vmodpress(j)
                     zp=(obsoper%vmodpress(ilmax)+pbtm)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     obsoper%zh(iobslev,j-2)=obsoper%zh(iobslev,j-2)+(pbtm - obsoper%vmodpress(ilmax))*zr1
                     obsoper%zh(iobslev,j-1)=obsoper%zh(iobslev,j-1)+(pbtm - obsoper%vmodpress(ilmax))*zr2
                     obsoper%zh(iobslev,j)=obsoper%zh(iobslev,j)+(pbtm - obsoper%vmodpress(ilmax))*zr3
                     obsoper%zhp(iobslev,j-2)=obsoper%zhp(iobslev,j-2)+zr1
                     obsoper%zhp(iobslev,j-1)=obsoper%zhp(iobslev,j-1)+zr2
                     obsoper%zhp(iobslev,j)=obsoper%zhp(iobslev,j)+zr3
                     ilmax=j
                  
                  end if
                  
                  if (ptop.gt.obsoper%vmodpress(1)*1.01) then
                     
                     j=ilmin-1
                     if (j.lt.1) j=1
                     if (j.gt.obsoper%nmodlev-2) j=obsoper%nmodlev-2
                     zp1= obsoper%vmodpress(j)
                     zp2= obsoper%vmodpress(j+1)
                     zp3= obsoper%vmodpress(j+2)
                     zp = (obsoper%vmodpress(ilmin)+ptop)/2.0
                     zr1=(zp-zp2)*(zp-zp3)/(zp1-zp2)/(zp1-zp3)
                     zr2=(zp-zp1)*(zp-zp3)/(zp2-zp1)/(zp2-zp3)
                     zr3=(zp-zp2)*(zp-zp1)/(zp3-zp2)/(zp3-zp1)
                  
                     obsoper%zh(iobslev,j)=obsoper%zh(iobslev,j)+(obsoper%vmodpress(ilmin)-ptop)*zr1
                     obsoper%zh(iobslev,j+1)=obsoper%zh(iobslev,j+1)+(obsoper%vmodpress(ilmin)-ptop)*zr2
                     obsoper%zh(iobslev,j+2)=obsoper%zh(iobslev,j+2)+(obsoper%vmodpress(ilmin)-ptop)*zr3
                     obsoper%zhp(iobslev,j)=obsoper%zhp(iobslev,j)+zr1
                     obsoper%zhp(iobslev,j+1)=obsoper%zhp(iobslev,j+1)+zr2
                     obsoper%zhp(iobslev,j+2)=obsoper%zhp(iobslev,j+2)+zr3
                     ilmin=j
                     if (ilmax.lt.j+2) ilmax=j+2
                     
                  end if
                  if (ilmin.gt.ilmax-2) ilmin=ilmax-2
               end if
            end if

            obsoper%lvl_top(iobslev)=ilmin
            obsoper%lvl_bot(iobslev)=ilmax
            
         else
            obsoper%zh(iobslev,:) = 0.0D0
            obsoper%zhp(iobslev,:) = 0.0D0
            
            obsoper%lvl_top(iobslev)=1
            obsoper%lvl_bot(iobslev)=1
         end if

      end do

  end subroutine chm_vertintg

!-----------------------------------------------------------------------------------------

  subroutine chm_vert_interp_operator(obsoper,pres_obs,ixtr,success)
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!           - Based on ch_vprof from 3DVAR-CHEM by Y. Rochon July 2005
!
! Revision:
!           Y.J. Rochon, ARQI/AQRD, May 2015
!           - Added input and use of ixtr and iavgkern
!           M. Sitwell, ARQI/AQRD, April 2015
!           - Some input arguments moved into obsoper
!
! Purpose:  Interpolation to point in profile. Uses piecewise linear vertical
!           interpolation in log(Pressure).
!
! Arguments:
!
!  Input
!
!       obsoper%pp      pressure on model levels, assumed to be in ascending order
!       pres_obs        pressure on observation levels
!       ixtr            Flag indicating if obs outside model vertical range
!                       0 for no.
!
!  Output
!
!       obsoper%zh      interpolation coefficients
!       success         success of interpolation
!       ixtr            Modified ixtr as needed.
!
! Comments:  Current implementation searches for index of nearest model level. This step
!            is redundant since this information is already saved in obsSpaceData in OBS_LYR.
!            This step is repeated so that the routines in chem_mod are more independent
!            of the rest of the EnVar code. If it is desired to skip this redundant step,
!            the content of the OBS_LYR column could be passed to chm_obsoperators and
!            subsequentially to this subroutine.
!
!-----------------------------------------------------------------------------------------

    implicit none

    type(struct_chm_obsoperators), intent(inout) :: obsoper
    integer, intent(inout) :: ixtr(obsoper%nobslev)
    real(8), intent(in) :: pres_obs(obsoper%nobslev)
    logical, intent(inout) :: success(obsoper%nobslev)

    integer :: iobslev,jmodlev

    do iobslev=1,obsoper%nobslev

       ! check if obs is above or below model boundaries
       if ( pres_obs(iobslev).lt.obsoper%pp(1) .or. &
            pres_obs(iobslev).gt.obsoper%pp(obsoper%nmodlev) ) then
          success(iobslev)=.false.
          if (pres_obs(iobslev).lt.obsoper%pp(1)) then
              ixtr(iobslev)=1
          else
              ixtr(iobslev)=2
          end if 
       end if

       if (success(iobslev).or.(ixtr(iobslev).eq.0.and.obsoper%iavgkern.ne.0)) then

          ! Find model layers directly above and below obs.
          ! After exit of loop, the obs will be between model
          ! levels jmodlev and jmodlev+1.
          do jmodlev=1,obsoper%nmodlev-1
             if ( pres_obs(iobslev).ge.obsoper%pp(jmodlev) .and. &
                  pres_obs(iobslev).lt.obsoper%pp(jmodlev+1) ) then
                exit
             end if
          end do

          ! Set interpolation weights
          obsoper%zh(iobslev,jmodlev+1) = LOG(pres_obs(iobslev)/obsoper%pp(jmodlev)) &
                                        / LOG(obsoper%pp(jmodlev+1)/obsoper%pp(jmodlev))
          obsoper%zh(iobslev,jmodlev) = 1.0D0 - obsoper%zh(iobslev,jmodlev+1)

          ! set range of nonzero elements for model vertical levels
          obsoper%lvl_top(iobslev) = jmodlev
          obsoper%lvl_bot(iobslev) = jmodlev+1

       else
          obsoper%lvl_top(iobslev) = 1
          obsoper%lvl_bot(iobslev) = 1
       end if

    end do

  end subroutine chm_vert_interp_operator

!-----------------------------------------------------------------------------------------

  integer function chm_igetmodlev(rpress, rppobs, topbtm, ntotlev)

!
!  Author: Y. Yang    May 2004
!
!  Revisions:
!             Y.J. Rochon, ARQI/MSC May 2005 - May 2007, Feb 2015
!             - Changes to form and comments
!
!  Purpose: Get the vertical level index for the pressure in rppobs
!           within obs layer and nearest specified obs layer boundary.
!
!  Arguments:
!
!              rpress : pressure value in Pascal
!              rppobs : profile of pressure at obs. location
!              topbtm : indicating whether we are looking for top or bottom
!                       presure
!              ntotlev: total number of levels of rppobs
!
!-----------------------------------------------------------------------------------------
      implicit none
 
      integer, intent(in) :: ntotlev
      real(8), intent(in) :: rpress, rppobs(ntotlev)
      character(len=*), intent(in) :: topbtm
      
      integer     :: ilev1, ilev2
      integer     :: jk
!
!     Find the model levels adjacent to pressure level rpress
!
!     Default values
!
      if (rpress .lt. 0.) then
        if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
             chm_igetmodlev = ntotlev
        endif
        if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
             chm_igetmodlev = 1
        endif
                                                       
      endif
!
      ilev1=0
      ilev2=1
      do jk=1,ntotlev
         if (rpress.gt.rppobs(jk)) then
           ilev1=jk
           ilev2=jk+1
         else
           exit
         endif
      enddo
!
!     Find the model level index
!
!     If we are looking for top level, the index is the level immediately 
!     below. if looking for bottom level, the index is the one immediately 
!     above.
!
      if ((topbtm .eq. 'btm') .or. (topbtm .eq. 'BTM')) then
           chm_igetmodlev=ilev1
      else if ((topbtm .eq. 'top') .or. (topbtm .eq. 'TOP')) then
           chm_igetmodlev=ilev2
      endif
!
      if (chm_igetmodlev .lt. 1) chm_igetmodlev=1
      if (chm_igetmodlev .gt. ntotlev) chm_igetmodlev=ntotlev
!     
  end function chm_igetmodlev 
!-----------------------------------------------------------------------------------------

  subroutine chm_genoper(obsoper,kmode,success)
!
! Author  : Y. Rochon, April 2015
!           - From pre-EnVar version of Nov 2004.
!
! Revision: 
!           M. Sitwell, April 2016
!           - Some input arguments moved into obsoper
!           Y. Rochon, May 2016
!           - Added weighting cases 
!
! Purpose:  Set generalized innovation operator for integral or layer avg obs.
!           Relevant only for 3D incremental fields.
!           This version is intended to vertically distribute the obs increments 
!           proportionally to the background state. See comments section for 
!           details.
!
! Arguments:
!
!  Input   

!           obsoper%zh, zhp   -- See routine chm_vertintg_setup
!           kmode             -- Index specifying if content to be applied,
!                                i.e. if kmode >1.
!           success           -- Logical indicating if calc are to be performed.
!
!           chm_config%generalized_operator -- indicates specification of weighting
!
!  Output  
!           obsoper%zh(obsoper%nmodlev)  -- a*w: Final innovation model array 
!                                                (other than conversion constants)
!           obsoper%zhp(obsoper%nmodlev) -- w (see comments section)
!
! Comments:
!
!     (1) This routine prepares an alternative innovation operator g, called
!     the generalized innovation operator, to take the place of the
!     innovation (TLM) operator h (row of zh). The operator g is
!     specified as:
!
!            g = a*w
!
!     where the modified innovation operator 'w' can be set as:
!
!            w= P[ (h'x)^T ] *  B^{-1}     
!
!     with  h' is the part of h which excludes resolution dependence
!              (only/mostly contains the physics part of h; zhp),
!           x is the state profile rval
!           P is a window cutoff operator (sets small values to zero), and
!           B is the original/initial total "vertical" covariance matrix (in 2D)
!         
!
!     and 'a' is a proportionality constant ensuring that the innovation
!             increment remains unchanged for the 1D case in the absence
!             of other obs., i.e.,
!
!                 a^2 = (h*B*h^T)(w*B*w^T)^{-1},
!
!     Application of the state profile x (rval) is to make the
!     increment profile be more proportional to the state profile.
!
!     The presence of B^{-1} is to negate the weight re-distribution from the later 
!     application of B in grad(Jo).
!
!     While dx is provided to the obs operator, the minimization is done for
!     dx/sigma where sigma is the background error std. dev. in B and so C (correlation matrix)
!     is used instead of B in the minimization. Moreover, the transformation from dx/sigma 
!     to dx is done outside the forward model operators (at the spectral to physical space 
!     transformation step). For this reason, the expression for w should technically be replaced by
! 
!            w= P[ (h'x/sigma^2)^T ] *  C^{-1}             (Option 1 below)
!
!     still with
!
!            a^2 = (h*B*h^T)(w*B*w^T)^{-1}
! 
!     The presence of C^{-1} does/can give difficulty to the iterative variational 
!     minimization. It can result in oscillations in the increment profile depending on
!     where the iterations are stopped. Moreover, if the spectral space C matrix is for 
!     non-seperable vertical and horizontal correlations, there will be oscillations 
!     due to inconstencies between the total inverse vertical correlation C^{-1} in physical space 
!     and the inverse vertical correlation matrix for each spectral wavenumber.
!
!     As alternatives, one can completely omit the role of  C^{-1} from w, i.e.
!
!            w= P[ (h'x/sigma^2)^T ]                        (Option 3)
!
!      or use the following substitute to approximate the role of C^{-1} in approximatily
!      negating the weight re-distribution from later application of C in grad(Jo), i.e.
!
!            w(i)= P[ (h'x/sigma^2)^T ]_i / sum(C(:,i))     (Option 2 - preferred)
!
!     (2) The matrices B and B^{-1} are the total error covariance matrix (in physical space)
!     and its inverse with the related error correlation matrices 'corvert' and 'corverti' 
!     provided from 'bmatrixchem_mod.ftn90'.
!
!     (3) In the presence of both (a) neighbouring measurements and (b) horizontal background error 
!     correlation lengths that vary in the vertical, the increments will also be subject to the
!     the latter, displaying larger increments in vertical regions with larger horizontal
!     error correlation lengths - this distorting the vertical increment distribution stemming
!     from chm_genoper alone. This stems from w accounting for vertical correlations via C^{^-1}
!     and not the horizontal correlations in B.
!
!     (4) NOTE: Cases with ensemble-based and or lam-based background covariances
!     are not taken into account in this version.
!
!-----------------------------------------------------------------------------------------
      use bmatrixchem, ONLY : bchm_corvert, bchm_corverti, bchm_invsum, bchm_varnamelist
      
      implicit none
      
      type(struct_chm_obsoperators), intent(inout) :: obsoper
      integer, intent(in) :: kmode
      logical, intent(in) :: success(obsoper%nobslev)
!
!     Declaration of local variables
!
      real(8), parameter :: pwin=0.01
      integer  :: iobslev,imodlev,irmse,jvar
      logical  :: lrgsig
      real(8)  :: zwbw(1),zhbh(1),za,work(obsoper%nmodlev),sigma_trial(obsoper%nmodlev,4)
      real(8), parameter :: threshold=1.D-20
      real(8)  :: zmin,rvalw(obsoper%nmodlev),rvalr(obsoper%nmodlev), &
                  rvalc(obsoper%nmodlev),rmse,w1 
      character(len=22) :: code
   
      if (kmode.le.1) return

!     Retrieve from stored background error std dev [elemements (:,1-2)] at obs location [and inverses at elements (:,3-4)]    
      sigma_trial=chm_retrieve_sigma_trial(obsoper%obs_index)               
!
!     Identify variable position index in background error correlation matrices
!
      jvar=1
      do while (trim(bchm_varnamelist(jvar)).ne.'') 
         if (trim(bchm_varnamelist(jvar)).eq.trim(obsoper%varName)) exit
         jvar=jvar+1
      end do
      if (trim(bchm_varnamelist(jvar)).eq.'') call abort3d('chm_genoper: Correlation matrix not found for ' // trim(obsoper%varName) )
!
!     Initialize reference mass (mixing ratio) weighting profile as profile from trial field
! 
      rvalr(1:obsoper%nmodlev)=obsoper%trial(1:obsoper%nmodlev)
!
!     Check on rvalr
!        
      if (any(abs(rvalr(:)).le.threshold)) then
!         write(*,*) 'chm_genoper: Trial field profile segment is ~zero. Could cause an abort in this routine.'
!         write(*,*) 'chm_genoper: To prevent abort and still be effective, corresponding elements set to a non-zero constant.'
!         write(*,*) 'chm_genoper: ',varName,rlat,rlong,nobslev
         if (all(abs(rvalr(:)).le.threshold)) then
              rvalr(:)=1.0 
         else  
              zmin=minval(abs(rvalr(:)), &
                   mask=abs(rvalr(:)).gt.threshold)
              where (abs(rvalr(:)).le.threshold) &
                   rvalr(:)=zmin  
         end if
      end if
!
!     Loop over obs elements
!
      lrgsig=.true. 
      write(code,'(I22)') obsoper%obs_index
      
      do iobslev=1,obsoper%nobslev
           
         if (.not.success(iobslev)) cycle   
!
!        Set reference mass (mixing ratio) weighting profile
!
         rvalw(1:obsoper%nmodlev)=rvalr(1:obsoper%nmodlev)
         if (chm_config%generalized_operator(obsoper%constituent_id).gt.1) then
!
!           Set reference mass weighting profile according to the difference between 
!           an external reference (such as a climatology) and trial field profiles.
!
!           This is a mechanism to force the solution profile shape somewhat towards that 
!           of the external reference when the reliability of the vertical structure of the 
!           trial field is not high.
!
!           This can be used at the beginning of long assimilation periods if the initial
!           trial field is not as realistic as may be desired or somewhat mitigate
!           gradual biasing of vertical structures that might otherwise occur from assimilation 
!           of integrated quantities (when there is insufficient data from other observation types).
!
!           The larger the rms difference of xc (external reference) with xb (trial field profile), 
!           the greater is the influence of this difference in the weighting. If there is 
!           little difference, then either xb or xc can be directly used as the weighting 
!           profile; xb is used below.
!
            rmse=0.0
            irmse=0
            rvalc(1:obsoper%nmodlev)=obsdata_get_array1d(chm_ref_trial,code)
            
            zmin=pwin*maxval(abs(obsoper%zhp(iobslev,1:obsoper%nmodlev)))
            do imodlev=1,obsoper%nmodlev
               if (obsoper%zhp(iobslev,imodlev).gt.zmin) then
                   irmse=irmse+1
                   rmse=rmse+((rvalc(imodlev)-obsoper%trial(imodlev))*sigma_trial(imodlev,3))**2
               end if
            end do
            rmse=rmse*2./irmse
            if (rmse.lt.1.0) then
               rvalw(1:obsoper%nmodlev)=rvalc(1:obsoper%nmodlev)
            else 
               rvalw(1:obsoper%nmodlev)=rvalc(1:obsoper%nmodlev)-obsoper%trial(1:obsoper%nmodlev)
               if (rmse.lt.5.0) then
                  w1=(5.0-rmse)/(5.0-1.0)
                  rvalw(1:obsoper%nmodlev)=(1.0-w1)*rvalw(1:obsoper%nmodlev)+w1*obsoper%trial(1:obsoper%nmodlev)
               end if
               where (abs(rvalw(1:obsoper%nmodlev)).lt.0.01*rvalc(1:obsoper%nmodlev)) &
                      rvalw(1:obsoper%nmodlev)=sign(0.01*rvalc(1:obsoper%nmodlev),rvalw(1:obsoper%nmodlev))
            end if         
         end if
!
!        Begin preparation of the new innovation operator w (=new zhp)
!
         if (obsoper%nobslev.eq.1.and.obsoper%lvl_top(iobslev).eq.1.and. &
            obsoper%lvl_bot(iobslev).eq.obsoper%nmodlev) then
            
!           Treat as total column obs. Here, zhp would be approx. equal
!           to 1 except for the near-end points of the model vertical domain,
!           the latter due to the discretized domain. Not using zhp avoids this
!           discretization issue from weakly affecting results at the boundaries.
!
            work(1:obsoper%nmodlev)=obsoper%trial(1:obsoper%nmodlev)*sigma_trial(1:obsoper%nmodlev,3) 
          else 

!           Account for localized obs function (e.g. partial columns, Jacobians. For Jacobians,
!           zhp must also be independent of the model layer thicknesses.)
            work(1:obsoper%nmodlev)=obsoper%zhp(iobslev,1:obsoper%nmodlev)* &
                obsoper%trial(1:obsoper%nmodlev)*sigma_trial(1:obsoper%nmodlev,3) 
         end if

!        Apply cutoff (apply to zhp*obsoper%trial/sigma_trial(:,1) instead of the resultant zh)
!        Resultant outside cutoff region should be zhp*obsoper%trial/sigma_trial(:,1)/sigma_trial(:,1).
!        Note: sigma_trial(:,3)=1.0/sigma_trial(:,1)
 
         zmin=pwin*maxval(abs(work(1:obsoper%nmodlev)))
         where (abs(work(1:obsoper%nmodlev)).lt.zmin) 
             work(1:obsoper%nmodlev)=0.0D0 
         elsewhere        
             work(1:obsoper%nmodlev)=work(1:obsoper%nmodlev)*sigma_trial(1:obsoper%nmodlev,3)
         endwhere
!
!        Application of C^{-1} or substitute (for negating the weight impact of the
!        later application of C in finalizing grad(Jo). Option 2 is favoured.
!  
!        Option 1: Application of C^{-1}
!         call chm_corvert_mult(obsoper%varName,work(1:obsoper%nmodlev),obsoper%zhp(iobslev,1:obsoper%nmodlev), &
!                   obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,obsoper%nmodlev, &
!                   .false.,-1)
!
!        Option 2: Application of 1/sum(C(:,j)) to approximately negate the weight re-distribution from C
!                  in the calc of grad(Jo).
!
!!         call chm_corvert_mult(obsoper%varName,work(1:obsoper%nmodlev),obsoper%zhp(iobslev,1:obsoper%nmodlev), &
!!                  obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev,obsoper%nmodlev, &
!!                  .false.,0)
         obsoper%zhp(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev))= &
                 obsoper%zhp(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                 *bchm_invsum(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),jvar)
!
!        Option 3: Just skip over consideration attempt at negating the weight re-distribution from C.
!         chm_obsoper%zhp(iobslev,1:obsoper%nmodlev)=work(1:obsoper%nmodlev)
!
!        Determine proportionality factor 'a' = (h*B*h^T)(w*B*w^T)^{-1}
!
!        Determine/estimate w*B*w^T (zwbw(1))
!
!!         call chm_corvert_mult(obsoper%varName,obsoper%zhp(iobslev,1:obsoper%nmodlev), &
!!                   zwbw,obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev, &
!!                   1,lrgsig,3,sigma_trial))
         do imodlev=obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev)
            work(imodlev)=sum(obsoper%zhp(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                         *bchm_corvert(imodlev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),jvar) &
                         *sigma_trial(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),1))*sigma_trial(imodlev,1)
         end do
         zwbw(1)=sum(obsoper%zhp(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                *work(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)))
!          
!        Determine/estimate h*B*h^T (zhbh(1))
!
!!         call chm_corvert_mult(obsoper%varName,obsoper%zh(iobslev,1:obsoper%nmodlev), &
!!                  zhbh,obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev),1,obsoper%nmodlev, &
!!                  1,lrgsig,3,sigma_trial)
         do imodlev=obsoper%lvl_top(iobslev),obsoper%lvl_bot(iobslev)
            work(imodlev)=sum(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                         *bchm_corvert(imodlev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),jvar) &
                         *sigma_trial(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev),1))*sigma_trial(imodlev,1)
         end do
         zhbh(1)=sum(obsoper%zh(iobslev,obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)) &
                *work(obsoper%lvl_top(iobslev):obsoper%lvl_bot(iobslev)))
! 
!        Set proportionality factor 'a'
!
         za=sqrt(zhbh(1)/zwbw(1))
!         if (abs(obsoper%lat*180./3.1415-78.).lt.2.0.and.abs(rlon*180./3.1415-185.).lt.2.0) then
!             write(6,*) 'ZA  ',obsoper%lat*180.0/3.1415,rlon*180.0/3.1415,za,zhbh(1),zwbw(1)
!             write(6,*) 'obsoper%trial',obsoper%trial(1:obsoper%nmodlev)
!             write(6,*) 'sigma_trial',sigma_trial(1:obsoper%nmodlev,1)
!             write(6,*) 'ZH  ',chm_obsoper%zh(iobslev,1:obsoper%nmodlev)
!             write(6,*) 'ZHP ',chm_obsoper%zhp(iobslev,1:obsoper%nmodlev)*za
!         end if
!
!        Set final innovation operator
!
         obsoper%zh(iobslev,1:obsoper%nmodlev)=obsoper%zhp(iobslev,1:obsoper%nmodlev)*za
!
      end do
  
  end subroutine chm_genoper
!-----------------------------------------------------------------------------------------

  subroutine chm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot, &
                              ndim1,ndim2,ndim3,lrgsig,itype,rsig)
!
! Author  : Y. Rochon, April 2015
!
! Revision: 
!
! Purpose: Multiplication with covariance matrix(ces) C=corvert (itype>0) or their 
!          inverse CI=corverti (itype<0).
!
!          Given A=rmat_in (=input)
!
!          itype       Output
!          -----       ------
!            0          D(i,j)=A(i,j)/sum(C(1:n,i))
!            1          A*C
!            2          C*A
!            3          A*C*A^T
!           -1          A*CI
!           -2          CI*A
!           -3          A*CI*A^T
!
! Arguments:
!
!  Input
!
!           varName              -- Variable name
!           rmat_in(ndim1,ndim2) -- Input matrix/vector A (see comments sections)
!           lvl_top(ndim1)       -- Top level of non-zero values in rmat_in
!           lvl_bot(ndim1)       -- Bottom level of non-zero values in rmat_in
!           ndim1,ndim2          -- Matrix dimensions
!                                   ndim1 to be 1 one 1D input vectors
!           ndim3                -- Expected output dimension.
!                                   =ndim1 for itype= +/-3
!                                   =ndim2 otherwise
!           lrgsig               -- Index to indicate if rgsig to be included as part of C or CI below.
!           itype                -- Type of operator (see above). 
!           rsig(ndim2,2)        -- Background error std. dev. at obs locations.
!                                   Must be provided when lrgsig=.true.    
!
!  Output:
!
!           rmat_out(ndim1,ndim2) -- Output matrix/vector (see comments sections)
!
! Comments:
!
! (A) If rmat_in is a 1-D vector, then 
!     
!     for cases +/- 2, one should have set ndim2=1 and ndim1=vector-length.
!     for cases +/- 1,3, one should have set ndim1=1 and ndim2=vector-length.
!
! (B) Revisions required whem LAM and ensembles cases become available.
!
!-----------------------------------------------------------------------------------------
      use bmatrixchem, ONLY : bchm_corvert_mult
 
      implicit none
      character(len=*), intent(in) :: varName
      logical, intent(in)    :: lrgsig
      integer, intent(in)    :: ndim1,ndim2,ndim3,itype
      integer, intent(in)    :: lvl_top(ndim1),lvl_bot(ndim1)
      real(8), intent(in)    :: rmat_in(ndim1,ndim2)
      real(8), intent(out)   :: rmat_out(ndim1,ndim3)
      real(8), intent(in), optional :: rsig(ndim2,2)
   
      integer :: nsize
      real(8) :: rsig_local(ndim2,2)
      
      rmat_out(:,:)=0.0D0
      rsig_local=0.0
      if (present(rsig)) rsig_local=rsig
        
!     Apply operation related to static background error covariance/correlation matrix.
!     Applicability tests within b*chm_corvert_mult.

      call bchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                             lrgsig,itype,rsig_local(:,1))
!      call blamchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                             lrgsig,itype,rsig_local(:,1))

!     Apply operation related to ensemble-based background error covariance/correlation matrix.
!     Applicability test within benschm_corvert_mult.

!      call benschm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
!                                lrgsig,itype,rsig_local(:,2))

  end subroutine chm_corvert_mult
!-----------------------------------------------------------------------------------------

end module chem_mod
