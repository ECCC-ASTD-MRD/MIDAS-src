!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE restoreMasks 
      use modmask
      use obsSpaceData_mod
      implicit none
c Purpose:
c Compute the global masks such as lmaskpp_inout_g,lmasksf_inout_g,... 
c
c Author  : BIN HE  *ARMA/MRB MAY 2009
c
c Revision:
C   

#include "comlun.cdk"
#include "comdimo.cdk"


#include "cvcord.cdk"
*
! Define Local Variables. 
      INTEGER :: ierr
      INTEGER :: nobtot_l
      integer :: mask_dim
      LOGICAL,DIMENSION(:),pointer :: llmask_l  
* 
       nobtot_l=nobtot 
       mask_dim = ubound(lmaskpp_in,1)  
         
       ALLOCATE(lmaskpp_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskpp_inout_g')
       ALLOCATE(lmasksf_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmasksf_inout_g')
       ALLOCATE(lmaskto_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskto_g')

       ALLOCATE(lmaskgo_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskgo_g')

       ALLOCATE(lmaskro_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskro_g')

       ALLOCATE(lmaskzp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskzp_g')

       ALLOCATE(lmask_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmask_g')

       ALLOCATE(lmaskgp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskgp_g')

       ALLOCATE(llmask_l(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cant Allocate Mem. to llmask_l')

       CALL restore_mask(lmask_g,obsSpaceData%mxobstotal,lmask,obs_num_obstotal(obsSpaceData))  

       llmask_l = lmaskpp_in .or. lmaskpp_out
       CALL restore_mask(lmaskpp_inout_g,obsSpaceData%mxobstotal,llmask_l,obs_num_obstotal(obsSpaceData))  

       llmask_l =  lmasksf_in .or. lmasksf_out
       CALL restore_mask(lmasksf_inout_g,obsSpaceData%mxobstotal,llmask_l,obs_num_obstotal(obsSpaceData))  

       CALL restore_mask(lmaskto_g,obsSpaceData%mxobstotal,lmaskto,obs_num_obstotal(obsSpaceData))  

       CALL restore_mask(lmaskgo_g,obsSpaceData%mxobstotal,lmaskgo,obs_num_obstotal(obsSpaceData))  
       CALL restore_mask(lmaskro_g,obsSpaceData%mxobstotal,lmaskro,obs_num_obstotal(obsSpaceData))  
       CALL restore_mask(lmaskzp_g,obsSpaceData%mxobstotal,lmaskzp,obs_num_obstotal(obsSpaceData))  

       CALL restore_mask(lmaskgp_g,obsSpaceData%mxobstotal,lmaskgp,obs_num_obstotal(obsSpaceData))  
       CONTAINS

       SUBROUTINE restore_mask(lmask_g,kdata_g,lmask_l,kdata_l)
        INTEGER :: kdata_l,kdata_g 
        Logical ,DIMENSION(kdata_g) :: lmask_g 
        Logical ,DIMENSION(kdata_l) :: lmask_l 

       INTEGER :: i,ii,j ,iobs,idata,idataend,ierr  

       lmask_g=.false.
       ii=0
       DO i=1,nobtot
         iobs=locObsTag(i)
         idata=obs_elem_i(obsSpaceData,'RLN ',iobs)
         idataend=obs_elem_i(obsSpaceData,'NLV ',iobs) + idata -1
         DO j=idata,idataend
           ii=ii+1
           lmask_g(j)=lmask_l(ii)
         ENDDO
       ENDDO  
       CALL rpn_comm_allreduce(lmask_g,lmask_g,kdata_g,"MPI_LOGICAL","MPI_LOR","GRID",ierr )
       END SUBROUTINE   restore_mask
 
      END SUBROUTINE restoreMasks     
