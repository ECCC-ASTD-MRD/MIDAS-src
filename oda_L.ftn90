!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_L(statevector,lcolumn,lcolumng,lobsSpaceData)
  use MathPhysConstants_mod
  use mod4dv, only : l4dvar
  use mpi 
  use gridstatevector_mod
  use gaussGrid_mod
  use obsSpaceData_mod
  use columnData_mod 
  use modfgat
  implicit none
  !
  !Purpose: Localisation (3D) / Tangent Linear Model (4D) operator
  !Compute profiled increments from grided increments
  !  ->In 3D mode : Call a bilinear interpolator
  !  ->In 4D mode : Send dx to the TLM and wait for the profiled increments
  !  ->Results are saved in COMMVO
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
#include "pardim.cdk"
#include "comdimo.cdk"

  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_gsv) :: statevector
  ! Local declarations
  integer :: nl_ilev, nl_err
  integer :: ierr
  !
  call tmg_start (76, 'GD->PROF')                          !
  IF(L4DVAR) THEN
!modular1     if(mpi_myid == 0) CALL PUTDX2('P')
     call rpn_comm_barrier("GRID",ierr) 
!modular1     CALL GETPROF
     nl_ilev = 1
     CALL GD2MVO('TG',nl_ilev)
  else
!
     IF(mpi_myid == 0) THEN
       write(*,*)'ODA_L- Horizontal interpolation GD --> MVO'
     endif
!
!    Conversion of wind images to physical winds
!
     call uvwi2uv(statevector)
!$OMP PARALLEL
!$OMP SECTIONS PRIVATE(nl_ilev)
!
!    3D fields interpolation
!
!$OMP SECTION
     if(NGEXIST(nguu).eq.1)  call gd2mvo('UU',lcolumn%nlev)
!$OMP SECTION
     if(NGEXIST(ngvv).eq.1)  call gd2mvo('VV',lcolumn%nlev)
!$OMP SECTION
     if(NGEXIST(ngq).eq.1)   call gd2mvo('Q0',lcolumn%nlev)
!$OMP SECTION
     if(NGEXIST(ngtt).eq.1)  call gd2mvo('TT',lcolumn%nlev)
!$OMP SECTION
     if(NGEXIST(nggz).eq.1)  call gd2mvo('GZ',lcolumn%nlev)
!$OMP SECTION
     if(NGEXIST(ngtr).eq.1)  call gd2mvo('TR',lcolumn%nlev)
!
!    2D fields interpolation
!
!$OMP SECTION
     nl_ilev = 1
     if(NGEXIST(ngps).eq.1)  call gd2mvo('PS',nl_ilev)
     if(NGEXIST(ngtg).eq.1)  call gd2mvo('TG',nl_ilev)
!$OMP END SECTIONS
!$OMP END PARALLEL

  endif
  call tmg_stop(76)
  
  !     TL of variable conversions
  !------------------------------
  call tmg_start(51,'VAR_CH') !
  if(NMVOEXIST(NOGZ).eq.1) call ltt2phi(lcolumn,lcolumng)
  call tmg_stop(51)


  CONTAINS

      SUBROUTINE GD2MVO(CDVARNAME,klev)
!*
!***s/r GD2MVO  - Horizontal interpolation of the model variables
!*               in grid-point space to observation locations.
!*               Bilinear interpolation from the 4 nearest grid points.
!*     .         (adapted from BILIN)
!*
!*Author  : P. GAUTHIER *ARMA/MSC JULY 2002
!*     .
!*Revision:
!*
!**    Purpose:  Build lcolumn from GD (in COMGD0) using
!*     .         bilinear interpolation.
!*
!*     CDVARNAME: identificator of the variable to be treated
!*     KLEV     : number of levels (typically 1 for 2D-fields and LCOLUMN%NLEV for 3D-fields)
!*
!*
!*     Arguments
!*
      character*2 cdvarname
      integer klev
!*
!*     Local Variables
!*
      INTEGER   JLEV, JGL, JLON, JOBS, JSTEP
      INTEGER   ILON, ILOS, IMIDDLE, ISYM, ILA, IMAX
      REAL*8    DLMEAN, DLMEAS, DLDLON, DLDLOS
      REAL*8    DLDXN, DLDXS, DLDY, DLW1, DLW2, DLW3, DLW4
      real*4    DLLAO, DLLOO

      real*8  zfield(0:(statevector%ni+2),1:klev,(-1):(statevector%nj+2))
      real*8  zprofil(1:klev,lcolumn%nobtot)
!*
!*     Transfer Grid point field into local array (for generecity)
!*
      zfield(:,:,:) = 0.
      zprofil(:,:)  = 0.

      do jstep=1,nstepobsinc

        select case (cdvarname)
!*
!*     2D fields
!*
        case('TG')
           zfield(1:statevector%NI,1,1:statevector%NJ)= statevector%TG(1:statevector%NI,1,1:statevector%NJ,jstep)
        case('PS')
           zfield(1:statevector%NI,1,1:statevector%NJ)= statevector%PS(1:statevector%NI,1,1:statevector%NJ,jstep)
!*
!*     3D fields
!*
        case('TT')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%TT(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('Q0')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%HU(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('TR')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%TR(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ,jstep)
        case('UU')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%UU(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('VV')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%VV(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case ('GZ')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%GZ(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ,jstep)
        end select
!C
!C*    1. EXPAND GRID-POINTS ARRAYS OF GD BY REPEATING MERIDIANS
!C     NI, 1, AND 2 INTO MERIDIANS 0, NI+1,
!C     AND NI AND ALSO TWO PARALLELS NEAR THE POLES.
!C     ----------------------------------------------------------
!C
!C*    1.1 EXTRA MERIDIANS
!C
!C     MERIDIAN NI DUPLICATED INTO MERIDIAN 0
!C     MERIDIAN 1  DUPLICATED INTO MERIDIAN NI + 1
!C     MERIDIAN 2  DUPLICATED INTO MERIDIAN NI + 2
!C
        DO JLEV = 1, KLEV
           DO JGL = 1, STATEVECTOR%NJ
              IMAX = STATEVECTOR%NI
              ZFIELD(0     ,jlev,JGL) = ZFIELD(STATEVECTOR%NI,jlev,JGL)
              ZFIELD(IMAX+1,jlev,JGL) = ZFIELD( 1,jlev,JGL)
              ZFIELD(IMAX+2,jlev,JGL) = ZFIELD( 2,jlev,JGL)
           END DO
        END DO
!C
!C     *    1.2 EXTRA PARALLELS
!C
!C     COMPUTATION OF VALUES AT NORTH AND SOUTH POLES.
!C
        LEVELS: DO JLEV = 1, KLEV
           DLMEAN = 0.
           DLMEAS = 0.
           IMAX = STATEVECTOR%NI
           DO JLON = 1, IMAX
              DLMEAN = DLMEAN + ZFIELD(JLON,jlev,1)
              DLMEAS = DLMEAS + ZFIELD(JLON,jlev,STATEVECTOR%NJ)
           END DO
           DLMEAN = DLMEAN / STATEVECTOR%NI
           DLMEAS = DLMEAS / STATEVECTOR%NI
           IMAX = STATEVECTOR%NI
           DO JLON = 0, IMAX + 2
              ZFIELD(JLON,jlev,0)    = DLMEAN
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+1) = DLMEAS
           END DO
!C
!C     COMPUTATION OF VALUES FOR PARALLELS -1 AND NJ + 2 (WITH SYMETRIZATION)
!C
           IMIDDLE = STATEVECTOR%NI / 2
           DO JLON = 0, IMIDDLE
              ISYM = JLON + IMIDDLE
              ZFIELD(JLON,jlev,-1)   = ZFIELD(ISYM,jlev,1)
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+2) = ZFIELD(ISYM,jlev,STATEVECTOR%NJ)
           END DO
           IMAX = STATEVECTOR%NI
           DO JLON = IMIDDLE + 1, IMAX + 2
              ISYM = JLON - IMIDDLE
              ZFIELD(JLON,jlev,-1)   = ZFIELD(ISYM,jlev,1)
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+2) = ZFIELD(ISYM,jlev,STATEVECTOR%NJ)
           END DO

        END DO LEVELS
!C     ---------------------------------
!C*    2. LOOP OVER ALL THE OBSERVATIONS
!C     ---------------------------------
!C
        DO JOBS = 1, LCOLUMN%NOBTOT
          if(obs_getTimeInterpWeight(lobsSpaceData,jobs,jstep).gt.0.0d0) then
            DLLAO=obs_elem_r4(lobsSpaceData,'LAT ',jobs)
            DLLOO=obs_elem_r4(lobsSpaceData,'LON ',jobs)
!C
!C     *    2.1. LOCATE FIRST LATITUDE ROW NUMBER (ILA) TO THE NORTH
!C     *    OF ZLAO, AND THE TWO LONGITUDE POINT NUMBERS IMMEDIATELY
!C     *    TO THE WEST (ILON AND ILOS).
!C
            ila=obs_elem_i(lobsSpaceData,'TLA ',jobs)

            IF(DLLOO.LT.0.) DLLOO = DLLOO + 2.*RPI
            IF(DLLOO.GE.2.*RPI) DLLOO = DLLOO - 2.*RPI
            DLDLON = 2.*RPI/STATEVECTOR%NI
            DLDLOS = 2.*RPI/STATEVECTOR%NI
            ILON = INT(DLLOO/DLDLON) + 1
            ILOS = INT(DLLOO/DLDLOS) + 1
!C
!C     *    2.2 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
!C
            DLDXN = DLLOO/DLDLON + 1. - ILON
            DLDXS = DLLOO/DLDLOS + 1. - ILOS
            DLDY  = (gaus_RLATI(ILA)-DLLAO)/(gaus_RLATI(ILA)-gaus_RLATI(ILA+1))
            DLW1  = (1.-DLDXN)*(1.-DLDY)
            DLW2  = DLDXN*(1.-DLDY)
            DLW3  = (1.-DLDXS)*DLDY
            DLW4  = DLDXS*DLDY
!C
!C     *    2.3 Interpolate the model state to the obs point
!C
            DO JLEV = 1, KLEV
              ZPROFIL(JLEV,JOBS) =   ZPROFIL(JLEV,JOBS) +  &
                 obs_getTimeInterpWeight(lobsSpaceData,jobs,jstep)*  &
                 ( DLW1*ZFIELD(ILON,JLEV,ILA)    &
                 + DLW2*ZFIELD(ILON+1,JLEV,ILA)  &
                 + DLW3*ZFIELD(ILOS,JLEV,ILA+1)  &
                 + DLW4*ZFIELD(ILOS+1,JLEV,ILA+1) )
            END DO
          endif
        END DO

      ENDDO ! JSTEP

      SELECT CASE (CDVARNAME)
!*
!*     2D fields
!*
      CASE('TG')
         lcolumn%tg(1:KLEV,1:LCOLUMN%NOBTOT) = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('PS')
         lcolumn%ps(1:KLEV,1:LCOLUMN%NOBTOT) = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
!*
!*     3D fields
!*
      CASE('TT')
         lcolumn%tt(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('Q0')
         lcolumn%hu(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('TR')
         lcolumn%tr(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('UU')
         lcolumn%uu(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('VV')
         lcolumn%vv(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      CASE('GZ')
         lcolumn%gz(1:KLEV,1:LCOLUMN%NOBTOT)  = ZPROFIL(1:KLEV,1:LCOLUMN%NOBTOT)
      END SELECT

      RETURN
      END subroutine gd2mvo

 
end subroutine oda_L
