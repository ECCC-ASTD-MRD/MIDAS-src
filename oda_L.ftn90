!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_L(statevector,lcolumn,lcolumng,lobsSpaceData)
  use MathPhysConstants_mod
  use mpi 
  use gridstatevector_mod
  use gaussGrid_mod
  use obsSpaceData_mod
  use columnData_mod 
  implicit none
  !
  !Purpose: Localisation (3D) / Tangent Linear Model (4D) operator
  !Compute profiled increments from grided increments
  !  ->In 3D mode : Call a bilinear interpolator
  !  ->In 4D mode : Send dx to the TLM and wait for the profiled increments
  !  ->Results are saved in COMMVO
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_gsv) :: statevector
  ! Local declarations
  integer :: nl_ilev, nl_err
  integer :: ierr
  !
  call tmg_start (76, 'GD->PROF')                          !

  IF(mpi_myid == 0) THEN
    write(*,*)'ODA_L- Horizontal interpolation GD --> MVO'
  endif

  !    Conversion of wind images to physical winds
  call uvwi2uv(statevector)

!$OMP PARALLEL
!$OMP SECTIONS PRIVATE(nl_ilev)

  ! 3D fields interpolation
!$OMP SECTION
  if(NGEXIST(nguu).eq.1)  call gd2mvo('UU',col_getNumLev(lcolumn))
!$OMP SECTION
  if(NGEXIST(ngvv).eq.1)  call gd2mvo('VV',col_getNumLev(lcolumn))
!$OMP SECTION
  if(NGEXIST(ngq).eq.1)   call gd2mvo('HU',col_getNumLev(lcolumn))
!$OMP SECTION
  if(NGEXIST(ngtt).eq.1)  call gd2mvo('TT',col_getNumLev(lcolumn))
!$OMP SECTION
  if(NGEXIST(nggz).eq.1)  call gd2mvo('GZ',col_getNumLev(lcolumn))
!$OMP SECTION
  if(NGEXIST(ngtr).eq.1)  call gd2mvo('TR',col_getNumLev(lcolumn))

  ! 2D fields interpolation
!$OMP SECTION
  nl_ilev = 1
  if(NGEXIST(ngps).eq.1)  call gd2mvo('P0',nl_ilev)
  if(NGEXIST(ngtg).eq.1)  call gd2mvo('TG',nl_ilev)

!$OMP END SECTIONS
!$OMP END PARALLEL

  call tmg_stop(76)
  
  ! TL of variable conversions
  call tmg_start(51,'VAR_CH') !
  if(col_varExist('GZ')) call ltt2phi(lcolumn,lcolumng)
  call tmg_stop(51)


  CONTAINS

      SUBROUTINE GD2MVO(CDVARNAME,klev)
!*
!***s/r GD2MVO  - Horizontal interpolation of the model variables
!*               in grid-point space to observation locations.
!*               Bilinear interpolation from the 4 nearest grid points.
!*     .         (adapted from BILIN)
!*
!*Author  : P. GAUTHIER *ARMA/MSC JULY 2002
!*     .
!*Revision:
!*
!**    Purpose:  Build lcolumn from GD (in COMGD0) using
!*     .         bilinear interpolation.
!*
!*     CDVARNAME: identificator of the variable to be treated
!*     KLEV     : number of levels (typically 1 for 2D-fields and COL_GETNUMLEV(LCOLUMN) for 3D-fields)
!*
!*
!*     Arguments
!*
      character*2 cdvarname
      integer klev
!*
!*     Local Variables
!*
      INTEGER   JLEV, JLAT, JLON, JOBS, JSTEP
      INTEGER   ILON, ILOS, IMIDDLE, ISYM, ILA
      REAL*8    DLMEAN, DLMEAS, DLDLON, DLDLOS
      REAL*8    DLDXN, DLDXS, DLDY, DLW1, DLW2, DLW3, DLW4, DLLAO, DLLOO

      real*8  zfield(0:(statevector%ni+2),1:klev,(-1):(statevector%nj+2))
      real*8, allocatable :: zprofil(:,:)

      allocate(zprofil(klev,col_getNumCol(lcolumn)))
!*
!*     Transfer Grid point field into local array (for generecity)
!*
      zfield(:,:,:) = 0.
      zprofil(:,:)  = 0.

      do jstep=1,statevector%nt

        select case (cdvarname)
!*
!*     2D fields
!*
        case('TG')
           zfield(1:statevector%NI,1,1:statevector%NJ)= statevector%TG(1:statevector%NI,1,1:statevector%NJ,jstep)
        case('P0')
           zfield(1:statevector%NI,1,1:statevector%NJ)= statevector%PS(1:statevector%NI,1,1:statevector%NJ,jstep)
!*
!*     3D fields
!*
        case('TT')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%TT(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('HU')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%HU(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('TR')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%TR(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ,jstep)
        case('UU')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%UU(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case('VV')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%VV(1:STATEVECTOR%NI,1:KLEV,1:STATEVECTOR%NJ,jstep)
        case ('GZ')
           zfield(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ)=  statevector%GZ(1:STATEVECTOR%NI,1:klev,1:STATEVECTOR%NJ,jstep)
        end select
!C
!C*    1. EXPAND GRID-POINTS ARRAYS OF GD BY REPEATING MERIDIANS
!C     NI, 1, AND 2 INTO MERIDIANS 0, NI+1,
!C     AND NI AND ALSO TWO PARALLELS NEAR THE POLES.
!C     ----------------------------------------------------------
!C
!C*    1.1 EXTRA MERIDIANS
!C
!C     MERIDIAN NI DUPLICATED INTO MERIDIAN 0
!C     MERIDIAN 1  DUPLICATED INTO MERIDIAN NI + 1
!C     MERIDIAN 2  DUPLICATED INTO MERIDIAN NI + 2
!C
        DO JLEV = 1, KLEV
           DO JLAT = 1, STATEVECTOR%NJ
              ZFIELD(0     ,jlev,JLAT) = ZFIELD(STATEVECTOR%NI,jlev,JLAT)
              ZFIELD(STATEVECTOR%NI+1,jlev,JLAT) = ZFIELD( 1,jlev,JLAT)
              ZFIELD(STATEVECTOR%NI+2,jlev,JLAT) = ZFIELD( 2,jlev,JLAT)
           END DO
        END DO
!C
!C     *    1.2 EXTRA PARALLELS
!C
!C     COMPUTATION OF VALUES AT NORTH AND SOUTH POLES.
!C
        LEVELS: DO JLEV = 1, KLEV
           DLMEAN = 0.
           DLMEAS = 0.
           DO JLON = 1, STATEVECTOR%NI
              DLMEAN = DLMEAN + ZFIELD(JLON,jlev,1)
              DLMEAS = DLMEAS + ZFIELD(JLON,jlev,STATEVECTOR%NJ)
           END DO
           DLMEAN = DLMEAN / STATEVECTOR%NI
           DLMEAS = DLMEAS / STATEVECTOR%NI
           DO JLON = 0, STATEVECTOR%NI + 2
              ZFIELD(JLON,jlev,0)    = DLMEAN
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+1) = DLMEAS
           END DO
!C
!C     COMPUTATION OF VALUES FOR PARALLELS -1 AND NJ + 2 (WITH SYMETRIZATION)
!C
           IMIDDLE = STATEVECTOR%NI / 2
           DO JLON = 0, IMIDDLE
              ISYM = JLON + IMIDDLE
              ZFIELD(JLON,jlev,-1)   = ZFIELD(ISYM,jlev,1)
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+2) = ZFIELD(ISYM,jlev,STATEVECTOR%NJ)
           END DO
           DO JLON = IMIDDLE + 1, STATEVECTOR%NI + 2
              ISYM = JLON - IMIDDLE
              ZFIELD(JLON,jlev,-1)   = ZFIELD(ISYM,jlev,1)
              ZFIELD(JLON,jlev,STATEVECTOR%NJ+2) = ZFIELD(ISYM,jlev,STATEVECTOR%NJ)
           END DO

        END DO LEVELS
!C     ---------------------------------
!C*    2. LOOP OVER ALL THE OBSERVATIONS
!C     ---------------------------------
!C
        DO JOBS = 1, col_getNumCol(LCOLUMN)
          if(col_getTimeInterpWeight(lcolumn,jobs,jstep).gt.0.0d0) then
            DLLAO=real(obs_elem_r4(lobsSpaceData,'LAT ',jobs),8)
            DLLOO=real(obs_elem_r4(lobsSpaceData,'LON ',jobs),8)
!C
!C     *    2.1. LOCATE FIRST LATITUDE ROW NUMBER (ILA) TO THE NORTH
!C     *    OF ZLAO, AND THE TWO LONGITUDE POINT NUMBERS IMMEDIATELY
!C     *    TO THE WEST (ILON AND ILOS).
!C
            ila=obs_elem_i(lobsSpaceData,'TLA ',jobs)

            IF(DLLOO.LT.0.) DLLOO = DLLOO + 2.*RPI
            IF(DLLOO.GE.2.*RPI) DLLOO = DLLOO - 2.*RPI
            DLDLON = 2.*RPI/STATEVECTOR%NI
            DLDLOS = 2.*RPI/STATEVECTOR%NI
            ILON = INT(DLLOO/DLDLON) + 1
            ILOS = INT(DLLOO/DLDLOS) + 1
!C
!C     *    2.2 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
!C
            DLDXN = DLLOO/DLDLON + 1. - ILON
            DLDXS = DLLOO/DLDLOS + 1. - ILOS
            DLDY  = (gaus_RLATI(ILA)-DLLAO)/(gaus_RLATI(ILA)-gaus_RLATI(ILA+1))
            DLW1  = (1.-DLDXN)*(1.-DLDY)
            DLW2  = DLDXN*(1.-DLDY)
            DLW3  = (1.-DLDXS)*DLDY
            DLW4  = DLDXS*DLDY
!C
!C     *    2.3 Interpolate the model state to the obs point
!C
            DO JLEV = 1, KLEV
              ZPROFIL(JLEV,JOBS) =   ZPROFIL(JLEV,JOBS) +  &
                 col_getTimeInterpWeight(lcolumn,jobs,jstep)*  &
                 ( DLW1*ZFIELD(ILON,JLEV,ILA)    &
                 + DLW2*ZFIELD(ILON+1,JLEV,ILA)  &
                 + DLW3*ZFIELD(ILOS,JLEV,ILA+1)  &
                 + DLW4*ZFIELD(ILOS+1,JLEV,ILA+1) )
            END DO
          endif
        END DO

      ENDDO ! JSTEP

      call col_fillmvo(lcolumn,CDVARNAME,'NA',zprofil,klev,col_getNumCol(lcolumn))

      deallocate(zprofil)

      RETURN
      END subroutine gd2mvo

 
end subroutine oda_L
