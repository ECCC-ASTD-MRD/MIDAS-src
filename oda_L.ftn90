!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_L(statevector,lcolumn,lcolumng,lobsSpaceData)
  use MathPhysConstants_mod
  use mpi 
  use gridstatevector_mod
  use gaussGrid_mod
  use obsSpaceData_mod
  use columnData_mod 
  implicit none
  !
  !Purpose: Localisation (3D) operator
  !Compute profiled increments from grided increments
  !  ->In 3D mode : Call a bilinear interpolator
  !  ->Results are saved in COMMVO
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_gsv) :: statevector
  ! Local declarations
  integer :: nl_ilev,ierr,myLatP1
  !
  IF(mpi_myid == 0) THEN
    write(*,*)'ODA_L- Horizontal interpolation GD --> MVO'
    call flush(6)
  endif

  myLatP1 = min(statevector%myLatEnd+1,statevector%nj)

  !    Conversion of wind images to physical winds
  call uvwi2uv(statevector)

  ! Communicate extra latitude needed for interpolation  
  call tmg_start(38,'INTERP_BARR')
  call rpn_comm_barrier("GRID",ierr)
  call tmg_stop(38)
  call tmg_start(39,'INTERP_COMM')
  call gsv_commLat(statevector)
  call tmg_stop(39)

!$OMP PARALLEL
!$OMP SECTIONS PRIVATE(nl_ilev)

  ! 3D fields interpolation
!$OMP SECTION
  if(gsv_varExist('UU'))  call gd2mvo('UU',col_getNumLev(lcolumn))
!$OMP SECTION
  if(gsv_varExist('VV'))  call gd2mvo('VV',col_getNumLev(lcolumn))
!$OMP SECTION
  if(gsv_varExist('HU'))   call gd2mvo('HU',col_getNumLev(lcolumn))
!$OMP SECTION
  if(gsv_varExist('TT'))  call gd2mvo('TT',col_getNumLev(lcolumn))
!$OMP SECTION
  if(gsv_varExist('GZ'))  call gd2mvo('GZ',col_getNumLev(lcolumn))

  ! 2D fields interpolation
!$OMP SECTION
  nl_ilev = 1
  if(gsv_varExist('P0'))  call gd2mvo('P0',nl_ilev)
  if(gsv_varExist('TG'))  call gd2mvo('TG',nl_ilev)

!$OMP END SECTIONS
!$OMP END PARALLEL

  ! TL of variable conversions
  if(col_varExist('GZ')) call ltt2phi(lcolumn,lcolumng)


  CONTAINS

      SUBROUTINE GD2MVO(varName,klev)
!*
!***s/r GD2MVO  - Horizontal interpolation of the model variables
!*               in grid-point space to observation locations.
!*               Bilinear interpolation from the 4 nearest grid points.
!*     .         (adapted from BILIN)
!*
!*Author  : P. GAUTHIER *ARMA/MSC JULY 2002
!*     .
!*Revision:
!*
!**    Purpose:  Build lcolumn from GD (in COMGD0) using
!*     .         bilinear interpolation.
!*
!*     VARNAME: identificator of the variable to be treated
!*     KLEV     : number of levels (typically 1 for 2D-fields and COL_GETNUMLEV(LCOLUMN) for 3D-fields)
!*
!*
!*     Arguments
!*
      character(len=*) :: varName
      integer klev
!*
!*     Local Variables
!*
      INTEGER   JLEV, JLAT, JLON, JOBS, JSTEP
      INTEGER   ILON, ILA
      REAL*8    DLMEAN, DLMEAS, DLDLON
      REAL*8    DLDX, DLDY, DLW1, DLW2, DLW3, DLW4, DLLAO, DLLOO

      real*8  zfield(0:(statevector%ni+2),1:klev,(statevector%myLatBeg-1):(statevector%myLatEnd+1))
      real*8, pointer :: column_ptr(:,:)
      real*8, pointer :: field_ptr(:,:,:,:)

      if(col_getNumCol(LCOLUMN).le.0) return

      field_ptr => gsv_getField(statevector,varName)
      column_ptr => col_getAllColumns(lcolumn,varName)
      column_ptr(:,:) = 0.0d0

      do jstep=1,statevector%numStep

        zfield(1:STATEVECTOR%NI,1:klev,statevector%myLatBeg:myLatP1)=  &
           field_ptr(1:STATEVECTOR%NI,1:KLEV,statevector%myLatBeg:myLatP1,jstep)
!C
!C*    1. EXPAND GRID-POINTS ARRAYS OF GD BY REPEATING MERIDIANS
!C     NI, 1, AND 2 INTO MERIDIANS 0, NI+1,
!C     AND NI AND ALSO TWO PARALLELS NEAR THE POLES.
!C     ----------------------------------------------------------
!C
!C*    1.1 EXTRA MERIDIANS
!C
!C     MERIDIAN NI DUPLICATED INTO MERIDIAN 0
!C     MERIDIAN 1  DUPLICATED INTO MERIDIAN NI + 1
!C     MERIDIAN 2  DUPLICATED INTO MERIDIAN NI + 2
!C
        DO JLEV = 1, KLEV
           DO JLAT = statevector%myLatBeg, myLatP1
              ZFIELD(0,jlev,JLAT) = ZFIELD(STATEVECTOR%NI,jlev,JLAT)
              ZFIELD(STATEVECTOR%NI+1,jlev,JLAT) = ZFIELD(1,jlev,JLAT)
              ZFIELD(STATEVECTOR%NI+2,jlev,JLAT) = ZFIELD(2,jlev,JLAT)
           END DO
        END DO
!C
!C     1.2 EXTRA PARALLELS AT NORTH AND SOUTH POLES.
!C
        LEVELS: DO JLEV = 1, KLEV

           if(statevector%myLatBeg.eq.1) then
              DLMEAN = 0.
              DO JLON = 1, STATEVECTOR%NI
                 DLMEAN = DLMEAN + ZFIELD(JLON,jlev,1)
              END DO
              DLMEAN = DLMEAN / STATEVECTOR%NI
              DO JLON = 0, STATEVECTOR%NI + 2
                 ZFIELD(JLON,jlev,0)    = DLMEAN
              END DO
           endif

           if(statevector%myLatEnd.eq.statevector%nj) then
              DLMEAS = 0.
              DO JLON = 1, STATEVECTOR%NI
                 DLMEAS = DLMEAS + ZFIELD(JLON,jlev,STATEVECTOR%NJ)
              END DO
              DLMEAS = DLMEAS / STATEVECTOR%NI
              DO JLON = 0, STATEVECTOR%NI + 2
                 ZFIELD(JLON,jlev,STATEVECTOR%NJ+1) = DLMEAS
              END DO
           endif

        END DO LEVELS
!C     ---------------------------------
!C*    2. LOOP OVER ALL THE OBSERVATIONS
!C     ---------------------------------
!C
        DLDLON = 2.*MPC_PI_R8/STATEVECTOR%NI
        DO JOBS = 1, col_getNumCol(LCOLUMN)
          if(col_getTimeInterpWeight(lcolumn,jobs,jstep).gt.0.0d0.and. &
             .not.btest(obs_headElem_i(lobsSpaceData,OBS_ST1,jobs),5) ) then
!C
!C     *    2.1. LOCATE FIRST LATITUDE ROW NUMBER (ILA) TO THE NORTH
!C     *    OF ZLAO, AND THE TWO LONGITUDE POINT NUMBERS IMMEDIATELY
!C     *    TO THE WEST (ILON).
!C
            call col_getLatLon(lcolumn,jobs,dllao,dlloo,ila)
           
            ! Check if obs is outside of latitude band on this PE
            if((ila.lt.statevector%myLatBeg.or.ila.gt.statevector%myLatEnd).and. &
                ila.ne.0.and.ila.ne.statevector%nj) then
              write(*,*) 'oda_L: ',jobs,ila,statevector%myLatBeg,statevector%myLatEnd
            endif

            IF(DLLOO.LT.0.) DLLOO = DLLOO + 2.*MPC_PI_R8
            IF(DLLOO.GE.2.*MPC_PI_R8) DLLOO = DLLOO - 2.*MPC_PI_R8
            ILON = INT(DLLOO/DLDLON) + 1
!C
!C     *    2.2 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
!C
            DLDX = DLLOO/DLDLON + 1. - ILON
            DLDY  = (gaus_RLATI(ILA)-DLLAO)/(gaus_RLATI(ILA)-gaus_RLATI(ILA+1))
            DLW1  = (1.-DLDX)*(1.-DLDY)
            DLW2  = DLDX*(1.-DLDY)
            DLW3  = (1.-DLDX)*DLDY
            DLW4  = DLDX*DLDY
!C
!C     *    2.3 Interpolate the model state to the obs point
!C
            DO JLEV = 1, KLEV
              column_ptr(JLEV,JOBS) = column_ptr(JLEV,JOBS) +  &
                 col_getTimeInterpWeight(lcolumn,jobs,jstep)*  &
                 ( DLW1*ZFIELD(ILON,JLEV,ILA)    &
                 + DLW2*ZFIELD(ILON+1,JLEV,ILA)  &
                 + DLW3*ZFIELD(ILON,JLEV,ILA+1)  &
                 + DLW4*ZFIELD(ILON+1,JLEV,ILA+1) )
            END DO
          endif
        END DO

      ENDDO ! JSTEP

      RETURN
      END subroutine gd2mvo

 
end subroutine oda_L
