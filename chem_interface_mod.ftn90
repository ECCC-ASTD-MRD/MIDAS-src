!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_interface_mod
!
! Module managers: Mike Sitwell and Yves Rochon (ARQI/AQRD)
!
! PURPOSE:
!    Provides an interface to chem_mod so that functions and subroutines in chem_mod are
!    kept independent of structures outside of chem_mod (e.g. struct_obs,struct_columnData,etc...)
!
!-----------------------------------------------------------------------------------
  implicit none
  private

! public procedures
! -----------------

  public :: chm_observation_operators,chm_get_comboIdlist,chm_calc_OmA_nonassim
  public :: chm_transform_final_increments,chm_assim

contains
  
!-----------------------------------------------------------------------------------
  subroutine chm_observation_operators(column_bkgrnd,obsSpaceData,kmode,column_inc,jobs)
!
! Purpose: Apply the observation operators for chemical constituents. Mode of operator
!          set by kmode.
! 
! Author: Mike Sitwell,  ARQI/AQRD Aug 2015
!         - Amalgamatated into a single unit from the original content of subroutines oonl_chm, 
!           oda_H, oda_HTchm, and compute_HBHT_static_chm produced from earlier developments 
!           by Ping Du, CMDA/MSC (Jan/Feb 2015), Y. Rochon and M. Sitwell (ARQI/AQRD)
!
! Revision: 
!          M. Sitwell, ARQI/AQRD Nov 2015
!          - Modified the flagging of observations after chm_obsoperators is called
!          M. Sitwell, ARQI/AQRD April 2016
!          - Moved most of the input to chm_obsoperators into obsoper
!          Y. Rochon, ARQI/AQRD May 2016
!          - Modified skipping over processing when not needed
!
! Input
!
!   kmode           Mode of observation operator, with values
!                     0 for general (non-linear and linear) simulation operator
!                     1 for determination of sqrt(diag(H*B*H^T))
!                     2 for tangent linear operator
!                     3 for adjoint of tangent linear operator
!
!   column_bkgrnd   Column of x_background interpolated to observation location. Can
!                   have the same vertical levels as the trial field (columnhr) or
!                   as the increment field (columng)
!
!   obsSpaceData    Observation space data structure
!
! Output
!
!   For kmode values of 0) OmP and total Jo(x_background) for CH. 
!                          OmP saved in OBS_OMP of obsSpaceData
!                       1) background error standard deviations in
!                          observation space, sqrt(diag(H*B_static*H^T)).
!                          Saved in OBS_HPHT of obsSpaceData
!                       2) Hdx saved in OBS_WORK of obsSpaceData
!                       3) H^T * R^-1 (OmP-Hdx) in column_inc
!
!   jobs            Optional output of total Jo(x_background) for chemical constituents. 
!                   Required for kmode=0 and not provided otherwise.
!
! Inout
!
!   column_inc      Optional argument for input/output of column of increment (column).
!                   For kmode=2, used as input for increment H_horiz dx interpolated
!                   to observation location. For kmode=3, used as output for
!                   H^T * R^-1 (OmP-Hdx). Required for kmode=2,3.
!
!  Comments:
!     - Also see type struct_chm_obsoperators in chem_mod.ftn90 for description of obsoper elements.
!     - Currently can only handle the case when nlev_bkgrnd == nlev_inc
!     - Two equivalent methods for looping over a report body.
!
!       Method 1:
!
!            call obs_set_current_body_list(obsSpaceData,headerIndex)
!            BODY: do
!
!               bodyIndex = obs_getBodyIndex(obsSpaceData)
!               if (bodyIndex < 0) exit BODY1
!
!               ... obs_bodyElem_r(obsSpaceData, ... ,bodyIndex)
!  
!            enddo BODY
!
!       Method 2:
!
!            bodyIndex = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)
!            do jl=0,obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)-1
!               ... obs_bodyElem_r(obsSpaceData, ... ,bodyIndex+jl)   
!            end do
!            
!-----------------------------------------------------------------------------------

    use chem_mod
    use codtyp_mod
    use obsSpaceData_mod
    use columnData_mod

    implicit none
    
    ! Subroutine arguments

    type(struct_columnData), intent(inout) :: column_bkgrnd
    type(struct_columnData), intent(inout), optional :: column_inc
    type(struct_obs), intent(inout) :: obsSpaceData
    integer, intent(in) :: kmode
    real(8), intent(out), optional :: jobs

    ! Local variables
    
    real(8) :: zomp,zinc
    integer :: jl,unit

    ! Obs space local variables

    integer :: headerIndex,bodyIndex
    integer :: icodtyp, iobslev, nobslev

    integer, allocatable :: ixtr(:), iass(:)
    logical, allocatable :: success(:),process_obs(:)

    ! Local variables: model space profile data

    real(8), allocatable :: obs_col(:)
    real(8), pointer :: col(:),model_col(:)
    integer :: nlev_bkgrnd,nlev_inc,bodyIndexCount
    character(len=2), parameter :: varType = 'TH'
    
    type(struct_chm_obsoperators) :: obsoper

    ! Open chm_warnings_file (file may be written to from routines in chem_mod)
    call chm_open_warningsfile(unit=unit)

    if ((kmode.eq.2.or.kmode.eq.3) .and. (.not.present(column_inc))) then
       write(*,*) "chm_observation_operators: column_inc must be specified for kmode = ",kmode
       call abort3d("chm_observation_operators")
    end if
    
    ! Initializations
    
    if (present(jobs)) jobs = 0.d0

    nlev_bkgrnd = col_getNumLev(column_bkgrnd,varType)
    
    ! Allocate memory for model_col. Not necessary for kmode=0 since model_col points to obsoper%trial.
    select case(kmode)
    case(2)
       nlev_inc = col_getNumLev(column_inc,varType)
       allocate(model_col(nlev_inc))
    case(1,3)
       allocate(model_col(nlev_bkgrnd))
    end select

    ! Allocations outside chm_obsoper_init since this can be done outside the HEADER loop.
    ! See chm_obsoper_init for assignment of array content.
    
    ! Model obs background, GZ, TT, and HU profiles.
    allocate(obsoper%trial(nlev_bkgrnd),obsoper%gz(nlev_bkgrnd),obsoper%tt(nlev_bkgrnd),obsoper%hu(nlev_bkgrnd))
    ! Model PP and pressure model layer boundaries taken as the middle between model levels.
    allocate(obsoper%pp(nlev_bkgrnd),obsoper%vmodpress(nlev_bkgrnd+1))
    ! Work array: derivative for any variable transform to be applied to a profile
    allocate(obsoper%dtransform(nlev_bkgrnd))
    ! Work array: integration weights array associated to the second order Lagrangian interpolation - see routines
    ! chm_vertintg* in chem_mod.ftn90
    allocate(obsoper%vweights(nlev_bkgrnd,nlev_bkgrnd))
    
    ! Loop over all header indices of the 'CH' family:
    
    call obs_set_current_header_list(obsSpaceData,'CH')
    HEADER: do

      headerIndex = obs_getHeaderIndex(obsSpaceData)
      if (headerIndex < 0) exit HEADER

      icodtyp  = obs_headElem_i(obsSpaceData,OBS_ITY,headerIndex)
      if (icodtyp.ne.codtyp_chemremote.and.icodtyp.ne.codtyp_cheminsitu) cycle HEADER
      
      ! Body info that we only need for first point in the profile
      bodyIndex = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)

      ! Set number of obs profile elements
      nobslev = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)  
      iobslev=0    
      do jl=0,obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)-1
         if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex+jl).eq.8090) nobslev = nobslev-1   ! Skip over 08090 elements
      end do

      ! Allocate memory for remaining profile data not in obsoper
      allocate(obs_col(nobslev), success(nobslev), ixtr(nobslev), iass(nobslev), process_obs(nobslev))

      ! Prepare for checking if any processing is needed according to initial flag values     
      ! First loop over all body indices (profile elements) to get/set flags      
      iobslev=0
      do jl=0,obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)-1
         bodyIndexCount=bodyIndex+jl
         if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndexCount).ne.8090) then
            iobslev=iobslev+1
            ixtr(iobslev) = obs_bodyElem_i(obsSpaceData,OBS_XTR,bodyIndexCount) ! flag indicating if obs extends outside model profile vertical range
            iass(iobslev) = obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndexCount) ! flag indicating if obs is to be processed/assimilated
            process_obs(iobslev) = ixtr(iobslev).eq.0 .and. iass(iobslev).eq.1  ! indicates if this obs should be processed by chm_obsoperators
         end if
      end do

      ! Initialize processing success flag
      success(1:nobslev) = process_obs(1:nobslev)

      
      if (all(.not.process_obs)) then
         ! All observations in the profile flagged so can skip obs operator for current measurement
         if (kmode.eq.3) model_col(:) = 0.0D0

      else  

         ! Initialize obsoper variables and allocate arrays
         call chm_obsoper_init(obsoper,obsSpaceData,headerIndex,column_bkgrnd,nlev_bkgrnd,nobslev,kmode)
 
         ! Initialize model_col, dependent on kmode. Used for input for kmode=0,2, output for kmode=3.
         ! model_col represents for kmode 0) the horizontally interpolated background H_horiz(x_b)
         !                                1) not used
         !                                2) the analysis increment H_horiz dx
         !                                3) the result of applying the adjoint of H_vert 
         select case(kmode)
         case(0)
            model_col => obsoper%trial
         case(2)
            do jl = 1, nlev_inc
               model_col(jl) = col_getElem(column_inc,JL,headerIndex,obsoper%varName)
            end do
         case(1,3)
            model_col(:) = 0.0D0
         end select
               
         ! Loop over all body indices (profile elements) to aquire remaining data
      
         iobslev=0
         call obs_set_current_body_list(obsSpaceData,headerIndex)
         BODY1: do

            bodyIndex = obs_getBodyIndex(obsSpaceData)
            if (bodyIndex < 0) exit BODY1
            
            ! Get position in profile and skip over 08090 elements

            if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).ne.08090) then
               iobslev=iobslev+1
            else
               cycle BODY1
            end if
        
            ! Get vertical coordinate data. Valid for point data values in profiles.
            ! For layer data values, vertical coordinate data will instead be assigned within chm_obsoperators.

            obsoper%obslev(iobslev) = obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex)

            ! Get normalized increment
            if (kmode.eq.3) obs_col(iobslev) = obs_bodyElem_r(obsSpaceData,OBS_WORK,bodyIndex)

         enddo BODY1
      
         ! Apply observation operator. model_col,obs_col are the inputs/outputs in model,observation
         ! space, respectively. Other required inputs are in obsoper. Input/output is as follows:
         !
         !    kmode      model_col      obs_col
         !    -----      ---------      -------
         !      0           in            out
         !      1         not used        out
         !      2           in            out
         !      3           out           in


         call chm_obsoperators(obsoper,model_col,obs_col,kmode,ixtr,success)
 
      end if


      ! Output results
      
      if (kmode.eq.3) then
         ! Store H^T * R^-1 (OmP-Hdx) in column_inc
         
         col => col_getColumn(column_inc,headerIndex,obsoper%varName)
         col(1:nlev_bkgrnd) = model_col(1:nlev_bkgrnd)

      else
         ! Store results in obsSpaceData

         iobslev=0
         call obs_set_current_body_list(obsSpaceData,headerIndex)
         BODY2: do
            bodyIndex = obs_getBodyIndex(obsSpaceData)
            if (bodyIndex < 0) exit BODY2
            
            ! Get position in profile and skip over 08090 elements
            if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).ne.08090) then
               iobslev=iobslev+1
            else
               cycle BODY2
            end if

            ! Check for success in calculations
            if (.not.success(iobslev)) then
               if ((iass(iobslev).ne.3.and.iass(iobslev).ne.4).or.kmode.lt.2) then
                  call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,0)
                  call obs_bodySet_r(obsSpaceData,OBS_OMP,bodyIndex,0.0D0)
                  call obs_bodySet_r(obsSpaceData,OBS_OMA,bodyIndex,0.0D0)
                  if (process_obs(iobslev)) &
                       call obs_bodySet_i(obsSpaceData,OBS_FLG,bodyIndex, ibset(obs_bodyElem_i(obsSpaceData,OBS_FLG,bodyIndex),17) )
               end if
               if (kmode.eq.1) call obs_bodySet_r(obsSpaceData,OBS_HPHT,bodyIndex,0.0D0)
               cycle BODY2
            end if
        
            ! Store result in appropriate location in obsSpaceData            
            select case(kmode)
            case(0)
            
               ! Store OmP in OBS_OMP and add to Jo(x_background) of CH.   
                            
               zomp = obs_bodyElem_r(obsSpaceData,OBS_VAR,bodyIndex) - obs_col(iobslev)
               call obs_bodySet_r(obsSpaceData,OBS_OMP,bodyIndex,zomp)
               
               if (.not.chm_lcheck_skipassim(obsoper%stnid,obsoper%varno,obsoper%nobslev,iass(iobslev))) then
                  ! Add to Jo contribution (factor of 0.5 to be applied outside report loop)
                  zinc = zomp/obs_bodyElem_r(obsSpaceData,OBS_OER,bodyIndex)
                  if (present(jobs)) jobs = jobs + zinc*zinc
               else
                  ! Set flag to be recognized at postmin diagnostics calc in
                  ! routine chm_calc_OmA_nonassim
                  call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,3)
               end if

            case(1)
            
               ! Background error standard deviations in
               ! observation space, sqrt(diag(H*B_static*H^T)), 
               ! saved in OBS_HPHT of obsSpaceData

               call obs_bodySet_r(obsSpaceData,OBS_HPHT,bodyIndex,obs_col(iobslev))
            case(2)
            
               !   Store Hdx in OBS_WORK of obsSpaceData
               
               call obs_bodySet_r(obsSpaceData,OBS_WORK,bodyIndex,obs_col(iobslev))
            end select

         enddo BODY2

      end if

      ! Deallocate profile data
      deallocate(process_obs,success,ixtr,iass,obs_col)
      call chm_obsoper_dealloc(obsoper)
  
    enddo HEADER

    deallocate(obsoper%trial,obsoper%pp,obsoper%tt,obsoper%dtransform)
    deallocate(obsoper%gz,obsoper%vmodpress,obsoper%vweights,obsoper%hu)
    if (kmode.ne.0) deallocate(model_col)
   
    if (present(jobs)) jobs=0.5d0*jobs

    ! Close chm_warnings_file
    close(unit)
    
  end subroutine chm_observation_operators

! -------------------------------------------------------------------------------------------

  subroutine chm_obsoper_init(obsoper,obsSpaceData,headerIndex,column_bkgrnd,nmodlev,nobslev,kmode)
!
! Author: M. Sitwell and Y. Rochon, April 2016
!
! Purpose: Initializes struct_chm_obsoperators variables and allocates arrays.
!
! Input
!
!     column_bkgrnd   Column of x_background interpolated to observation location. Can
!                     have the same vertical levels as the trial field (columnhr) or
!                     as the increment field (columng)
!     obsSpaceData    Obs database struture
!     headerIndex     Measurement index in obsSpaceData (see main)
!     bodyIndex       Measurement element index in obsSpaceDate (see chm_obsoper_proceed)
!     kmode           0 for non-linear/linear model in assimilation (all models included are currently linear)
!                     1 for determination of sqrt(diag(H*B*H^T))
!                     2 for tangent linear model
!                     3 for adjoint model 
!     nobslev         Number of obs elements (see chm_obsoper_proceed)
!     nmodlev         Number of background field (model) levels
!     varType         Vertical coordinate type ='TH'
!
! InOut
!
!     obsoper        Structure for constituents associated to obs (see struct_chm_obsoperators in chem_mod.ftn90)
!
! Comments: 
!
!          - Allocation of arrays that are only dependent on nlev_bkgrd (nmodlev) have been moved
!            outside this subroutine so that they are only allocated once.
! 
! ---------------------------------------------------------------------------------------

    use chem_mod
    use obsSpaceData_mod
    use columnData_mod
    use earthconstants_mod
    use bmatrixchem        ! for access to bchm_getsigma

    implicit none

    integer, intent(in) :: headerIndex,nmodlev,nobslev,kmode
    type(struct_chm_obsoperators), intent(inout) :: obsoper
    type(struct_obs), intent(inout) :: obsSpaceData
    type(struct_columnData), intent(inout) :: column_bkgrnd

    integer :: bodyIndex,jl,nmodlev_uv
    real(8), pointer :: col_ptr_gzb(:)
    real(8), allocatable :: uu(:),vv(:)
    character(len=2), parameter :: varType = 'TH'

    obsoper%nmodlev = nmodlev
    obsoper%nobslev = nobslev
    obsoper%obs_index = headerIndex

    ! Get obs space info that are part of the profile header
    obsoper%stnid = obs_elem_c(obsSpaceData,'STID',headerIndex)
    obsoper%date  = obs_headElem_i(obsSpaceData,OBS_DAT,headerIndex)
    obsoper%hhmm  = obs_headElem_i(obsSpaceData,OBS_ETM,headerIndex)
    ! Constituent identifyer following local version of WMO GRIB Table 08046 (similar to BUFR Table 08043)
    obsoper%constituent_id = obs_headElem_i(obsSpaceData,OBS_CHM,headerIndex)
    if (obsoper%constituent_id.gt.chm_constituents_size.and.obsoper%constituent_id.lt.7000) then
        ! chm_constituents_size <7000 as values >=7000 restricted to NWP fields.
        write(*,*) 'chm_obsoper_init: chm_constituents_size less than ',obsoper%constituent_id,' for STNID ',obsoper%stnid
        write(*,*) 'chm_obsoper_init: may need to increae chm_constituents_size in chem_mod.ftn90'
        write(*,*) 'chm_obsoper_init: or edit BURP file values for Table 08046 element.'
        call abort3d('aborting in chm_obsoper_init')                  
    end if

    obsoper%lat = obs_headElem_r(obsSpaceData,OBS_LAT,headerIndex) 
    obsoper%lon = obs_headElem_r(obsSpaceData,OBS_LON,headerIndex) 

    ! Body info that we only need for first point in the profile
    bodyIndex       = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex) 
    ! Index of vertical coordinate type    
    obsoper%vco     = obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex)  
    ! Model field name (NOMVAR value)
    obsoper%varName = vnl_varnameFromVarnum(obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex), obsoper%constituent_id)
    
    ! varno is expected to be the same for all profile points where OBS_VNM value .ne. 8090
    do jl=0,obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)-1
       if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex+jl).ne.8090) then
          obsoper%varno = obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex)
          exit
       end if
    end do

    ! Allocate arrays

    allocate(obsoper%obslev(nobslev))       ! Reference vertical levels
    allocate(obsoper%vlayertop(nobslev))    ! Layer tops for layer measurements
    allocate(obsoper%vlayerbottom(nobslev)) ! Layer bottoms for layer measurements
    allocate(obsoper%lvl_top(nobslev))      ! Index of highest model level (lowest index) involved with obs element
    allocate(obsoper%lvl_bot(nobslev))      ! Index of lowest model level (highest index) involved with obs element

    allocate(obsoper%zh(nobslev,nmodlev))   ! Local model operator H (excluding conversion constants and horizontal interpolation)
    allocate(obsoper%zhp(nobslev,nmodlev))  ! Part of zh that excludes aspects related to vertical resolition

    obsoper%vweights(:,:)=0.0D0            
    obsoper%zh(:,:)=0.0D0
    obsoper%zhp(:,:)=0.0D0
    obsoper%lvl_top(:)=1
    obsoper%lvl_bot(:)=nmodlev
    obsoper%dtransform(:)=1.0D0

    if (.not.col_varExist('TT')) then
       if (chm_required_field('TT',obsoper%varno)) then
          write(*,*) "chm_observation_operators: TT required for BUFR code ",obsoper%varno 
          call abort3d("chm_observation_operators")
       end if
    end if

    ! Get background profiles at observation location
    do jl=1,nmodlev
       obsoper%pp(jl) = col_getPressure(column_bkgrnd,jl,headerIndex,varType)
       obsoper%trial(jl) = col_getElem(column_bkgrnd,jl,headerIndex,obsoper%varName)
       obsoper%tt(jl) = col_getElem(column_bkgrnd,jl,headerIndex,'TT')
    enddo

    if (col_varExist('TT').and.col_varExist('HU').and.col_varExist('P0')) then     
       ! GZ would have been generated in the call to sugomobs. 
       ! Convert from geopotential to geopotential height.
       col_ptr_gzb => col_getColumn(column_bkgrnd,headerIndex,'GZ','TH')
       obsoper%gz(1:nmodlev) = col_ptr_gzb(1:nmodlev)/RG
    else
       obsoper%gz(:) = -1.
    end if

    ! Get specific humidity if available
    if (col_varExist('HU')) then
       do jl=1,nmodlev
          obsoper%hu(jl) = exp(col_getElem(column_bkgrnd,jl,headerIndex,'HU')) ! Convert from LQ to Q (lnq to q)
       enddo
    else
       obsoper%hu(:)=-1
    end if
    
    ! If applicable, get column upper boundaries for use with total column measurements when the related increment profile
    ! is to be restricted to the lower atmosphere (e.g. troposphere or PBL; when m_config%tropo_bound(:)>0 - see chem_mod.ftn90)
    if (obsoper%vco.eq.4.and.nobslev.eq.1.and.kmode.ne.1) then
       if (kmode.eq.0) then
          
          if (col_varExist('HU')) then
             if (col_varExist('UU').and.col_varExist('VV')) then
                nmodlev_uv=col_getNumLev(column_bkgrnd,'MM')
                allocate(uu(nmodlev_uv),vv(nmodlev_uv))
                do jl=1,nmodlev_uv
                   uu(jl) = col_getElem(column_bkgrnd,jl,headerIndex,'UU')
                   vv(jl) = col_getElem(column_bkgrnd,jl,headerIndex,'VV')
                enddo
                obsoper%column_bound = chm_get_col_boundary(obsoper%constituent_id,nmodlev,obsoper%pp,obsoper%tt,obsoper%gz,hu=obsoper%hu,uu=uu,vv=vv)
                deallocate(uu,vv)
             else 
                obsoper%column_bound = chm_get_col_boundary(obsoper%constituent_id,nmodlev,obsoper%pp,obsoper%tt,obsoper%gz,hu=obsoper%hu)   
             end if

          else
              obsoper%column_bound = chm_get_col_boundary(obsoper%constituent_id,nmodlev,obsoper%pp,obsoper%tt,obsoper%gz)
          end if

          call chm_add_col_boundary(headerIndex,obsoper%column_bound)  ! save boundary for kmode>0 calls using headerIndex

       else
          obsoper%column_bound = chm_retrieve_col_boundary(headerIndex)
       end if
    else
       obsoper%column_bound = -1.
    end if

  end subroutine chm_obsoper_init

! -------------------------------------------------------------------------------------------

  subroutine chm_obsoper_dealloc(obsoper)
!
! Author: M. Sitwell, April 2016
!
! Purpose: Deallocate arrays for struct_chm_obsoperators.
!
! Comments: Deallocation of arrays that are only dependent on nmodlev have been moved
!           outside this subroutine so that they are only deallocated once.
!
! ---------------------------------------------------------------------------------------

    use chem_mod

    implicit none

    type(struct_chm_obsoperators), intent(inout) :: obsoper

    if (allocated(obsoper%obslev))       deallocate(obsoper%obslev)
    if (allocated(obsoper%vlayertop))    deallocate(obsoper%vlayertop)
    if (allocated(obsoper%vlayerbottom)) deallocate(obsoper%vlayerbottom)
    if (allocated(obsoper%zh))           deallocate(obsoper%zh)
    if (allocated(obsoper%zhp))          deallocate(obsoper%zhp)
    if (allocated(obsoper%lvl_top))      deallocate(obsoper%lvl_top)
    if (allocated(obsoper%lvl_bot))      deallocate(obsoper%lvl_bot)

  end subroutine chm_obsoper_dealloc

!-----------------------------------------------------------------------------------

  subroutine chm_get_comboIdlist(obsSpaceData,stnid_list,varno_list,unilev_list,num_elements,nset)
! 
! Author: M. Sitwell (ARQI/AQRD), Sept 2015
!         - Made as a separate subroutine from earlier code by
!           Y. Rochon and M. Sitwell 
!
! Revisions:
!
! Purpose: Uses the subroutine chm_comboIdlist in chem_mod to compile a unique list of stnid,  
!          (stnid,varno) or (stnid,varno,multi/uni-level) combinations to be used in searches.
!
! Input
!
!   obsSpaceData    Observation space data
!
! Output
!
!   stnid_list       List of unique stnids
!   varno_list       List of unique varno
!   unilev_list      List of unique uni/multi-level identifications
!   num_elements     Number of unique elements in *_list arrrays
!   nset             Integer indicating grouping, with values indicating
!                      1: group by stnid
!                      2: group by (stnid,bufr)
!                      3: group by (stnid,bufr,multi/uni-level)
!
!-----------------------------------------------------------------------------------

    use chem_mod
    use obsSpaceData_mod

    implicit none

    type(struct_obs), intent(inout) :: obsSpaceData

    integer, parameter :: nmax=100
    integer, intent(out) :: num_elements,nset,varno_list(nmax)
    character(len=9), intent(out) :: stnid_list(nmax)
    logical, intent(out) :: unilev_list(nmax)

    integer :: headerIndex,bodyIndex,vco,nlev_obs,varno
    logical :: all_combos


    call chm_comboIdlist(all_combos=all_combos)
    
    if (all_combos) then
    
       ! Loop over obs to find all (stnid,varno) pairs to form a common sequence of search pairs
       ! over all processors. The prescribed starting stnid selections can have wild card 
       ! characters (via *, see routine chm_comboIdlist).

       call obs_set_current_header_list(obsSpaceData,'CH')
       HEADER: do
          headerIndex = obs_getHeaderIndex(obsSpaceData)
          if (headerIndex < 0) exit HEADER
         
          ! Body info that we only need for first point in the profile
          bodyIndex = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)     
          vco = obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex)

          if (vco.ne.1 .and. vco.ne.2 .and. vco.ne.4 .and. vco.ne.5) then
             ! Vertical coordinate not handled
             write(*,*) 'chm_get_comboIdlist: Currently unaccounted VCO = ',vco
             cycle HEADER
          end if
          
          ! Identify varno and nlev_obs (exclude 8090 elements)
          nlev_obs = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)
          call obs_set_current_body_list(obsSpaceData,headerIndex)
          do
             bodyIndex = obs_getBodyIndex(obsSpaceData)
             if (bodyIndex < 0) exit
             if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).eq.8090) then
                nlev_obs = nlev_obs-1
             else
                varno=obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex)
             end if
          end do

          ! Adds to running list of unique pairs if unique
          call chm_comboIdlist(stnid_add=obs_elem_c(obsSpaceData,'STID',headerIndex), varno_add=varno, unilev_add=(nlev_obs.eq.1.and.vco.ge.4))
                       
       end do HEADER
       
       ! Get a common sequence of search pairs over all processors. 
       
       call chm_comboIdlist(gather_mpi=.true.)
       
    end if
    
    ! Get list of unique pairs
    call chm_comboIdlist(stnid_list=stnid_list, varno_list=varno_list, unilev_list=unilev_list, num_elements=num_elements, nset=nset)

  end subroutine chm_get_comboIdlist

!-----------------------------------------------------------------------------------

  subroutine chm_calc_OmA_nonassim(columng,obsSpaceData)
!
! Author: M. Sitwell Sept 2015
!
! Revisions:
!
! Purpose: Calculates the OmA for non-assimilated as identified by chm_lcheck_skipassim.
!          The non-assimilated observations where the OmA is to be calculated is
!          identified by an OBS_ASS value of 3, which is set in the subroutine
!          chm_observation_operators.
!
! InOut
!
!   columng          Background field interpolated to observation locations 
!   obsSpaceData     Observation space data
!
!-----------------------------------------------------------------------------------

    use obsSpaceData_mod
    use controlVector_mod
    use columnData_mod
    use gridStateVector_mod

    implicit none

    type(struct_columnData), intent(inout) :: columng
    type(struct_obs), intent(inout) :: obsSpaceData

    type(struct_gsv) :: statevector
    type(struct_columnData) :: column
    integer :: bodyIndex,iass,headerIndex,ierr
    logical :: calc_OmA,calc_OmA_global

    calc_OmA = .false.
    
    ! Temporarily switch OBS_ASS values of 1 with 4 and 3 with 1
    call obs_set_current_body_list(obsSpaceData,'CH')
    BODY1: DO
       bodyIndex = obs_getBodyIndex(obsSpaceData)
       if (bodyIndex < 0) exit BODY1
       iass = obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex)
       if (iass.eq.1) then
          call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,4)
       else if (iass.eq.3) then
          call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,1)
          calc_OmA = .true.
       end if
    end DO BODY1
    
    call rpn_comm_allreduce(calc_OmA,calc_OmA_global,1,"MPI_LOGICAL","MPI_LOR","GRID",ierr)

    if (calc_OmA_global) then
       
       ! Initialize columnData object for increment
       call col_setVco(column,col_getVco(columng))
       call col_allocate(column,col_getNumCol(columng),mpi_local=.true.)
       call col_copyLatLon(columng,column)
       
       ! Get the increment from the control vector
       call chm_get_increment(columng,statevector)
      
       ! Put H_horiz dx in column 
       call chm_horizontal_interp(statevector,column,columng,obsSpaceData) 
       
       ! Call tangent linear operator (kmode=2) and save Hdx in OBS_WORK
       call chm_observation_operators(columng,obsSpaceData,kmode=2,column_inc=column) 
       
       ! Calculate OBS_OMA from OBS_WORK (from oda_res)
       call obs_set_current_body_list(obsSpaceData,'CH')
       BODY2: DO
          bodyIndex = obs_getBodyIndex(obsSpaceData)
          if (bodyIndex < 0) exit BODY2
          if (obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex).eq.1) then
             call  obs_bodySet_r(obsSpaceData,OBS_OMA,bodyIndex, &
                  obs_bodyElem_r(obsSpaceData,OBS_OMP,bodyIndex) &
                 -obs_bodyElem_r(obsSpaceData,OBS_WORK,bodyIndex) )
          endif
       enddo BODY2

    end if
       
    ! Switch OBS_ASS values back from 4 to 1 and 1 to 0
    call obs_set_current_body_list(obsSpaceData,'CH')
    BODY3: DO
       bodyIndex = obs_getBodyIndex(obsSpaceData)
       if (bodyIndex < 0) exit BODY3
       iass = obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex)
       if (iass.eq.4) then
          call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,1)
       else if (iass.eq.1) then
          call obs_bodySet_i(obsSpaceData,OBS_ASS,bodyIndex,0)
       end if
    end DO BODY3

  end subroutine chm_calc_OmA_nonassim

!-----------------------------------------------------------------------------------

  subroutine chm_get_increment(columng,statevector)
!
! Author: M. Sitwell Sept 2015
!
! Purpose: Returns the analysis increment from the control vector via B^(1/2). The
!          call to apply B^1/2 is taken from the subroutine bmat_sqrtB.
!
! Input
!
!   columng          background field at observation locations (with same vertical
!                    levels as the increment)
!
! Output
!
!   statevector      the analysis increment
!
! Comment:
!
! 1) Ensemble-based part commented out. To be completed later
!
!-----------------------------------------------------------------------------------

    use controlVector_mod
    use gridStateVector_mod
    use verticalCoord_mod
    use HorizontalCoord_mod
    use columnData_mod
    use timeCoord_mod
    use bMatrixChem

    implicit none

    type(struct_columnData), intent(inout) :: columng
    type(struct_gsv), intent(inout) :: statevector
    type(struct_gsv)  :: statevector_temp

    type(struct_hco), pointer :: hco_anl
    type(struct_vco), pointer :: vco_anl
    real(8), pointer :: cvBchm(:),cvbChmEns(:)

    ! Static covariance matrix component

    ! Initialize the statevector
    
    hco_anl => hco_Get('Analysis')
    vco_anl => col_getVco(columng)

    call gsv_setVco(statevector,vco_anl)
    call gsv_setHco(statevector,hco_anl)
    call gsv_allocate(statevector,tim_nstepobsinc,mpi_local=.true.)
    call gsv_zero(statevector) 
    
    ! Apply B^(1/2) to control vector
        
    if ( statevector % hco % global ) then
        cvBchm => cvm_getSubVector(cvm_vazx,3) ! Differs for global static covariances
    else 
        cvBchm => cvm_getSubVector(cvm_vazx,1)
    end if
    if ( associated(cvBchm) ) then
      if ( statevector % hco % global ) then
        ! Global mode
        call bchm_bsqrt( cvBchm,      & ! IN
                        statevector )   ! OUT
      else
        ! LAM mode
        !call lbhi_bSqrt( cvBchm,      & ! IN
        !                 statevector )  ! OUT
      end if
      
      ! Copy 3D increment to other timesteps to create 4D increment
      call gsv_3dto4d(statevector)
    end if
    
    !Ensemble-based covariance matrix component
    
    !  cvBChmEns => cvm_getSubVector(cvm_vazx,2)
    !! OR cvBChmEns => cvm_getSubVector(cvm_vazx,4) depending on controlvector_mod.ftn90
    !if ( associated(cvBChmEns) ) then

    !!  Initialize the statevector_temp

    !   call gsv_setVco(statevector_temp,vco_anl)
    !   call gsv_setHco(statevector_temp,hco_anl)
    !   call gsv_allocate(statevector_temp,tim_nstepobsinc,mpi_local=.true.)
    !   call gsv_zero(statevector_temp) 
    !
    !   call bEn_bsqrt(cvBChmEns, statevector_temp)
    !
    !!  Add the two contributions together, result in statevector
    !   call gsv_add(statevector_temp,statevector)
    !
    !   call gsv_deallocate(statevector_temp)
    !end if

  end subroutine chm_get_increment

!-----------------------------------------------------------------------------------

  subroutine chm_horizontal_interp(statevector,column,columng,lobsSpaceData)
!
! Author: M. Sitwell Sept 2015
!
! Purpose: Performs horizontal interpolation of background field to observation
!          locations. Code adapted from subroutine oda_L
!
! Input
!
!   statevector      the analysis increment
!   lobsSpaceData    observation space data
!
! Output
!
!   column           increment at observation locations
!   columng          background field at observation locations (with same vertical
!                    levels as the increment)
!
!-----------------------------------------------------------------------------------

    use MathPhysConstants_mod
    use mpivar_mod 
    use gridstatevector_mod
    use obsSpaceData_mod
    use columnData_mod
    use timeCoord_mod
    use varNameList_mod

    implicit none

    type(struct_columnData) :: column, columng
    type(struct_obs)        :: lobsSpaceData
    type(struct_gsv)        :: statevector
    
    integer :: nl_ilev, ierr, myLonEndP1, myLatEndP1, status, Vcode_anl

    ! Additional variables for section 1.2  
    character(len=2) :: varType
    character(len=4) :: varName
    integer :: jvar

    myLonEndP1 = statevector%myLonEnd + 1
    myLatEndP1 = min(statevector%myLatEnd + 1, statevector%nj)

    !- 1.1 Communicate extra latitude needed for interpolation  
    call rpn_comm_barrier("GRID",ierr)
    if (mpi_nprocs /= 1) call gsv_commLatLon(statevector)

    !- 1.2 Horizontal interpolation of field

!$OMP PARALLEL
!$OMP DO PRIVATE(jvar,varName,varType,nl_ilev) 

    do jvar = 1, vnl_numvarmax
      if(gsv_varExist(vnl_varNameList(jvar))) then
         if (vnl_varKindFromVarname(vnl_varNameList(jvar)).ne.'CH') cycle
         varName = trim(vnl_varNameList(jvar))
         varType = vnl_vartypeFromVarname(varName)
         nl_ilev = col_getNumLev(column,varType)
         call gd2mvo(varName,nl_ilev)
      end if
    end do
  
!$OMP END DO
!$OMP END PARALLEL
 
    contains

    ! The following is a local copy of routine 'gd2mvo' found in file 'oda_L.ftn90'.
      
    subroutine gd2mvo(varName,klev)
      
      implicit none
    
      character(len=*), intent(in) :: varName
      integer,          intent(in) :: klev
      
      INTEGER :: JLEV, JLAT, JLON, headerIndex, JSTEP
      INTEGER :: ILON, ILAT, ILO
    
      REAL(8) :: DLMEAN, DLMEAS, DLDLON
      REAL(8) :: DLDX, DLDY, DLDX_new, DLDY_new,DLW1, DLW2, DLW3, DLW4
      real(8) :: xpos, ypos, lat, lon, latrot, lonrot
    
      real(8), pointer :: column_ptr(:,:)
      real(8), pointer :: field_ptr(:,:,:,:)

      field_ptr  => gsv_getField(statevector,varName)

      if (col_getNumCol(column) > 0) then
         column_ptr => col_getAllColumns(column,varName)
         column_ptr(:,:) = 0.0d0
      end if

      ! Note: We assume here the all the obs between the poles and the last grid points
      !       (i.e. outside the grid) have been moved within the grid by sugomobs

      do jstep = 1, statevector%numStep
         !
         !- LOOP OVER ALL THE OBSERVATIONS
         !
         DO headerIndex = 1, col_getNumCol(column)

            if ( tim_getTimeInterpWeight(headerIndex,jstep) > 0.0d0 .and. &
                 .not. btest(obs_headElem_i(lobsSpaceData,OBS_ST1,headerIndex),5) ) then

               !- 2.1 Find the obs position within the analysis grid
               call col_getLatLon( column, headerIndex,                 & ! IN
                                   Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT

               !- Make sure we are within bounds
               if ( ypos < real(statevector%myLatBeg,8) .or. &
                    ypos > real(myLatEndP1          ,8) .or. &
                    xpos < real(statevector%myLonBeg,8) .or. &
                    xpos > real(myLonEndP1          ,8) ) then
                 
                  write(*,*) 'gd2mvo: Obs outside local domain for headerIndex = ', headerIndex,' ',varName                  
                  write(*,*) '        obs lat, lon position               = ', Lat*MPC_DEGREES_PER_RADIAN_R8, Lon*MPC_DEGREES_PER_RADIAN_R8
                  write(*,*) '        obs x, y     position               = ', xpos, ypos
                  write(*,*) '        domain x_start, x_end, y_start, y_end bounds = ',  &
                       statevector%myLonBeg, myLonEndP1, statevector%myLatBeg, myLatEndP1

                  ! if obs above or below latitude band, move it to the edge of this latitude band
                  if( ypos < real(statevector%myLatBeg,8) ) ypos = real(statevector%myLatBeg,8)
                  if( ypos > real(myLatEndP1          ,8) ) ypos = real(myLatEndP1          ,8)

                  ! if obs left or right longitude band, move it to the edge of this longitude band
                  if( xpos < real(statevector%myLonBeg,8) ) xpos = real(statevector%myLonBeg,8)
                  if( xpos > real(myLonEndP1          ,8) ) xpos = real(myLonEndP1          ,8)
                  write(*,*) ' new   obs x, y     position               = ', xpos, ypos
               end if

               !- 2.2 Find the lower-left grid point next to the observation
               if ( xpos /= real(myLonEndP1,8) ) then
                  ILON = floor(xpos)
               else
                  ILON = floor(xpos) - 1
               end if

               if ( ypos /= real(myLatEndP1,8) ) then
                  ILAT = floor(ypos)
               else
                  ILAT = floor(ypos) - 1
               end if

               !- 2.3 Compute the 4 weights of the bilinear interpolation
               DLDX = xpos - real(ILON,8)
               DLDY = ypos - real(ILAT,8)

               DLW1 = (1.d0-DLDX) * (1.d0-DLDY)
               DLW2 =       DLDX  * (1.d0-DLDY)
               DLW3 = (1.d0-DLDX) *       DLDY
               DLW4 =       DLDX  *       DLDY

               !- 2.4 Interpolate the model state to the obs point
               DO JLEV = 1, KLEV
                  column_ptr(JLEV,headerIndex) = column_ptr(JLEV,headerIndex)  +  &
                                    tim_getTimeInterpWeight(headerIndex,jstep) *  &
                                     ( DLW1 * field_ptr(ILON  ,JLEV,ILAT  ,JSTEP) &
                                     + DLW2 * field_ptr(ILON+1,JLEV,ILAT  ,JSTEP) &
                                     + DLW3 * field_ptr(ILON  ,JLEV,ILAT+1,JSTEP) &
                                     + DLW4 * field_ptr(ILON+1,JLEV,ILAT+1,JSTEP) )
               END DO

            end if

         END DO ! Obs

      END DO ! JSTEP

    end subroutine gd2mvo
    
  end subroutine chm_horizontal_interp

!-----------------------------------------------------------------------------------

  subroutine chm_transform_final_increments(increment,background)
!
! Author: M. Sitwell Sept 2015
!         - Originally as chm_check_negative
!
! Revisions:
!            Y. Rochon, Nov 2015
!            - Added upper bound.
!            - Modified from chm_check_negative to chm_transform_final_inscrements.
!            - Use of col_varExist
!
! Purpose: Apply any required adjustments and/or transformations to increments
!          prior to saving in rebm file.
!
!          Possible adjustments/transformations:
!
!          - Convert to dx when the analysis increments are in a different form (e.g. dlnx).
!
!          - Checks for negative analysis values and if any negative values found will
!          modify the increment so that the analysis  is reset to low_cutoff*background
!          at these points. This check is done with fields of the same resolution as
!          the increment. Correspondingly impose upper limits.
!
!
! InOut
!
!   increment        statevector for the increment
!   background       statevector for the background (with same resolution as the increment)
!
!-----------------------------------------------------------------------------------

    use gridStateVector_mod
    use varNameList_mod
    use columnData_mod
    use chem_mod

    implicit none
    
    type(struct_gsv), intent(inout) :: increment,background

    real(8), pointer :: inc_ptr(:,:,:,:),bkgrnd_ptr(:,:,:,:)

    integer :: jvar
    character(len=4)  :: varName

    do jvar = 1, vnl_numvarmax
      if (gsv_varExist(vnl_varNameList(jvar))) then 
         if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then

            varName=vnl_varNameList(jvar)
            inc_ptr => gsv_getField(increment,varName)
            bkgrnd_ptr => gsv_getField(background,varName)

!           Analysis increment transformations to dx if needed.
           
            call chm_apply_transform_array4d(varName, bkgrnd_ptr, l_reverse=.true., mode=2, incr_ptr=inc_ptr)

!           Apply min and max boundaries if needed.

            call chm_apply_bounds(varName,bkgrnd_ptr,inc_ptr)
             
         end if
      end if
    end do
    
  end subroutine chm_transform_final_increments

!-----------------------------------------------------------------------------------

  logical function chm_assim()
!
! Author: M. Sitwell Sept 2015
!
! Purpose: Checks if any of the variables to be assimilated (i.e. specified in the
!          namelist NAMSTATE) are part of the CH family.
!
!-----------------------------------------------------------------------------------

    use gridStateVector_mod
    use varNameList_mod

    implicit none

    integer :: jvar

    chm_assim = .false.

    VARLIST: do jvar = 1, vnl_numvarmax
       if (gsv_varExist(vnl_varNameList(jvar))) then
          if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then
             chm_assim = .true.
             exit VARLIST 
          end if
       end if
    end do VARLIST

  end function chm_assim

end module chem_interface_mod
