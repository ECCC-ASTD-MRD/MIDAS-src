!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE SUPREP(lobsSpaceData)
#if defined (DOC)
*
*s/r SUPREP -FILTER CMA BEFORE 3D-VAR ANALYSIS
*
*Author  : P. Koclas *CMC/AES  September 1994
*Revision:
*          P. Koclas *CMC/AES  August 1995
*                    -Exclude  T-Td ABOVE 300 Mbs
*          P. Koclas *CMC/AES  April 1996
*                     -print more information on rejected elements
*                     -replace comstat by comtstato
*          C.Charette *ARMA/AES Jan 1997
*                     -remove readnml. remove default values
*                      now done in suobs.ftn
*          S. Pellerin *ARMA/AES Sept 97.
*                     -Control of the different model state of the 3Dvar
*                      through COMSTATE, COMSTATEC and COMSTNUM common
*                      blocks variables (comstate.cdk).
*          C. Charette *ARMA/AES Oct 98.
*                     -Adapt code to the fact that pressure coordinate
*                      is in Pascal instead of Millibar in the CMA
*          J. Halle    *CMDA/AES Oct 1999
*                     -processing of TOVS data
*          P. KOCLAS   *CMC/CMDA JAN 2000
*                     -PRINT REJECT DATA IN MORE DETAIL
*          C. Charette *ARMA/AES Jun 2000.
*                     -Added pointers and tables for surface elements
*          J. Halle    *CMC/CMDA Dec 2000
*                     - TOVS level 1B data.
*          JM Belanger *CMDA/SMC june 2001.
*                     - 32 bits conversion.
*          P. KOCLAS  *cmda Sept 2001 .
*                        -changes to loops that set OBS_LOBS PARAMETER
*                        -allow bogus gz data to analysis ( conf =141)
*          S. Pellerin *ARMA/SMC Nov. 2001
*                     - Comment out conflicting ikout* unit
*          C. Charette *ARMA/SMC Feb. 2002
*                     - Removed conflicting ikout* unit
*          J. Halle    *CMDA/SMC May 2002
*                     - allow T-Td observations up to 70mbs.
*                     - adapt to RTTOV-7
*          N. Wagneur  *CMDA/MSC June 2002
*                     -processing of GOES data
*          J. Halle  *CMDA/SMC april 2003
*                     -use RLIMLVHU, which is the top level of humidity analysis (mbs).
*          C. Charette - ARMA/SMC - Jun. 2003
*                - Conversion to hybrid vertical coordinate
*          JM Belanger *CMDA/SMC* Feb 2004
*                     - Introducing Quikscat surface wind vectors.
*          D. Anselmo *ARMA/SMC October 2004
*                     -set OBS_ASS to exclude assimilation of RAOBS and surface ln q
*                      added to CMA by burp_estohu.ftn
*          J. Halle  *CMDA/SMC Sept. 2005
*                     -added codtyp=182 (MHS).
*          J. Halle  *CMDA/SMC May  2006
*                     -adapt to RTTOV-8, by removing check of validity of channel.
*          A. Beaulne *CMDA/SMC July 2006
*                      -added codtyp=183 (AIRS)
*                      -added flag -8 to CREASON
*          J.M. Aparicio *ARMA/MSC* October 2006
*                      - Adapt for GPSRO
*          L. Fillion *ARMA/MSC- 4 Feb 2004 - On v9_5_0 - 24 Apr 2006 - On v10_0_0
*                     - For Limited-Area option:
*                       Put (x,y) grid-location of obs into ROBHDR for later use by gd2mvo_la
*                     - 15 Aug 2007 - Update lam4d to v_10_0_3.
*          A. Beaulne *CMDA/SMC July 2007
*                      - add possibility for one channel assimilation for tovs
*          S. Macpherson  *ARMA/MRD  Sept. 2007
*                     -added ground-based GPS data
*          R. Sarrazin CMDA April 2008
*                      - add idatyp 185
*          S. Heilliette
*                      - add idatyp 186
*          L. Fillion *ARMA/EC- 24 Apr 2008 - Update lam4d to v_10_1_0.
*          L. Fillion *ARMA/EC- 24 Jan 2009 - Update lam4d to v_10_2_1.
*          P. Koclas *CMDA/     Jan 2009
*           remove  search for element 15036 in case of gps data(element
*           must now be specified in namelist like all other elements)
*          L. Fillion *ARMA/EC- 7 Oct 2009 - Include Rotated global Gaussian grid option.
*          L. Fillion *ARMA/EC- 4 May 2010 - Update on v_11_01_2B.
*	   M. Buehner and S. Heilliette - Mar 2012 - Replace uninitialized idatyp with idburp
*          S. Macpherson - Feb 2013 - add idatyp 192 (ATMS)
*          S. Heilliette - Feb 2013 - add idatyp 193 (CrIS)
*          S. Macpherson  ARMA  - Apr 2013 - Remove #include comtovst.cdk, partov.cdk
*
*
**    Purpose:
*             -Select the data in the CMA file which is to be assimilated
*              by the 3D-var.
*
#endif

      use MathPhysConstants_mod
      use gaussGrid_mod
      use obsSpaceData_mod
      use bufr
      use tovs_mod ,only :  tvs_Is_idburp_tovs
      IMPLICIT NONE
*implicits
*
#include "comct0.cdk"
#include "comfilt.cdk"
#include "comgpsgb.cdk"
C
C  .......  DEFINITION OF A FEW BUFR ELEMENTS ..........................
C ....
C           NAME                          BUFR CODE
C           HEIGHT                         0 10 194
C           TEMPERATURE                    0 12 001
C           TEMPERATURE  AT 2M             0 12 004
C           T - TD                         0 12 192
C           T - TD AT 2M                   0 12 203
C           WIND DIRECTION                 0 11 001
C           WIND SPEED                     0 11 002
C           U-COMPONENT                    0 11 003
C           V-COMPONENT                    0 11 004
C           WIND DIRECTION AT 10M          0 11 011
C           WIND SPEED     AT 10M          0 11 012
C           U-COMPONENT    AT 10M          0 11 215
C           V-COMPONENT    AT 10M          0 11 216
C           PRESSURE                       0 07 004
C           MSL PRESSURE                   0 10 051
C           STATION PRESSURE               0 10 004
C           BRIGHTNESS TEMPERATURE         0 12 062
C           BRIGHTNESS TEMPERATURE         0 12 063
C           BRIGHTNESS TEMPERATURE         0 12 163
C           GPS ZENITH TROPOSPHERIC DELAY  0 15 031
C           GPS ZTD ERROR                  0 15 032
C
C  ........ Quality control flags bit definitions (see ADE BANCO
C document)
C           BIT #
C                1  'RESERVED    '
C                2  'RESERVED    '
C                3  'GENERATED OI'
C                4  'REJECTION OI'
C                5  'BLACK LIST  '
C                6  'RESERVED    '
C                7  'RESERVED    '
C                8  'INTERPOL  EL'
C                9  'DOUBTFUL  EL'
C               10  'MODIFIED  EL'
C               11  'CLIMAT  XTRM'
C               12  'ERRONEOUS EL'
C               13  'RESERVED    '
C
      type(struct_obs) :: lobsSpaceData
      INTEGER, parameter :: numFamily = 9
      CHARACTER(len=2), parameter :: listFamily(numFamily) = (/'UA','AI','SF','SW','PR','RO','GP','SC','TO'/)
      REAL*8 ZLAT, GPH
      CHARACTER*35 CREASON(-8:13)
      CHARACTER*80 CELLIST,CSFLIST
      INTEGER INDEX_HEADER,index_family,IVCO
      INTEGER IPRES,IPRESMB
      INTEGER JD,INDEX_BODY,JK
      INTEGER IJ,IDBURP,ITYP,IFLG,IBIT,IBAD,IKNT(numFamily)
      INTEGER IDATA,IDATEND
      INTEGER ILANSEA,IPROCES,INDXREG,INDXCLD,INDXM
      integer index,ibin(17,numFamily),IBINS(numFamily),isum,INIV(17)
      LOGICAL LLOK,LLDIAG,LLREJ,LLBOGUS
      INTEGER ISRCHEQ
      EXTERNAL ISRCHEQ
C
      INTEGER IKNTDSA,IKNTFSA,IKNTUSA,IKNTVSA,IKNTTSA,IKNTESSA,IKNTPSA
     &     ,IKNTPNA,IKNTZDA
      INTEGER IKNTDSR,IKNTFSR,IKNTUSR,IKNTVSR,IKNTTSR,IKNTESSR,IKNTPSR
     &     ,IKNTPNR,IKNTZDR
      INTEGER IKNTFFR(17),IKNTDDR(17),IKNTUR(17),IKNTVR(17),IKNTZR(17)
     &     ,IKNTTR(17),IKNTER(17),IKNTDR(17),IKNTOR(17),IKNTBTR(17)
      INTEGER IKNTFFA(17),IKNTDDA(17),IKNTUA(17),IKNTVA(17),IKNTZA(17)
     &     ,IKNTTA(17),IKNTEA(17),IKNTDA(17),IKNTOA(17),IKNTBTA(17)
      DATA INIV/1000,925,850,700,500,400,300,250,200,150,100,070,050,
     &     030,020,010,000/
      DATA CREASON/'JACOBIAN IMPORTANT ABOVE MODEL TOP','ABS OROGRAPH-PHI ','MASQUE TERRE-MER '
     &     ,'OROGRAPHIE       ','REJECTED BY QCVAR     '
     &     ,'REJECTED BY BACKGROUND GCHECK '
     &     ,'BACKGROUND CHECK  LEVEL 3 ','BACKGROUND CHECK  LEVEL 2 '
     &     ,'BACKGROUND GHECK  LEVEL 1 ','RESERVED    '
     &     ,'REJECTED BY SELECTION PROCESS ','GENERATED BY OI  '
     &     ,'REJECTION BY  OI','ELEMENT ON BLACK LIST  ','RESERVED    '
     &     ,'CORRECTED ELEMENT','INTERPOLATED ELEMENT'
     &     ,'DOUBTFUL ELEMENT','POSSIBLY ERRONEOUS ELEMENT '
     &     ,'ERRONEOUS ELEMENT','ELEMENT EXCEEDS CLIMATE EXTREME'
     &     ,'ELEMENT MODIFIED OR GEN BY  ADE'/
!-----------------------------------------------------------------------
!
      WRITE(*,'(1X,"SUBROUTINE SUPREP")')
      WRITE(*,'(1X,"-----------------",/)')
      WRITE(*,'(1X,"***********************************")')
      WRITE(*,'(1X," ELEMENTS SELECTED FOR ASSIMILATION:",/)')
      WRITE(*,'(1X,"***********************************")')
      DO JD=1,NELEMS
        WRITE(*,'(15X,I5,/)') NLIST(JD)
      ENDDO
      WRITE(*,'(1X,"***********************************")')
      WRITE(*,*) ' REJECT ELEMENTS WITH REJECT FLAG '
      WRITE(*,*)'           BIT :  '
      DO JD=1,NFLAGS
        IBIT= NLISTFLG(JD)
        WRITE(*,*) IBIT,' ',CREASON(IBIT)
      ENDDO
      WRITE(*,'(1X,"***********************************")')
C
C     2. Put observation number in each data of CMA file.
C
C     Displace observations located between poles and the last row
C     of the grid being used to the last row. (Do always now, used 
C     to not do when cvcord=MAM)
C
      DO INDEX_HEADER  = 1, obs_numheader(lobsSpaceData)
        ZLAT    = obs_headElem_r(lobsSpaceData,OBS_LAT,INDEX_HEADER)
        IF(ZLAT .GT. gaus_RLATI(1)) THEN
          call obs_headSet_r(lobsSpaceData,OBS_LAT,INDEX_HEADER, gaus_RLATI(1))
        ELSEIF(ZLAT .LT. gaus_RLATI(gaus_NJ)) THEN
          call obs_headSet_r(lobsSpaceData,OBS_LAT,INDEX_HEADER, gaus_RLATI(gaus_NJ))
        ENDIF
      ENDDO
C
      IJ=0
      DO INDEX_HEADER = 1, obs_numheader(lobsSpaceData)
        IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,INDEX_HEADER)
        IDATEND = obs_headElem_i(lobsSpaceData,OBS_NLV,INDEX_HEADER) + IDATA - 1
        DO INDEX_BODY= IDATA, IDATEND
          IJ   = IJ+1
          call obs_bodySet_i(lobsSpaceData,OBS_HIND,IJ, INDEX_HEADER)
        ENDDO
      ENDDO
C
C     3. filter data in CMA file
C     .  -----------------------
      IKNT(:)=0
      ibin(:,:)=0
      ibins(:)=0
      CELLIST
     &     ='    FF      DD      UU      VV      GZ      TT      ES      DZ      OZ  '
      CSFLIST
     &     ='    FS      DS      US     VS      TS      ES      PS      PN      ZD  '
C
!$OMP PARALLEL  
!$OMP& PRIVATE(INDEX_FAMILY,JK,index_body,INDEX_HEADER,ITYP,
!$OMP& IFLG,IPRES,IVCO,IDBURP,LLOK,LLDIAG,LLBOGUS,GPH,INDEX,IPRESMB,
!$OMP& LLREJ,JD,IBAD,
!$OMP& ILANSEA,INDXM,INDXREG,IPROCES,INDXCLD,
!$OMP& IKNTFFR,
!$OMP& IKNTDDR,
!$OMP& IKNTUR,
!$OMP& IKNTVR,
!$OMP& IKNTZR,
!$OMP& IKNTTR,
!$OMP& IKNTER,
!$OMP& IKNTDR,
!$OMP& IKNTOR,
!$OMP& IKNTBTR,
!$OMP& IKNTFFA,
!$OMP& IKNTDDA,
!$OMP& IKNTUA,
!$OMP& IKNTVA,
!$OMP& IKNTZA,
!$OMP& IKNTTA,
!$OMP& IKNTEA,
!$OMP& IKNTDA,
!$OMP& IKNTOA,
!$OMP& IKNTBTA,
!$OMP& IKNTDSA,
!$OMP& IKNTFSA,
!$OMP& IKNTUSA,
!$OMP& IKNTVSA,
!$OMP& IKNTTSA,
!$OMP& IKNTESSA,
!$OMP& IKNTPSA,
!$OMP& IKNTPNA,
!$OMP& IKNTZDA,
!$OMP& IKNTDSR,
!$OMP& IKNTFSR,
!$OMP& IKNTUSR,
!$OMP& IKNTVSR,
!$OMP& IKNTTSR,
!$OMP& IKNTESSR,
!$OMP& IKNTPSR,
!$OMP& IKNTPNR,
!$OMP& IKNTZDR)
!$OMP DO ORDERED
      FAMILY: DO INDEX_FAMILY = 1,numFamily
C
        DO JK=1,17
          IKNTFFR(JK)=0
          IKNTDDR(JK)=0
          IKNTUR(JK)=0
          IKNTVR(JK)=0
          IKNTZR(JK)=0
          IKNTTR(JK)=0
          IKNTER(JK)=0
          IKNTDR(JK)=0
          IKNTOR(JK)=0
          IKNTBTR(JK)=0
          IKNTFFA(JK)=0
          IKNTDDA(JK)=0
          IKNTUA(JK)=0
          IKNTVA(JK)=0
          IKNTZA(JK)=0
          IKNTTA(JK)=0
          IKNTEA(JK)=0
          IKNTDA(JK)=0
          IKNTOA(JK)=0
          IKNTBTA(JK)=0
        ENDDO
        IKNTDSA =0
        IKNTFSA =0
        IKNTUSA =0
        IKNTVSA =0
        IKNTTSA =0
        IKNTESSA=0
        IKNTPSA =0
        IKNTPNA =0
        IKNTZDA =0
C
        IKNTDSR =0
        IKNTFSR =0
        IKNTUSR =0
        IKNTVSR =0
        IKNTTSR =0
        IKNTESSR=0
        IKNTPSR =0
        IKNTPNR =0
        IKNTZDR =0
C
        BODY: do index_body=1,obs_numbody(lobsSpaceData)
          INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
          if(obs_getFamily(lobsSpaceData,index_header).eq.listFamily(index_family)) then
            ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
            IFLG = obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY)
            IPRES= NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
            IVCO = obs_bodyElem_i(lobsSpaceData,OBS_VCO,INDEX_BODY)
            IDBURP=obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
C
C     a. Unwanted data types via types specified in NLIST
C
            LLOK = .FALSE.
            LLBOGUS=(IDBURP .eq. 150 .or. IDBURP .eq. 151 .or. IDBURP
     &           .eq. 152 .or. IDBURP .eq. 153)
            DO JD =1,NELEMS
              LLOK=( ITYP .EQ. NLIST(JD) )  .OR. LLOK
            ENDDO
*
*pik        ALLOW GZ FOR BOGUS DATA ONLY in analysis case ( nconf 141)
*
            if  ( nconf .eq. 141 .and. llok .and. (ityp .eq. BUFR_negz) .and.
     &           .not. llbogus  ) then
              llok=.false.
            endif
C
C           For GPS Radio Occultation data (codtyp 169):
C           Allow only refractivity observations (ITYP=15036)
C
            IF ( IDBURP .EQ. 169 ) THEN
C
C     *        Only heights between 0 and 80000 m:
C
               GPH = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
               IF (GPH .LT. 0. .OR. GPH .GT. 80000.) THEN
                  LLOK = .FALSE.
               ENDIF
            ENDIF
C
C           Ground-based GPS (GP) data (codtyp 189)
C           LLOK = .TRUE. DY DEFAULT IF ELEMENT IS IN NLIST
C           Don't want to assimilate ZTD error (BUFR_NEFE).
C           If LASSMET = .FALSE. don't want to assimilate Ps (BUFR_NEPS),
C           Ts (BUFR_NETS), or (T-Td)s (BUFR_NESS)
C
            IF ( IDBURP .EQ. 189 ) THEN
               IF (ITYP .EQ. BUFR_NEFE) THEN
                  LLOK = .FALSE.
               ENDIF
               IF (.NOT.LASSMET .AND. (ITYP .EQ. BUFR_NEPS .OR.
     +              ITYP .EQ. BUFR_NETS .OR. ITYP .EQ. BUFR_NESS)) THEN
                  LLOK = .FALSE.
               ENDIF
            ENDIF
C
C        Process data reported in pressure coordinate
            IF (IVCO .EQ. 2 ) THEN
C
C     b. Exclude T-Td above level RLIMLVHU (mbs)
C
              IF ( (ITYP  .EQ. BUFR_NEES) .AND.
     &             (IPRES .LT. NINT(RLIMLVHU*100)) ) LLOK=.FALSE.
C
C     c. Bad data with quality control flags via bit list
C        specified in NLISTFLG
C
              IPRESMB=ipres/100
              if ( IPRESMB .gt. INIV(1) ) then
                index=1
              else if (  IPRESMB.le.INIV(1) .and. IPRESMB.gt.INIV(2)
     &               )then
                index=1
              else if (  IPRESMB.le.INIV(2) .and. IPRESMB.gt.INIV(3)
     &               )then
                index=2
              else if (  IPRESMB.le.INIV(3) .and. IPRESMB.gt.INIV(4)
     &               )then
                index=3
              else if (  IPRESMB.le.INIV(4) .and. IPRESMB.gt.INIV(5)
     &               )then
                index=4
              else if (  IPRESMB.le.INIV(5) .and. IPRESMB.gt.INIV(6)
     &               )then
                index=5
              else if (  IPRESMB.le.INIV(6) .and. IPRESMB.gt.INIV(7)
     &               )then
                index=6
              else if (  IPRESMB.le.INIV(7) .and. IPRESMB.gt.INIV(8)
     &               )then
                index=7
              else if (  IPRESMB.le.INIV(8) .and. IPRESMB.gt.INIV(9)
     &               )then
                index=8
              else if (  IPRESMB.le.INIV(9) .and. IPRESMB.gt.INIV(10)
     &               )then
                index=9
              else if (  IPRESMB.le.INIV(10) .and. IPRESMB.gt.INIV(11)
     &               )then
                index=10
              else if (  IPRESMB.le.INIV(11) .and. IPRESMB.gt.INIV(12)
     &               )then
                index=11
              else if (  IPRESMB.le.INIV(12) .and. IPRESMB.gt.INIV(13)
     &               )then
                index=12
              else if (  IPRESMB.le.INIV(13) .and. IPRESMB.gt.INIV(14)
     &               )then
                index=13
              else if (  IPRESMB.le.INIV(14) .and. IPRESMB.gt.INIV(15)
     &               )then
                index=14
              else if (  IPRESMB.le.INIV(15) .and. IPRESMB.gt.INIV(16)
     &               )then
                index=15
              else
                index=16
              endif
              ibin(index,index_family)=ibin(index,index_family) +1
            ENDIF
C
C      Check rejection bit in datum's FLAG
C
            LLREJ = .FALSE.
            DO JD=1,NFLAGS
              IBAD= 13-NLISTFLG(JD)
              LLREJ=( BTEST(IFLG,IBAD) ) .OR. LLREJ
            ENDDO
C
C     d. Filter TOVS data
C
            ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
            IF ( ITYP .EQ. BUFR_NBT1 .OR.
     S           ITYP .EQ. BUFR_NBT2 .OR.
     S           ITYP .EQ. BUFR_NBT3 .AND.
     S           tvs_Is_idburp_tovs(IDBURP) ) THEN
C
C        d.1 Valid channel?
C
C           ... channel validity check removed, jh may  2006 ....
C
C        d.2 Data from this satellite to be assimilated?
C
C             .....this check not done anymore, jh may 2002....
C
C        d.3 Invalid land/sea/sea-ice flag
C
              ILANSEA  = obs_headElem_i(lobsSpaceData,OBS_OFL,INDEX_HEADER)
              INDXM = ILANSEA
              IF (INDXM .EQ. 2 ) INDXM = 0
              IF (INDXM .LT. 0 .OR. INDXM .GT. 1  ) THEN
                LLOK = .FALSE.
              ENDIF
C
C        d.4 Channel not included in list of channels to
C            be assimilated
C
C             .....this check not done anymore, jh may 2002....
C
            ENDIF
C
C     f. Exclude RAOBS and surface ln q data added to CMA, but designate as diagnostic
C
            LLDIAG = .FALSE.
            IF ( ITYP  .EQ. BUFR_NEHU .or. ITYP .EQ. BUFR_NEHS ) THEN
              LLOK   = .FALSE.
              LLDIAG = ((ITYP .EQ. BUFR_NEHU)
     &            .AND. (IVCO .EQ. 2)
     &            .AND. (IPRES.GE.NINT(RLIMLVHU*100)))
     &            .OR. ((ITYP .EQ. BUFR_NEHS) .AND.
     &                  (IVCO .EQ. 1))
            ENDIF
C
C
            IF ( LLOK  .AND..NOT. LLREJ ) THEN
              IF( IVCO .EQ. 2 ) THEN
                IF( ITYP .EQ. BUFR_NEFF)  IKNTFFA(INDEX)=IKNTFFA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEDD)  IKNTDDA(INDEX)=IKNTDDA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEUU)  IKNTUA(INDEX)=IKNTUA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEVV)  IKNTVA(INDEX)=IKNTVA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEGZ)  IKNTZA(INDEX)=IKNTZA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NETT)  IKNTTA(INDEX)=IKNTTA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEES)  IKNTEA(INDEX)=IKNTEA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEDZ)  IKNTDA(INDEX)=IKNTDA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEOZ)  IKNTOA(INDEX)=IKNTOA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT1)  IKNTBTA(INDEX)=IKNTBTA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT2)  IKNTBTA(INDEX)=IKNTBTA(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT3)  IKNTBTA(INDEX)=IKNTBTA(INDEX) + 1
              ELSEIF( IVCO .EQ. 1 ) THEN
                IF( ITYP .EQ. BUFR_NEDS)  IKNTDSA=IKNTDSA + 1
                IF( ITYP .EQ. BUFR_NEFS)  IKNTFSA=IKNTFSA + 1
                IF( ITYP .EQ. BUFR_NEUS)  IKNTUSA=IKNTUSA + 1
                IF( ITYP .EQ. BUFR_NEVS)  IKNTVSA=IKNTVSA + 1
                IF( ITYP .EQ. BUFR_NETS)  IKNTTSA=IKNTTSA + 1
                IF( ITYP .EQ. BUFR_NESS) IKNTESSA=IKNTESSA + 1
                IF( ITYP .EQ. BUFR_NEPS)  IKNTPSA=IKNTPSA + 1
                IF( ITYP .EQ. BUFR_NEPN)  IKNTPNA=IKNTPNA + 1
                IF( ITYP .EQ. BUFR_NEZD)  IKNTZDA=IKNTZDA + 1
                IBINS(index_family) = IBINS(index_family) + 1
              ENDIF
            ELSE IF ( LLOK .AND.  LLREJ ) THEN
              IF( IVCO .EQ. 2 ) THEN
                IF( ITYP .EQ. BUFR_NEFF)  IKNTFFR(INDEX)=IKNTFFR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEDD)  IKNTDDR(INDEX)=IKNTDDR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEUU)  IKNTUR(INDEX)=IKNTUR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEVV)  IKNTVR(INDEX)=IKNTVR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEGZ)  IKNTZR(INDEX)=IKNTZR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NETT)  IKNTTR(INDEX)=IKNTTR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEES)  IKNTER(INDEX)=IKNTER(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEDZ)  IKNTDR(INDEX)=IKNTDR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NEOZ)  IKNTOR(INDEX)=IKNTOR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT1)  IKNTBTR(INDEX)=IKNTBTR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT2)  IKNTBTR(INDEX)=IKNTBTR(INDEX) + 1
                IF( ITYP .EQ. BUFR_NBT3)  IKNTBTR(INDEX)=IKNTBTR(INDEX) + 1
              ELSEIF( IVCO .EQ. 1 ) THEN
                IF( ITYP .EQ. BUFR_NEDS)  IKNTDSR=IKNTDSR + 1
                IF( ITYP .EQ. BUFR_NEFS)  IKNTFSR=IKNTFSR + 1
                IF( ITYP .EQ. BUFR_NEUS)  IKNTUSR=IKNTUSR + 1
                IF( ITYP .EQ. BUFR_NEVS)  IKNTVSR=IKNTVSR + 1
                IF( ITYP .EQ. BUFR_NETS)  IKNTTSR=IKNTTSR + 1
                IF( ITYP .EQ. BUFR_NESS) IKNTESSR=IKNTESSR + 1
                IF( ITYP .EQ. BUFR_NEPS)  IKNTPSR=IKNTPSR + 1
                IF( ITYP .EQ. BUFR_NEPN)  IKNTPNR=IKNTPNR + 1
                IF( ITYP .EQ. BUFR_NEZD)  IKNTZDR=IKNTZDR + 1
                IBINS(index_family) = IBINS(index_family) + 1
              ENDIF
            ENDIF
C
            IF (LLOK .AND. .NOT. LLREJ) THEN
              call obs_bodySet_i(lobsSpaceData,OBS_ASS,INDEX_BODY,1)
              IKNT(index_family)= IKNT(index_family) + 1
            ELSEIF (LLDIAG) THEN
              call obs_bodySet_i(lobsSpaceData,OBS_ASS,INDEX_BODY,-1)
            ELSE
              call obs_bodySet_i(lobsSpaceData,OBS_ASS,INDEX_BODY,0)
            ENDIF
C
          ENDIF
C
        ENDDO BODY
C
!$OMP ORDERED
        write(*,'(15x,a2,2x,a12)') listFamily(index_family)
     &       ,'DATA  FAMILY'
        WRITE(*
     &       ,'(12x,"                                              ")')
        WRITE(*
     &       ,'(12x,"    NUMBER OF REJECTED DATA PRESSURE COORD")')
        WRITE(*
     &       ,'(12x," =======================================================================")')
        WRITE(*,'(12x,A80)')CELLIST
        WRITE(*,'(12x,10("  ------"))' )
C
        DO JK=1,16
          WRITE(*,888)iniv(jk),'-',iniv(jk+1),
     &         IKNTFFR(JK),IKNTDDR(JK),IKNTUR(JK),IKNTVR(JK),IKNTZR(JK)
     &         ,IKNTTR(JK),IKNTER(JK),IKNTDR(JK),IKNTOR(JK),IKNTBTR(JK),'
     &         rej'
        ENDDO
C
        if ( listFamily(index_family) == 'UA' .OR. listFamily(index_family) == 'SF' .OR.
     &       listFamily(index_family) == 'SC' .OR. listFamily(index_family) == 'GP' ) then
          WRITE(*
     &         ,'(12x," =======================================================================",/)')
          WRITE(*
     &         ,'(12x,"                                              ")'
     &         )
          WRITE(*,'(12x,"    NUMBER OF REJECTED SURFACE DATA")')
          WRITE(*
     &         ,'(12x," =======================================================================")')
          WRITE(*,'(12x,A80)')CSFLIST
          WRITE(*,'(12x,9("  ------"))' )
          WRITE(*,890)'   sfc   ',
     &         IKNTFSR,IKNTDSR,IKNTUSR,IKNTVSR,IKNTTSR,IKNTESSR,IKNTPSR
     &         ,IKNTPNR,IKNTZDR,'rej'
          WRITE(*
     &         ,'(12x," =======================================================================",/)')
        endif
C
        WRITE(*
     &       ,'(12x,"                                              ")')
        WRITE(*
     &       ,'(12x,"    NUMBER OF ACCEPTED DATA PRESSURE COORD")')
        WRITE(*
     &       ,'(12x," =======================================================================")')
        WRITE(*,'(12x,A80)')CELLIST
        WRITE(*,'(12x,10("  ------"))' )
        DO JK=1,16
          WRITE(*,888)iniv(jk),'-',iniv(jk+1),
     &         IKNTFFA(JK),IKNTDDA(JK),IKNTUA(JK),IKNTVA(JK),IKNTZA(JK)
     &         ,IKNTTA(JK),IKNTEA(JK),IKNTDA(JK),IKNTOA(JK),IKNTBTA(JK),'
     &         acc'
        ENDDO
        WRITE(*
     &       ,'(12x," =======================================================================",/)')
C
        if ( listFamily(index_family) == 'UA' .OR. listFamily(index_family) == 'SF' .OR.
     &       listFamily(index_family) == 'SC' .OR. listFamily(index_family) .eq. 'GP' ) then
          WRITE(*
     &         ,'(12x,"                                              ")'
     &         )
          WRITE(*,'(12x,"    NUMBER OF ACCEPTED SURFACE DATA")')
          WRITE(*
     &         ,'(12x," =======================================================================")')
          WRITE(*,'(12x,A80)')CSFLIST
          WRITE(*,'(12x,9("  ------"))' )
          WRITE(*,890)'   sfc   ',
     &         IKNTFSA,IKNTDSA,IKNTUSA,IKNTVSA,IKNTTSA,IKNTESSA,IKNTPSA
     &         ,IKNTPNA,IKNTZDA,'acc'
          WRITE(*
     &         ,'(12x," =======================================================================",/)')
        endif
 888    FORMAT(1X,i4,a1,i4,10(2x,i6),1x,a3)
 890    FORMAT(1X,a9,9(2x,i6),1x,a3)
!$OMP END ORDERED
      ENDDO FAMILY
!$OMP END DO
!$OMP END PARALLEL
C
C-----------------------------------------------------------------------
      WRITE(*,'(1x," Number of data assimilated by 3d-var:",i10)')
     &     sum(IKNT(:))
C
C
C-----------------------------------------------------------------------
C
      WRITE(*,'(1X,"****************************************** ")')
      WRITE(*,'(1X,"  ---END OF SUPREP---")')
      WRITE(*,'(1X,"****************************************** ",/)')
C
C     SUM OVER ALL BINS SHOULD BE EQUAL TO obs_numbody(lobsSpaceData)
C
      isum=0
      do jk=1,16
        isum=isum+sum(ibin(jk,:))
      enddo
      ISUM = ISUM + sum(IBINS(:))
      write(*,*) ' isum obs_numbody(lobsSpaceData)  ',isum,obs_numbody(lobsSpaceData)
C
C     ABORT IF THERE IS NO DATA TO BE ASSIMILATED
      IF (sum(IKNT(:)) .EQ. 0 ) THEN
        call abort3d('SUPREP. NO DATA TO BE ASSIMILATED')
      ENDIF
C
      RETURN
      END
