!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE DOBSGPSRO(PJO,lcolumnhr,lobsSpaceData)
#if defined (DOC)
*
***s/r DOBSGPSRO - Computation of Jo and the residuals to the GPSRO observations
*
*
*Author  : J. M. Aparicio Jan 2004
*          Adapted Nov 2012 for both refractivity and bending angle data
*    -------------------
**    Purpose:
*
*Arguments
*     PJO: total value of Jo for GPSRO
*
#endif
      use EarthConstants_mod
      use MathPhysConstants_mod
      use modgps01ctphys    , only : p_TC, p_knot
      use modgps02wgs84grav , only : gpsgravitysrf
      use modgps03diff
      use modgps04profile   , only : gpsprofile, gpsstruct1sw
      use modgps08refop     , only : gpsrefopv
      use modgps09bend      , only : gpsbndopv1
      use modgpsro_mod
      use obsSpaceData_mod
      use columnData_mod
      use vGrid_Descriptors
      IMPLICIT NONE
C
      type(struct_columnData) :: lcolumnhr
      type(struct_obs)        :: lobsSpaceData
C
      REAL*8 PJO, PJOB, PJO1
      REAL*8 zLat, Lat, sLat
      REAL*8 zLon, Lon
      REAL*8 zAzm, Azm
      INTEGER IAZM, ISAT, ICLF, jj
      REAL*8 Rad, Geo, rad1, WFGPS
      INTEGER,pointer,dimension(:) :: IP1
      REAL*8, allocatable :: ZPP(:)
      REAL*8, allocatable :: ZDP(:)
      REAL*8, allocatable :: ZTT(:)
      REAL*8, allocatable :: ZHU(:)
      REAL*8, allocatable :: ZUU(:)
      REAL*8, allocatable :: ZVV(:)
      real sfcfield
      REAL  ,pointer,dimension(:) :: rDP
      REAL*8 zP0, zMT
C
      REAL*8 HNH1, ZOBS, ZMHX, ZOER, ZINC
C
      INTEGER INDEX_HEADER, IDATYP, INDEX_BODY
      INTEGER JL, NGPSLEV, NWNDLEV, stat, stat1
C
      LOGICAL  ASSIM, FIRSTHEADER, LDSC

      INTEGER NH, NH1
      TYPE(GPSPROFILE)           :: PRF
      REAL*8       , ALLOCATABLE :: H   (:),AZMV(:)
      TYPE(GPSDIFF), ALLOCATABLE :: RSTV(:),RSTVP(:),RSTVM(:)
      type(struct_vco), pointer  :: vco_trl

      WRITE(*,*)'ENTER DOBSGPSRO'
C
C     * 1.  Initializations
C     *     ---------------
C
      NGPSLEV=col_getNumLev(LCOLUMNHR,'TH')
      NWNDLEV=col_getNumLev(LCOLUMNHR,'MM')
      allocate(ZPP (NGPSLEV))
      allocate(ZDP (NGPSLEV))
      allocate(ZTT (NGPSLEV))
      allocate(ZHU (NGPSLEV))
      allocate(ZUU (NGPSLEV))
      allocate(ZVV (NGPSLEV))
C
      allocate( H    (GPSRO_MAXPRFSIZE) )
      allocate( AZMV (GPSRO_MAXPRFSIZE) )
      allocate( RSTV (GPSRO_MAXPRFSIZE) )
C      IF (LEVELGPSRO.EQ.1) THEN
C         allocate( RSTVP(GPSRO_MAXPRFSIZE) )
C         allocate( RSTVM(GPSRO_MAXPRFSIZE) )
C      ENDIF

      vco_trl => col_getVco(lcolumnhr)
      stat = 0
      stat = vgd_get(vco_trl%vgrid,key='vipt - vertical ip1 levels (t)',value=IP1)
C
C     Loop over all header indices of the 'RO' family:
C
      call obs_set_current_header_list(lobsSpaceData,'RO')
      FIRSTHEADER = .TRUE.

      HEADER: do
         INDEX_HEADER = obs_getHeaderIndex(lobsSpaceData)
         if (INDEX_HEADER < 0) exit HEADER
C
C     *  Process only refractivity data (codtyp 169)
C
         IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
         IF ( IDATYP .EQ. 169 ) THEN
C
C     *     Scan for requested data values of the profile, and count them
C
            ASSIM = .FALSE.
            NH = 0
            call obs_set_current_body_list(lobsSpaceData, INDEX_HEADER)
            BODY: do 
               index_body = obs_getBodyIndex(lobsSpaceData)
               if (index_body < 0) exit BODY
               IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1 ) THEN
                  ASSIM = .TRUE.
                  NH = NH + 1
               ENDIF
            ENDDO BODY
C
C     *     If assimilations are requested, prepare and apply the observation operator
C
            IF (ASSIM) THEN
C
C     *        Basic geometric variables of the profile:
C
               IAZM = obs_headElem_i(lobsSpaceData,OBS_AZA,INDEX_HEADER)
               ISAT = obs_headElem_i(lobsSpaceData,OBS_SAT,INDEX_HEADER)
               ICLF = obs_headElem_i(lobsSpaceData,OBS_ROQF,INDEX_HEADER)
               Rad  = obs_headElem_r(lobsSpaceData,OBS_TRAD,INDEX_HEADER)
               Geo  = obs_headElem_r(lobsSpaceData,OBS_GEOI,INDEX_HEADER)
               zAzm = 0.01d0*IAZM / MPC_DEGREES_PER_RADIAN_R8
               zMT  = col_getHeight(lcolumnhr,NGPSLEV,INDEX_HEADER,'TH')/RG
               WFGPS=0.d0
               DO JJ=1,NUMGPSSATS
                  IF (ISAT.EQ.IGPSSAT(JJ)) WFGPS=WGPS(JJ)
               ENDDO
C
C     *        Profile at the observation location:
C
               zLat = obs_headElem_r(lobsSpaceData,OBS_LAT,INDEX_HEADER)
               zLon = obs_headElem_r(lobsSpaceData,OBS_LON,INDEX_HEADER)
               Lat  = zLat * MPC_DEGREES_PER_RADIAN_R8
               Lon  = zLon * MPC_DEGREES_PER_RADIAN_R8
               Azm  = zAzm * MPC_DEGREES_PER_RADIAN_R8
               sLat = sin(zLat)
               zMT  = zMT * RG / gpsgravitysrf(sLat)
               zP0  = col_getElem(lcolumnhr,1,INDEX_HEADER,'P0')
               sfcfield=zP0
               stat1= vgd_dpidpis(vco_trl%vgrid,IP1,rDP,sfcfield)
               DO JL = 1, NGPSLEV
C
C     *           Profile x
C
                  ZPP(JL) = col_getPressure(LCOLUMNHR,JL,INDEX_HEADER,'TH')
C     *           True implementation of ZDP (dP/dP0)
                  ZDP(JL) = rDP(JL)
                  ZTT(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'TT') - p_TC
                  ZHU(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'HU')
                  ZUU(JL) = 0.d0
                  ZVV(JL) = 0.d0
               ENDDO
               DO JL = 1, NWNDLEV
                  ZUU(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'UU') * p_knot
                  ZVV(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'VV') * p_knot
               ENDDO
               ZUU(NGPSLEV) = ZUU(NWNDLEV)
               ZVV(NGPSLEV) = ZUU(NWNDLEV)
C     
C     *        GPS profile structure:
C
               call gpsstruct1sw(ngpslev,zLat,zLon,zAzm,zMT,Rad,geo,zPP,zDP,zTT,zHU,zUU,zVV,prf)
               LDSC=.NOT.BTEST(ICLF,16-3)
C
C     *        Prepare the vector of all the observations:
C
               NH1 = 0
C
C     *        Loop over all body indices for this index_header:
C     *        (start at the beginning of the list)
C
               call obs_set_current_body_list(lobsSpaceData, index_header)
               BODY_2: do 
                  index_body = obs_getBodyIndex(lobsSpaceData)
                  if (index_body < 0) exit BODY_2
                  IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1 ) THEN
                     NH1      = NH1 + 1
                     H(NH1)   = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
                     AZMV(NH1)= zAzm
                  ENDIF
               ENDDO BODY_2
C
C     *        Apply the observation operator:
C
               IF (LEVELGPSRO.EQ.1) THEN
                  CALL GPSBNDOPV1(H      , AZMV, NH, PRF, RSTV)
C                  CALL GPSBNDOPV1(H+WFGPS, AZMV, NH, PRF, RSTVP)
C                  CALL GPSBNDOPV1(H-WFGPS, AZMV, NH, PRF, RSTVM)
C                  do nh1 = 1, nh
C                     RSTV(nh1)=(RSTVP(nh1)+RSTV(nh1)+RSTVM(nh1))/3.d0
C                  enddo
               ELSE
                  CALL GPSREFOPV (H,       NH, PRF, RSTV)
               ENDIF
C
C     *        Perform the (H(x)-Y)/S operation:
C
               NH1 = 0
               PJOB = 0.d0
C
C     *        Loop over all body indices for this index_header:
C     *        (start at the beginning of the list)
C
               call obs_set_current_body_list(lobsSpaceData, index_header)
               BODY_3: do 
                  index_body = obs_getBodyIndex(lobsSpaceData)
                  if (index_body < 0) exit BODY_3
                  IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1 ) THEN
                     NH1 = NH1 + 1
C
C     *              Altitude:
C
                     HNH1= obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
                     IF (LEVELGPSRO.EQ.1) HNH1=HNH1-Rad
C
C     *              Observation operator H(x)
C
                     ZMHX = RSTV(NH1)%VAR
C
C     *              Observation value    Y
C
                     ZOBS = obs_bodyElem_r(lobsSpaceData,OBS_VAR,INDEX_BODY)
C
C     *              Observation error    S
C
                     ZOER = obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY)
C
C     *              Normalized increment
C
                     ZINC = (ZMHX - ZOBS) / ZOER
C                           
C                    Datum contribution to Jo:
C
                     PJO1 = 0.5d0 * ZINC * ZINC
C
C     *              Total (PJO) and per profile (PJOB) cumulatives:
C
                     PJO = PJO + PJO1
                     PJOB= PJOB+ PJO1
C
                     IF (FIRSTHEADER) THEN
                        WRITE(*,
     +                       '(A9,i10,3f7.2,f11.1,4f12.6,15f12.4)')
     +                       'DOBSGPSRO',
     +                       INDEX_HEADER,Lat,Lon,Azm,HNH1,ZOBS,ZOER,
     +                       ZMHX,ZINC,PJOB,PRF%GST(NGPSLEV)%Var
                     ENDIF
                     call obs_bodySet_r(lobsSpaceData,OBS_OMP,INDEX_BODY, ZOBS - ZMHX)
                  ENDIF
               ENDDO BODY_3

               WRITE(*,
     +              '(A9,i10,2f7.2,f18.10,f12.4,2I6)')
     +              'GPSRO_JO',INDEX_HEADER,Lat,Lon,PJOB,zMT,ISAT,LDSC
            ENDIF
         ENDIF
         FIRSTHEADER = .FALSE.
      ENDDO HEADER

C      IF (LEVELGPSRO.EQ.1) THEN
C         DEALLOCATE( RSTVM )
C         DEALLOCATE( RSTVP )
C      ENDIF
      DEALLOCATE( RSTV )
      DEALLOCATE( AZMV )
      DEALLOCATE( H    )

      deallocate(zVV)
      deallocate(zUU)
      deallocate(zHU)
      deallocate(zTT)
      deallocate(zDP)
      deallocate(zPP)

      WRITE(*,*)'EXIT DOBSGPSRO'
      RETURN
      END SUBROUTINE DOBSGPSRO
