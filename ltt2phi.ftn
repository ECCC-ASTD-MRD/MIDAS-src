!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE ltt2phi(lcolumn,lcolumng)
#if defined (DOC)
*
***s/r ltt2phi - Temperature increments to geopotential
*                increments transformation
*
*
*Author  : S. Pellerin *ARMA/AES September 1998
*
*Revision: L. Fillion *ARMA/AES - 24 nov 98
*        - Include ES option
*          C. Charette *ARMA/AES November 1998
*                      - Added LLPRINT for diagnostics
*          L. Fillion *ARMA/AES - 3 feb 1999
*                      - Introduce ps dependence of TLM
*          C. Charette *ARMA/AES - 8 feb 1999
*                      - Replaced zptop by lcolumng%rppobs(1,jobs)
*                        and zpscon by lcolumng%ps(1,jobs)
*          JM Belanger CMDA/SMC  Nov 2000
*                   . 32 bits conversion
*           C. Charette ARMA/SMC FEV. 2002
*            - Commented out the if(llprint...) statements within
*              the do loops. They were preventing vectorization.
*           P. Koclas CMDA/SMC  Apr 2003
*            - changed loop order  ( lcolumn%hu ---> lcolumnt%hu)
*           C. Charette - ARMA/SMC - Sep. 2004
*            - Conversion to hybrid vertical coordinate
*           Bin He  - ARMA   June  2005
*            - OpenMP optimization.
*
**    Purpose:  -Computation of virtual temperature increments from
*                temperature and logarith of specific humidity
*                increments
*
*               -call lvtap for del vt to del phi transformation
*
*
*Arguments
*
#endif
      use MathPhysConstants_mod
      use columnData_mod 
 
      IMPLICIT NONE
*implicits
c------------------------------------------------------------------------
#include "comlun.cdk"
#include "pardim.cdk"
#include "comdim.cdk"
#include "comdimo.cdk"
#include "comgem.cdk"
c
      type(struct_columnData) :: lcolumn,lcolumng
      type(struct_columnData) :: lcolumnt
      LOGICAL LLPRINT
      integer jobs,jlev
      real*8  zpscon, zcon,zdelps,zdelt,zalpha,zfacps,zfactt
      INTEGER IERR,ILEN
      real*8 zpresb,zpresbd,zterm
      INTEGER mythread,numthd,OMP_GET_NUM_THREADS,OMP_GET_THREAD_NUM
      real*8 vma(lcolumn%nlev),vmb(lcolumn%nlev),vmc(lcolumn%nlev)
      real*8 vmd(lcolumn%nlev),vme(lcolumn%nlev),vmf(lcolumn%nlev)
C
      LLPRINT = .false.
*
      call col_allocate(lcolumnt,lcolumn%nlev,lcolumn%nobtot)
**
c
c*1   First set delq properly and store in lcolumnt%hu ready for Tv
C computation
c     ------------------------------------------------------------------
C -
c
 100  continue
      do jobs = 1, lcolumn%nobtot
        do jlev = 1, lcolumn%nlev
          lcolumnt%hu(jlev,jobs) = lcolumn%hu(jlev,jobs)
        enddo
      enddo
c
c*2   Computation of virtual temperature increments
c     ---------------------------------------------
c
 200  continue
!$OMP PARALLEL PRIVATE(jobs,jlev,mythread,numthd,zpresb,zterm,zpresbd)
!$OMP+ PRIVATE(zcon,zfactt,zfacps,zdelt,zdelps)
      mythread=omp_get_thread_num()+1
      numthd=omp_get_num_threads()
      do jobs = mythread, lcolumn%nobtot,numthd
        do jlev = 1, lcolumn%nlev
          lcolumnt%tt(jlev,jobs) = oltv(1,jlev,jobs)*lcolumn%tt(jlev,jobs) + oltv(2
     &         ,jlev,jobs)*lcolumnt%hu(jlev,jobs)
***************************************************************
c       if (LLPRINT .AND.jobs.eq.1) then
c          write(nulout,*) 'ltt2phi: jobs,lcolumn%nobtot,lcolumn%nlev '
c     &          ,jobs,lcolumn%nobtot,lcolumn%nlev
c          write(nulout,*) 'ltt2phi: jobs,jlev,OLTV(1,,),OLTV(2,,)'
c     &        , jobs,jlev,OLTV(1,jlev,jobs),OLTV(2,jlev,jobs)
c          write(nulout,*)'ltt2phi:gmt1,GMQ(jlev,jobs),GMT(jlev,jobs) '
c     &        ,lcolumnt%tt(jlev,jobs),lcolumn%hu(jlev,jobs),lcolumn%tt(jlev,jobs)
c       endif
***************************************************************
        enddo
!      enddo
c
c*3   Prepare r.h.s. for TL-Hydrostatic equation
c     ------------------------------------------
c
 300  continue
!      do jobs = 1, lcolumn%nobtot
        do jlev = 1, lcolumn%nlev
c
c      zcon = d(rtapfac)/d(ps)
c
          zpresb  = ((vhybinc(jlev) - rptopinc/rprefinc)
     &               /(1.0D0-rptopinc/rprefinc))**rcoefinc
          if((rcoefinc-1.0) .lt. RPRECIS) then
            zterm = 1.0
          else
            zterm = ((vhybinc(jlev) - rptopinc/rprefinc)
     &           /(1.0-rptopinc/rprefinc))**(rcoefinc-1.0)
          endif
          zpresbd = rcoefinc * zterm
          zcon    =(zpresbd-zpresb*rtapfac(jlev,jobs))/lcolumng%rppobs(jlev,jobs)
          zfactt  = rtapfac(jlev,jobs)
          zfacps  = lcolumng%tt(jlev,jobs)*zcon
          zdelt   = rtapfac(jlev,jobs)*lcolumnt%tt(jlev,jobs)
          zdelps  = lcolumng%tt(jlev,jobs)*zcon * lcolumn%ps(1,jobs)
          lcolumnt%tt(jlev,jobs)=rtapfac(jlev,jobs)*lcolumnt%tt(jlev,jobs)
     &         + lcolumng%tt(jlev,jobs)*zcon * lcolumn%ps(1,jobs)
c
***************************************************************
c       if (LLPRINT .AND.jobs.eq.1) then
c          write(nulout,*) 'ltt2phi: jobs,lcolumn%nobtot,lcolumn%nlev '
c     &          ,jobs,lcolumn%nobtot,lcolumn%nlev
c          write(nulout,*)'ltt2phi: jobs,jlev,zfactt,zfacps,zcon'
c     &        , jobs,jlev,zfactt,zfacps,zcon
c          write(nulout,*)'ltt2phi: jobs,jlev,zdelt,zdelps'
c     &        , jobs,jlev,zdelt,zdelps
c          write(nulout,*)'ltt2phi: jobs,jlev,zpresb,zpresbd '
c     &           ,jobs,jlev,zpresb,zpresbd
c       endif
****************************************************************
        enddo
      enddo
!$OMP END PARALLEL
c
c*4   Computation of del(GZ)
c     ----------------------
c
 400  continue

      zalpha=0.0D0
      call matapat(vhybinc,zalpha,lcolumn%nlev,vma,vmb,vmc,vmd,vme,vmf)
      call lvtap

      call col_deallocate(lcolumnt)

      return

      CONTAINS

      subroutine lvtap
*S/P LVTAP:
*         CALCULE Y A PARTIR DE R PAR SOLUTION DE L'EQUATION R*CON=S**E*D(Y)
*         AVEC UN SCHEME DU 4EME ORDRE DU A J. COTE.
*         NOTE: CET ALGORITHME EST EXACTEMENT REVERSIBLE (VOIR VPAT).
*
*         ON DOIT FOURNIR LA COND
*         A LA LIMITE INF. Y(N). LA MATRICE MATAP A ETE CALCULEE DANS LA
*         SUBR. MATAPAT.
*
*
* AUTHOR: MICHEL BELAND - AVRIL 1984 - ADAPTE AU MODELE SEF, AVRIL 1984.
*
* REVISION: LUC FILLION - AUG 94 - MODIFIED FOR VARIATIONAL ANALYSIS.
*           S. Pellerin - Sept 98 - Use of lcolumnt%tt for virtual
*                                   temperatures
*                                 - GZ(lcolumn%nlev) = 0 (tangent linear
*                                   version of vtap).
*                                 - Introduction of surface pressure
*                                   dependant factor (rtapfac) for eta
*                                   coordinates
*                                 - Introduction of site constants
*          C. Charette *ARMA/AES November 1998
*                      - Added LLPRINT for diagnostics
*          L. Fillion *ARMA/AES - 3 Feb 1999
*                      - remove rtapfac
*           C. Charette ARMA/SMC FEV. 2002
*            - Commented out the if(llprint...) statements within
*              the do loops. They were preventing vectorization.
*           Bin He  *ARMA      - June 25,2005
*            -  OpenMP parallelization.
*
      IMPLICIT NONE
      INTEGER  KILG, KLEV
      REAL*8     PCON
*
      LOGICAL  LLPRINT
      INTEGER  JLON, IKLEVM2, JK, IK, jobs
      REAL*8     ZAK0, ZBK0, ZCK0
      REAL*8     ZAK, ZBK, ZCK, ZCON
      INTEGER mythread,numthd
      INTEGER OMP_GET_THREAD_NUM,OMP_GET_NUM_THREADS
*implicits
c
c lcolumnt%tt : working vector of virtual temperatures.
c
      LLPRINT = .FALSE.
      ZCON = -RGASD
      ZAK0  = -2.0*ZCON*VMA(lcolumn%nlev)
      ZBK0  = -2.0*ZCON*VMB(lcolumn%nlev)
      ZCK0  = -2.0*ZCON*VMC(lcolumn%nlev)
!$OMP PARALLEL PRIVATE(jobs,jk,IKLEVM2,mythread,numthd)
!$OMP+ PRIVATE(zak,zbk,zck)
      mythread=omp_get_thread_num()+1
      numthd=omp_get_num_threads()
      do jobs = mythread, lcolumn%nobtot,numthd
        lcolumn%gz(lcolumn%nlev,jobs) = 0.0
        lcolumn%gz(lcolumn%nlev-1,jobs)=ZAK0*lcolumnt%tt(lcolumn%nlev-1,jobs)+
     $                      ZBK0*lcolumnt%tt(lcolumn%nlev,jobs)+
     &                      ZCK0*lcolumnt%tt(lcolumn%nlev-2,jobs)+
     $                      lcolumn%gz(lcolumn%nlev,jobs)
********************************************************
c       if (LLPRINT .and. jobs.eq.1) then
c       print *,'lvtap:lcolumn%nlev,jobs,zak,zbk,zck,lcolumn%gz(lcolumn%nlev,) ',
c     &       lcolumn%nlev,jobs,zak,zbk,zck,lcolumn%gz(lcolumn%nlev,jobs)
c       print *,'lvtap:lcolumn%nlev-1,jobs,zak,zbk,zck,lcolumn%gz(lcolumn%nlev-1,) ',
c     &       lcolumn%nlev-1,jobs,zak,zbk,zck,lcolumn%gz(lcolumn%nlev-1,jobs)
c       endif
********************************************************
*
      IKLEVM2 = lcolumn%nlev-2
      do JK = 1, IKLEVM2
        IK = lcolumn%nlev-1-JK
        ZAK = -2.0*ZCON*VMA(IK+1)
        ZBK = -2.0*ZCON*VMB(IK+1)
        ZCK = -2.0*ZCON*VMC(IK+1)
!        do jobs = 1, lcolumn%nobtot
          lcolumn%gz(ik,jobs)= ZAK*lcolumnt%tt(IK,jobs)+
     $                    ZBK*lcolumnt%tt(IK+1,jobs)+
     $                    ZCK*lcolumnt%tt(IK+2,jobs)+
     +                    lcolumn%gz(IK+2,jobs)
********************************************************
c       if (LLPRINT .and. jobs.eq.1) then
c          print *,'lvtap:ik,jobs,zak,zbk,zck lcolumn%gz(ik,)= ',
c     &       ik,jobs,zak,zbk,zck,lcolumn%gz(ik,jobs)
c          print *,'lvtap:ik,jobs,lcolumnt%tt(ik,),lcolumnt%tt(ik+1,),lcolumnt%tt(ik+2,)= '
c     &       ,ik,jobs,lcolumnt%tt(IK,jobs),lcolumnt%tt(IK+1,jobs),lcolumnt%tt(IK+2,jobs)
c          print *,'lvtap:ik,jobs= '
c     &       ,ik,jobs
c       endif
**********************************************************
        enddo
      enddo
!$OMP END PARALLEL
C
      RETURN
      END SUBROUTINE lvtap

      end
