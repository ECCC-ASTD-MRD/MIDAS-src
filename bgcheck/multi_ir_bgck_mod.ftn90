!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

Module multi_ir_bgck_mod

!************************************************************************
!*
!*       MODULE MULTI_IR_BGCHECK
!*       -------------------
!*
!*       PURPOSE: VARIABLES FOR MULTISPECTRAL INFRARED BACKGROUND CHECK
!*                  AND QUALITY CONTROL
!*
!*       AUTHOR:   A. BEAULNE (CMDA/SMC) February 2006
!*
!*       REVISION: adapted to IASI and CrIS by S. Heilliette
!*
!*
!************************************************************************
 Use tovs_nl_mod, only : jplev,rttov_coefs,transmission_Type,tvs_Is_idburp_tovs, &
      tvs_Is_idburp_inst, &
      radiance_d,lsensor,coefs,nchan,NSENSORS,PLATFORM,SATELLITE,INSTRUMENT,NOBTOV

  implicit none
  save
  private
! Public functions (methods)
  public :: hirqc,BGCK_IR_SETUP
! Public  parameters (constants)
  public :: NCLASSAVHRR,NIR,NVIS,NCHANAVHRR,NCO2,BITFLAG
! Public variables ("global")
  public ::coefs_avhrr,avhrr_bgck,profiles_qc,transmission,transmission_d, emissivity
!public types
  public :: avhrr_bgck_iasi,prof_qc

  INTEGER ,PARAMETER :: NCLASSAVHRR=7
  INTEGER ,PARAMETER :: NIR=3,NVIS=3
  INTEGER ,PARAMETER :: NCHANAVHRR=NIR+NVIS

  ! Reference (and alternate) window channel for clear / cloudy profile detection
  ! (subroutine cloud_height)

  INTEGER, PARAMETER :: IWINDOW_AIRS = 787, IWINDOW_ALT_AIRS = 950
  INTEGER, PARAMETER :: IWINDOW_IASI = 1090, IWINDOW_ALT_IASI = 1133
  INTEGER, PARAMETER :: IWINDOW_CRIS = 427, IWINDOW_ALT_CRIS = 529

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the "background profile matching" method (subroutine cloud_top)

  INTEGER, PARAMETER        :: NCH_HE = 4

  INTEGER, PARAMETER  :: ILIST1_AIRS(NCH_HE) = (/ 528, 787, 950, 2209 /)

  INTEGER, PARAMETER  :: ILIST1_IASI(NCH_HE) = (/ 705, 1090, 1133, 7475 /)

  INTEGER, PARAMETER  :: ILIST1_CRIS(NCH_HE) = (/ 279, 427, 529, 1290 /)

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the CO2-slicing method. IREFR is the reference channel number (and alternate).
  ! (subroutine co2_slicing)


  INTEGER, PARAMETER  :: NCO2 = 13

  INTEGER, PARAMETER  :: ILIST2_AIRS(NCO2) = (/ 204, 221, 232, 252, 262, 272,  &
                                                299, 305, 310, 355, 362, 375, 375 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_AIRS(NCO2) = (/ 252, 262, 272, 299, 305, 310,  &
                                                     355, 362, 375, 375, 262, 252, 204/)

  INTEGER, PARAMETER  :: ILIST2_IASI(NCO2) = (/ 252, 269, 285, 309, 320, 332, &
                                                363, 371, 375, 433, 442, 459, 459 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_IASI(NCO2) = (/ 309, 320, 332,363, 371, 375, &
                                                     433, 442, 459, 459, 320, 309, 252 /)

  INTEGER, PARAMETER  :: ILIST2_CRIS(NCO2) = (/ 99, 116, 138, 133, 158, 154, &
                                               123, 143, 168, 163, 175, 198, 198 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_CRIS(NCO2) = (/ 133, 158, 154, 123, 143, 168, &
                                                     163, 175, 198, 198, 158, 133, 99 /)

  ! Cloud top units : (1) mb, (2) meters
  ! (subroutines cloud_height (IOPT1) and cloud_top (IOPT2))

  INTEGER, PARAMETER        :: IOPT1 = 2   ! verify subr input if iopt1 changes
  INTEGER, PARAMETER        :: IOPT2 = 1

  ! Cloud top based on which background profile matching (subroutine cloud_top)
  ! (0) brightness temperature, (1) radiance, (2) both

  INTEGER, PARAMETER        :: IHGT = 2

  ! Maximum delta temperature allowed between guess and true skin temperature
  ! over water (DTW) and land (DTL)   (subroutine airsqc)

  REAL(8), PARAMETER        :: DTW = 1.5_8
  REAL(8), PARAMETER        :: DTL = 4.0_8

  ! Minimum and maximum RTTOV levels for LEV_START variable entering CO2 slicing
  ! In mb, between 50mb and 325mb (subroutine co2_slicing)

  Real(8), PARAMETER        :: PCO2MIN = 56.73_8, PCO2MAX = 321.5_8

  ! First channel affected by sun (for channels used only at night)
  ! (subroutine airsqc)

  INTEGER, PARAMETER   :: ICHN_SUN_AIRS = 1865
  INTEGER, PARAMETER   :: ICHN_SUN_IASI = 5446
  INTEGER, PARAMETER   :: ICHN_SUN_CRIS = 1147

  ! Minimum solar zenith angle for night (between 90 and 180)
  ! (subroutine airsqc)

  REAL(8), PARAMETER       :: NIGHT_ANG = 100._8

  ! Highest flag in post files (value of N in 2^N)
  ! Currently 21

  INTEGER, PARAMETER :: BITFLAG = 29

  Real(8),parameter :: seuilalb_static(NIR,0:2)= reshape( (/ 70.0,67.0,50.0, &
                                                             40.0,37.0,37.0, &
                                                             70.0,57.0,40. /),(/3,3/) ) 
  Real(8),parameter :: seuilalb_homog(NIR,0:2)= reshape( (/ 15.0,18.0,13.0, &
                                                            9.0,10.0,10.0, &
                                                            18.0,16.0,10.0 /),(/3,3/) )
  
  Real(8) :: seuilbt_homog(NVIS+1:NVIS+NIR,0:2,1:2)= reshape( (/5._8, 4._8, 4._8, 4._8, 3._8, 3._8, &
                                                                5._8, 4._8, 4._8, 5._8, 5._8, 5._8, &
                                                                4._8, 3._8, 3._8, 5._8, 5._8, 5._8/), (/3,3,2/) )

  type( rttov_coefs ) :: coefs_avhrr

  TYPE avhrr_bgck_iasi
     SEQUENCE   
     REAL(8)              :: RADMOY(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: RADSTD(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: CFRAC(NCLASSAVHRR)
     REAL(8)              :: TBMOY(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: TBSTD(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBEDMOY(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: ALBEDSTD(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: TBSTD_PIXELIASI(NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBSTD_PIXELIASI(1:NVIS)
     REAL(8)              :: RADCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: TBCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: RADOVCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMSURF(NVIS+1:NVIS+NIR)
     REAL(8)              :: EMISS(NVIS+1:NVIS+NIR)
  END TYPE avhrr_bgck_iasi

  TYPE prof_qc
     SEQUENCE
     REAL(8)              :: LAT      ! latitude (-90 to 90)
     REAL(8)              :: LON      ! longitude (0 to 360)
     REAL(8), POINTER     :: Z(:)     ! height field (m)
     REAL(8)              :: SUNZA    ! sun zenith angle (deg)
     REAL(8)              :: ALBEDO   ! surface albedo (0-1)
     REAL(8)              :: ICE      ! ice cover (0-1) 
     REAL(8)              :: SNOW     ! snow cover (0-1)
     REAL(8)              :: PCNT_WAT ! water percentage in pixel containing profile (0-1)
     REAL(8)              :: PCNT_REG ! water percentage in an area around profile (0-1)
     INTEGER              :: LTYPE    ! surface type (1,...,20)
  END TYPE prof_qc

  type(avhrr_bgck_iasi)  , allocatable :: avhrr_bgck(:)      ! avhrr parameters for IASI quality control
  type( prof_qc )     ,     allocatable :: profiles_qc(:)    ! profiles buffer used in airsqc call
  type(transmission_Type) :: transmission                    ! transmissions full structure buffer used in rttov calls
  type(transmission_Type) , allocatable :: transmission_d(:) ! transmissions organized by profile
  real(8) , allocatable :: emissivity(:,:)   ! surface emissivities organized by profiles and channels

contains

  SUBROUTINE BGCK_IR_SETUP(lobsSpaceData)
#if defined (DOC)
!
!  s/r BGCK_IR_SETUP : Memory allocation for the Hyperspectral Infrared
!                background check variables
!          (original name of routine: sutovalo)
!
! Revision:

!           S.  Heilliette
!            - creation from tovs_setup_allo  December 2013
#endif

    use obsSpaceData_mod

    IMPLICIT NONE
!implicits

    type(struct_obs) :: lobsSpaceData

    Integer :: alloc_status(2)

    INTEGER :: KRTID
    INTEGER ::  JO, IDATYP,NCMAX
    INTEGER ::  ISENS, NC, NL
    INTEGER ::  ICHN
    INTEGER ::  NOBIASI
    integer ::  index_header

!     1. Determine the number of IASI profiles to be assimilated.
!     .  ---------------------------------------------------
 
    NOBIASI = 0

  ! loop over all header indices of the 'TO' family
  ! Set the header list
  ! (& start at the beginning of the list)
    call obs_set_current_header_list(lobsSpaceData,'TO')
    HEADER: do
       index_header = obs_getHeaderIndex(lobsSpaceData)
       if (index_header < 0) exit HEADER

       IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)
     
       IF ( .not.  tvs_Is_idburp_tovs(IDATYP) ) cycle HEADER   ! Proceed to the next header_index

       IF ( tvs_Is_idburp_inst(IDATYP,"IASI") ) NOBIASI = NOBIASI + 1

    ENDDO HEADER

    write(*,*) ' BGCK_IR_SETUP: nobiasi = ', nobiasi
!-----------------------------------------------------------------------

!     2. Memory allocation for background check related variables
!     .  -----------------------------------------------------

    allocate(profiles_qc(NOBTOV) , stat= alloc_status(1))
    If( alloc_status(1) /= 0) then
       WRITE(*,FMT=9201)
9201   FORMAT(' BGCK_IR_SETUP: Memory Allocation Error')
       CALL ABORT3D('BGCK_IR_SETUP')
    End If

    do jo = 1, NOBTOV
       isens = lsensor(jo)
       nl = coefs(isens)%coef % nlevels
       allocate( profiles_qc(jo) % z  ( nl ) ,stat= alloc_status(1))
       
       If( alloc_status(1)/=0 ) then
          WRITE(*,FMT=9201)
          CALL ABORT3D('BGCK_IR_SETUP')
       End If
    end do

!___ radiance by profile

    alloc_status(:) = 0


    do jo = 1, NOBTOV
       isens = lsensor(jo)
       nc = nchan(isens)
       nl = coefs(isens) % coef % nlevels

       allocate( radiance_d(jo)  % overcast  (nl-1,nc) ,stat= alloc_status(1))
       radiance_d(jo)  % overcast  (:,:) = 0._8
     
       If( alloc_status(1) /= 0 ) then
          WRITE(*,FMT=9201)
          CALL ABORT3D('BGCK_IR_SETUP')
       End If
    end do

!___ transmission by profile

    alloc_status(:) = 0
    allocate( transmission_d(NOBTOV),stat= alloc_status(1))

    do jo = 1, NOBTOV
       isens = lsensor(jo)
       nc = nchan(isens)
       nl = coefs(isens) % coef % nlevels

     !! allocate transmittance from surface and from pressure levels
       allocate( transmission_d(jo)  % tau_total ( nc ) ,stat= alloc_status(1))
       allocate( transmission_d(jo)  % tau_levels(nl,nc) ,stat= alloc_status(2))

       If( any(alloc_status /= 0) ) then
          WRITE(*,FMT=9201)
          CALL ABORT3D('BGCK_IR_SETUP')
       End If
    end do

!___ emissivity by profile

    ncmax = 1

    do jo = 1, NOBTOV
       isens = lsensor(jo)
       nc = nchan(isens)
       if (nc>ncmax) ncmax=nc
    end do

    allocate( emissivity (ncmax,NOBTOV) ,stat=alloc_status(1))
       
    If( alloc_status(1) /= 0 ) then
       WRITE(*,FMT=9201)
       CALL ABORT3D('BGCK_IR_SETUP')
    End If

    DO KRTID = 1, NSENSORS

       IF ( PLATFORM(KRTID) == 10 .AND. &
            INSTRUMENT(KRTID) == 16 ) THEN

          allocate ( avhrr_bgck(NOBIASI), stat= alloc_status(1))

          If( alloc_status(1)/=0 ) then
             WRITE(*,FMT=9201)
             CALL ABORT3D('BGCK_IR_SETUP')
          End If

          EXIT

       END IF

    END DO

  END SUBROUTINE BGCK_IR_SETUP


  SUBROUTINE BGCK_GET_QCPARAM(CINSTR,IWINDOW,IWINDOW_ALT,ILIST1,ILIST2,ILIST2_PAIR,ICHN_SUN)
    IMPLICIT NONE
    character (len=*),intent(in) :: CINSTR
    integer ,intent (out) :: IWINDOW,IWINDOW_ALT,ILIST1(NCH_HE),ILIST2(NCO2),ILIST2_PAIR(NCO2),ICHN_SUN

    select case(trim(cinstr))
    case ("AIRS","airs")
       IWINDOW     = IWINDOW_AIRS
       IWINDOW_ALT = IWINDOW_ALT_AIRS
       ILIST1      = ILIST1_AIRS
       ILIST2      = ILIST2_AIRS
       ILIST2_PAIR = ILIST2_PAIR_AIRS
       ICHN_SUN=ICHN_SUN_AIRS
    case("IASI","iasi")
       IWINDOW     = IWINDOW_IASI
       IWINDOW_ALT = IWINDOW_ALT_IASI
       ILIST1      = ILIST1_IASI
       ILIST2      = ILIST2_IASI
       ILIST2_PAIR = ILIST2_PAIR_IASI
       ICHN_SUN    = ICHN_SUN_IASI
    case("CRIS","cris")
       IWINDOW     = IWINDOW_CRIS
       IWINDOW_ALT = IWINDOW_ALT_CRIS
       ILIST1      = ILIST1_CRIS
       ILIST2      = ILIST2_CRIS
       ILIST2_PAIR = ILIST2_PAIR_CRIS
       ICHN_SUN    = ICHN_SUN_CRIS
    case default
       Write(*,*) "Unknown instrument ",CINSTR
       CALL ABORT3D('BGCK_GET_QCPARAM')
    end select

  END SUBROUTINE BGCK_GET_QCPARAM

  SUBROUTINE HIRQC ( lcolumnhr, lobsSpaceData,CINST,id_in)
!
!**ID HIRQC -- QUALITY CONTROL OF HYPERSPECTRAL INFRARED OBSERVATIONS
!
!       SCIENCE:  L. GARAND
!       AUTHOR:   A. BEAULNE (CMDA/SMC) August 2004
!                 A. BEAULNE (CMDA/SMC)   June 2006  (ADAPT TO 3DVAR)
!                 S. HEILLIETTE           February 2008 (adaptation to IASI)
!                 S. MACPHERSON, S.HEILLIETTE (ARMA) February 2013 
!                   -- modify test pour detecter le isatzen manquant ou anormal
!
!       REVISION:
!
!       OBJECT: ASSIGN ASSIMILATION FLAGS TO OBSERVATIONS 
!
!       ARGUMENTS:
!          INPUT:
!            -LOOP_DONE : NUMBER OF PREVIOUS CALLS TO HIRQC
!
!          OUTPUT:
!            -LEND       : AT THE END OF THIS CALL TO HIRQC, DO ALL 
!                               PROFILES BEEN TREATED (true) OR NOT (false)
!
    use EarthConstants_mod
    use MathPhysConstants_mod
    use tovs_nl_mod
    use hir_chans
    use columnData_mod
    use obsSpaceData_mod
    use verticalCoord_mod
    IMPLICIT NONE
    integer,intent(in),optional :: id_in
    type(struct_columnData),intent(in) :: lcolumnhr
    type(struct_obs),intent(inout) :: lobsSpaceData
    character (len=*),intent(in) :: CINST
!******************************************************************
    INTEGER       :: JC,NCHN,JCH,JF,JL,NLEV,NLEVB,iextr,NPRF,NFLG,ICHN
    INTEGER       :: IWINDO,IWINDO_ALT
    INTEGER       :: INDEX_BODY,IDATA,IDATEND,INDEX_HEADER
    INTEGER       :: IDATYP
    INTEGER       :: DIFFTOP_MIN
    INTEGER ,SAVE :: IMODTOP
    INTEGER       :: count
    REAL(8)       :: T_EFFECTIVE
    integer       :: alloc_status(30)

    real(8) :: ZTG,ZPS,ZTS,ptop_T
    real(8), allocatable :: ZT(:),ZHT(:),ZLQ(:),ZVLEV(:)
    real(8), allocatable :: ZLEVMOD(:)
    real(8), allocatable :: BTOBSERR(:),BTOBS(:),BTCALC(:),RCAL_CLR(:),SFCTAU(:)
    real(8), allocatable :: ROBS(:),RCLD(:,:),TRANSM(:,:),EMI_SFC(:) 
    real(8), allocatable :: TOEXT(:),ZHOEXT(:)
    real(8), allocatable :: PTOP_BT(:),PTOP_RD(:)
    real(8), allocatable :: PMIN(:),DTAUDP1(:),MAXWF(:)
    real(8), allocatable :: RCLD_AVHRR(:,:)
    integer, allocatable :: REJFLAG(:,:) 
    integer, allocatable :: NTOP_BT(:),NTOP_RD(:)
    integer, allocatable :: MINP(:),FATE(:)
    real(8), allocatable :: xpres(:)

    real(8) :: CLFR,SUNZA,SATAZIM,SATZEN,SUNAZIM
    real(8) :: ALBEDO,ICE,PCNT_WAT,PCNT_REG
    real(8) :: PTOP_EQ,PTOP_MB
    real(8) :: PTOP_CO2(NCO2),FCLOUD_CO2(NCO2)
    real(8) :: ETOP,VTOP,ECF,VCF,HEFF
    real(8) :: TAMPON,CFSUB
    real(8) :: ZTS_AVHRR(NCLASSAVHRR),SFCTAU_AVHRR(NIR),EMI_SFC_AVHRR(NIR),RCAL_CLR_AVHRR(NIR)
    real(8) :: PTOP_BT_AVHRR(NIR,NCLASSAVHRR),PTOP_RD_AVHRR(NIR,NCLASSAVHRR)
    real(8) :: BTOBS_AVHRR(NIR,NCLASSAVHRR),ROBS_AVHRR(NIR,NCLASSAVHRR),PTOP_EQ_AVHRR(NCLASSAVHRR)
    real(8) :: CFRAC_AVHRR
    real(8) :: avhrr_surfem1(NIR)
    Real(8) :: seuil_albed(NIR)

    integer :: KSURF,LTYPE
    integer :: CLDFLAG,LEV_START   
    integer :: GNCLDFLAG
    integer :: ICHREF,INDX(1)
    integer :: NTOP_EQ,NTOP_MB
    integer  :: NGOOD
    integer  :: NTOP_CO2(NCO2)
    integer :: CLDFLAG_AVHRR(NCLASSAVHRR),LEV_START_AVHRR(NCLASSAVHRR),ICHREF_AVHRR(NCLASSAVHRR),NTOP_RD_AVHRR(NIR,NCLASSAVHRR)
    integer :: NTOP_BT_AVHRR(NIR,NCLASSAVHRR),NTOP_EQ_AVHRR(NCLASSAVHRR)
    integer :: ICL

    logical :: ASSIM_ALL
  
    integer ,parameter :: nn=2
    integer ,parameter :: ilist_avhrr(nn)=(/ 2 ,3 /)
    integer :: cpt,iclass
    logical :: bad
    Real(8),parameter :: sunzenmax=87.12_8
    Real(8) :: minpavhrr(2:3)
    Real(8) :: anisot,zlamb,zcloud,scos,del,deltaphi
    Integer :: ier,ijour,iloc(2:3),co2min(1),co2max(1),iobs
    integer :: isatzen
    integer :: chan_indx,ILIST_SUN,ilist_co2(NCO2),ilist_co2_pair(NCO2),ilist_he(NCH_HE)
!***************************************************************************************
    integer :: nlv_T,nch_sel,id,KRTID
    integer :: IWINDOW,IWINDOW_ALT,ILIST1(NCH_HE),ILIST2(NCO2),ILIST2_PAIR(NCO2),ICHN_SUN
    logical :: liasi,lairs,lcris
!****************************************

    liasi= ( trim(cinst)=="IASI" .or.  trim(cinst)=="iasi")
    lairs= ( trim(cinst)=="AIRS" .or.  trim(cinst)=="airs")
    lcris= ( trim(cinst)=="CRIS" .or.  trim(cinst)=="cris")

    call BGCK_GET_QCPARAM(cinst,IWINDOW,IWINDOW_ALT,ILIST1,ILIST2,ILIST2_PAIR,ICHN_SUN)

    if (present(id_in)) then
       id=id_in
    else
! ** find sensor number corresponding to the desired instrument
       ID =-1
       DO KRTID = 1, NSENSORS
          IF ( trim(CINSTRUMENTID(KRTID)) == TRIM(CINST)) THEN
             ID = KRTID
             EXIT
          END IF
       END DO
       IF (ID<0) Call abort3d("hirqc: should not happen !")
    endif

! ** find number of profiles 
    count = 0

  ! loop over all header indices of the 'TO' family
    call obs_set_current_header_list(lobsSpaceData,'TO')
    HEADER: do
       index_header = obs_getHeaderIndex(lobsSpaceData)
       if (index_header < 0) exit HEADER
       
       IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
       IF ( tvs_Is_idburp_inst(IDATYP,CINST) .and. lsensor(ltovsno (index_header))==id ) THEN
          count = count + 1
       END IF
    END DO HEADER

    if ( count == 0 ) return
! ** find number of channels and RTTOV levels

    NCHN = coefs(id)%coef%fmv_chn
  
    NLEV = coefs(id)%coef%nlevels 
    allocate (xpres(NLEV))
    xpres(1:NLEV)=coefs(id)% coef% ref_prfl_p(1:NLEV)

    iextr=0
    if (nlev==44) iextr=1
    if (nlev==51) iextr=2
    if (nlev /= 43 .and. nlev/=44 .and. nlev/= 51) then
       Write(*,*) "Attention: modification necessaire dans HIRQC"
       call abort3d('hirqc')
    endif
    
    NLEVB=NLEV-iextr

    write(*,*) ' HIRQC - nchn ', nchn
  
    nlv_T= col_getNumLev(lcolumnhr,'TH')
    nch_sel= hir_get_nchan_selected(cinst)

! information to extract (transvidage)
! ------------------------------------
!
! ZTG -- guess skin temperatures (deg K)
! ZPS(NPRF) -- surface pressure (hPa)
! ZT(nlv_T) -- temperature profiles on NWP model levels (deg K)
! ZHT(nlv_T) -- height profiles on NWP model levels (m)
! ZLQ(nlv_T) -- surface specific humidity in ln q (kg/kg)
! BTOBSERR(nch_sel) -- observation error standard deviation
! BTOBS(nch_sel) -- observed brightness temperatures (deg K)
! BTCALC(nch_sel) -- computed brightness temperatures (deg K)
! RCAL_CLR(nch_sel) -- computed clear radiances (mw/m2/sr/cm-1)
! SFCTAU(nch_sel) -- surface to space transmittances (0-1)
! RCLD(nch_sel,NLEV) -- overcast cloudy radiances (mw/m2/sr/cm-1)
! TRANSM(nch_sel,NLEV) -- layer to space transmittances (0-1)
! EMI_SFC(nch_sel) -- surface emissivities (0-1)
! KSURF -- surface type in obs file (0, 1)
! CLFR -- cloud fraction (%)
! TOEXT(NLEV) -- temperature profiles on RT model levels (deg K)
! ZHOEXT(NLEV) -- height profiles on RT model levels (m)
! SUNZA -- sun zenith angle (deg)
! SATAZIM -- satellite azimuth angle (deg)
! SATZEN -- satellite zenith angle (deg)
! ALBEDO -- surface albedo (0-1)
! ICE -- ice fraction (0-1)
! LTYPE -- surface type (1,...,20)
! PCNT_WAT -- water fraction (0-1)
! PCNT_REG -- water fraction in the area (0-1)
! ROBS(nch_sel) -- observed radiances (mW/m2/sr/cm-1)

  alloc_status(:) = 0
 
  allocate ( BTOBSERR(nch_sel),         stat= alloc_status(1))
  allocate ( BTOBS(nch_sel),            stat= alloc_status(2))
  allocate ( BTCALC(nch_sel),           stat= alloc_status(3))
  allocate ( RCAL_CLR(nch_sel),         stat= alloc_status(4))
  allocate ( SFCTAU(nch_sel),           stat= alloc_status(5))
  allocate ( RCLD(nch_sel,NLEVB),       stat= alloc_status(6))
  allocate ( TRANSM(nch_sel,NLEVB),     stat= alloc_status(7))
  allocate ( EMI_SFC(nch_sel),          stat= alloc_status(8))
  allocate ( TOEXT(NLEVB),              stat= alloc_status(9))
  allocate ( ZHOEXT(NLEVB),             stat= alloc_status(10))
  allocate ( ROBS(nch_sel),             stat= alloc_status(11))
  allocate ( REJFLAG(nch_sel,0:BITFLAG),stat= alloc_status(12))
  allocate ( NTOP_BT(nch_sel),          stat= alloc_status(13))
  allocate ( NTOP_RD(nch_sel),          stat= alloc_status(14))
  allocate ( PTOP_BT(nch_sel),          stat= alloc_status(15))
  allocate ( PTOP_RD(nch_sel),          stat= alloc_status(16))
  allocate ( MINP(nch_sel),             stat= alloc_status(17))
  allocate ( PMIN(nch_sel),             stat= alloc_status(18))
  allocate ( DTAUDP1(nch_sel),          stat= alloc_status(19))
  allocate ( FATE(nch_sel),             stat= alloc_status(20))
  if (liasi) allocate ( RCLD_AVHRR(NIR,NLEVB), stat= alloc_status(21))
  allocate ( maxwf(nch_sel),            stat= alloc_status(22))
  allocate ( ZVLEV(NLEVB),              stat= alloc_status(23))
  allocate ( ZLEVMOD(nlv_T),            stat= alloc_status(24))
  allocate ( ZT(nlv_T),                 stat= alloc_status(25))
  allocate ( ZHT(nlv_T),                stat= alloc_status(26))
  allocate ( ZLQ(nlv_T),                stat= alloc_status(27))
  if( any(alloc_status /= 0) ) then
     write(*,*) ' hirqc : memory allocation error'
     call abort3d('hirqc')
  end if

  DO JL = 1, NLEVB
     ZVLEV(JL) = XPRES(JL+iextr)
  END DO

  
  DIFFTOP_MIN = 100000._8
  IMODTOP     = 1

  ptop_T = col_getPressure(lcolumnhr,1,1,'TH')
  DO JL = 1, NLEVB
     IF ( ABS(ptop_T-100._8*ZVLEV(JL)) < DIFFTOP_MIN ) THEN
        DIFFTOP_MIN = ABS(ptop_T-100._8*ZVLEV(JL))
        IMODTOP = JL
     END IF
  END DO
!* -- FIND RADIATIVE TRANSFER MODEL LEVEL NEAREST TO TRIAL TOP (only compute one time)
  write(*,*) 'TOIT DU MODELE (MB)'
  write(*,*) 0.01_8*ptop_T
  write(*,*) 'NIVEAU DU MODELE DE TRANSFERT RADIATIF LE PLUS PRES DU TOIT DU MODELE'
  write(*,*) IMODTOP

  CO2MIN=minloc( abs( ZVLEV(:) - pco2min ) )
  CO2MAX=minloc( abs( ZVLEV(:) - pco2max ) )

  NOBTOV = 0

  ! loop over all header indices of the 'TO' family
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER_2: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER_2

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)

     IF ( tvs_Is_idburp_tovs(idatyp) ) NOBTOV = NOBTOV + 1

     IF ( tvs_Is_idburp_inst(IDATYP,CINST) .and. lsensor(ltovsno (index_header))==id) THEN
        BTOBS(:)    = -1._8
        BTCALC(:)   = -1._8
        RCAL_CLR(:) = -1._8
        SFCTAU(:)   = -1._8
        RCLD(:,:)   = -1._8
        TRANSM(:,:) = -1._8
        EMI_SFC(:)  = -1._8
        REJFLAG(:,:) = 0

        if (liasi) then
           INDX=index_header
           iclass=1
           do iobs=OBS_CF1,OBS_CF7
              avhrr_bgck(INDEX_HEADER)%CFRAC(iclass)=obs_headElem_i(lobsSpaceData,iobs,index_header)
              iclass=iclass+1
           enddo
           iclass=1
           ichn=1
           do iobs=OBS_M1C1,OBS_M7C6
              avhrr_bgck(INDEX_HEADER)%radmoy(iclass,ichn)=obs_headElem_r(lobsSpaceData,iobs,index_header)
              ichn=ichn+1
              if (ichn>NCHANAVHRR) then
                 ichn=1
                 iclass=iclass+1
              endif
           enddo
           iclass=1
           ichn=1
           do iobs=OBS_S1C1,OBS_S7C6
              avhrr_bgck(INDEX_HEADER)%radstd(iclass,ichn)=obs_headElem_r(lobsSpaceData,iobs,index_header)
              ichn=ichn+1
              if (ichn>NCHANAVHRR) then
                 ichn=1
                 iclass=iclass+1
              endif
           enddo
           SUNAZIM = 0.01_8 * obs_headElem_i(lobsSpaceData,OBS_SAZ,index_header)
        end if

        ZTG = col_getElem(lcolumnhr,1,INDEX_HEADER,'TG')
        ZPS = col_getElem(lcolumnhr,1,INDEX_HEADER,'P0') * MPC_MBAR_PER_PA_R8

        DO JL = 1, nlv_T
           ZT(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'TT')
           ZHT(JL) = col_getHeight(lcolumnhr,JL,INDEX_HEADER,'TH') / RG
           ZLQ(JL) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'HU')
           ZLEVMOD(JL)= col_getPressure(lcolumnhr,JL,INDEX_HEADER,'TH') * MPC_MBAR_PER_PA_R8
        END DO

        IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,index_header)
        IDATEND = obs_headElem_i(lobsSpaceData,OBS_NLV,index_header) + IDATA - 1
        BAD=.false.
        if (lcris) BAD=( obs_headElem_i(lobsSpaceData,OBS_GQF,index_header)/=0 .or. &
             obs_headElem_i(lobsSpaceData,OBS_GQL,index_header) /=0)
        if (liasi) BAD=( obs_headElem_i(lobsSpaceData,OBS_GQF,index_header)/=0 .or. &
             obs_headElem_i(lobsSpaceData,OBS_GQL,index_header) >1) 
   
        DO INDEX_BODY= IDATA, IDATEND
           IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY)==1 ) THEN
              ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
              ICHN = MAX(0,MIN(ICHN,JPCHMAX+1))
              chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
              BTOBSERR(chan_indx) = obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY)
              BTOBS(chan_indx) = obs_bodyElem_r(lobsSpaceData,OBS_VAR,INDEX_BODY)
! *** Flag check on observed BTs ***
              IF (.not.liasi .and. BTEST(obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY),2)) REJFLAG(chan_indx,9) = 1
              IF (BAD) REJFLAG(chan_indx,9) = 1
! *** Gross check on observed BTs ***
              IF (BTOBS(chan_indx)<150._8) REJFLAG(chan_indx,9) = 1
              IF (BTOBS(chan_indx)>350._8) REJFLAG(chan_indx,9) = 1
           END IF
        END DO

        DO JC = 1, NCHN
           ICHN = ichan(JC,ID)
           chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
           BTCALC(chan_indx) = radiance_d(nobtov)%bt(jc)
           RCAL_CLR(chan_indx) = radiance_d(nobtov)%clear(jc)
           SFCTAU(chan_indx) = transmission_d(nobtov)%tau_total(jc)
           DO JL = 1, NLEVB
              RCLD(chan_indx,JL) = radiance_d(nobtov)%overcast(jl+iextr-1,jc)
              TRANSM(chan_indx,JL) = transmission_d(nobtov)%tau_levels(jl+iextr,jc)
           END DO
           EMI_SFC(chan_indx) = emissivity(JC,NOBTOV)
! *** Gross check on computed BTs ***
           IF (BTCALC(chan_indx)<150._8) REJFLAG(chan_indx,9) = 1
           IF (BTCALC(chan_indx)>350._8) REJFLAG(chan_indx,9) = 1
        END DO


        KSURF = profiles(nobtov)%skin%surftype
!Test pour detecter le isatzen manquant (-1) ou anormal
! (angle negatif ou superieur a 75 degres )
        isatzen= obs_headElem_i(lobsSpaceData,OBS_SZA,INDEX_HEADER)
        if ( isatzen < 9000 .or. &
             isatzen > 16500 ) then
           DO JC = 1, NCHN
              ICHN = ichan(JC,ID)
              chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
              REJFLAG(chan_indx,9) = 1
           ENDDO
        endif
!**************************************************************
        CLFR = 0.
        if (lairs) CLFR = obs_headElem_i(lobsSpaceData,OBS_CLF,INDEX_HEADER)

        DO JL = 1, NLEVB
           TOEXT(JL) = profiles(nobtov)%t(jl+iextr)
           ZHOEXT(JL) = profiles_qc(nobtov)%z(jl+iextr)
        END DO

        SUNZA = profiles_qc(nobtov)%sunza
        if (liasi) then
           SATAZIM = profiles(nobtov)%azangle 
           SATZEN = profiles(nobtov)%zenangle
        endif
        ALBEDO = profiles_qc(nobtov)%albedo
        ICE = profiles_qc(nobtov)%ice
        LTYPE = profiles_qc(nobtov)%ltype
        IF (LTYPE==20) KSURF=2
        PCNT_WAT = profiles_qc(nobtov)%pcnt_wat
        PCNT_REG = profiles_qc(nobtov)%pcnt_reg
           
! ** find TOA radiances converted from observed BT's

        ROBS(:) = -1._8
        
        channels: DO JC = 1, NCHN
           ICHN = ichan(JC,ID)
           chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
           IF ( REJFLAG(chan_indx,9) == 1 ) CYCLE channels
           t_effective =  coefs(id)%coef%ff_bco(jc) &
                + coefs(id)%coef%ff_bcs(jc) * BTOBS(chan_indx)
           ROBS(chan_indx) =  coefs(id)%coef%planck1(jc) / &
                ( Exp( coefs(id)%coef%planck2(jc)/t_effective ) - 1._8 )
        END DO channels

! ** set height fields to 'height above ground' fields

        DO JL = 1, NLEVB
           ZHOEXT(JL) = ZHOEXT(JL) - ZHT(nlv_T)
        END DO
        DO JL = 1, nlv_T
           ZHT(JL) = ZHT(JL) - ZHT(nlv_T)
        END DO
!**********************************************************************************************
!* ///// ---------------------------------------------------- /////
!* ///// DETERMINATION OF THE CLEAR/CLOUDY PROFILES (CLDFLAG) /////
!* ///// ---------------------------------------------------- /////
           
        CLDFLAG = 0
        
!* -- REFERENCE FOR WINDOW CHANNEL
           
        IWINDO     = hir_get_chindx_fr_chn(CINST,IWINDOW)
        IWINDO_ALT = hir_get_chindx_fr_chn(CINST,IWINDOW_ALT)
        ICHREF  = IWINDO
           
        IF ( REJFLAG(IWINDO,9) == 1 ) THEN
           ICHREF = IWINDO_ALT
           IF ( REJFLAG(IWINDO_ALT,9) == 1 ) THEN
              ICHREF = -1
              CLDFLAG = -1
              REJFLAG(:,9) = 1
              write(*,*) 'WARNING'
              write(*,*) 'WINDOW AND ALTERNATE WINDOW CHANNEL OBSERVATIONS'
              write(*,*) 'HAVE BEEN REJECTED.                             '
              write(*,*) 'ALL '//cinst//' OBSERVATIONS FROM THIS PROFILE REJECTED'
           END IF
        END IF

!* -- CLOUD TOP BASED ON MATCHING OBSERVED BRIGHTNESS TEMPERATURE 
!* -- AT A REFERENCE SURFACE CHANNEL WITH BACKGROUND TEMPERATURE PROFILE (PTOP_EQ)
!* -- ON GUESS VERTICAL LEVELS.

        LEV_START = 0

!iopt2=1 : calcul de la hauteur en hPa PTOP_MB et du NTOP_MB correspondant
        CALL CLOUD_HEIGHT (PTOP_MB,NTOP_MB, btobs,cldflag,zt, &
             zht,zps,zlevmod,nlv_T,nch_sel,ichref,lev_start,iopt2)

!iopt1=2 : calcul de la hauteur em metres PTOP_EQ et du NTOP_EQ correspondant
        CALL CLOUD_HEIGHT (PTOP_EQ,NTOP_EQ, btobs,cldflag,zt, &
             zht,zps,zlevmod,nlv_T,nch_sel,ichref,lev_start,iopt1)

        if (liasi) then
! appel de RTTOV pour calculer les radiances des 3 canaux IR (3b, 4 et 5) de AVHRR 3
           
           call get_avhrr_emiss(emi_sfc,coefs(id) %coef%ff_cwn,coefs(id) % coef%fmv_chn,avhrr_surfem1)

           call tovs_rttov_AVHRR_for_IASI(indx,avhrr_surfem1,SATELLITE(id))
                 
           IOBS=INDX(1)
           call convert_avhrr(profiles_qc(IOBS)%sunza, avhrr_bgck(IOBS) )
           call stat_avhrr(avhrr_bgck(IOBS))
     
           LEV_START_AVHRR(:) = 0
           cldflag_avhrr(:)=0
           DO JC=1,NCLASSAVHRR
              btobs_avhrr(:,JC)= avhrr_bgck(IOBS) % TBMOY(JC,:)
              robs_avhrr(1:NIR,JC)= avhrr_bgck(IOBS) % RADMOY(JC,NVIS+1:NIR+NVIS)
              RCAL_CLR_AVHRR(:) = avhrr_bgck(IOBS) % RADCLEARCALC(:)
              EMI_SFC_AVHRR(:) = avhrr_bgck(IOBS) % EMISS(:)
              SFCTAU_AVHRR(:) = avhrr_bgck(IOBS) % TRANSMSURF(:)
        
              DO JL=1,NLEVB
                 RCLD_AVHRR(:,JL) = avhrr_bgck(IOBS) % RADOVCALC(JL+iextr-1,:)
              ENDDO
           
              IF (btobs_avhrr(2,JC) >100._8 ) THEN
                 ichref_avhrr(JC)=2
              ELSE IF (btobs_avhrr(3,JC) >100._8 ) THEN
                 ichref_avhrr(JC)=3
              ELSE
                 ichref_avhrr(JC)=-1
                 cldflag_avhrr(JC)=-1
              ENDIF

              CALL CLOUD_HEIGHT (PTOP_EQ_AVHRR(JC),NTOP_EQ_AVHRR(JC), btobs_avhrr(:,JC),cldflag_avhrr(JC),zt, &
                   zht,zps,zvlev,nlv_T,NIR,ichref_avhrr(JC),lev_start_avhrr(JC),iopt1)
           ENDDO
         
        end if

!* -- CLEAR/CLOUDY PROFILE DETECTION USING THE GARAND & NADON ALGORITHM

        CALL GARAND1998NADON (CLDFLAG, btobs,ztg,zt, &
             zht,nlv_T,nch_sel,ptop_eq,ntop_eq,ichref)

        if (liasi) then
           DO JC=1,NCLASSAVHRR
              CALL GARAND1998NADON (CLDFLAG_AVHRR(jC), btobs_avhrr(:,JC),ztg,zt, &
                   zht,nlv_T,NIR,ptop_eq_avhrr(JC),ntop_eq_avhrr(JC),ichref_avhrr(JC))
           ENDDO
        end if

!* -- FURTHER TESTS TO REMOVE POTENTIAL CLOUDY PROFILES
! *** TEST # A ***
! *** In daytime, set cloudy if cloud fraction over 5% ***
        CFSUB=-1._8
        if (lairs) then
           IF ( CLDFLAG == 0 .AND. CLFR > 5._8 .AND. SUNZA < 90._8 ) THEN
              CLDFLAG = 1
              CFSUB=0.01_8*CLFR !conversion % -> 0-1
           ENDIF
        endif
! *** TEST # B ***
! *** Set cloudy if temperature difference between guess (ZTG)     ***
! *** and estimated true (ZTS) skin temperatures is over threshold ***

        CALL ESTIM_TS(ZTS, ztg,emi_sfc,rcal_clr,robs, &
             sfctau,cldflag,ichref,nch_sel,nchn,id,CINST)

        IF ( CLDFLAG == 0 .AND. KSURF == 1 &
             .AND. ABS(ZTS-ZTG) > DTW ) CLDFLAG = 1 

        IF ( CLDFLAG == 0 .AND. KSURF /= 1 &
             .AND. ABS(ZTS-ZTG) > DTL ) CLDFLAG = 1

        if (liasi) then

           DO JC=1,NCLASSAVHRR
              CALL ESTIM_TS_AVHRR(ZTS_AVHRR(JC), ztg,emi_sfc_avhrr,rcal_clr_avhrr,robs_avhrr(:,JC), &
                   sfctau_avhrr,CLDFLAG_AVHRR(jC),ichref_avhrr(JC),NIR)
           ENDDO

           DO JC=1,NCLASSAVHRR
              IF ( CLDFLAG_AVHRR(JC) == 0 .AND. KSURF == 1 &
                   .AND. ABS(ZTS_AVHRR(JC)-ZTG) > DTW ) CLDFLAG_AVHRR(JC) = 1
              
              IF ( CLDFLAG_AVHRR(JC) == 0 .AND. KSURF /= 1 &
                   .AND. ABS(ZTS_AVHRR(JC)-ZTG) > DTL ) CLDFLAG_AVHRR(JC) = 1
              
           ENDDO

!criteres AVHRR utilisant les canaux visibles (de jour seulement)
           IF (sunza<sunzenmax) THEN 
              ANISOT=1._8
              deltaphi=abs(SATAZIM - SUNAZIM )
           
              IF (deltaphi>180._8) deltaphi=360._8 - deltaphi
           
              IF (ALBEDO<0.17_8) THEN               
                 CALL VISOCN(sunza,satzen,deltaphi,ANISOT,ZLAMB,ZCLOUD,IER)
                 SEUIL_ALBED=10._8*max(1._8,ANISOT) 
              ELSE
                 SEUIL_ALBED=100._8*ALBEDO + 10._8
              ENDIF
              
              IF (ANISOT<1.5_8) THEN !to avoid sun glint
                 SCOS=COS ( sunza * MPC_DEGREES_PER_RADIAN_R8 )
                 CALL  cor_albedo ( DEL, SCOS )
                 SEUIL_ALBED=SEUIL_ALBED * DEL
                 DO JC=1,NCLASSAVHRR
                    IF (avhrr_bgck(IOBS)%ALBEDMOY(JC,1) > SEUIL_ALBED(1) ) THEN
                       CLDFLAG_AVHRR(JC) = 1
                    ENDIF
                  !static AVHRR thresholds v3
                    DO JL=1,NVIS
                       IF (avhrr_bgck(IOBS)%ALBEDMOY(JC,JL) > seuilalb_static(JL,KSURF) ) THEN
                          CLDFLAG_AVHRR(JC) = 1
                       ENDIF
                    ENDDO
                 ENDDO
             
              ENDIF
           ENDIF

!Calcul de la pseudo fraction nuageuse AVHRR

           CFRAC_AVHRR=0._8
           DO JC=1,NCLASSAVHRR
              IF (CLDFLAG_AVHRR(JC) == 1) CFRAC_AVHRR=CFRAC_AVHRR + avhrr_bgck(IOBS)%CFRAC(JC)
           ENDDO

           CFSUB=-1.0_8
           IF ( CLDFLAG == 0 .AND. CFRAC_AVHRR > 5._8 ) THEN
              CLDFLAG = 1
              CFSUB=0.01_8* MIN(CFRAC_AVHRR,100._8) !conversion % -> 0-1 avec seuil car parfois CFRAC_AVHRR=101
           ENDIF

!AVHRR Homogeneity criteria
           IF (CLDFLAG == 0) THEN
              IJOUR=1
              IF (SUNZA<90._8) IJOUR=2
              ! 1 NUIT
              ! 2 JOUR
              IF (IJOUR==2) THEN
                 DO JC=1,NVIS
                    IF (avhrr_bgck(IOBS)%ALBSTD_PIXELIASI(JC)> seuilalb_homog(JC,KSURF) ) CLDFLAG=1
                 ENDDO
              ENDIF
              DO JC=NVIS+1,NVIS+NIR
                 IF (avhrr_bgck(IOBS)%TBSTD_PIXELIASI(JC)>seuilbt_homog(JC,KSURF,IJOUR)) CLDFLAG=1
              ENDDO
           ENDIF
        endif

        GNCLDFLAG=CLDFLAG

!* ///// ------------------------------------------------------- /////
!* ///// DETERMINATION OF THE ASSIMILABLE OBSERVATIONS (REJFLAG) /////
!* ///// ------------------------------------------------------- /////


!* -- FIRST TESTS TO REJECT OBSERVATIONS


! *** TEST # 1 ***
! *** Do not assimilate where cloudy ***

        IF ( CLDFLAG == 1 ) then
           REJFLAG(:,11) = 1
           REJFLAG(:,23) = 1
        endif
             
! *** TEST # 2 ***
! *** Gross check on valid BTs ***

!     already done


!* -- CLOUD TOP BASED ON MATCHING 
!* -- OBSERVED BRIGHTNESS TEMPERATURE WITH BACKGROUND TEMPERATURE PROFILES (PTOP_BT)
!* -- OR COMPUTED OBSERVED RADIANCES WITH BACKGROUND RADIANCE PROFILES (PTOP_RD)
!* -- ON RTTOV VERTICAL LEVELS

        LEV_START = 0

        DO JCH = 1, NCH_HE
           ILIST_HE(JCH) = hir_get_chindx_fr_chn(CINST,ILIST1(JCH))
        END DO
              
        CALL CLOUD_TOP ( PTOP_BT,PTOP_RD,NTOP_BT,NTOP_RD, &
             btobs,toext,zhoext,rcal_clr,zps,robs,rcld,zvlev,nlevb, &
             nch_sel,cldflag,rejflag,lev_start,iopt2,ihgt,ichref,nch_he,ilist_he)

        if (liasi) then
           LEV_START_AVHRR(:) = 0

           DO JC=1,NCLASSAVHRR
              CALL CLOUD_TOP_AVHRR ( PTOP_BT_AVHRR(:,JC),PTOP_RD_AVHRR(:,JC),NTOP_BT_AVHRR(:,JC),NTOP_RD_AVHRR(:,JC), &
                   btobs_avhrr(:,JC),toext,zhoext,rcal_clr_avhrr,zps,robs_avhrr(:,JC),rcld_avhrr,zvlev,nlevb, &
                   NIR,cldflag_avhrr(jc),lev_start_avhrr(JC),iopt2,ihgt,nn,ilist_avhrr)
           ENDDO
        endif

!* -- REFERENCE CHANNEL FOR CO2-SLICING

        DO JCH = 1, NCO2
           ILIST_CO2(JCH) = hir_get_chindx_fr_chn(CINST,ILIST2(JCH))
           ILIST_CO2_PAIR(JCH) = hir_get_chindx_fr_chn(CINST,ILIST2_PAIR(JCH))
        END DO

        cpt=0
        DO JCH=1,NCO2
           IF ( REJFLAG(ILIST_CO2(JCH),9)==1 .or. &
                REJFLAG(ILIST_CO2_PAIR(JCH),9)==1 ) cpt=cpt+1
        ENDDO
         
        IF (cpt==nco2) THEN
           CLDFLAG = -1
           REJFLAG(:,9) = 1
           write(*,*) 'WARNING'
           write(*,*) 'CO2 REFERENCE AND ALTERNATE CHANNEL OBSERVATIONS'
           write(*,*) 'HAVE BEEN REJECTED.                             '
           write(*,*) 'ALL '//CINST//' OBSERVATIONS FROM THIS PROFILE REJECTED'
        ENDIF

!* -- EQUIVALENT HEIGHT OF SELECTED WINDOW CHANNEL

        HEFF = PTOP_RD( hir_get_chindx_fr_chn(CINST,ILIST1(2)))

              
        IF (ICHREF==IWINDO_ALT) HEFF = PTOP_RD( hir_get_chindx_fr_chn(CINST,ILIST1(3)) )
              
!* -- CLOUD TOP BASED ON CO2 SLICING 
              
              
        LEV_START = MAX( MIN(LEV_START,CO2MAX(1)), CO2MIN(1) )
              
        CALL CO2_SLICING ( PTOP_CO2,NTOP_CO2,FCLOUD_CO2, &
             rcal_clr,rcld,robs,zps,zvlev,nlevb,nch_sel,cldflag,rejflag, &
             lev_start,ichref,ilist_co2,ilist_co2_pair)


!* -- FIND CONSENSUS CLOUD TOP AND FRACTION
 
        CALL SELTOP ( ETOP,VTOP,ECF,VCF,NGOOD, heff,ptop_co2,fcloud_co2, &
             CFSUB,PTOP_MB,zps,cldflag,gncldflag )

        if (liasi) then
! Correction pour les nuages trop bas:
! en principe Pco2 < Heff.
! on cherche les cas pathologiques avec Pco2>Min(Heff(AVHRR))
           minpavhrr(2:3)=12200
           ILOC(2:3)=-1      ! pour eviter les catastrophes...
           DO JC=1,NCLASSAVHRR
              IF (avhrr_bgck(IOBS)%CFRAC(JC)>0._8) THEN
                 IF (PTOP_RD_AVHRR(2,JC)<minpavhrr(2)) THEN
                    ILOC(2)=JC
                    minpavhrr(2)=PTOP_RD_AVHRR(2,JC)
                 ENDIF
                 IF (PTOP_RD_AVHRR(3,JC)<minpavhrr(3)) THEN
                    ILOC(3)=JC
                    minpavhrr(3)=PTOP_RD_AVHRR(3,JC)
                 ENDIF
              ENDIF
           ENDDO
           IF ( ILOC(2)/=-1 .and. ILOC(3)/=-1) THEN ! pour eviter les catastrophes...
! on se limite aux cas "surs" ou les deux hauteurs effectives sont > a Pco2
! et ou un accord raisonnable existe entre les deux hauteurs effectives
              IF ( ILOC(2)==ILOC(3) .and. &
                   minpavhrr(2) < ETOP .and. &
                   minpavhrr(3) < ETOP .and. &
                   ABS(minpavhrr(2)- minpavhrr(3))<25._8 .and. &
                   CLDFLAG_AVHRR(ILOC(2))/=-1 .and. CLDFLAG_AVHRR(ILOC(3))/=-1) THEN
        
                 IF (ECF==0._8 .and. CLDFLAG==1) THEN
                 ! cas predetermine nuageux mais ramene a clair 
                    ECF=0.01_8* min(100._8,CFRAC_AVHRR)
                 ! cette ligne peut generer des fractions nuageuses inferieures a 20 %.
                    ETOP=0.5_8*(minpavhrr(2) + minpavhrr(3))
                 ENDIF

                 IF (ECF>0._8 .and. CLDFLAG==1) THEN
                    !cas predetermine nuageux pas ramene clair (==normal)
                    ETOP=0.5_8*(minpavhrr(2) + minpavhrr(3))
                 ENDIF

                 IF (CLDFLAG==0) THEN
                 !cas predetermine clair ... que faire
                    CLDFLAG=1
                    ETOP=0.5_8*(minpavhrr(2) + minpavhrr(3))
                    ECF=0.01_8* min(100._8,CFRAC_AVHRR)
                 ENDIF
              ENDIF
           END IF
        endif


!* -- FIND MINIMUM LEVEL OF SENSITIVITY FOR CHANNEL ASSIMILATION NOT SENSIBLE TO CLOUDS
        
        CALL MIN_PRES_new (MAXWF, MINP,PMIN,DTAUDP1, zps,transm,zvlev,cldflag,nlevb,nch_sel,imodtop )

!* -- ASSIMILATION OF OBSERVATIONS WHEN CLOUDY PROFILES

! *** TEST # 3 ***
! *** Assimilation above clouds (refinement of test 1)             ***
! *** Set security margin to 2x the std on height from CO2-slicing *** 

        TAMPON = MAX(50._8, 2._8*VTOP)                                                          

        DO JC = 1, nch_sel        
           IF ( REJFLAG(JC,11) == 1 .AND. REJFLAG(JC,23) == 1 .and. ETOP - TAMPON > PMIN(JC) ) THEN
              REJFLAG(JC,11) = 0
              REJFLAG(JC,23) = 0
           end IF
        END DO

!     LOOK AT THE FATE OF THE OBSERVATIONS

        FATE(:) = SUM(REJFLAG(:,:),DIM=2)            


!     FURTHER REASONS TO REJECT OBSERVATIONS

        ILIST_SUN= hir_get_chindx_fr_chn(CINST,ICHN_SUN)

        DO JC = 1, nch_sel

           IF ( FATE(JC) == 0 ) THEN

! *** TEST # 4 ***
! *** Background check, do not assimilate if O-P > 3sigma ***

              IF ( ABS(BTOBS(JC)-BTCALC(JC)) > 3._8*BTOBSERR(JC) ) THEN
                 REJFLAG(JC,9)  = 1
                 REJFLAG(JC,16) = 1
              END IF

! *** TEST # 5 ***
! *** Do not assimilate shortwave channels during the day ***

              IF ( JC >= ILIST_SUN .AND. SUNZA < NIGHT_ANG ) then
                 REJFLAG(JC,11) = 1
                 REJFLAG(JC,7)  = 1
              END IF

! *** TEST # 6 ***
! *** Do not assimilate surface channels over land ***

              IF ( MINP(JC) == NLEVB .or. ZPS-PMIN(JC) < 100._8 ) THEN
                 IF ( KSURF == 0 ) THEN
                    REJFLAG(JC,11) = 1    !!! comment this line if assimilation under conditions
                    REJFLAG(JC,19) = 1    !!! comment this line if assimilation under conditions
                    IF ( PCNT_WAT > 0.01_8 .OR. PCNT_REG > 0.1_8 .OR. EMI_SFC(JC) < 0.97_8 ) THEN
                       REJFLAG(JC,11) = 1
                       REJFLAG(JC,19) = 1
                    END IF

! *** TEST # 7 ***
! *** Do not assimilate surface channels over water under conditions ***

                 ELSE IF ( KSURF == 1 ) THEN
                    IF ( PCNT_WAT < 0.99_8 .OR. PCNT_REG < 0.97_8 .OR. &
                         ICE > 0.001_8 .OR. ALBEDO >= 0.17_8 .OR. EMI_SFC(JC) < 0.9_8 ) THEN
                       REJFLAG(JC,11) = 1   
                       REJFLAG(JC,19) = 1   
                    END IF

! *** TEST # 8 ***
! *** Do not assimilate surface channels over sea ice ***
                          
                 ELSE IF ( KSURF == 2 ) THEN
                    REJFLAG(JC,11) = 1
                    REJFLAG(JC,19) = 1   
                 END IF
              END IF

           END IF

! *** TEST # 9 ***
! *** Do not assimilate if jacobian has a significant contribution over model top ***

! Condition valid if model top at 10mb or lower only
           IF ( NINT(ptop_T) >= 1000 ) THEN
              IF ( REJFLAG(JC,9) /= 1 .AND. DTAUDP1(JC)  > 0.50_8 ) THEN
                 REJFLAG(JC,11) = 1
                 REJFLAG(JC,21) = 1
              END IF
           END IF
        
! Condition valid if model top at 10mb or lower only
           IF ( NINT(ptop_T) >= 1000 ) THEN
              IF ( REJFLAG(JC,9) /= 1 .AND. TRANSM(JC,1) < 0.99_8 ) THEN
                 REJFLAG(JC,11) = 1
                 REJFLAG(JC,21) = 1 
              END IF
           END IF

! Condition valid if model top is higher than 10 mb
           IF ( NINT(ptop_T) < 1000 ) THEN
              IF ( REJFLAG(JC,9) /= 1 .AND. TRANSM(JC,1) < 0.95_8 ) THEN
                 REJFLAG(JC,11) = 1
                 REJFLAG(JC,21) = 1 
              END IF
           END IF

! *** TEST # 10 ***
! *** Do not assimilate blacklisted channels ***
                 
           IF ( hir_get_assim_chan(CINST,JC) == 0 ) REJFLAG(JC,8) = 1

        END DO

!* -- FOR EACH PROFILE, ARE ALL NON-BLACKLISTED CHANNELS ASSIMILATED

        ASSIM_ALL = .true.
        FATE(:) = SUM(REJFLAG(:,:),DIM=2)            
        
        chn: DO JC = 1, nch_sel
           IF ( REJFLAG(JC,8) == 0 ) THEN
              IF ( FATE(JC) /= 0 ) THEN
                 ASSIM_ALL = .false.
                 EXIT chn
              END IF
           END IF
        END DO chn

        if  (.not.ASSIM_ALL) then
           call obs_headSet_i(lobsSpaceData, OBS_ST1, index_header,ibset(obs_headElem_i(lobsSpaceData,OBS_ST1,INDEX_HEADER),6) )
        endif
!* -- ADDITION OF BACKGROUND CHECK PARAMETERS TO BURP FILE
!* ------------------------------------------------

        call obs_headSet_r(lobsSpaceData, OBS_ETOP, index_header, ETOP )
        call obs_headSet_r(lobsSpaceData, OBS_VTOP, index_header, VTOP )
        call obs_headSet_r(lobsSpaceData, OBS_ECF,  index_header, 100._8*ECF )
        call obs_headSet_r(lobsSpaceData, OBS_VCF,  index_header, 100._8*VCF )
        call obs_headSet_r(lobsSpaceData, OBS_HE,   index_header, HEFF )
        call obs_headSet_r(lobsSpaceData, OBS_ZTSR, index_header, ZTS )
        call obs_headSet_i(lobsSpaceData, OBS_NCO2, index_header, NGOOD)
        call obs_headSet_r(lobsSpaceData, OBS_ZTM,  index_header, ZT(nlv_T) )
        call obs_headSet_r(lobsSpaceData, OBS_ZTGM, index_header, ZTG )
        call obs_headSet_r(lobsSpaceData, OBS_ZLQM, index_header, EXP(ZLQ(nlv_T)) )
        call obs_headSet_r(lobsSpaceData, OBS_ZPS,  index_header, 100._8*ZPS )
        call obs_headSet_i(lobsSpaceData, OBS_STYP, index_header, KSURF )

        DO INDEX_BODY= IDATA, IDATEND
           ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
           ICHN = MAX(0,MIN(ICHN,JPCHMAX+1))
           chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
           call obs_bodySet_r(lobsSpaceData,OBS_SEM,INDEX_BODY,EMI_SFC(chan_indx))
           DO NFLG = 0, BITFLAG
              IF ( REJFLAG(chan_indx,NFLG) == 1 ) &
                   call obs_bodySet_i(lobsSpaceData,OBS_FLG,INDEX_BODY,IBSET(obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY),NFLG))
           END DO
        END DO
              
     END IF

  END DO HEADER_2

  alloc_status(:) = 0
 
  deallocate ( BTOBSERR,  stat= alloc_status(1) )
  deallocate ( BTOBS,     stat= alloc_status(2) )
  deallocate ( BTCALC,    stat= alloc_status(3) )
  deallocate ( RCAL_CLR,  stat= alloc_status(4) )
  deallocate ( SFCTAU,    stat= alloc_status(5))
  deallocate ( RCLD,      stat= alloc_status(6))
  deallocate ( TRANSM,    stat= alloc_status(7))
  deallocate ( EMI_SFC,   stat= alloc_status(8))
  deallocate ( TOEXT,     stat= alloc_status(9))
  deallocate ( ZHOEXT,    stat= alloc_status(10))
  deallocate ( ROBS,      stat= alloc_status(11))
  deallocate ( REJFLAG,   stat= alloc_status(12))
  deallocate ( NTOP_BT,   stat= alloc_status(13))
  deallocate ( NTOP_RD,   stat= alloc_status(14))
  deallocate ( PTOP_BT,   stat= alloc_status(15))
  deallocate ( PTOP_RD,   stat= alloc_status(16))
  deallocate ( MINP,      stat= alloc_status(17))
  deallocate ( PMIN,      stat= alloc_status(18))
  deallocate ( DTAUDP1,   stat= alloc_status(19))
  deallocate ( FATE,      stat= alloc_status(20))
  if (liasi) deallocate ( RCLD_AVHRR , stat= alloc_status(21))
  deallocate ( maxwf,     stat= alloc_status(22))
  deallocate ( ZVLEV,     stat= alloc_status(23))
  deallocate ( ZLEVMOD,   stat= alloc_status(24))
  deallocate ( XPRES,     stat= alloc_status(25))
  deallocate ( ZT,        stat= alloc_status(26))
  deallocate ( ZHT,       stat= alloc_status(27))
  deallocate ( ZLQ,       stat= alloc_status(28))
  if( any(alloc_status /= 0) ) then
     write(*,*) ' hirqc : memory deallocation error'
     call abort3d('hirqc        ')
  end if
        
end SUBROUTINE HIRQC

subroutine convert_avhrr(sunzen,avhrr)
! conversion des radiance IR en temperatures de brillance
! et des radiances visibles en "albedo"
  
  implicit none
  real(8) ,intent(in) :: sunzen
  type (avhrr_bgck_iasi) ,intent(inout) :: avhrr

  integer :: ICL
  REAL (8) :: tb(NIR),dtbsdrad(NIR)
  REAL (8) :: FREQ(NIR),OFFSET(NIR),SLOPE(NIR)


  freq=coefs_avhrr%coef%ff_cwn (:)
  offset=coefs_avhrr%coef%ff_bco(:)
  slope=coefs_avhrr%coef%ff_bcs(:)

  DO ICL=1,NCLASSAVHRR
     call calcbt(avhrr % radmoy(ICL,4:6), tb, dtbsdrad,freq,offset,slope)
     avhrr % tbmoy(ICL,4:6)=tb(1:3)
     avhrr % tbstd(ICL,4:6)=avhrr % radstd(ICL,4:6) * dtbsdrad(1:3)
     call calcreflect(avhrr % radmoy(ICL,1:3) ,sunzen,avhrr % ALBEDMOY(ICL,1:3) )
     call calcreflect(avhrr % radstd(ICL,1:3) ,sunzen,avhrr % ALBEDSTD(ICL,1:3) )
  ENDDO

end subroutine convert_avhrr

subroutine calcreflect(rad,sunzen,reflect)
  Use MathPhysConstants_mod ,only : MPC_PI_R8, MPC_RADIANS_PER_DEGREE_R8
  implicit none

  REAL (8) , INTENT(IN) ,dimension(nvis) :: rad
  REAL (8) , INTENT(IN) :: sunzen
  REAL (8) , INTENT(out),dimension(nvis) :: reflect ! reflectivite en %
!************
  REAL (8) ,DIMENSION(NVIS) :: SOLAR_FILTERED_IRRADIANCE
  DATA SOLAR_FILTERED_IRRADIANCE /139.873215_8,232.919556_8,14.016470_8/
!# equivalent widths, integrated solar irradiance,  effective central wavelength
!0.084877,139.873215,0.632815
!0.229421,232.919556,0.841679
!0.056998,14.016470,1.606119
! pour la definition de l'albedo voir http://calval.cr.usgs.gov/PDF/Rao.CRN_IJRS.24.9.2003_Chander.pdf
  REAL (8) :: RADB ! radiance en W/m2/str
!
  integer :: i
!**************************************************************

  Do i = 1, nvis
     if (rad(i)>= 0.0_8 ) THEN
        radb=rad(i) / 1000.0_8
        reflect(i)=(MPC_PI_R8*radb)/SOLAR_FILTERED_IRRADIANCE(I)
        IF (sunzen < 90.0_8 ) reflect(i)= reflect(i) / COS(sunzen*MPC_RADIANS_PER_DEGREE_R8)
     else
        reflect(i)=-1
     end if
  End Do
  
end subroutine calcreflect

subroutine calcbt(rad,tb,dtbsdrad,freq,offset,slope)
  implicit none
  INTEGER,parameter  :: nchan=3
  Real(8) ,parameter :: c1= 1.19106590D-05   ! first planck constant
  Real(8) ,parameter :: c2= 1.438833_8     ! second planck constant 
  REAL (8) , INTENT(IN) ,dimension(nchan) :: rad,freq,offset,slope
  REAL (8) , INTENT(out) ,dimension(nchan) :: tb,dtbsdrad
  !************
  integer :: i
  REAL (8) ::  radtotal,tstore,planck1,planck2

  Do i = 1, nchan
     if (rad(i)>1.d-20) THEN
        planck2= c2 * freq(I)
        planck1= c1 * ( freq(I) **3 ) 
        tstore = planck2 / Log( 1+planck1/rad(i) )
        tb(i) = ( tstore - offset(i) ) / slope(i)
        
        radtotal = rad(i)
   
        dtbsdrad(i) = planck1 * tstore**2 / ( planck2 * radtotal * ( radtotal + planck1 ) )
        
        dtbsdrad(i) = dtbsdrad(i) / slope(i)

     else
        tb(i) =0._8
        dtbsdrad(i) = 0._8
     end if
     
  End Do

end subroutine calcbt

real (8) function dplanck(nu,t,offset,slope)
!    fonction de planck en double precision
!    nu en cm-1 t en Kelvin  planck en Watt / ( m2 strd cm-1 )
!    c en m/s  h en J.s  k en J/K
  implicit none
  real (8),intent(in) :: nu,t,offset,slope
  real (8) :: nu0,tt
  real (8) ,parameter :: c=299792458._8
  real (8) ,parameter :: k=1.3806505D-23
  real (8) ,parameter :: h=6.62606876D-34
  real (8) ,parameter :: scale=100._8
   
  dplanck=-1._8

  if (t>0._8) then
     nu0=nu*scale
     tt=t*slope+offset
     dplanck=scale*2._8*h*c**2*nu0**3/(dexp(h*c/k*nu0/tt)-1._8)
  endif

end function dplanck

subroutine stat_avhrr(avhrr)
! calcul de statistiques
! sur l'information sous-pixel AVHRR
  implicit none
  type (avhrr_bgck_iasi) ,intent(inout) :: avhrr
  integer :: ICL,ICH
  Real (8) :: SUMFRAC(NVIS+NIR),TBMIN(NVIS+1:NVIS+NIR),TBMAX(NVIS+1:NVIS+NIR),SUMTB(NVIS+1:NVIS+NIR),SUMTB2(NVIS+1:NVIS+NIR)
  Real (8) :: SUMALB(1:NVIS),SUMALB2(1:NVIS)
!******************************************

  SUMFRAC(:)=0._8
  SUMTB(:)=0._8
  SUMTB2(:)=0._8
  SUMALB(:)=0._8
  SUMALB2(:)=0._8

  DO ICL=1,NCLASSAVHRR
     IF (avhrr%CFRAC(ICL) > 0._8 ) THEN
        DO ICH=1,NVIS
           IF (avhrr%ALBEDMOY(ICL,ICH) >=0._8 ) THEN
              SUMFRAC(ICH)=SUMFRAC(ICH)+avhrr%CFRAC(ICL)
              SUMALB(ICH) = SUMALB(ICH) + avhrr%CFRAC(ICL) * avhrr%ALBEDMOY(ICL,ICH)
              SUMALB2(ICH) = SUMALB2(ICH) + avhrr%CFRAC(ICL) * ( avhrr%ALBEDMOY(ICL,ICH)**2 + avhrr%ALBEDSTD(ICL,ICH)**2)
           ENDIF
        ENDDO
        DO ICH=1+NVIS,NVIS+NIR
           IF (avhrr%TBMOY(ICL,ICH) > 0._8 ) THEN
              SUMFRAC(ICH) = SUMFRAC(ICH) + avhrr%CFRAC(ICL)
              SUMTB(ICH) = SUMTB(ICH) + avhrr%CFRAC(ICL) * avhrr%TBMOY(ICL,ICH)
              SUMTB2(ICH) = SUMTB2(ICH) + avhrr%CFRAC(ICL) * (avhrr%TBMOY(ICL,ICH)**2 + avhrr%TBSTD(ICL,ICH)**2 )
           ENDIF
        ENDDO
     ENDIF
  ENDDO
  
  DO ICH=1,NVIS
     IF (SUMFRAC(ICH) >0._8 ) THEN
        SUMALB(ICH) = SUMALB(ICH) / SUMFRAC(ICH)
        SUMALB2(ICH) = SUMALB2(ICH)/SUMFRAC(ICH) - SUMALB(ICH)**2
        IF (SUMALB2(ICH)>0._8) THEN
           SUMALB2(ICH)=SQRT( SUMALB2(ICH) )
        ELSE
           SUMALB2(ICH)=0._8
        ENDIF
     ENDIF
  ENDDO
  
  DO ICH=NVIS+1,NVIS+NIR
     IF (SUMFRAC(ICH) >0._8 ) THEN
        SUMTB(ICH) = SUMTB(ICH) / SUMFRAC(ICH)
        SUMTB2(ICH) = SUMTB2(ICH)/SUMFRAC(ICH) - SUMTB(ICH)**2
        IF (SUMTB2(ICH)>0._8) THEN
           SUMTB2(ICH)=SQRT ( SUMTB2(ICH) )
        ELSE
           SUMTB2(ICH)=0._8
        ENDIF
     ENDIF
  ENDDO

  avhrr%TBSTD_PIXELIASI=SUMTB2
  avhrr%ALBSTD_PIXELIASI=SUMALB2

end subroutine stat_avhrr

SUBROUTINE CO2_SLICING ( PTOP,NTOP,FCLOUD,    &
     rcal,rcld,robs,ps,plev,nlev,nchn,cldflag,rejflag, &
       lev_start,ichref,ilist,ilist_pair)
!
!**ID CO2_SLICING -- CLOUD TOP HEIGHT COMPUTATION
!
!       AUTHOR:   L. GARAND               July 2004
!                 A. BEAULNE (CMDA/SMC)  March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION: 001 O. Pancrati various improvements
!
!       OBJECT:   CLOUD TOP FROM CO2 SLICING AND CLOUD FRACTION ESTIMATE
!
!       ARGUMENTS:
!          INPUT:
!            -RCAL(NCHN)      : COMPUTED CLEAR RADIANCES (MW/M2/SR/CM-1)
!            -RCLD(NCHN,NLEV) : COMPUTED CLOUD RADIANCES FROM EACH LEVEL (")
!            -ROBS(NCHN)      : COMPUTED OBSERVED RADIANCES (")
!            -PS             : SURFACE PRESSURE (HPA)
!            -PLEV(NLEV)           : PRESSURE LEVELS (HPA)
!            -NLEV                 : NUMBER OF VERTICAL LEVELS
!            -NCHN                 : NUMBER OF CHANNELS
!            -CLDFLAG        : (0) CLEAR, (1) CLOUDY, (-1) UNDEFINED PROFILE
!            -REJFLAG(NCHN,0:BITFLAG) : FLAGS FOR REJECTED OBSERVATIONS
!            -BITFLAG              : HIGHEST FLAG IN POST FILES (VALUE OF N IN 2^N)
!            -ICHREF         : WINDOW CHANNEL TO PREDETERMINE CLEAR
!            -NCO2                 : NUMBER OF CHANNELS TO GET ESTIMATES IN
!                                     COMBINATION WITH ICHREF_CO2 (NOT INCLUDED)
!            -ILIST(NCO2)          : LIST OF THE CHANNEL NUMBERS, ICHREF_CO2 NOT INCLUDED
!                                     (SUBSET VALUES)
!
!          INPUT/OUTPUT:
!            -LEV_START      : LEVEL TO START ITERATION (IDEALLY TROPOPAUSE)
!
!          OUTPUT:
!            -PTOP(NCO2)      : CLOUD TOP (HPA)
!            -FCLOUD(NCO2)    : CLOUD FRACTION
!            -NTOP(NCO2)      : NEAREST PRESSURE LEVEL CORRESPONDING TO PTOP
!                                     (PTOP <= PS)
!
  IMPLICIT NONE
  integer ,intent (in) :: NLEV,NCHN
  REAL(8) ,intent (in) :: RCAL(NCHN),RCLD(NCHN,NLEV),ROBS(NCHN)
  REAL(8) ,intent (in) :: PLEV(NLEV),PS
  integer ,intent (in) :: ICHREF,CLDFLAG,REJFLAG(NCHN,0:BITFLAG)
  integer ,intent (in) :: ILIST(NCO2),ILIST_PAIR(NCO2)
  integer ,intent (inout) :: LEV_START
  REAL(8) ,intent (out) :: PTOP(NCO2),FCLOUD(NCO2)
  integer ,intent (out) :: NTOP(NCO2)
!*********************************************************************************
  INTEGER     :: J,JCH,JC,JPMAX,JMAX
  INTEGER     :: SUMREJ
  REAL(8)     :: EPS
  REAL(8)     :: FC(NCHN,NLEV),RAPG,RADP
  REAL(8)     :: DRAP(NCO2,NLEV),A_DRAP(NLEV)
  REAL(8)     :: VAL,VAL1,VAL2,VAL3,FCINT
  REAL(8)     :: EMI_RATIO
  INTEGER     :: JC_PAIR
  INTEGER     :: ITER,NITER
      
  EPS         = 1.D-12

  PTOP(:)   = -1._8
  NTOP(:)   = -1
  FCLOUD(:) = -1._8


!**     profile not assimilated if data from 2 windows channels bad
!**     and/or if data from 2 reference co2 channels bad

  IF ( CLDFLAG == -1 ) RETURN

!**     define closest level jpmax to surface pressure ps

  JPMAX = NLEV

  DO J = LEV_START, NLEV
     IF ( PLEV(J) > PS ) THEN
        JPMAX = J
        EXIT
     END IF
  END DO
  
!**     define jmax as last level for co2-slicing calculations
  
  JMAX = JPMAX - 1
    
!**     predetermined clear window channel, all nco2 estimates clear

  SUMREJ = SUM(REJFLAG(ICHREF,:))

  IF ( SUMREJ == 0 ) THEN
     PTOP(:) = PS
     NTOP(:) = JPMAX
     FCLOUD(:) = 0._8
     RETURN
  END IF

  channels: DO JCH = 1, NCO2
        
     JC = ILIST(JCH)
     JC_PAIR = ILIST_PAIR(JCH)
     FC(JC_PAIR,:) = RCAL(JC_PAIR) - RCLD(JC_PAIR,:)
     NITER=1
     IF ( JCH > 13) NITER=2 
     
     iteration: DO ITER = 1, NITER
        DRAP(JCH,:)   = 9999._8
        NTOP(JCH) = -1
          !-------------------------------------------------------------------------------
          !         calcul EMI_RATIO
        IF (JCH > 13) THEN
             
           If ( ITER == 1 ) THEN
              EMI_RATIO = 1.0376_8
           Else
              EMI_RATIO = 1.09961_8 - 0.09082_8*FCLOUD(JCH)
           Endif
             
        ELSE
           EMI_RATIO = 1.0_8
        ENDIF
!-------------------------------------------------------------------------------
	  
        FC(JC,:) = RCAL(JC) - RCLD(JC,:)

!**       gross check failure

        IF ( REJFLAG(JC,9) == 1 ) CYCLE channels
        IF ( REJFLAG(JC_PAIR,9) == 1 ) CYCLE channels
	  
        IF ( abs(RCAL(JC_PAIR)-ROBS(JC_PAIR)) > EPS ) THEN
           RAPG = (RCAL(JC)-ROBS(JC)) / (RCAL(JC_PAIR)-ROBS(JC_PAIR))
        ELSE
           RAPG = 0.0_8
        ENDIF

        DO J = LEV_START, JPMAX
           IF ( FC(JC,J) > 0._8 .AND. FC(JC_PAIR,J) > 0._8 )  &
                DRAP(JCH,J) = RAPG - (FC(JC,J) / FC(JC_PAIR,J))*EMI_RATIO
        END DO

        A_DRAP(:) = ABS(DRAP(JCH,:))

        levels: DO J = LEV_START+1, JMAX

!**         do not allow fc negative (i.e. drap(jch,j) = 9999.)

           IF ( DRAP(JCH,J) > 9000._8 .AND. &
                A_DRAP(J-1) < EPS .AND. &
                A_DRAP(J+1) < EPS ) CYCLE channels

           VAL = DRAP(JCH,J) / ( DRAP(JCH,J-1) )

!**         find first, hopefully unique, zero crossing

           IF ( VAL < 0._8 ) THEN

!**         conditions near zero crossing of isolated minimum need monotonically
!**         decreasing drap from j-3 to j-1 as well increasing from j to j+1

              VAL1 = DRAP(JCH,J-2) / ( DRAP(JCH,J-1) )
              VAL2 = DRAP(JCH,J-3) / ( DRAP(JCH,J-1) )
              VAL3 = DRAP(JCH,J)   / ( DRAP(JCH,J+1) )

              IF ( VAL1 > 0._8 .AND.  & 
                   VAL2 > 0._8 .AND.  & 
                   VAL3 > 0._8 .AND.  &
                   A_DRAP(J-2) > A_DRAP(J-1) .AND.  &
                   A_DRAP(J-3) > A_DRAP(J-2) .AND.  &
                   A_DRAP(J)   < 9000._8     .AND.  &
                   A_DRAP(J+1) > A_DRAP(J) )        &
                   THEN
                 PTOP(JCH) = PLEV(J)
                 NTOP(JCH) = J
              END IF
                
              EXIT levels
                      
           END IF
              
        END DO levels

        J = NTOP(JCH)

!**       special cases of no determination

        IF ( J <= LEV_START .OR. DRAP(JCH,J) > 9000._8 ) THEN
!           IF ( ITER == 1) THEN
           PTOP(JCH)   = -1._8
           NTOP(JCH)   = -1
           FCLOUD(JCH) = -1._8
              !	   ENDIF
           CYCLE channels
        END IF

        IF ( ABS(RCLD(JC,J)-RCAL(JC)) > 0._8 )       &
             FCLOUD(JCH) = (ROBS(JC)-RCAL(JC)) /   &
             (RCLD(JC,J)-RCAL(JC))

        !**       find passage to zero if it exists and interpolate to exact pressure

        PTOP(JCH) = PLEV(J-1) - DRAP(JCH,J-1) /                        &
             ( DRAP(JCH,J) - DRAP(JCH,J-1) ) * ( PLEV(J) - PLEV(J-1) )
!**       find cloud radiance at zero crossing to use to get cloud fraction

        FCINT = FC(JC,J-1) + ( FC(JC,J) - FC(JC,J-1) ) /                  &
             ( PLEV(J) - PLEV(J-1) ) * ( PTOP(JCH) - PLEV(J-1) )

!**       find cloud fraction based on exact cloud top

        IF ( ABS(FCINT) > 0._8 )                                            &
             FCLOUD(JCH) = ( RCAL(JC) - ROBS(JC) ) / FCINT

        FCLOUD(JCH) = MIN ( FCLOUD(JCH),  1.5_8 )
        FCLOUD(JCH) = MAX ( FCLOUD(JCH), -0.5_8 )
	  
        IF (FCLOUD(JCH) < 0.0_8 .or. FCLOUD(JCH) > 1.0_8 )  CYCLE channels
	  
     END DO iteration
     
  END DO channels
      

END SUBROUTINE CO2_SLICING

SUBROUTINE SELTOP ( ETOP,VTOP,ECF,VCF,NGOOD, he,ht,cf,cfsub,ptop_mb,ps,cldflag,gncldflag )
!
!**ID SELTOP -- SELECT CLOUD TOP
!
!       AUTHOR:   L. GARAND                  July 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   SELECT CLOUD TOP BY AVERAGING CO2-SLICING RESULTS
!          JUDGED CORRECT. ALL MISSING VALUES ARE -1.
!
!       ARGUMENTS:
!          INPUT:
!            -HE(NPRF)      : EQUIVALENT CLOUD TOP HEIGHTS 
!                              FROM A WINDOW CHANNEL (HPA)
!            -HT(NCO2,NPRF) : CLOUD TOPS FROM CO2-SLICING (HPA)
!            -CF(NCO2,NPRF) : EFFECTIVE CLOUD FRACTION FOR CO2-SLICING
!            -CFSUB(NPRF)   : visible ("subpixel") cloud fraction
!            -PTOP_MB(NPRF) : height (mb) from cloud_height subroutine           
!            -PS(NPRF)      : SURFACE PRESSURE IN (HPA)
!            -CLDFLAG(NPRF) : (0) CLEAR, (1) CLOUDY, (-1) UNDEFINED PROFILE
!            -NPRF          : NUMBER OF PROFILES
!
!          OUTPUT:
!            -ETOP(NPRF)    : CONSENSUS CLOUD TOP (HPA)
!            -VTOP(NPRF)    : CORRESPONDING VARIANCE ON ETOP (HPA)
!            -ECF(NPRF)     : CONSENSUS EFFECTIVE CLOUD FRACTION
!            -VCF(NPRF)     : CORRESPONDING VARIANCE ON ECF
!            -NGOOD(NPRF)   : NUMBER OF GOOD ESTIMATES
!
  IMPLICIT NONE
  REAL(8) ,intent (in) :: HE,HT(NCO2),CF(NCO2),PS,CFSUB
  integer ,intent (in) :: CLDFLAG, GNCLDFLAG
  REAL(8) ,intent (out):: ETOP,VTOP,ECF,VCF
  integer ,intent (out):: NGOOD
!***********************************************************************************
  INTEGER    :: N,JCH
  REAL(8)    :: PTOP_MB
  REAL(8)    :: H(NCO2),F(NCO2)


  ETOP = -1._8
  VTOP = -1._8
  ECF  = -1._8
  VCF  = -1._8
  NGOOD= 0

!**     profile not assimilated if data from 2 windows channels bad
!**     and/or if data from 2 reference co2 channels bad

  IF ( CLDFLAG == -1 ) RETURN

  N = 0
  H(:) = 0._8
  F(:) = 0._8

  DO JCH = 1, NCO2

!*        CHECK FOR ZERO CLOUD FRACTION

     IF ( CF(JCH) > -0.9_8 .AND. CF(JCH) < 1.D-6 ) THEN
        N = N + 1
        H(N) = PS
        F(N) = 0._8
     ELSE


!*        CONSIDER ONLY VALID VALUES OF CLOUD FRACTION ABOVE SOME THRESHOLD

!         IMPORTANT LOGIC: FOR VALUES ABOVE 1.0 OF CO2-SLICING CLOUD FRACTION,
!         SET IT TO 1.0 AND FORCE THE TOP EQUAL TO THE EFFECTIVE HEIGHT HE.
!         CO2-SLICING NOT ALLOWED TO GIVE ESTIMATES BELOW HE, WHICH HAPPENS
!         FOR CLOUD FRACTION CF > 1.0.

        IF ( HT(JCH) > 0.0_8 ) THEN
           N=N+1
           H(N) = HT(JCH)
           F(N) = MIN(CF(JCH), 1.0_8)
           F(N) = MAX(F(N), 0._8)
           IF ( CF(JCH) > 1.0_8 ) H(N) = HE
        END IF
     ENDIF

  ENDDO


  NGOOD = N

!*      COMPUTE MEAN AND VARIANCE

  IF ( N >= 1 ) THEN
         
!         ETOP = SUM(H(1:N)) / N
!         ECF  = SUM(F(1:N)) / N

     call calcul_median_fast(N,NCO2,H,F,ETOP,ECF)

     VTOP = SQRT ( SUM((H(1:N)-ETOP)**2)/N )
     VCF  = SQRT ( SUM((F(1:N)- ECF)**2)/N )         

     IF ( N == 1 ) THEN
        VTOP = 50._8
        VCF  = 0.20_8
     END IF
       
  ELSE

!*      IF NO SOLUTION FROM CO2-SLICING, AND NOT PREDETERMINED CLEAR, 
!*      ASSUME CLOUDY WITH TOP EQUAL TO EFFECTIVE HEIGHT HE;
!*      HOWEVER IF HE IS VERY CLOSE TO SURFACE PRESSURE PS, ASSUME CLEAR.

     ETOP = HE
     ECF  = 1.0_8
     IF (CFSUB>=0.05_8) THEN
        ECF=CFSUB
        ETOP=MIN(MIN(HE,PTOP_MB),PS-50.0_8)
     ENDIF
     VTOP = 50._8
     VCF  = 0.30_8
     IF ( HE > (PS-10._8) ) ECF = 0._8
     IF ( GNCLDFLAG == 0 ) THEN
        ECF=0.0_8
        ETOP=PS
     ENDIF
  END IF

  IF ( ECF < 0.05_8 ) THEN
     ECF=0.0_8
     ETOP=PS
  ENDIF

END SUBROUTINE SELTOP
  

subroutine calcul_median_fast(NN,Nmax,Hin,Fin,CTP,CFR)
! 
  implicit none
  integer ,intent (in) :: NN
  integer ,intent (in) :: Nmax
  real (8) ,intent (in):: Hin(Nmax),Fin(Nmax)
  real (8) ,intent (out):: CTP,CFR
!*********************************************
  INTEGER    :: index(NN)
  real (4) :: H(NN)
!*******
  integer :: i

  IF (NN==1) THEN
     CTP=Hin(NN)
     CFR=Fin(NN)
  ELSE

     H(1:NN)=Hin(1:NN)
        
     call IPSORT(index,H,NN)

     if (mod(NN,2)==0) then		! N - pair
        i=index(NN/2)
        CTP=Hin(i)
        CFR=Fin(i)
     else				! N - impair
        i=index(1+NN/2)
        CTP=Hin(i)
        CFR=Fin(i)
     endif
     
  ENDIF

end subroutine calcul_median_fast

SUBROUTINE MIN_PRES_new(MAXHEIGHT,MINP,PMIN,DT1, ps,tau,plev,cldflag,nlev,nchn,imodtop)
!
!**ID MIN_PRES -- FIND MINIMUM HEIGHT LEVEL OF SENSITIVITY
!
!       AUTHOR:   L. GARAND                   May 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   FROM TOTAL TRANSMITTANCE ARRAY, FIND MINIMUM HEIGHT 
!          LEVEL OF SENSITIVITY FOR A NUMBER OF PROFILES AND CHANNELS.
!          THIS MAY BE USED TO SELECT FOR ASSIMILATION ONLY THE
!          OBSERVATIONS WITHOUT SENSITIVITY TO CLOUDS, THAT IS THE
!          RESPONSE FUNCTION SIGNIFICANT ONLY ABOVE CLOUD LEVEL.
!          THE CRITERION IS THAT dTAU/dPLEV > 0.01 FOR A 100 MB LAYER.
!
!       ARGUMENTS:
!          INPUT:
!            -PS            : SURFACE PRESSURE (HPA)
!            -TAU(NCHN,NLEV) : LAYER TO SPACE TRANSMITTANCES (0.-1.)
!            -PLEV(NLEV)          : PRESSURE LEVELS (HPA)
!            -CLDFLAG       : (0) CLEAR, (1) CLOUDY, (-1) UNDEFINED PROFILE
!            -NLEV                : NUMBER OF VERTICAL LEVELS
!            -NCHN                : NUMBER OF CHANNELS
!            -IMODTOP             : RT MODEL LEVEL NEAREST TO MODEL TOP
!
!          OUTPUT:
!            -PMIN(NCHN)     : MINIMUM HEIGHT OF SENSITIVITY (HPA)
!            -MINP(NCHN)     : VERTICAL LEVEL CORRESPONDING TO PMIN
!            -DT1(NCHN)      : VALUE OF 'DTAU/DLOGP' AT MODEL TOP
!            -MAXHEIGHT(NCHN): Height (hPa) of the maximum of the weighting function
!
  IMPLICIT NONE
  INTEGER ,INTENT(IN)   :: NCHN,NLEV,IMODTOP,CLDFLAG
  REAL(8), intent(in)   :: PLEV(NLEV),PS,TAU(NCHN,NLEV)
  INTEGER, INTENT (out) :: MINP(NCHN)
  REAL(8), intent(out)  :: PMIN(NCHN), DT1(NCHN),MAXHEIGHT(NCHN)
!*******************************************************************************

  REAL(8) :: MAXWF
  INTEGER   :: J,JC,ipos(1)
  REAL(8)   :: WFUNC(NLEV-1),RAP(NLEV-1)

  MINP(:) = -1
  PMIN(:) = -1._8
  DT1(:)  = -1._8

  DO J = 1, NLEV-1
     RAP(J) = LOG( PLEV(J+1) / PLEV(J) )
  ENDDO

  channels: DO JC = 1, NCHN

!**       profile not assimilated if data from 2 windows channels bad
!**       and/or if data from 2 reference co2 channels bad
     IF ( CLDFLAG == -1 ) RETURN

     DO J = 1, NLEV
        IF ( TAU(JC,J) < 0._8) CYCLE channels
     END DO

     MINP(JC) = NLEV
     PMIN(JC) = MIN(PLEV(NLEV),PS)


!*        COMPUTE ENTIRE ARRAY OF dTAU/dlog(P)
          
     DO J = 1, NLEV-1
        WFUNC(J) = (TAU(JC,J)-TAU(JC,J+1)) / ( RAP(J) )
     END DO
       
     DT1(JC) = WFUNC(IMODTOP)

!*        IF CHANNEL SEES THE SURFACE, DON'T RECALCULATE MINP AND PMIN

     IF ( TAU(JC,NLEV) > 0.01_8 ) CYCLE channels

! Recherche du maximum
     IPOS=MAXLOC( WFUNC(:) )
! Calcul de la valeur du maximum
     MAXWF = WFUNC(IPOS(1))
! maximum entre les 2 niveaux puisque WF calculee pour une couche finie ( discutable ?)
     MAXHEIGHT(JC)= 0.5_8 * ( PLEV(IPOS(1)) +  PLEV(IPOS(1)+1)  )

!*        IF CHANNEL DOESN'T SEE THE SURFACE, SEE WHERE dTAU/dlog(PLEV) BECOMES IMPORTANT
!*        FOR RECOMPUTATION OF MINP AND PMIN.

     DO J = NLEV-1, IPOS(1), -1
        IF ( ( WFUNC(J)/ MAXWF ) > 0.01_8) THEN
           MINP(JC) = J+1
           PMIN(JC) = MIN(PLEV(J+1),PS)
           EXIT
        END IF
     ENDDO
     
  END DO channels

END SUBROUTINE MIN_PRES_NEW

SUBROUTINE CLOUD_HEIGHT (PTOP,NTOP, &
     btobs,cldflag,tt,gz,ps,plev,nlev, &
     nchn,ichref,lev_start,iopt)
!
!**ID CLOUD_HEIGHT -- CLOUD TOP HEIGHT COMPUTATION
!
!       SCIENCE:  L. GARAND
!       AUTHOR:   A. BEAULNE (CMDA/SMC)   August 2004
!                 A. BEAULNE (CMDA/SMC) February 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   COMPUTATION OF CLOUD TOP HEIGHT (ABOVE THE GROUND)
!          BASED ON MATCHING OBSERVED BRIGHTNESS TEMPERATURE AT A 
!          REFERENCE SURFACE CHANNEL WITH BACKGROUND TEMPERATURE PROFILE.
!          TO USE WITH ONE REFERENCE CHANNEL. USED HERE ON MODEL LEVELS.
!
!       ARGUMENTS:
!          INPUT:
!            -BTOBS(NCHN) : OBSERVED BRIGHTNESS TEMPERATURE (DEG K)
!            -CLDFLAG    : CLEAR(0), CLOUDY(1), UNDEFINED(-1) PROFILES
!            -TT(NLEV)    : TEMPERATURE PROFILES (DEG K)
!            -GZ(NLEV)    : HEIGHT PROFILES ABOVE GROUND (M)
!            -PS(NPRF)         : SURFACE PRESSURE (HPA)
!            -PLEV(NLEV)  : PRESSURE LEVELS (HPA)
!            -NLEV             : NUMBER OF VERTICAL LEVELS
!            -NCHN             : NUMBER OF CHANNELS
!            -ICHREF     : CHOSEN REFERENCE SURFACE CHANNEL
!            -IOPT             : LEVELS USING PLEV (1) OR GZ (2)
!
!
!          INPUT/OUTPUT:
!            -LEV_START : LEVEL TO START ITERATION (IDEALLY TROPOPAUSE)
!
!          OUTPUT:
!            -PTOP    : CHOSEN EQUIVALENT CLOUD TOPS 
!                             (IN HPA|M WITH IOPT = 1|2) 
!            -NTOP    : NUMBER OF POSSIBLE PTOP SOLUTIONS
!
!
  IMPLICIT NONE
  integer ,intent (in) :: NCHN,NLEV,IOPT,ICHREF,CLDFLAG
  REAL(8) ,intent (in) :: BTOBS(NCHN),TT(NLEV),GZ(NLEV),PS,PLEV(NLEV)
  integer ,intent (inout) :: LEV_START
  REAL(8) ,intent (out) :: PTOP
  integer ,intent (out) :: NTOP
!**********************************************************************************************

  INTEGER     :: JN 
  INTEGER     :: ITOP
  INTEGER     :: NHT
  REAL(8)     :: HT(NLEV)
 
  IF ( IOPT == 1 ) THEN
     
     PTOP = PS
     NTOP = 1      

     IF ( CLDFLAG == -1 ) RETURN
     
     CALL GET_TOP ( HT,NHT, btobs(ichref),tt,plev,nlev,lev_start,iopt ) 

     ITOP = 1
     IF ( NHT >= 2 ) ITOP = 2
     PTOP = MIN ( HT(ITOP), PS )
     NTOP = NHT

  ELSEIF ( IOPT == 2 ) THEN

     PTOP = 0._8
     NTOP = 1      

     IF ( CLDFLAG == -1 ) RETURN

     CALL GET_TOP ( HT,NHT, btobs(ichref),tt,gz,nlev,lev_start,iopt )

     ITOP = 1
     IF ( NHT >= 2 ) ITOP = 2
     PTOP = MAX ( HT(ITOP), 0._8 )
     NTOP = NHT
       
  END IF

END SUBROUTINE CLOUD_HEIGHT
 
SUBROUTINE GARAND1998NADON (CLDFLAG, btobs,tg,tt,gz,nlev, &
     nchn,ptop_eq,ntop_eq,ichref)
!
!**ID GARAND1998NADON -- DETERMINE IF PROFILES ARE CLEAR OR CLOUDY
!
!       SCIENCE:  L. GARAND AND S. NADON
!       AUTHOR:   A. BEAULNE (CMDA/SMC)      June 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   DETERMINE IF THE PROFILES ARE CLEAR OR CLOUDY BASED ON
!          THE ALGORITHM OF GARAND & NADON 98 J.CLIM V11 PP.1976-1996
!          WITH CHANNEL IREF
!
!       ARGUMENTS:
!          INPUT:
!            -BTOBS(NCHN) : OBSERVED BRIGHTNESS TEMPERATURES (DEG K)
!            -TG         : GUESS SKIN TEMPERATURES (DEG K)
!            -TT(NLEV)    : GUESS TEMPERATURE PROFILES (DEG K)
!            -GZ(NLEV)    : GUESS HEIGHT PROFILE ABOVE GROUND (M)
!            -NLEV             : NUMBER OF VERTICAL LEVELS
!            -NCHN             : NUMBER OF CHANNELS
!            -PTOP_EQ    : CHOSEN EQUIVALENT CLOUD TOPS (M)
!            -NTOP_EQ    : NUMBER OF POSSIBLE PTOP_EQ SOLUTIONS
!            -ICHREF     : CHOSEN REFERENCE SURFACE CHANNEL
!
!          INPUT/OUTPUT:
!            -CLDFLAG(NPRF)  : CLEAR(0), CLOUDY(1), UNDEFINED(-1) PROFILES
!
  IMPLICIT NONE
  integer ,intent (in) :: NLEV,NCHN
  REAL(8) ,intent (in) :: BTOBS(NCHN),TG,GZ(NLEV),TT(NLEV),PTOP_EQ
  integer ,intent (in) :: NTOP_EQ,ICHREF
  integer ,intent (inout) :: CLDFLAG
!*********************************************************************************************
  INTEGER    :: NINV
  REAL(8)    :: LEV(2)

      
  LEV(1) = 222._8
  LEV(2) = 428._8


  IF ( CLDFLAG == -1 ) return

  IF ( BTOBS(ICHREF) >= TG-3._8 .AND. BTOBS(ICHREF) <= TG+3._8 ) THEN
     CLDFLAG = 0
     return
  END IF

  IF ( BTOBS(ICHREF) >= TG-4._8 .AND. BTOBS(ICHREF) <= TG-3._8 ) THEN
     IF ( PTOP_EQ > 1100._8 ) THEN
        CLDFLAG = 1
        return
     ELSE
        CLDFLAG = 0
        return
     END IF
  END IF
    
  IF ( PTOP_EQ > 728._8 ) THEN
     CLDFLAG = 1
     return
  END IF

  IF ( TG-BTOBS(ICHREF) > 8._8 ) THEN 
     IF ( NTOP_EQ >= 3 ) THEN
        IF ( PTOP_EQ > 73._8 ) THEN
           CLDFLAG=1
           return
        ELSE
           CLDFLAG=0
           return
        END IF
     ELSE
        CALL MONOTONIC_INVERSION (NINV, tg,tt,gz,nlev,lev(1))
        IF ( NINV == 1 ) THEN
           IF ( PTOP_EQ > 222._8 ) THEN
              CLDFLAG = 1
              return
           ELSE
              CLDFLAG = 0 
              return
           END IF
        ELSE
           CLDFLAG = 0
           return
        END IF
     END IF
  END IF
    
  IF ( TG-BTOBS(ICHREF) > 5._8 ) THEN
     IF ( NTOP_EQ >= 3 ) THEN
        IF ( PTOP_EQ > 222._8 ) THEN
           CLDFLAG = 1
           return
        ELSE
           CLDFLAG = 0
           return
        END IF
     ELSE
        CALL MONOTONIC_INVERSION (NINV, tg,tt,gz,nlev,lev(2))
        IF ( NINV == 1) THEN
           IF( PTOP_EQ > 428._8 ) THEN
              CLDFLAG = 1
              return
           ELSE
              CLDFLAG = 0
              return
           END IF
        ELSE
           CLDFLAG = 0
        END IF
     END IF
  ELSE
     CLDFLAG=0
  END IF

END SUBROUTINE GARAND1998NADON

SUBROUTINE MONOTONIC_INVERSION (NINVR, ptg,ptt,pgz,npr,lvl)

#if defined (DOC)
!***********************************************************************
!
!**ID MONOTONIC_INVERSION -- DETECT TEMPERATURE INVERSION
!
!       SCIENCE:  L. GARAND AND S. NADON
!       AUTHOR:   A. BEAULNE (CMDA/SMC)      June 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   DETERMINE IF THERE IS A PRESENCE (NINVR=1) OR NOT (NINVR=0)
!           OF A TEMPERATURE INVERSION GOING FROM THE SURFACE UP TO THE
!           HEIGHT LVL
!
!       ARGUMENTS:
!          INPUT:
!            -PTG       : SKIN TEMPERATURE (DEG K)
!            -PTT(NPR) : TEMPERATURE PROFILE (DEG K)
!            -PGZ(NPR) : HEIGHT PROFILE ABOVE GROUND (M)
!            -NPR     : NUMBER OF VERTICAL LVLELS
!            -LVL      : HEIGHT TO SEARCH FOR TEMPERATURE INVERSION (M)
!
!          OUTPUT:
!            -NINVR     : PRESENCE (1) OR NOT (0) OF A TEMPERATURE INVERSION
!                         FROM THE SURFACE TO HEIGHT LVL
!
!
!***********************************************************************
#endif


  IMPLICIT NONE
  integer ,intent (in) :: npr
  REAL(8),intent (in)  :: PTT(NPR),PGZ(NPR),PTG,LVL
  integer ,intent (out):: ninvr
!**************************************************
  INTEGER   :: NL

  NINVR = 0
  IF ( PTG - PTT(NPR) < 0._8 ) THEN
     NINVR = 1
     DO NL = NPR-1, 1, -1
        IF ( PGZ(NL) > LVL ) EXIT
        IF ( PTT(NL+1) - PTT(NL) > 0._8 ) THEN
           NINVR = 0
           EXIT
        END IF
     END DO
  END IF
    

END SUBROUTINE MONOTONIC_INVERSION

SUBROUTINE ESTIM_TS(TS, tg,emi,rcal,radobs,sfctau,cldflag, &
     ichref,nchn,nchnkept,satid,CINST)

!
!**ID ESTIM_TS -- GET AN ESTIMATED SKIN TEMPERATURE
!
!       AUTHOR:   L. GARAND                   May 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   GET AN ESTIMATED SKIN TEMPERATURE BY INVERSION OF
!          RADIATIVE TRANSFER EQUATION ASSUMING GUESS T AND Q PROFILES
!          ARE PERFECT. DESIGNED FOR A SINGLE CHANNEL ICHREF AND NPRF
!          PROFILES. ASSUMES A REAL TG (GUESS) OVER OCEANS AND A TG 
!          WITH HYPOTHESIS OF UNITY EMISSIVITY OVER LAND.
!      
!          USES:  RCAL = B(TG)*EMI*SFCTAU + ATMOS_PART
!             TS = B(TS)*EMI*SFCTAU + ATMOS_PART
!          SOLVES FOR TS
!
!       ARGUMENTS:
!          INPUT:
!            -TG          : GUESS SKIN TEMPERATURE (DEG K)
!            -EMI(NCHN)    : SURFACE EMISSIVITIES FROM WINDOW CHANNEL (0.-1.)
!            -RCAL(NCHN)   : COMPUTED CLEAR RADIANCES (MW/M2/SR/CM-1)
!            -RADOBS(NCHN) : OBSERVED RADIANCES (")
!            -SFCTAU(NCHN) : SURFACE TO SPACE TRANSMITTANCES (0.-1.)
!            -CLDFLAG     : CLEAR(0), CLOUDY(1) OR UNDEFINED(-1) PROFILES
!            -ICHREF      : REFERENCE SURFACE CHANNEL (SUBSET VALUES)
!            -NCHN              : NUMBER OF CHANNELS
!            -NCHNKEPT          : NUMBER OF CHANNELS KEPT IN CMA
!            -SATID             : SATELLITE IDENTYFIER
!            -CINST             : INTRUMENT CrIS, IASI or AIRS
!
!          OUTPUT:
!            -TS          : RETRIEVED SKIN TEMPERATURE (-1. FOR MISSING)
!
  use tovs_nl_mod
  use hir_chans

  IMPLICIT NONE
  integer ,intent(in) :: NCHN,NCHNKEPT,satid
  integer ,intent(in) :: ICHREF,CLDFLAG
  REAL(8) ,intent(in) :: TG,EMI(NCHN),RCAL(NCHN),RADOBS(NCHN)
  REAL(8) ,intent(in) :: SFCTAU(NCHN)
  CHARACTER (LEN=*)  ,intent(in) :: CINST
  REAL(8) ,intent(out):: TS
!************************************************************************************
  INTEGER    :: JC
  INTEGER    :: ICHN,INDX
  REAL(8)    :: RTG,RADTG(NCHN)
  REAL(8)    :: RADTS,TS1(NCHN),tstore,t_effective
  integer    :: ptc(NCHNKEPT)


  TS1(:) = -1._8
  TS = -1._8
  RADTG(:) = -1._8

  if (NCHNKEPT/=hir_get_nchan_selected(CINST)) then
     Write(*,*) "Invalid NCHNKEPT: ",NCHNKEPT,hir_get_nchan_selected(CINST),CINST
     call abort3d("estim_ts")
  endif


  DO JC=  1, NCHNKEPT
     ptc(JC)=hir_get_chindx_fr_chn(CINST,ichan(JC,SATID))
  END DO


!*    transform guess skin temperature to plank radiances 

  IF ( CLDFLAG /= -1 ) THEN
     DO JC = 1, NCHNKEPT
        t_effective =  coefs(satid)%coef%ff_bco(jc) + coefs(satid)%coef%ff_bcs(jc) * TG
        
        indx=ptc(jc)
        
        RADTG(indx) =  coefs(satid)%coef%planck1(jc) / &
             ( Exp( coefs(satid)%coef%planck2(jc)/t_effective ) - 1.0_8 )
     END DO
  ENDIF
      

  IF ( CLDFLAG /= 0 ) RETURN

!*   compute TOA planck radiances due to guess skin planck radiances

  RTG =   RADTG(ICHREF)*EMI(ICHREF)*SFCTAU(ICHREF)

!*   compute true skin planck radiances due to TOA true planck radiances

  RADTS = ( RADOBS(ICHREF) + RTG - RCAL(ICHREF) ) / &
       ( EMI(ICHREF) * SFCTAU(ICHREF) )
    
!*   transform true skin planck radiances to true skin temperatures

  DO JC = 1, NCHNKEPT
     tstore = coefs(satid)%coef%planck2(jc) / Log( 1+coefs(satid)%coef%planck1(jc)/RADTS )
     indx=ptc(jc)
     TS1(indx) = ( tstore-coefs(satid)%coef%ff_bco(jc) ) / coefs(satid)%coef%ff_bcs(jc)
  END DO
    
  TS = TS1(ichref)


END SUBROUTINE ESTIM_TS

SUBROUTINE ESTIM_TS_AVHRR(TS, tg,emi,rcal,radobs,sfctau,cldflag, &
     ichref,nchn)
!
!**ID ESTIM_TS -- GET AN ESTIMATED SKIN TEMPERATURE
!
!       AUTHOR:   L. GARAND                   May 2004
!                 A. BEAULNE (CMDA/SMC)     March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   GET AN ESTIMATED SKIN TEMPERATURE BY INVERSION OF
!          RADIATIVE TRANSFER EQUATION ASSUMING GUESS T AND Q PROFILES
!          ARE PERFECT. DESIGNED FOR A SINGLE CHANNEL ICHREF AND NPRF
!          PROFILES. ASSUMES A REAL TG (GUESS) OVER OCEANS AND A TG 
!          WITH HYPOTHESIS OF UNITY EMISSIVITY OVER LAND.
!      
!          USES:  RCAL = B(TG)*EMI*SFCTAU + ATMOS_PART
!             TS = B(TS)*EMI*SFCTAU + ATMOS_PART
!          SOLVES FOR TS
!
!       ARGUMENTS:
!          INPUT:
!            -TG          : GUESS SKIN TEMPERATURE (DEG K)
!            -EMI(NCHN)    : SURFACE EMISSIVITIES FROM WINDOW CHANNEL (0.-1.)
!            -RCAL(NCHN)   : COMPUTED CLEAR RADIANCES (MW/M2/SR/CM-1)
!            -RADOBS(NCHN) : OBSERVED RADIANCES (")
!            -SFCTAU(NCHN) : SURFACE TO SPACE TRANSMITTANCES (0.-1.)
!            -CLDFLAG     : CLEAR(0), CLOUDY(1) OR UNDEFINED(-1) PROFILES
!            -ICHREF      : REFERENCE SURFACE CHANNEL (SUBSET VALUES)
!            -NCHN              : NUMBER OF CHANNELS
!
!          OUTPUT:
!            -TS          : RETRIEVED SKIN TEMPERATURE (-1. FOR MISSING)
!
!

  IMPLICIT NONE
  integer ,intent(in) :: nchn
  integer ,intent(in) :: ichref,CLDFLAG
  REAL(8) ,intent(in) :: TG,EMI(NCHN),RCAL(NCHN),RADOBS(NCHN)
  REAL(8) ,intent(in) :: SFCTAU(NCHN)
  REAL(8) ,intent(out):: TS
!***************************************
  INTEGER    :: JC
  INTEGER    :: ICHN
  REAL(8)    :: RTG,RADTG(NCHN)
  REAL(8)    :: RADTS,TS1(NCHN),tstore,t_effective

  TS1(:) = -1._8
  TS = -1._8
  RADTG(:) = -1._8

!*    transform guess skin temperature to plank radiances 


  IF ( CLDFLAG /= -1 ) THEN

     DO JC = 1, NCHN
        t_effective =  coefs_avhrr%coef%ff_bco(jc) + coefs_avhrr%coef%ff_bcs(jc) * TG
        RADTG(JC) =  coefs_avhrr%coef%planck1(jc) / &
             ( Exp( coefs_avhrr%coef%planck2(jc)/t_effective ) - 1.0_8 )
     END DO
  ENDIF

  IF ( CLDFLAG /= 0 ) RETURN

!*   compute TOA planck radiances due to guess skin planck radiances

  RTG =   RADTG(ICHREF)*EMI(ICHREF)*SFCTAU(ICHREF)
       
!*   compute true skin planck radiances due to TOA true planck radiances

  RADTS = ( RADOBS(ICHREF) + RTG - RCAL(ICHREF) ) / &
       ( EMI(ICHREF) * SFCTAU(ICHREF) )

!*   transform true skin planck radiances to true skin temperatures

  DO JC = 1, NCHN
     tstore = coefs_avhrr%coef%planck2(jc) / Log( 1+coefs_avhrr%coef%planck1(jc)/RADTS )
     TS1(JC) = ( tstore-coefs_avhrr%coef%ff_bco(jc) ) / coefs_avhrr%coef%ff_bcs(jc)
  END DO
  TS = TS1(ichref)
    
END SUBROUTINE ESTIM_TS_AVHRR

SUBROUTINE CLOUD_TOP ( PTOP_BT,PTOP_RD,NTOP_BT,NTOP_RD,  &
     btobs,tt,gz,rcal,ps,robs,rcld,plev,nlev,nchn, &
     cldflag,rejflag,lev_start,iopt,ihgt,ichref,nch,ilist)
!
!**ID CLOUD_TOP -- CLOUD TOP HEIGHT COMPUTATION
!
!       AUTHOR:   L. GARAND             August 2004
!                 A. BEAULNE (CMDA/SMC)  March 2006  (ADAPT TO 3DVAR)      
!                
!       REVISION:  001 S. Heilliette: removal of hard-coded rttov level
!
!       OBJECT:   COMPUTATION OF CLOUD TOP HEIGHT (ABOVE THE GROUND)
!          BASED ON MATCHING OBSERVED BRIGHTNESS TEMPERATURE WITH 
!          BACKGROUND TEMPERATURE PROFILES AND/OR COMPUTED OBSERVED
!          RADIANCES WITH BACKGROUND RADIANCE PROFILES.
!          TO USE WITH MORE THAN ONE CHANNEL. USED HERE ON RTTOV LEVELS.
!
!       ARGUMENTS:
!          INPUT:
!            -BTOBS(NCHN)     : OBSERVED BRIGHTNESS TEMPERAUTRES (DEG K)
!            -TT(NLEV)        : TEMPERATURE PROFILES (DEG K)
!            -GZ(NLEV)        : HEIGHT PROFILES ABOVE GROUND (M)
!            -RCAL(NCHN)      : COMPUTED CLEAR RADIANCES (MW/M2/SR/CM-1)
!            -PS            : SURFACE PRESSURE (HPA)
!            -ROBS(NCHN)      : COMPUTED OBSERVED RADIANCES (MW/M2/SR/CM-1)
!            -RCLD(NCHN,NLEV) : COMPUTED CLOUD RADIANCES FROM EACH LEVEL (")
!            -PLEV(NLEV)           : PRESSURE LEVELS (HPA)
!            -NLEV                 : NUMBER OF VERTICAL LEVELS
!            -NCHN                 : NUMBER OF CHANNELS
!            -CLDFLAG        : CLEAR(0), CLOUDY(1), UNDEFINED(-1) PROFILES
!            -REJFLAG(NCHN,0:BITFLAG) : FLAGS FOR REJECTED OBSERVATIONS
!            -IOPT                 : LEVELS USING PLEV (1) OR GZ (2)
!            -IHGT                 : GET *_BT* ONLY (0), *_RD* ONLY (1), BOTH (2)
!            -ICHREF         : REFERENCE SURFACE CHANNEL (SUBSET VALUE)
!            -NCH                  : NUMBER OF CHANNELS WE WANT OUTPUTS
!            -ILIST(NCH )          : LIST OF THE CHANNEL NUMBERS (SUBSET VALUES) 
!
!          INPUT/OUTPUT:
!            -LEV_START      : LEVEL TO START ITERATION (IDEALLY TROPOPAUSE)
!
!          OUTPUT:
!            -PTOP_BT(NCHN)  : CHOSEN EQUIVALENT CLOUD TOPS BASED ON 
!                                    BRIGHTNESS TEMPERATURES (IN HPA|M WITH IOPT = 1|2)
!            -PTOP_RD(NCHN)  : CHOSEN EQUIVALENT CLOUD TOPS BASED ON 
!                                    RADIANCES (IN HPA|M WITH IOPT = 1|2)
!            -NTOP_BT       : NUMBER OF POSSIBLE PTOP_BT SOLUTIONS
!            -NTOP_RD       : NUMBER OF POSSIBLE PTOP_RD SOLUTIONS
!
  IMPLICIT NONE
  integer, intent (in) :: NCHN,NCH,NLEV,IOPT,IHGT
  REAL(8), intent (in) :: BTOBS(NCHN),RCLD(NCHN,NLEV)
  REAL(8), intent (in) :: ROBS(NCHN),RCAL(NCHN)
  REAL(8), intent (in) :: TT(NLEV),GZ(NLEV),PLEV(NLEV),PS
  integer, intent (in) :: REJFLAG(NCHN,0:BITFLAG),ILIST(NCH),CLDFLAG,ICHREF
  integer, intent (inout) :: LEV_START
  REAL(8), intent (out) ::  PTOP_BT(NCHN),PTOP_RD(NCHN)
  INTEGER, intent (out) ::  NTOP_BT(NCHN),NTOP_RD(NCHN)
!******************************************************************
  INTEGER      ::  JCH,JC,ITOP,NHT,i10,i
  INTEGER      ::  SUMREJ
  REAL(8)      ::  HT(NLEV)

      
  i10=1
  DO I=2,NLEV
     IF (plev(i-1)<=100._8 .AND. plev(i)>100._8) THEN
        I10=I
        EXIT
     ENDIF
  ENDDO

  PTOP_BT(:) = -10._8
  PTOP_RD(:) = -10._8

  NTOP_BT(:) = 0._8
  NTOP_RD(:) = 0._8

!**     profile not assimilated if data from 2 windows channels bad

  IF ( CLDFLAG == -1 ) RETURN

!**     predetermined clear

  SUMREJ = SUM(REJFLAG(ICHREF,:))

  IF ( SUMREJ == 0 ) THEN
        
     IF ( IOPT == 1 ) THEN
        PTOP_BT(:) = MIN ( PLEV(NLEV), PS )
        PTOP_RD(:) = MIN ( PLEV(NLEV), PS )
     ELSE IF ( IOPT == 2 ) THEN
        PTOP_BT(:) = 0._8
        PTOP_RD(:) = 0._8
     END IF
     
     NTOP_BT(:) = 1
     NTOP_RD(:) = 1
     
     LEV_START = MAX ( LEV_START , i10 )
        
     RETURN

  END IF


  channels: DO JCH = 1, NCH
       
     JC = ILIST(JCH)
       
       !**       gross check failure

     IF ( REJFLAG(JC,9) == 1 ) CYCLE channels

!**       no clouds if observed radiance warmer than clear estimate

     IF ( ROBS(JC) > RCAL(JC) ) THEN

        IF ( IOPT == 1 ) THEN
           PTOP_BT(JC) = MIN ( PLEV(NLEV), PS )
           PTOP_RD(JC) = MIN ( PLEV(NLEV), PS )
        ELSE IF ( IOPT == 2 ) THEN
           PTOP_BT(JC) = 0._8
           PTOP_RD(JC) = 0._8
        END IF

        NTOP_BT(JC) = 1
        NTOP_RD(JC) = 1

        CYCLE channels
           
     END IF

!**       cloudy

     IF ( REJFLAG(JC,11) == 1 .and. REJFLAG(JC,23) == 1 ) THEN
        
        IF ( IOPT == 1 ) THEN

           IF ( IHGT == 0 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, btobs(jc),tt,plev,nlev,lev_start,iopt) 
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_BT(JC) = MIN ( HT(ITOP), PS )
              NTOP_BT(JC) = NHT
           END IF
              
           IF ( IHGT == 1 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, robs(jc),rcld(jc,:),plev,nlev,lev_start,iopt)
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_RD(JC) = MIN ( HT(ITOP), PS )
              NTOP_RD(JC) = NHT
           END IF

        ELSE IF ( IOPT == 2 ) THEN 
             
           IF ( IHGT == 0 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, btobs(jc),tt,gz,nlev,lev_start,iopt) 
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_BT(JC) = MAX ( HT(ITOP), 0._8 )
              NTOP_BT(JC) = NHT
           END IF

           IF ( IHGT == 1 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, robs(jc),rcld(jc,:),gz,nlev,lev_start,iopt)
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_RD(JC) = MAX ( HT(ITOP), 0._8 )
              NTOP_RD(JC) = NHT
           END IF
           
        END IF
        
     END IF
     
  END DO channels

END SUBROUTINE CLOUD_TOP

SUBROUTINE CLOUD_TOP_AVHRR ( PTOP_BT,PTOP_RD,NTOP_BT,NTOP_RD,  &
     btobs,tt,gz,rcal,ps,robs,rcld,plev,nlev,nchn, &
     cldflag,lev_start,iopt,ihgt,nch,ilist)
!
!**ID CLOUD_TOP -- CLOUD TOP HEIGHT COMPUTATION
!
!       AUTHOR:   L. GARAND             August 2004
!                 A. BEAULNE (CMDA/SMC)  March 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION: 001 S. Heilliette:
!                     -to remove hard-coded rttov pressure level numbers
!
!       OBJECT:   COMPUTATION OF CLOUD TOP HEIGHT (ABOVE THE GROUND)
!          BASED ON MATCHING OBSERVED BRIGHTNESS TEMPERATURE WITH 
!          BACKGROUND TEMPERATURE PROFILES AND/OR COMPUTED OBSERVED
!          RADIANCES WITH BACKGROUND RADIANCE PROFILES.
!          TO USE WITH MORE THAN ONE CHANNEL. USED HERE ON RTTOV LEVELS.
!
!       ARGUMENTS:
!          INPUT:
!            -BTOBS(NCHN)     : OBSERVED BRIGHTNESS TEMPERAUTRES (DEG K)
!            -TT(NLEV)        : TEMPERATURE PROFILES (DEG K)
!            -GZ(NLEV)        : HEIGHT PROFILES ABOVE GROUND (M)
!            -RCAL(NCHN)      : COMPUTED CLEAR RADIANCES (MW/M2/SR/CM-1)
!            -PS             : SURFACE PRESSURE (HPA)
!            -ROBS(NCHN)      : COMPUTED OBSERVED RADIANCES (MW/M2/SR/CM-1)
!            -RCLD(NCHN,NLEV) : COMPUTED CLOUD RADIANCES FROM EACH LEVEL (")
!            -PLEV(NLEV)           : PRESSURE LEVELS (HPA)
!            -NLEV                 : NUMBER OF VERTICAL LEVELS
!            -NCHN                 : NUMBER OF CHANNELS
!            -CLDFLAG        : CLEAR(0), CLOUDY(1), UNDEFINED(-1) PROFILES
!            -IOPT                 : LEVELS USING PLEV (1) OR GZ (2)
!            -IHGT                 : GET *_BT* ONLY (0), *_RD* ONLY (1), BOTH (2)
!            -NCH                  : NUMBER OF CHANNELS WE WANT OUTPUTS
!            -ILIST(NCH)           : LIST OF THE CHANNEL NUMBERS (SUBSET VALUES) 
!
!          INPUT/OUTPUT:
!            -LEV_START      : LEVEL TO START ITERATION (IDEALLY TROPOPAUSE)
!
!          OUTPUT:
!            -PTOP_BT(NCHN)  : CHOSEN EQUIVALENT CLOUD TOPS BASED ON 
!                                    BRIGHTNESS TEMPERATURES (IN HPA|M WITH IOPT = 1|2)
!            -PTOP_RD(NCHN)  : CHOSEN EQUIVALENT CLOUD TOPS BASED ON 
!                                    RADIANCES (IN HPA|M WITH IOPT = 1|2)
!            -NTOP_BT(NCHN)  : NUMBER OF POSSIBLE PTOP_BT SOLUTIONS
!            -NTOP_RD(NCHN)  : NUMBER OF POSSIBLE PTOP_RD SOLUTIONS
!
  IMPLICIT NONE
  INTEGER ,intent(in) :: NCH,IOPT,IHGT,NLEV,NCHN
  INTEGER ,intent(in) :: ILIST(NCH),CLDFLAG
  REAL(8) ,intent(in) ::  PLEV(NLEV),PS
  REAL(8) ,intent(in) ::  ROBS(NCHN),RCAL(NCHN)
  REAL(8) ,intent(in) ::  BTOBS(NCHN),RCLD(NCHN,NLEV)
  REAL(8) ,intent(in) ::  TT(NLEV),GZ(NLEV)
  INTEGER ,intent(inout) :: LEV_START
  REAL(8) ,intent(out) ::  PTOP_BT(NCHN),PTOP_RD(NCHN)
  INTEGER ,intent(out) ::  NTOP_BT(NCHN),NTOP_RD(NCHN)
!*********************************************************************
  INTEGER      ::  JCH,JC,ITOP,NHT,i10,i
  REAL(8)      ::  HT(NLEV)
     
  i10=1
  DO I=2,NLEV
     IF (plev(i-1)<=100._8 .AND. plev(i)>100._8) THEN
        I10=I
        EXIT
     ENDIF
  ENDDO
    
  PTOP_BT(:) = -10._8
  PTOP_RD(:) = -10._8

  NTOP_BT(:) = 0._8
  NTOP_RD(:) = 0._8


!**     profile not assimilated if data from 2 windows channels bad

  IF ( CLDFLAG == -1 ) RETURN

!**     predetermined clear

        
  IF ( CLDFLAG ==0 ) THEN
        
     IF ( IOPT == 1 ) THEN
        PTOP_BT(:) = MIN ( PLEV(NLEV), PS )
        PTOP_RD(:) = MIN ( PLEV(NLEV), PS )
     ELSE IF ( IOPT == 2 ) THEN
        PTOP_BT(:) = 0._8
        PTOP_RD(:) = 0._8
     END IF
       
     NTOP_BT(:) = 1
     NTOP_RD(:) = 1

     LEV_START = MAX ( LEV_START , i10 )
       
     RETURN

  END IF

  channels: DO JCH = 1, NCH

     JC = ILIST(JCH)

!**       gross check failure

     IF ( BTOBS(JC)<150._8 .or. BTOBS(JC)>350._8) CYCLE channels

!**       no clouds if observed radiance warmer than clear estimate
     
     IF ( ROBS(JC) > RCAL(JC) ) THEN
          
        IF ( IOPT == 1 ) THEN
           PTOP_BT(JC) = MIN ( PLEV(NLEV), PS )
           PTOP_RD(JC) = MIN ( PLEV(NLEV), PS )
        ELSEIF ( IOPT == 2 ) THEN
           PTOP_BT(JC) = 0._8
           PTOP_RD(JC) = 0._8
        END IF
           
        NTOP_BT(JC) = 1
        NTOP_RD(JC) = 1

        CYCLE channels

     END IF

!**       cloudy

     IF ( CLDFLAG ==1 ) THEN

        IF ( IOPT == 1 ) THEN

           IF ( IHGT == 0 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, btobs(jc),tt,plev,nlev,lev_start,iopt) 
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_BT(JC) = MIN ( HT(ITOP), PS )
              NTOP_BT(JC) = NHT
           END IF
              
           IF ( IHGT == 1 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, robs(jc),rcld(jc,:),plev,nlev,lev_start,iopt)
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_RD(JC) = MIN ( HT(ITOP), PS )
              NTOP_RD(JC) = NHT
           END IF
           
        ELSE IF ( IOPT == 2 ) THEN 
              
           IF ( IHGT == 0 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, btobs(jc),tt,gz,nlev,lev_start,iopt) 
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_BT(JC) = MAX ( HT(ITOP), 0._8 )
              NTOP_BT(JC) = NHT
           END IF

           IF ( IHGT == 1 .OR. IHGT == 2 ) THEN
              CALL GET_TOP ( HT,NHT, robs(jc),rcld(jc,:),gz,nlev,lev_start,iopt)
              ITOP = 1
              IF ( NHT >= 2 ) ITOP = 2
              PTOP_RD(JC) = MAX ( HT(ITOP), 0._8 )
              NTOP_RD(JC) = NHT
           END IF
              
        END IF
           
     END IF

  END DO channels

END SUBROUTINE CLOUD_TOP_AVHRR

SUBROUTINE GET_TOP (HT,NHT, bt,tt,pp,nlev,lev_start,iopt)

#if defined (DOC)
!**************************************************************************
!
!**ID GET_TOP -- CLOUD TOP HEIGHT COMPUTATION
!
!       AUTHOR:   L. GARAND                       2004
!                 A. BEAULNE (CMDA/SMC)  February 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   COMPUTATION OF CLOUD TOP HEIGHT AND NUMBER OF POSSIBLE HEIGHTS
!
!       ARGUMENTS:
!          INPUT:
!            -BT        : OBSERVED BRIGHTNESS TEMPERATURES (DEG K)
!                          OR COMPUTED OBSERVED RADIANCES (MW/M2/SR/CM-1)
!            -TT(NLEV)  : TEMPERATURE PROFILE (DEG K)
!                          OR COMPUTED CLOUD RADIANCE FROM EACH LEVEL TO TOP (")
!            -PP(NLEV)  : PRESSURE (HPA) OR HEIGHTS (M) PROFILE (IOPT=1 OR 2)
!            -NLEV      : NUMBER OF VERTICAL LEVELS
!            -IOPT      : HEIGHT UNITS IN HPA (1) OR IN METERS (2)
!
!          INPUT/OUTPUT:
!            -LEV_START : LEVEL TO START ITERATION (IDEALLY TROPOPAUSE)
!                         (IF <= 0, SEARCH & START AT COLDEST LEVEL)
!
!          OUTPUT:
!            -HT(NLEV)  : CLOUD TOP HEIGHT IN HPA OR METERS (IOPT = 1 OR 2)
!            -NHT       : NUMBER OF POSSIBLE CLOUD HEIGHT SOLUTIONS
!
!***************************************************************************
#endif

  IMPLICIT NONE
  integer ,intent   (in) :: NLEV,IOPT
  integer ,intent (inout) :: lev_start
  REAL(8)  ,intent (in) :: BT, TT(NLEV), PP(NLEV)
  REAL(8)  ,intent (out) :: HT(NLEV)
  integer ,intent (out) :: NHT
!*******************************************************
     
  INTEGER   :: I, IM, i10
  REAL(8)   :: P(NLEV)
  REAL(8)   :: DT, A, AA, B

  HT(:) = -1.
    
  IF (IOPT==1) P(:) = LOG(PP(:))


  IM = LEV_START


  IF ( LEV_START <= 0 ) THEN

!*      SEARCH INDEX IM WHERE TT IS MINIMUM

     CALL FMIN (IM, tt,nlev)
  
     i10=-1
     DO I=2,NLEV
        IF (pp(i-1)<=100._8 .AND. pp(i)>100._8) THEN
           I10=I
           EXIT
        ENDIF
     ENDDO
       
     LEV_START = IM
     
     IF ( IM == NLEV ) THEN
        LEV_START = MAX(LEV_START,i10)
        NHT = 1
        HT(1) = PP(NLEV)
        RETURN
     ENDIF
       
  END IF


  NHT = 0        
    
  DO I = IM, NLEV-1
     DT = TT(I+1) - TT(I) + 1.D-12
     IF ( BT > TT(I) .AND. BT <= TT(I+1) ) THEN

        NHT      = NHT+1

        IF (IOPT==1) then
           A    = P(I) + (P(I+1)-P(I))/DT*(BT-TT(I))
           HT(NHT)=EXP(A)
        ENDIF

        IF (IOPT==2) then
           B    = PP(I) + (PP(I+1)-PP(I))/DT*(BT-TT(I))
           HT(NHT)=B
        ENDIF
         
     ELSE IF ( BT >= TT(I+1) .AND. BT < TT(I) ) THEN

        NHT      = NHT+1

        IF(IOPT==1) THEN
           A    = P(I+1)- (P(I+1)-P(I))/DT* (TT(I+1)-BT)
           HT(NHT)=EXP(A)
        ENDIF

        IF(IOPT==2) THEN
           B    = PP(I+1)- (PP(I+1)-PP(I))/DT* (TT(I+1)-BT)
           HT(NHT)=B
        ENDIF
       
     ENDIF
  END DO
    
    
  IF ( NHT == 0 .AND. BT < TT(IM) )  THEN
     NHT  = 1
     HT(1) = PP(IM)
  ELSE IF ( NHT == 0 .AND. BT > TT(NLEV) )  THEN
     NHT   = 1
     HT(1) = PP(NLEV)
  ENDIF
    
END SUBROUTINE GET_TOP

SUBROUTINE FMIN ( IMIN, f, ndim )

#if defined (DOC)
!***********************************************************************
!
!**ID FMIN -- SEARCH MINIMUM VALUE OF VECTOR
!
!       AUTHOR:   L. GARAND
!                 A. BEAULNE (CMDA/SMC)  February 2006  (ADAPT TO 3DVAR)                 
!
!       REVISION:
!
!       OBJECT:   SEARCH THE POSITION IN VECTOR F WHERE VALUE IF MINIMUM
!
!       ARGUMENTS:
!          INPUT:
!            -F     : 1D VECTOR
!            -NDIM  : VECTOR DIMENSION
!
!          OUTPUT:
!            -IM    : INDEX OF VECTOR F WHERE VALUE IS MINIMUM
!
!
!***********************************************************************
#endif

  integer,intent (in) :: ndim
  REAL(8),intent (in) :: f(ndim)
  integer,intent (out):: imin
!*********************************
  INTEGER  :: I
  REAL(8)  :: X


  IMIN = 1
  X  = F(1)
    
  DO I=2,NDIM
     IF (F(I)<X) THEN
        X=F(I)
        IMIN=I
     END IF
  END DO
    

END SUBROUTINE FMIN

subroutine get_avhrr_emiss(iasi_surfem1,freqiasi,nchaniasi,avhrr_surfem1)
! choisi l'emissivit d'un canal IASI proche pour AVHRR
! a raffiner pour prendre en  compte la largeur  des canaux AVHRR ??
  implicit none
  integer ,intent(in) :: nchaniasi
  real (8) ,intent (in) :: iasi_surfem1 ( nchaniasi )
  real (8) ,intent (in) :: freqiasi( nchaniasi )
  real (8) ,intent (out):: avhrr_surfem1( NIR )
!****************************
  real (8),parameter :: freqavhrr(NIR)= (/0.2687000000D+04 , 0.9272000000D+03 , 0.8377000000D+03/)
  INTEGER,save :: indxavhrr(NIR)
  LOGICAL ,SAVE :: FIRST=.true.
  integer :: i,pos(1)
!*************************************************************8
  IF (FIRST) THEN
     DO I=1,NIR
        pos=minloc ( ABS (freqiasi(:)-freqavhrr(I)) )
        indxavhrr(i)=pos(1)
     ENDDO
     FIRST=.false.
  ENDIF
  DO I=1,NIR
     avhrr_surfem1(i)=iasi_surfem1(indxavhrr(i))
  ENDDO
  
end subroutine get_avhrr_emiss
 
subroutine tovs_rttov_AVHRR_for_IASI (iptobs,surfem1_avhrr,idiasi)
#if defined (doc)
!
!**s/r tovs_rttov_AVHRR_for_IASI  - Computation of forward radiance with rttov_direct
!                   (for AVHRR)
!
!
!author        : S. Heilliette
!
!revision 001  : s. heilliette october 2010
!                  - adaptation to rttov 10.0
!    -------------------
!     purpose:
!
!arguments
!

! appel de RTTOV pour le calcul des radiances AVHRR
! (non assimilees mais necessaires au background check IASI)

#endif
  Use tovs_nl_mod 
  implicit none
#include "rttov_setup.interface"
#include "rttov_direct2.interface"
#include "rttov_alloc_rad.interface"
  integer ,intent(in) :: idiasi
  integer ,intent (in) :: iptobs(1)
  real (8) , intent (in) :: surfem1_avhrr(3)
!*********************************************************************
  type (rttov_options ),save :: opts_avhrr
  type (rttov_chanprof)  :: chanprof(3)
  real(8) :: emissivity_out (3)
  real(8) :: cloudemissivity (3)
  logical :: calcemis  (3)
  INTEGER ::  list_sensor (3),setup_errorstatus
  integer, save :: idiasi_old=-1
  integer :: ich,i,j,jn,ichn
  integer :: VERBOSITY_LEVEL,ERR_UNIT=0
  integer :: ichan_avhrr (NIR)
  integer :: joff,ioffset
  type ( transmission_Type )  :: transmission
  type ( radiance_type )      :: radiancedata_d
  integer :: nchannels
  integer :: asw,nlevels,errorstatus,io
!***********************************************
  
  IF (IDIASI_OLD/=IDIASI) THEN
     VERBOSITY_LEVEL = 3
     LIST_SENSOR(1)=10
     LIST_SENSOR(2)=idiasi
     LIST_SENSOR(3)=5
     DO ICH=1,NIR
        ICHAN_AVHRR(ICH)=ICH
     ENDDO

     opts_avhrr%ipcreg=-1         ! index of the rquired PC predictors... to see later
     opts_avhrr%addinterp=.false. ! 
     opts_avhrr%addpc=.false.     ! to carry out principal component calculations 
     opts_avhrr%addradrec=.false. ! to reconstruct radiances from principal components
     opts_avhrr%addsolar=.false.  ! to model solar component in the near IR (2000 cm-1 et plus)
     opts_avhrr%addaerosl=.false. ! to account for scattering due to aerosols
     opts_avhrr%addclouds=.false. ! to account for scattering due to clouds
     opts_avhrr%switchrad=.true.  ! to use brightness temperature (true) or radiance (false) units in AD routine
     opts_avhrr%lgradp=.false.    ! allow tl/ad of user pressure levels 
     opts_avhrr%use_q2m=.false.   ! if true use of surface humidity
     opts_avhrr%apply_reg_limits=.false. ! if true application of profiles limits
     opts_avhrr%verbose_checkinput_warnings=.false. ! useful for debuging the code should be turned off later
     opts_avhrr%ozone_data=.true. ! profil d'ozone disponible
     opts_avhrr%clw_data=.false.  ! profil d'eau liquide pas disponible
     opts_avhrr%addrefrac=.false. ! to account for atmospheric refraction (useless)
     opts_avhrr%do_checkinput=.true. ! to check if input profiles are within absolute and regression limits

     setup_errorstatus=0

     if (IDIASI_OLD>0) then
        call rttov_dealloc_coefs(setup_errorstatus, coefs_avhrr )
        if ( setup_errorstatus/=0) then
           write(*,*) "Probleme dans rttov_dealloc_coefs !"
           call abort3d("tovs_rttov_AVHRR_for_IASI")
        endif
     endif

     call rttov_setup (&
          setup_errorstatus,&! out
          err_unit,         &! in
          verbosity_level,  &! in
          opts_avhrr,       &! in
          coefs_avhrr,      &! out
          list_sensor,      &! in
          ichan_avhrr  )     ! in Optional 
       
     if ( setup_errorstatus/=0) then
        write(*,*) "Probleme dans rttov_setup!"
        call abort3d("tovs_rttov_AVHRR_for_IASI")
     endif

     opts_avhrr%co2_data = ( coefs_avhrr%coef%nco2 > 0 )
     opts_avhrr%n2o_data = ( coefs_avhrr%coef%nn2o > 0 )
     opts_avhrr%co_data  = ( coefs_avhrr%coef%nco  > 0 )
     opts_avhrr%ch4_data = ( coefs_avhrr%coef%nch4 > 0 )
     
     IDIASI_OLD=IDIASI
   
  ENDIF


  nlevels=coefs_avhrr % coef % nlevels
  
  nchannels=NIR

  calcemis(:)=.false.

  ! Build the list of channels/profiles indices
  ichn = 0
  DO  ich = 1,NIR
     ichn = ichn +1
     chanprof(ichn)%prof=1
     chanprof(ichn)%chan=ich
  End Do


  cloudemissivity(:) = 0._8

! allocate transmittance structure

  call tovs_allocate_transmission(transmission,nchannels,nlevels)

! allocate radiance structure

  asw=1 ! 1 to allocate,0 to deallocate
  call rttov_alloc_rad (errorstatus,nchannels,radiancedata_d,nlevels-1,asw)
  if (errorstatus/=0) THEN
     Write(*,*) "Error in radiance allocation",errorstatus
     call abort3d("tovs_rttov_AVHRR_for_IASI")
  ENDIF
   

  Call rttov_direct2(    &
       errorstatus,      & ! out
       chanprof,         & ! in
       opts_avhrr,       & ! in
       profiles(iptobs(:)), & ! in
       coefs_avhrr,      & ! in
       calcemis,         & ! in
       surfem1_avhrr,    & ! inout
       emissivity_out,   & ! out
       cloudemissivity,  & ! inout
       transmission,     & ! inout
       radiancedata_d  )   ! inout
    
  io=iptobs(1)
  avhrr_bgck(io)% RADCLEARCALC(NVIS+1:NVIS+NIR) = radiancedata_d % clear(1:NIR)
  avhrr_bgck(io)% TBCLEARCALC(NVIS+1:NVIS+NIR)  = radiancedata_d % bt(1:NIR)
  avhrr_bgck(io)% RADOVCALC(1:nlevels-1,NVIS+1:NVIS+NIR) = radiancedata_d % overcast(1:nlevels-1,1:NIR)
  avhrr_bgck(io)% TRANSMCALC(1:nlevels,NVIS+1:NVIS+NIR) =  transmission % tau_levels(1:nlevels,1:NIR)
  avhrr_bgck(io)% EMISS(NVIS+1:NVIS+NIR) = emissivity_out(1:NIR)
  avhrr_bgck(io)% TRANSMSURF(NVIS+1:NVIS+NIR) = transmission% tau_total(1:NIR)

  call tovs_deallocate_transmission(transmission)
  asw=0 ! 1 to allocate,0 to deallocate
  call rttov_alloc_rad (errorstatus,nchannels,radiancedata_d,nlevels-1,asw)
  if (errorstatus/=0) THEN
     Write(*,*) "Erreur in radiance deallocation: ",errorstatus
     call abort3d("tovs_rttov_AVHRR_for_IASI")
  ENDIF

end subroutine tovs_rttov_AVHRR_for_IASI

SUBROUTINE  COR_ALBEDO  ( DEL, SCOS )
!***subroutine     COR_ALBEDO
!*
!*auteur           Louis Garand  - rpn - dorval
!*
!*revision 001     Jacques Halle - ddo - dorval - 421-4660
!*                                 fev 1991
!*                 adapter au systeme operationel GOES.
!*
!*REVISION 002     JACQUES HALLE - DDO - DORVAL - 421-4660
!*                                 Decembre 1995
!*                 Generaliser pour toutes les plateformes satellitaires.
!*
!*objet            ce sous-programme calcule un facteur de correction
!*                 pour l'albedo a partir du cosinus de l'angle solaire. 
!*
!*appel            CALL COR_ALBEDO  ( DEL, SCOS )
!*
!*arguments        del   - output - facteur de correction
!*                 scos  - input  - cosinus de l'angle solaire
!**
  Use MathPhysConstants_mod ,only : MPC_RADIANS_PER_DEGREE_R8
  implicit  none
  real(8),intent(in)  ::  scos
  real(8),intent(out) ::  del
!************************************
  integer  i1, i2
  real(8)  x1, x2, g1, g2, a, b
  real(8)  S(11)
 
  DATA  S / 00.00_8, 18.19_8, 31.79_8, 41.41_8, 49.46_8, 56.63_8, 63.26_8, 69.51_8, 75.52_8, 81.37_8, 87.13_8 /
 
  I1  = 12 -( SCOS+0.05_8)*10._8 
  I2  = I1+1 
  I1  = MIN0(I1,11)
  I2  = MIN0(I2,11)
  X1  = COS ( S(I1)*MPC_RADIANS_PER_DEGREE_R8 )  
  X2  = COS ( S(I2)*MPC_RADIANS_PER_DEGREE_R8 ) 
  G1  = DRCLD(I1)
  G2  = DRCLD(I2)
  if (I1==I2) then
     DEL =G1
  else
     CALL  SOLU ( G1, X1, G2 ,X2, A, B )
     DEL = A*SCOS + B
  endif
  
END SUBROUTINE COR_ALBEDO


SUBROUTINE  SOLU ( YY1, XX1, YY2, XX2, AA, BB )
!**subroutine     SOLU
!
!auteur           Louis Garand  - rpn - dorval
!
!revision 001     Jacques Halle - ddo - dorval - 421-4660
!                                 fev 1991
!                 adapter au systeme operationel GOES.
!
!REVISION 002     JACQUES HALLE - DDO - DORVAL - 421-4660
!                                 Decembre 1995
!                 Generaliser pour toutes les plateformes satellitaires.
!
!langage          fortran 5
!
!objet            ce sous-programme calcule la pente et l'intercept
!                 a partir de deux couples de donnees.
!
!appel            CALL SOLU ( Y1, X1, Y2, X2, A, B )
!
!arguments        XY1    - input - coordonnee Y du point 1
!                 XX1    - input - coordonnee X du point 1
!                 YY2    - input - coordonnee Y du point 2
!                 YX2    - input - coordonnee X du point 2
!                 AA     - output- pente
!                 BB     - output- intercept
!*
  implicit none
  real(8),intent (in)  ::  YY1, XX1, YY2, XX2
  real(8),intent (out) ::  AA, BB
    ! 
!  DROITE PASSANT PAR DEUX POINTS PENTE A ET INTERCEPT B
!


  AA = (YY1-YY2)/(XX1-XX2)
  BB = YY1 - AA*XX1

END SUBROUTINE SOLU

 
REAL(8) FUNCTION  DRCLD ( IZ ) 
!**fonction       DRCLD
!
!auteur           Louis Garand  - rpn - dorval
!
!revision 001     Jacques Halle - ddo - dorval - 421-4660
!                                 fev 1991
!                 adapter au systeme operationel GOES.
!
!REVISION 002     JACQUES HALLE - DDO - DORVAL - 421-4660
!                                 Decembre 1995
!                 Generaliser pour toutes les plateformes satellitaires.
!
!langage          fortran 5
!
!objet            ce sous-programme calcule la normalisation due
!                 a l'angle zenith solaire selon 
!                 MINNIS-HARRISSON (COURBE FIG 7), P1038,JCAM 84.  
!
!appel            xnorm = DRCLD ( IZ )
!
!arguments        xnorm - output - facteur de normalisation
!                 iz    - input  - cosinus de l'angle solaire
!*
  implicit  none

  integer,intent (in) ::  iz
    
  real(8)  DRF(11) 
    
  DATA  DRF / 1.000_8, 1.002_8, 1.042_8, 1.092_8, 1.178_8, 1.286_8, &
       1.420_8, 1.546_8, 1.710_8, 1.870_8, 2.050_8  / 

  DRCLD = DRF (IZ)

END FUNCTION DRCLD

SUBROUTINE VISOCN(SZ,SATZ,RZ,ANISOT,ZLAMB,ZCLOUD,IER)
!***subroutine     VISOCN
!*
!*auteur           LOUIS GARAND 1985
!*
!*REVISION 001     JACQUES HALLE - DDO - DORVAL - 421-4660
!*                                 Decembre 1995
!*                 Generaliser pour toutes les plateformes satellitaires.
!*
!*objet            THIS ROUTINE PROVIDES THE CORRECTIVE FACTORS FOR THE ANISOTROPY
!*                 OF REFLECTANCE OVER CLEAR OCEAN.
!*                 
!*
!*appel            CALL VISOCN(SZ,SATZ,RZ,ANISOT,ZLAMB,ZCLOUD,IER)
!*
!*arguments        sz     - input  - SUN ZENITH ANGLE IN DEGREES (0 TO 90)
!*                 satz   - input  - SATELLITE ZENITH ANGLE (0 TO 90)
!*                 rz     - input  - RELATIVE   ANGLE IN DEGREES (0 TO 180) WITH
!*                                   0 AS BACKSCATTERING AND 
!*                                   180 AS FORWARD SCATTERING
!*                 anisot - output - ANISOTROPIC CORRECTIVE FACTOR 
!*                                  (KHI IN MINNIS-HARRISSON)
!*                 zlamb  - output - CORRECTIVE FACTOR FOR LAMBERTIAN REFLECTANCE
!*                                   (DELTA """") ZLAMB IS A FUNCTION OF SZ ONLY.
!*                                   THIS IS FOR OCEAN SURFACE.
!*                 zcloud - output - SAME AS ZLAMB BUT FOR CLOUD SURFACE
!*                 ier    - output - error code (0=ok; -1=problem with interpolation)
!*
!*notes            OBTAINED FROM DR PAT MINNIS,LANGLEY , AND BASED ON THE WORK
!*                 OF MINNIS AND HARRISSON,JCAM 1984,P993.
!*                 THE ROUTINE IS A LOOK UP TABLE ALONG WITH INTERPOLATION ON THE 
!*                 THREE ANGLES. 
!**
  Use MathPhysConstants_mod ,only: MPC_RADIANS_PER_DEGREE_R8
  implicit  none
  real (8),intent(in) :: SZ,SATZ,rz
  real (8),intent(out):: ANISOT,ZLAMB,ZCLOUD
  integer ,intent(out) :: ier
!********************************************************
  integer  i1, i2, j1, j2, k1, k2, l, i, n, m, j, k
  real(8) cc, d1, d2, slop, cept, x1, x2
  real(8)   g1, g2
  real(8) VNORM(11,10,13),S(11),V(10),R(13),DA(2),DD(2) 

  DATA S/0.0_8,18.19_8,31.79_8,41.41_8,49.46_8,56.63_8,63.26_8,69.51_8,75.52_8,81.37_8,87.13_8/ 
    
  DATA R/0.0_8,15.0_8,30.0_8,45.0_8,60.0_8,75.0_8,90.0_8,105.0_8,120.0_8,135.0_8,150.0_8,165.0_8,180.0_8/ 

  DATA V/0.0_8,10.0_8,20.0_8,30.0_8,40.0_8,50.0_8,60.0_8,70.0_8,80.0_8,90.0_8/

  DATA ((VNORM(1,J,K),J=1,10),K=1,13)/  &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8, &
       2.668_8,2.210_8,1.105_8,0.979_8,0.810_8,0.735_8,0.785_8,0.979_8,1.092_8,1.174_8/ 

  DATA ((VNORM(2,J,K),J=1,10),K=1,13)/  &
       1.154_8, .960_8, .896_8, .818_8, .748_8, .825_8, .922_8,1.018_8,1.179_8,1.334_8, &
       1.154_8, .954_8, .838_8, .799_8, .735_8, .786_8, .883_8, .960_8,1.128_8,1.250_8, &
       1.514_8, .973_8, .825_8, .786_8, .722_8, .754_8,0.838_8,0.922_8,1.063_8,1.160_8, &
       1.514_8,0.967_8,0.864_8,0.818_8,0.715_8,0.728_8,0.793_8,0.876_8,1.005_8,1.102_8, &
       1.514_8,0.967_8,0.896_8,0.889_8,0.702_8,0.696_8,0.773_8,0.851_8,0.954_8,1.038_8, &
       1.514_8,1.070_8,0.986_8,0.922_8,0.677_8,0.696_8,0.754_8,0.838_8,0.922_8,1.012_8, &
       1.514_8,1.270_8,0.967_8,0.870_8,0.677_8,0.664_8,0.709_8,0.773_8,0.857_8,0.954_8, &
       1.514_8,1.495_8,1.166_8,0.960_8,0.683_8,0.690_8,0.728_8,0.806_8,0.896_8,0.999_8, &
       1.514_8,1.959_8,1.534_8,1.025_8,0.973_8,0.709_8,0.754_8,0.857_8,0.954_8,1.050_8, &
       1.514_8,2.165_8,2.165_8,1.270_8,1.038_8,0.760_8,0.812_8,0.902_8,1.012_8,1.115_8, &
       1.514_8,2.275_8,2.262_8,1.688_8,1.115_8,0.780_8,0.857_8,0.954_8,1.070_8,1.173_8, &
       1.514_8,2.326_8,2.520_8,2.172_8,1.257_8,0.812_8,0.883_8,1.005_8,1.108_8,1.212_8, &
       1.514_8,2.359_8,2.951_8,2.255_8,1.411_8,0.980_8,0.915_8,1.050_8,1.160_8,1.295_8/ 

  DATA ((VNORM(3,J,K),J=1,10),K=1,13)/   &
       0.897_8,0.792_8,0.765_8,0.765_8,0.778_8,0.897_8,0.996_8,1.095_8,1.306_8,1.431_8, &
       0.897_8,0.712_8,0.739_8,0.745_8,0.765_8,0.891_8,0.970_8,1.069_8,1.214_8,1.359_8, &
       0.897_8,0.666_8,0.699_8,0.745_8,0.759_8,0.811_8,0.917_8,1.042_8,1.148_8,1.306_8, &
       0.897_8,0.646_8,0.693_8,0.739_8,0.693_8,0.752_8,0.858_8,0.989_8,1.102_8,1.234_8, &
       0.897_8,0.686_8,0.679_8,0.726_8,0.679_8,0.693_8,0.792_8,0.924_8,1.049_8,1.154_8, &
       0.897_8,0.660_8,0.673_8,0.693_8,0.646_8,0.660_8,0.759_8,0.858_8,1.003_8,1.102_8, &
       0.897_8,0.673_8,0.765_8,0.792_8,0.712_8,0.600_8,0.699_8,0.811_8,0.963_8,1.055_8, &
       0.897_8,0.706_8,0.772_8,0.917_8,0.904_8,0.613_8,0.726_8,0.858_8,1.055_8,1.121_8, &
       0.897_8,0.825_8,0.924_8,0.996_8,0.989_8,0.686_8,0.778_8,0.937_8,1.115_8,1.181_8, &
       0.897_8,1.036_8,1.253_8,1.286_8,1.260_8,0.778_8,0.858_8,0.996_8,1.181_8,1.260_8, &
       0.897_8,1.201_8,1.788_8,1.986_8,1.827_8,0.884_8,0.851_8,1.062_8,1.227_8,1.333_8, &
       0.897_8,1.530_8,2.249_8,2.546_8,2.381_8,1.352_8,0.891_8,1.108_8,1.286_8,1.405_8, &
       0.897_8,1.854_8,2.401_8,3.325_8,2.559_8,1.590_8,0.937_8,1.168_8,1.214_8,1.425_8/ 

  DATA ((VNORM(4,J,K),J=1,10),K=1,13)/  &
       0.752_8,0.800_8,0.745_8,0.717_8,0.759_8,0.891_8,1.149_8,1.309_8,1.469_8,1.650_8, &
       0.752_8,0.773_8,0.717_8,0.703_8,0.752_8,0.835_8,1.065_8,1.246_8,1.406_8,1.552_8, &
       0.752_8,0.731_8,0.689_8,0.703_8,0.745_8,0.814_8,0.988_8,1.176_8,1.323_8,1.476_8, &
       0.752_8,0.689_8,0.675_8,0.654_8,0.696_8,0.752_8,0.940_8,1.100_8,1.246_8,1.378_8, &
       0.752_8,0.675_8,0.661_8,0.633_8,0.668_8,0.717_8,0.877_8,1.030_8,1.176_8,1.309_8, &
       0.752_8,0.647_8,0.640_8,0.620_8,0.613_8,0.682_8,0.814_8,0.947_8,1.107_8,1.232_8, &
       0.752_8,0.633_8,0.620_8,0.613_8,0.606_8,0.640_8,0.773_8,0.898_8,1.044_8,1.162_8, &
       0.752_8,0.626_8,0.626_8,0.626_8,0.620_8,0.654_8,0.821_8,0.947_8,1.128_8,1.225_8, &
       0.752_8,0.633_8,0.633_8,0.633_8,0.647_8,0.675_8,0.877_8,1.009_8,1.183_8,1.274_8, &
       0.752_8,0.682_8,0.717_8,0.961_8,1.023_8,0.968_8,0.940_8,1.142_8,1.274_8,1.413_8, &
       0.752_8,0.856_8,1.037_8,1.434_8,1.594_8,1.441_8,1.044_8,1.225_8,1.323_8,1.545_8, &
       0.752_8,1.044_8,1.295_8,2.207_8,1.610_8,2.311_8,1.385_8,1.274_8,1.441_8,1.636_8, &
       0.752_8,1.079_8,1.524_8,2.541_8,3.564_8,3.014_8,1.942_8,1.462_8,1.552_8,1.726_8/ 

  DATA ((VNORM(5,J,K),J=1,10),K=1,13)/  &
       0.552_8,0.588_8,0.617_8,0.638_8,0.724_8,0.860_8,1.133_8,1.362_8,1.556_8,1.678_8, &
       0.552_8,0.581_8,0.602_8,0.617_8,0.652_8,0.803_8,1.075_8,1.326_8,1.484_8,1.592_8, &
       0.552_8,0.559_8,0.588_8,0.595_8,0.617_8,0.731_8,1.018_8,1.283_8,1.412_8,1.527_8, &
       0.552_8,0.531_8,0.538_8,0.574_8,0.595_8,0.710_8,0.946_8,1.240_8,1.341_8,1.463_8, &
       0.552_8,0.516_8,0.523_8,0.552_8,0.559_8,0.695_8,0.911_8,1.226_8,1.291_8,1.412_8, &
       0.552_8,0.516_8,0.523_8,0.538_8,0.538_8,0.652_8,0.882_8,1.154_8,1.240_8,1.348_8, &
       0.552_8,0.516_8,0.523_8,0.538_8,0.523_8,0.595_8,0.774_8,1.075_8,1.169_8,1.269_8, &
       0.552_8,0.531_8,0.545_8,0.552_8,0.566_8,0.609_8,0.817_8,1.140_8,1.248_8,1.369_8, &
       0.552_8,0.538_8,0.545_8,0.566_8,0.581_8,0.645_8,0.911_8,1.240_8,1.319_8,1.441_8, &
       0.552_8,0.566_8,0.552_8,0.574_8,0.710_8,0.839_8,0.982_8,1.298_8,1.391_8,2.323_8, &
       0.552_8,0.566_8,0.559_8,0.710_8,1.147_8,1.176_8,1.040_8,1.348_8,1.671_8,2.674_8, &
       0.552_8,0.588_8,1.133_8,1.355_8,2.194_8,2.803_8,2.201_8,2.459_8,2.904_8,3.126_8, &
       0.552_8,0.710_8,1.341_8,1.757_8,3.026_8,3.900_8,4.445_8,4.503_8,4.445_8,4.503_8/ 

  DATA ((VNORM(6,J,K),J=1,10),K=1,13)/  &
       0.551_8,0.627_8,0.665_8,0.734_8,0.826_8,0.971_8,1.231_8,1.537_8,1.721_8,1.866_8, &
       0.551_8,0.604_8,0.619_8,0.665_8,0.765_8,0.895_8,1.185_8,1.476_8,1.568_8,1.652_8, &
       0.551_8,0.597_8,0.604_8,0.619_8,0.734_8,0.849_8,1.101_8,1.346_8,1.453_8,1.568_8, &
       0.551_8,0.581_8,0.589_8,0.597_8,0.665_8,0.795_8,1.032_8,1.262_8,1.346_8,1.445_8, &
       0.551_8,0.558_8,0.558_8,0.566_8,0.612_8,0.727_8,0.987_8,1.201_8,1.262_8,1.399_8, &
       0.551_8,0.505_8,0.505_8,0.512_8,0.566_8,0.696_8,0.925_8,1.117_8,1.185_8,1.308_8, &
       0.551_8,0.474_8,0.497_8,0.512_8,0.535_8,0.673_8,0.864_8,1.048_8,1.124_8,1.216_8, &
       0.551_8,0.497_8,0.505_8,0.520_8,0.551_8,0.681_8,0.902_8,1.124_8,1.201_8,1.323_8, &
       0.551_8,0.535_8,0.535_8,0.551_8,0.566_8,0.711_8,1.017_8,1.201_8,1.269_8,1.422_8, &
       0.551_8,0.535_8,0.543_8,0.558_8,0.704_8,1.193_8,1.247_8,1.285_8,1.346_8,1.950_8, &
       0.551_8,0.543_8,0.551_8,0.581_8,0.994_8,1.545_8,1.583_8,1.354_8,2.019_8,2.883_8, &
       0.551_8,0.566_8,0.612_8,0.788_8,1.468_8,2.233_8,2.340_8,2.531_8,2.983_8,3.365_8, &
       0.551_8,0.658_8,0.665_8,1.101_8,2.134_8,3.120_8,4.221_8,4.856_8,4.956_8,5.613_8/ 

  DATA ((VNORM(7,J,K),J=1,10),K=1,13)/  &
       0.545_8,0.606_8,0.683_8,0.744_8,0.798_8,0.990_8,1.228_8,1.704_8,1.850_8,2.049_8, &
       0.545_8,0.576_8,0.583_8,0.714_8,0.783_8,0.952_8,1.144_8,1.573_8,1.758_8,1.888_8, &
       0.545_8,0.560_8,0.568_8,0.629_8,0.744_8,0.875_8,1.105_8,1.504_8,1.642_8,1.788_8, &
       0.545_8,0.553_8,0.560_8,0.599_8,0.629_8,0.791_8,1.028_8,1.420_8,1.527_8,1.696_8, &
       0.545_8,0.545_8,0.553_8,0.599_8,0.606_8,0.714_8,0.990_8,1.335_8,1.451_8,1.581_8, &
       0.545_8,0.530_8,0.537_8,0.568_8,0.583_8,0.683_8,0.890_8,1.243_8,1.351_8,1.489_8, &
       0.545_8,0.491_8,0.499_8,0.507_8,0.576_8,0.622_8,0.791_8,1.182_8,1.282_8,1.389_8, &
       0.545_8,0.507_8,0.514_8,0.507_8,0.576_8,0.675_8,0.890_8,1.197_8,1.328_8,1.451_8, &
       0.545_8,0.522_8,0.537_8,0.522_8,0.591_8,0.760_8,0.944_8,1.259_8,1.389_8,1.527_8, &
       0.545_8,0.537_8,0.545_8,0.553_8,0.614_8,0.906_8,1.028_8,1.389_8,1.504_8,2.533_8, &
       0.545_8,0.553_8,0.553_8,0.576_8,0.637_8,1.036_8,1.550_8,1.658_8,1.934_8,3.277_8, &
       0.545_8,0.560_8,0.568_8,0.606_8,1.174_8,1.781_8,2.563_8,3.170_8,3.791_8,4.966_8, &
       0.545_8,0.591_8,0.614_8,1.259_8,2.065_8,2.824_8,3.761_8,4.498_8,5.902_8,6.148_8/ 

  DATA ((VNORM(8,J,K),J=1,10),K=1,13)/  &
       0.514_8,0.539_8,0.596_8,0.694_8,0.832_8,1.004_8,1.444_8,1.869_8,2.203_8,2.538_8, &
       0.514_8,0.539_8,0.571_8,0.645_8,0.751_8,0.906_8,1.387_8,1.779_8,2.056_8,2.317_8, &
       0.514_8,0.547_8,0.555_8,0.612_8,0.702_8,0.824_8,1.281_8,1.681_8,1.934_8,2.203_8, &
       0.514_8,0.539_8,0.555_8,0.588_8,0.653_8,0.743_8,1.028_8,1.404_8,1.624_8,2.024_8, &
       0.514_8,0.539_8,0.547_8,0.555_8,0.588_8,0.710_8,0.889_8,1.191_8,1.420_8,1.820_8, &
       0.514_8,0.522_8,0.522_8,0.539_8,0.563_8,0.710_8,0.849_8,1.044_8,1.208_8,1.534_8, &
       0.514_8,0.481_8,0.506_8,0.514_8,0.539_8,0.694_8,0.824_8,1.028_8,1.200_8,1.371_8, &
       0.514_8,0.481_8,0.514_8,0.547_8,0.563_8,0.702_8,0.898_8,1.134_8,1.297_8,1.501_8, &
       0.514_8,0.490_8,0.514_8,0.555_8,0.588_8,0.726_8,0.955_8,1.265_8,1.379_8,1.648_8, &
       0.514_8,0.547_8,0.547_8,0.571_8,0.604_8,0.767_8,1.036_8,1.355_8,1.550_8,3.142_8, &
       0.514_8,0.563_8,0.579_8,0.604_8,0.612_8,0.832_8,1.909_8,2.848_8,3.917_8,4.790_8, &
       0.514_8,0.522_8,0.563_8,0.677_8,0.767_8,1.420_8,2.040_8,3.158_8,4.863_8,6.291_8, &
       0.514_8,0.588_8,0.588_8,0.612_8,0.824_8,2.032_8,3.109_8,4.969_8,6.846_8,7.695_8/ 

  DATA ((VNORM(9,J,K),J=1,10),K=1,13)/  &
       0.572_8,0.608_8,0.679_8,0.751_8,0.831_8,1.001_8,1.377_8,1.913_8,2.512_8,2.879_8, &
       0.572_8,0.572_8,0.608_8,0.679_8,0.760_8,0.930_8,1.243_8,1.707_8,2.369_8,2.700_8, &
       0.572_8,0.563_8,0.590_8,0.644_8,0.706_8,0.831_8,1.171_8,1.618_8,2.190_8,2.378_8, &
       0.572_8,0.554_8,0.563_8,0.599_8,0.662_8,0.760_8,1.010_8,1.502_8,2.011_8,2.235_8, &
       0.572_8,0.545_8,0.563_8,0.590_8,0.626_8,0.715_8,0.885_8,1.323_8,1.815_8,2.119_8, &
       0.572_8,0.527_8,0.554_8,0.572_8,0.608_8,0.670_8,0.724_8,1.144_8,1.618_8,1.868_8, &
       0.572_8,0.545_8,0.572_8,0.572_8,0.599_8,0.662_8,0.724_8,1.117_8,1.484_8,1.761_8, &
       0.572_8,0.554_8,0.590_8,0.599_8,0.608_8,0.679_8,0.760_8,1.216_8,1.582_8,1.922_8, &
       0.572_8,0.572_8,0.599_8,0.608_8,0.635_8,0.715_8,0.822_8,1.377_8,1.707_8,2.056_8, &
       0.572_8,0.590_8,0.608_8,0.635_8,0.662_8,0.742_8,0.912_8,1.529_8,3.075_8,4.693_8, &
       0.572_8,0.590_8,0.626_8,0.644_8,0.670_8,0.760_8,1.109_8,1.564_8,3.111_8,4.702_8, &
       0.572_8,0.599_8,0.644_8,0.662_8,0.688_8,0.822_8,1.788_8,2.816_8,5.346_8,7.295_8, &
       0.572_8,0.608_8,0.662_8,0.670_8,0.715_8,1.851_8,3.227_8,4.810_8,6.669_8,9.557_8/ 

  DATA ((VNORM(10,J,K),J=1,10),K=1,13)/   &
       0.552_8,0.606_8,0.639_8,0.671_8,0.704_8,0.899_8,1.223_8,2.479_8,3.194_8,3.573_8, &
       0.552_8,0.574_8,0.606_8,0.628_8,0.682_8,0.855_8,1.148_8,2.339_8,2.642_8,3.378_8, &
       0.552_8,0.563_8,0.552_8,0.595_8,0.639_8,0.834_8,1.061_8,2.014_8,2.404_8,2.891_8, &
       0.552_8,0.563_8,0.509_8,0.552_8,0.628_8,0.801_8,0.985_8,1.689_8,2.176_8,2.653_8, &
       0.552_8,0.574_8,0.509_8,0.520_8,0.585_8,0.747_8,0.888_8,1.332_8,1.970_8,2.458_8, &
       0.552_8,0.531_8,0.509_8,0.509_8,0.531_8,0.682_8,0.801_8,1.191_8,1.819_8,2.425_8, &
       0.552_8,0.498_8,0.498_8,0.498_8,0.520_8,0.639_8,0.747_8,1.126_8,1.711_8,2.317_8, &
       0.552_8,0.498_8,0.509_8,0.509_8,0.541_8,0.671_8,0.780_8,1.278_8,1.862_8,2.598_8, &
       0.552_8,0.498_8,0.509_8,0.520_8,0.574_8,0.693_8,0.812_8,1.602_8,2.035_8,2.793_8, &
       0.552_8,0.520_8,0.520_8,0.531_8,0.595_8,0.725_8,0.844_8,1.916_8,2.588_8,3.768_8, &
       0.552_8,0.531_8,0.541_8,0.574_8,0.628_8,0.780_8,1.039_8,2.349_8,3.313_8,5.652_8, &
       0.552_8,0.574_8,0.563_8,0.606_8,0.660_8,0.812_8,1.797_8,3.010_8,5.478_8,7.492_8, &
       0.552_8,0.650_8,0.671_8,0.704_8,0.801_8,1.029_8,2.436_8,3.465_8,7.828_8,10.578_8/

  DATA ((VNORM(11,J,K),J=1,10),K=1,13)/   &
       0.518_8,0.576_8,0.605_8,0.633_8,0.662_8,0.864_8,1.238_8,2.620_8,3.455_8,3.887_8, &
       0.518_8,0.547_8,0.576_8,0.576_8,0.633_8,0.835_8,1.123_8,2.447_8,2.821_8,3.656_8, &
       0.518_8,0.518_8,0.518_8,0.547_8,0.605_8,0.806_8,1.036_8,2.102_8,2.533_8,3.080_8, &
       0.518_8,0.518_8,0.461_8,0.518_8,0.576_8,0.777_8,0.950_8,1.727_8,2.274_8,2.821_8, &
       0.518_8,0.547_8,0.461_8,0.489_8,0.547_8,0.720_8,0.864_8,1.353_8,2.044_8,2.591_8, &
       0.518_8,0.489_8,0.461_8,0.461_8,0.489_8,0.662_8,0.777_8,1.180_8,1.871_8,2.562_8, &
       0.518_8,0.461_8,0.461_8,0.461_8,0.489_8,0.605_8,0.720_8,1.123_8,1.756_8,2.418_8, &
       0.518_8,0.461_8,0.461_8,0.461_8,0.518_8,0.633_8,0.749_8,1.296_8,1.929_8,2.764_8, &
       0.518_8,0.461_8,0.461_8,0.489_8,0.547_8,0.662_8,0.777_8,1.641_8,2.130_8,2.994_8, &
       0.518_8,0.489_8,0.489_8,0.489_8,0.547_8,0.691_8,0.806_8,1.986_8,2.735_8,4.117_8, &
       0.518_8,0.489_8,0.489_8,0.547_8,0.576_8,0.749_8,1.008_8,2.476_8,3.599_8,6.334_8, &
       0.518_8,0.547_8,0.518_8,0.576_8,0.633_8,0.777_8,1.842_8,3.224_8,6.132_8,8.550_8, &
       0.518_8,0.605_8,0.633_8,0.662_8,0.777_8,1.008_8,2.562_8,3.771_8,8.953_8,12.293_8/
 
!   COMPUTE SUN ZENITH BIN
  CC  = COS(SZ*MPC_RADIANS_PER_DEGREE_R8)
  I1  = 12._8-(CC+0.05_8)*10._8
  I2  = I1+1 
  IF(I1>=11)I1=11 
  IF(I1==11)I2=I1 

!  COMPUTE SAT ZENITH BIN 
  J1  = INT(SATZ/10._8)+1 
  J2  = J1+1 
  IF(J1==10)J2=J1 

!  COMPUTE RELATIVE AZIMUTH BIN 
  K1  = RZ/15._8+1._8
  K2  = K1+1 
  IF(K1==13)K2=K1 

!  INTERPOLATE
  IER = 0 
  DO  L=I1,I2 
     I = L-I1+1
       
!     BETWEEN R'S FOR CONSTANT S
     DO  N=K1,K2 

!        BETWEEN V'S FOR CONSTANT R AND S 
        M  = N-K1+1
        D1 = VNORM(L,J1,N)
        D2 = VNORM(L,J2,N)
        IF(D1==D2)THEN
           DA(M) = D1
        ELSE
           CALL LINEQ(V(J1),V(J2),D1,D2,SLOP,CEPT,IER) 
           DA(M) = SLOP*SATZ+CEPT
        ENDIF
     enddo
     IF(K1==K2) THEN 
        DD(I) = DA(1) 
     ELSE
        CALL LINEQ(R(K1),R(K2),DA(1),DA(2),SLOP,CEPT,IER) 
        DD(I) = SLOP*RZ+CEPT
     ENDIF
  enddo

  !  BETWEEN S'S USING RESULT OF OTHER INTERPOLATIONS 
  IF(I1==I2)THEN
     ZLAMB  = DRM(I1) 
     ZCLOUD = DRCLD(I1)
     ANISOT = DD(1)
  ELSE
     X1     = COS(S(I1)*MPC_RADIANS_PER_DEGREE_R8) 
     X2     = COS(S(I2)*MPC_RADIANS_PER_DEGREE_R8) 
     CALL LINEQ(X1,X2,DD(1),DD(2),SLOP,CEPT,IER) 
     ANISOT = SLOP*CC+CEPT 
     G1     = DRM(I1)
     G2     = DRM(I2)
     CALL LINEQ(X1,X2,G1,G2,SLOP,CEPT,IER) 
     ZLAMB  = SLOP*CC+CEPT
     G1     = DRCLD(I1)
     G2     = DRCLD(I2)
     CALL LINEQ(X1,X2,G1,G2,SLOP,CEPT,IER) 
     ZCLOUD = SLOP*CC+CEPT 
  ENDIF

  IF(ANISOT<0.) THEN 
     IER    = -1
     ANISOT = 1._8 
     ZLAMB  = DRM(I1) 
     ZCLOUD = DRCLD(I1)
  ENDIF

END SUBROUTINE VISOCN


SUBROUTINE LINEQ(XX1,XX2,YY1,YY2,AA,BB,IERR) 
!**subroutine     LINEQ
!
!auteur           Louis Garand  - rpn - dorval
!
!REVISION 001     JACQUES HALLE - DDO - DORVAL - 421-4660
!                                 Decembre 1995
!                Generaliser pour toutes les plateformes satellitaires.
!
!langage          fortran 5
!
!objet            calculate slope and intercept of a line.
!
!appel            CALL  LINEQ(X1,X2,Y1,Y2,A,B,IER)
!
!arguments        x1  - input  - coordinate x of point 1
!                 x2  - input  - coordinate x of point 2
!                 y1  - input  - coordinate y of point 1
!                 y2  - input  - coordinate y of point 2
!                 a   - output - slope
!                 b   - output - intercept
!                 ier - output - error code (0=ok)
!
  real(8) ,intent(in)     :: XX1,XX2,YY1,YY2
  real(8) ,intent(out)    :: AA,BB
  integer ,intent(out) :: ierr
!****************************************
     
  ierr = 0
    
  IF((XX2-XX1)==0._8)THEN 
     IERR=-1
     RETURN
  ENDIF

  AA=(YY2-YY1)/(XX2-XX1) 
  BB=YY1-AA*XX1 
    
END SUBROUTINE LINEQ

REAL(8) FUNCTION DRM(IZ) 
!**function       DRM
!
!auteur           Louis Garand  - rpn - dorval
!
!REVISION 001     JACQUES HALLE - DDO - DORVAL - 421-4660
!                                 Decembre 1995
!                 Generaliser pour toutes les plateformes satellitaires.
!
!langage          fortran 5
!
!objet            NORMALIZATION FOR SUN ZENITH ANGLE (LAMBERTIAN)
!                 FOR OCEAN.
!
!appel            val = DRM(IZ)
!
!arguments        iz  - input  - index
!                 val - output - normalization factor
!*

  integer,intent (in) ::  iz

  REAL(8)  DRF(11)

  DATA DRF /1._8,1.0255_8,1.1197_8,1.2026_8,1.3472_8,1.4926_8,1.8180_8,2.1980_8, &
       2.8180_8,3.8615_8,4.3555_8/

  DRM=DRF(IZ) 
  
END FUNCTION DRM
      


End module MULTI_IR_BGCK_MOD
