Module multi_ir_bgck_mod

!************************************************************************
!*
!*       MODULE MULTI_IR_BGCHECK
!*       -------------------
!*
!*       PURPOSE: VARIABLES FOR MULTISPECTRAL INFRARED BACKGROUND CHECK
!*                  AND QUALITY CONTROL
!*
!*       AUTHOR:   A. BEAULNE (CMDA/SMC) February 2006
!*
!*       REVISION: adapted to IASI and CrIS by S. Heilliette
!*
!*
!************************************************************************
 Use tovs_nl_mod, only : jplev,rttov_coefs,transmission_Type,tvs_Is_idburp_tovs, &
      tvs_Is_idburp_inst, &
      radiance_d,lsensor,coefs,nchan,NSENSORS,PLATFORM,SATELLITE,INSTRUMENT,NOBTOV

  implicit none
  save
  private
! Public functions (methods)
  public :: hirqc,BGCK_IR_SETUP
! Public  parameters (constants)
  public :: NCLASSAVHRR,NIR,NVIS,NCHANAVHRR,NCO2,BITFLAG
! Public variables ("global")
  public ::coefs_avhrr,avhrr_bgck,profiles_qc,transmission,transmission_d, emissivity
!public types
  public :: avhrr_bgck_iasi,prof_qc

  INTEGER ,PARAMETER :: NCLASSAVHRR=7
  INTEGER ,PARAMETER :: NIR=3,NVIS=3
  INTEGER ,PARAMETER :: NCHANAVHRR=NIR+NVIS

  ! Reference (and alternate) window channel for clear / cloudy profile detection
  ! (subroutine cloud_height)

  INTEGER, PARAMETER :: IWINDOW_AIRS = 787, IWINDOW_ALT_AIRS = 950
  INTEGER, PARAMETER :: IWINDOW_IASI = 1090, IWINDOW_ALT_IASI = 1133
  INTEGER, PARAMETER :: IWINDOW_CRIS = 427, IWINDOW_ALT_CRIS = 529

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the "background profile matching" method (subroutine cloud_top)

  INTEGER, PARAMETER        :: NCH_HE = 4

  INTEGER, PARAMETER  :: ILIST1_AIRS(NCH_HE) = (/ 528, 787, 950, 2209 /)

  INTEGER, PARAMETER  :: ILIST1_IASI(NCH_HE) = (/ 705, 1090, 1133, 7475 /)

  INTEGER, PARAMETER  :: ILIST1_CRIS(NCH_HE) = (/ 279, 427, 529, 1290 /)

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the CO2-slicing method. IREFR is the reference channel number (and alternate).
  ! (subroutine co2_slicing)


  INTEGER, PARAMETER  :: NCO2 = 13

  INTEGER, PARAMETER  :: ILIST2_AIRS(NCO2) = (/ 204, 221, 232, 252, 262, 272,  &
                                                       299, 305, 310, 355, 362, 375, 375 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_AIRS(NCO2) = (/ 252, 262, 272, 299, 305, 310,  &
                                                            355, 362, 375, 375, 262, 252, 204/)

  INTEGER, PARAMETER  :: ILIST2_IASI(NCO2) = (/ 252, 269, 285, 309, 320, 332, &
                                                       363, 371, 375, 433, 442, 459, 459 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_IASI(NCO2) = (/ 309, 320, 332,363, 371, 375, &
                                                            433, 442, 459, 459, 320, 309, 252 /)

  INTEGER, PARAMETER  :: ILIST2_CRIS(NCO2) = (/ 99, 116, 138, 133, 158, 154, &
                                                     123, 143, 168, 163, 175, 198, 198 /)

  INTEGER, PARAMETER  :: ILIST2_PAIR_CRIS(NCO2) = (/ 133, 158, 154, 123, 143, 168, &
                                                           163, 175, 198, 198, 158, 133, 99 /)

  ! Cloud top units : (1) mb, (2) meters
  ! (subroutines cloud_height (IOPT1) and cloud_top (IOPT2))

  INTEGER, PARAMETER        :: IOPT1 = 2   ! verify subr input if iopt1 changes
  INTEGER, PARAMETER        :: IOPT2 = 1

  ! Cloud top based on which background profile matching (subroutine cloud_top)
  ! (0) brightness temperature, (1) radiance, (2) both

  INTEGER, PARAMETER        :: IHGT = 2

  ! Maximum delta temperature allowed between guess and true skin temperature
  ! over water (DTW) and land (DTL)   (subroutine airsqc)

  REAL(8), PARAMETER        :: DTW = 1.5D0
  REAL(8), PARAMETER        :: DTL = 4.0D0

  ! Minimum and maximum RTTOV levels for LEV_START variable entering CO2 slicing
  ! In mb, between 50mb and 325mb (subroutine co2_slicing)

  Real(8), PARAMETER        :: PCO2MIN = 56.73D0, PCO2MAX = 321.5D0

  ! First channel affected by sun (for channels used only at night)
  ! (subroutine airsqc)

  INTEGER, PARAMETER   :: ICHN_SUN_AIRS = 1865
  INTEGER, PARAMETER   :: ICHN_SUN_IASI = 5446
  INTEGER, PARAMETER   :: ICHN_SUN_CRIS = 1147

  ! Minimum solar zenith angle for night (between 90 and 180)
  ! (subroutine airsqc)

  REAL(8), PARAMETER       :: NIGHT_ANG = 100.D0

  ! Maximum number of profiles for one call to airs quality control
  ! (subroutine tovs_rttov)

  INTEGER, PARAMETER   :: BUNCH_AIRS = 120
  INTEGER, PARAMETER   :: BUNCH_IASI = 120
  INTEGER, PARAMETER   :: BUNCH_CRIS = 120

  ! Highest flag in post files (value of N in 2^N)
  ! Currently 21

  INTEGER, PARAMETER :: BITFLAG = 29

  Real(8),parameter :: seuilalb_static(NIR,0:2)= reshape( (/ 70.0,67.0,50.0, &
                                                             40.0,37.0,37.0, &
                                                             70.0,57.0,40. /),(/3,3/) ) 
  Real(8),parameter :: seuilalb_homog(NIR,0:2)= reshape( (/ 15.0,18.0,13.0, &
                                                            9.0,10.0,10.0, &
                                                            18.0,16.0,10.0 /),(/3,3/) )
  
  Real(8) :: seuilbt_homog(NVIS+1:NVIS+NIR,0:2,1:2)= reshape( (/5.d0, 4.d0, 4.d0, 4.d0, 3.d0, 3.d0, &
                                                                5.d0, 4.d0, 4.d0, 5.d0, 5.d0, 5.d0, &
                                                                4.d0, 3.d0, 3.d0, 5.d0, 5.d0, 5.d0/), (/3,3,2/) )

  type( rttov_coefs ) :: coefs_avhrr

  TYPE avhrr_bgck_iasi
     SEQUENCE   
     REAL(8)              :: RADMOY(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: RADSTD(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: CFRAC(NCLASSAVHRR)
     REAL(8)              :: TBMOY(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: TBSTD(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBEDMOY(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: ALBEDSTD(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: TBSTD_PIXELIASI(NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBSTD_PIXELIASI(1:NVIS)
     REAL(8)              :: RADCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: TBCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: RADOVCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMSURF(NVIS+1:NVIS+NIR)
     REAL(8)              :: EMISS(NVIS+1:NVIS+NIR)
  END TYPE avhrr_bgck_iasi

  TYPE prof_qc
     SEQUENCE
     REAL(8)              :: LAT      ! latitude (-90 to 90)
     REAL(8)              :: LON      ! longitude (0 to 360)
     REAL(8), POINTER     :: Z(:)     ! height field (m)
     REAL(8)              :: SUNZA    ! sun zenith angle (deg)
     REAL(8)              :: ALBEDO   ! surface albedo (0-1)
     REAL(8)              :: ICE      ! ice cover (0-1) 
     REAL(8)              :: SNOW     ! snow cover (0-1)
     REAL(8)              :: PCNT_WAT ! water percentage in pixel containing profile (0-1)
     REAL(8)              :: PCNT_REG ! water percentage in an area around profile (0-1)
     INTEGER              :: LTYPE    ! surface type (1,...,20)
  END TYPE prof_qc

  type(avhrr_bgck_iasi)  , allocatable :: avhrr_bgck(:)      ! avhrr parameters for IASI quality control
  type( prof_qc )     ,     allocatable :: profiles_qc(:)    ! profiles buffer used in airsqc call
  type(transmission_Type) :: transmission                    ! transmissions full structure buffer used in rttov calls
  type(transmission_Type) , allocatable :: transmission_d(:) ! transmissions organized by profile
  real(8) , allocatable :: emissivity(:,:)   ! surface emissivities organized by profiles and channels
contains

SUBROUTINE BGCK_IR_SETUP(lobsSpaceData)
#if defined (DOC)
!
!  s/r BGCK_IR_SETUP : Memory allocation for the Hyperspectral Infrared
!                background check variables
!          (original name of routine: sutovalo)
!
! Revision:

!           S.  Heilliette
!            - creation from tovs_setup_allo  December 2013
#endif

  use obsSpaceData_mod

  IMPLICIT NONE
!implicits

  type(struct_obs) :: lobsSpaceData

  Integer :: alloc_status(2)

  INTEGER :: KRTID
  INTEGER ::  JO, IDATYP,NCMAX
  INTEGER ::  ISENS, NC, NL
  INTEGER ::  ICHN
  INTEGER ::  NOBIASI
  integer ::  index_header

!     1. Determine the number of IASI profiles to be assimilated.
!     .  ---------------------------------------------------
 
  NOBIASI = 0

  ! loop over all header indices of the 'TO' family
  ! Set the header list
  ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)
     
     IF ( .not.  tvs_Is_idburp_tovs(IDATYP) ) cycle HEADER   ! Proceed to the next header_index

     IF ( tvs_Is_idburp_inst(IDATYP,"IASI") ) NOBIASI = NOBIASI + 1

  ENDDO HEADER

  write(*,*) ' BGCK_IR_SETUP: nobiasi = ', nobiasi
!-----------------------------------------------------------------------

!     2. Memory allocation for background check related variables
!     .  -----------------------------------------------------

  allocate(profiles_qc(NOBTOV) , stat= alloc_status(1))
  If( alloc_status(1) /= 0) then
     WRITE(*,FMT=9201)
  9201   FORMAT(' BGCK_IR_SETUP: Memory Allocation Error')
     CALL ABORT3D('BGCK_IR_SETUP')
  End If

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nl = coefs(isens)%coef % nlevels
     allocate( profiles_qc(jo) % z  ( nl ) ,stat= alloc_status(1))
        
     If( alloc_status(1)/=0 ) then
         WRITE(*,FMT=9201)
         CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ radiance by profile

  alloc_status(:) = 0


  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     nl = coefs(isens) % coef % nlevels

     allocate( radiance_d(jo)  % overcast  (nl-1,nc) ,stat= alloc_status(1))
     radiance_d(jo)  % overcast  (:,:) = 0.d0
     
    
     If( alloc_status(1) /= 0 ) then
         WRITE(*,FMT=9201)
         CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ transmission by profile

  alloc_status(:) = 0
  allocate( transmission_d(NOBTOV),stat= alloc_status(1))

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     nl = coefs(isens) % coef % nlevels

     !! allocate transmittance from surface and from pressure levels
     allocate( transmission_d(jo)  % tau_total ( nc ) ,stat= alloc_status(1))
     allocate( transmission_d(jo)  % tau_levels(nl,nc) ,stat= alloc_status(2))

     If( any(alloc_status /= 0) ) then
        WRITE(*,FMT=9201)
        CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ emissivity by profile

  ncmax = 1

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     if (nc>ncmax) ncmax=nc
  end do

  allocate( emissivity (ncmax,NOBTOV) ,stat=alloc_status(1))
       
  If( alloc_status(1) /= 0 ) then
      WRITE(*,FMT=9201)
      CALL ABORT3D('BGCK_IR_SETUP')
  End If



  DO KRTID = 1, NSENSORS

    IF ( PLATFORM(KRTID) == 10 .AND. &
         INSTRUMENT(KRTID) == 16 ) THEN

       allocate ( avhrr_bgck(NOBIASI), stat= alloc_status(1))

       If( alloc_status(1)/=0 ) then
          WRITE(*,FMT=9201)
          CALL ABORT3D('BGCK_IR_SETUP')
       End If

       EXIT

    END IF

 END DO

END SUBROUTINE BGCK_IR_SETUP


SUBROUTINE BGCK_GET_QCPARAM(CINSTR,IWINDOW,IWINDOW_ALT,ILIST1,ILIST2,ILIST2_PAIR,ICHN_SUN,BUNCH)
IMPLICIT NONE
character (len=*),intent(in) :: CINSTR
integer ,intent (out) :: IWINDOW,IWINDOW_ALT,ILIST1(NCH_HE),ILIST2(NCO2),ILIST2_PAIR(NCO2),ICHN_SUN,BUNCH

select case(trim(cinstr))
case ("AIRS","airs")
   IWINDOW=IWINDOW_AIRS
   IWINDOW_ALT=IWINDOW_ALT_AIRS
   ILIST1=ILIST1_AIRS
   ILIST2=ILIST2_AIRS
   ILIST2_PAIR=ILIST2_PAIR_AIRS
   ICHN_SUN=ICHN_SUN_AIRS
   BUNCH=BUNCH_AIRS
case("IASI","iasi")
   IWINDOW=IWINDOW_IASI
   IWINDOW_ALT=IWINDOW_ALT_IASI
   ILIST1=ILIST1_IASI
   ILIST2=ILIST2_IASI
   ILIST2_PAIR=ILIST2_PAIR_IASI
   ICHN_SUN=ICHN_SUN_IASI
   BUNCH=BUNCH_IASI
case("CRIS","cris")
   IWINDOW=IWINDOW_CRIS
   IWINDOW_ALT=IWINDOW_ALT_CRIS
   ILIST1=ILIST1_CRIS
   ILIST2=ILIST2_CRIS
   ILIST2_PAIR=ILIST2_PAIR_CRIS
   ICHN_SUN=ICHN_SUN_CRIS
   BUNCH=BUNCH_CRIS
case default
   Write(*,*) "Unknown instrument ",CINSTR
   CALL ABORT3D('BGCK_GET_QCPARAM')
end select

END SUBROUTINE BGCK_GET_QCPARAM

SUBROUTINE HIRQC ( lend, loop_done, lcolumnhr, lobsSpaceData,CINST,id_in)
!
!**ID HIRQC -- QUALITY CONTROL OF HYPERSPECTRAL INFRARED OBSERVATIONS
!
!       SCIENCE:  L. GARAND
!       AUTHOR:   A. BEAULNE (CMDA/SMC) August 2004
!                 A. BEAULNE (CMDA/SMC)   June 2006  (ADAPT TO 3DVAR)
!                 S. HEILLIETTE           February 2008 (adaptation to IASI)
!                 S. MACPHERSON, S.HEILLIETTE (ARMA) February 2013 
!                   -- modify test pour detecter le isatzen manquant ou anormal
!
!       REVISION:
!
!       OBJECT: ASSIGN ASSIMILATION FLAGS TO OBSERVATIONS 
!
!       ARGUMENTS:
!          INPUT:
!            -LOOP_DONE : NUMBER OF PREVIOUS CALLS TO HIRQC
!
!          OUTPUT:
!            -LEND       : AT THE END OF THIS CALL TO HIRQC, DO ALL 
!                               PROFILES BEEN TREATED (true) OR NOT (false)
!
  use EarthConstants_mod
  use MathPhysConstants_mod
  use tovs_nl_mod
  use hir_chans
  use columnData_mod
  use obsSpaceData_mod
  use verticalCoord_mod
  IMPLICIT NONE
  logical,intent(inout) :: lend
  integer,intent(in) :: loop_done
  integer,intent(in),optional :: id_in
  type(struct_columnData),intent(in) :: lcolumnhr
  type(struct_obs),intent(inout) :: lobsSpaceData
  character (len=*),intent(in) :: CINST
!******************************************************************
  type(struct_vco), pointer :: vco_trl
  INTEGER       :: JC,NCHN,JCH,JF,JL,NLEV,NLEVB,iextr,JN,NPRF,NFLG,ICHN
  INTEGER       :: IWINDO,IWINDO_ALT,NOBHIR
  INTEGER       :: INDEX_BODY,IDATA,IDATEND,INDEX_HEADER
  INTEGER       :: IDATYP
  INTEGER       :: DIFFTOP_MIN
  INTEGER ,SAVE :: IMODTOP
  INTEGER       :: count
  REAL(8)       :: T_EFFECTIVE
  integer       :: alloc_status(85)

  real(8), allocatable :: ZTG(:),ZPS(:),ZTS(:),ZT(:,:),ZHT(:,:),ZLQ(:,:),ZVLEV(:)
  real(8), allocatable :: ZLEVMOD(:,:)
  real(8), allocatable :: BTOBSERR(:),BTOBS(:,:),BTCALC(:,:),RCAL_CLR(:,:),SFCTAU(:,:)
  real(8), allocatable :: ROBS(:,:),RCLD(:,:,:),TRANSM(:,:,:),EMI_SFC(:,:) 
  real(8), allocatable :: CLFR(:),TOEXT(:,:),ZHOEXT(:,:),SUNZA(:),SATAZIM(:),SATZEN(:),SUNAZIM(:)
  real(8), allocatable :: ALBEDO(:),ICE(:),PCNT_WAT(:),PCNT_REG(:)
  integer, allocatable :: KSURF(:),LTYPE(:)
  integer, allocatable :: CLDFLAG(:),REJFLAG(:,:,:),LEV_START(:) 
  integer, allocatable :: GNCLDFLAG(:)
  integer, allocatable :: ICHREF(:),INDX(:)
  integer, allocatable :: NTOP_EQ(:),NTOP_BT(:,:),NTOP_RD(:,:),NTOP_MB(:)
  integer, allocatable :: NTOP_CO2(:,:),NGOOD(:)      
  real(8), allocatable :: PTOP_EQ(:),PTOP_BT(:,:),PTOP_RD(:,:),PTOP_MB(:)
  real(8), allocatable :: PTOP_CO2(:,:),FCLOUD_CO2(:,:),HE(:)
  real(8), allocatable :: ETOP(:),VTOP(:),ECF(:),VCF(:)
  integer, allocatable :: MINP(:,:),FATE(:,:)
  real(8), allocatable :: PMIN(:,:),DTAUDP1(:,:),TAMPON(:),MAXWF(:,:),CFSUB(:)
  logical, allocatable :: ASSIM_ALL(:)
  real(8), allocatable :: ZTS_AVHRR(:,:),SFCTAU_AVHRR(:,:),EMI_SFC_AVHRR(:,:),RCAL_CLR_AVHRR(:,:)
  real(8), allocatable :: RCLD_AVHRR(:,:,:),PTOP_BT_AVHRR(:,:,:),PTOP_RD_AVHRR(:,:,:)
  real(8), allocatable :: BTOBS_AVHRR(:,:,:),ROBS_AVHRR(:,:,:),PTOP_EQ_AVHRR(:,:)
  real(8), allocatable :: CFRAC_AVHRR(:),xpres(:)
  real(8), allocatable :: avhrr_surfem1(:)
  integer, allocatable :: CLDFLAG_AVHRR(:,:),LEV_START_AVHRR(:,:),ICHREF_AVHRR(:,:),NTOP_RD_AVHRR(:,:,:)
  integer, allocatable :: NTOP_BT_AVHRR(:,:,:),NTOP_EQ_AVHRR(:,:)
  integer :: ICL
  Real(8) :: seuil_albed(NIR)
  integer ,parameter :: nn=2
  integer ,parameter :: ilist_avhrr(nn)=(/ 2 ,3 /)
  integer :: cpt,iclass
  logical :: bad
!seuils detection nuageuse AVHRR
  Real(8),parameter :: sunzenmax=87.12d0
  Real(8) :: minpavhrr(2:3)
  Real(8) :: anisot,zlamb,zcloud,scos,del,deltaphi
  Integer :: ier,ijour,iloc(2:3),co2min(1),co2max(1),iobs
  integer :: isatzen
  integer :: chan_indx,ILIST_SUN,ilist_co2(NCO2),ilist_co2_pair(NCO2),ilist_he(NCH_HE)
!********************************************************************************************
  integer :: nlv_T,nch_sel,id,KRTID
  integer :: IWINDOW,IWINDOW_ALT,ILIST1(NCH_HE),ILIST2(NCO2),ILIST2_PAIR(NCO2),ICHN_SUN,BUNCH
  logical :: liasi,lairs,lcris
!****************************************

  liasi= ( trim(cinst)=="IASI" .or.  trim(cinst)=="iasi")
  lairs= ( trim(cinst)=="AIRS" .or.  trim(cinst)=="airs")
  lcris= ( trim(cinst)=="CRIS" .or.  trim(cinst)=="cris")

  call BGCK_GET_QCPARAM(cinst,IWINDOW,IWINDOW_ALT,ILIST1,ILIST2,ILIST2_PAIR,ICHN_SUN,BUNCH)
  vco_trl => col_getVco(lcolumnhr)

  if (present(id_in)) then
     id=id_in
  else
! ** find sensor number corresponding to the desired instrument
     ID =-1
     DO KRTID = 1, NSENSORS
        IF ( trim(CINSTRUMENTID(KRTID)) .EQ. TRIM(CINST)) THEN
           ID = KRTID
           EXIT
        END IF
     END DO
     IF (ID<0) Call abort3d("hirqc: should not happen !")
  endif
! ** find number of profiles (for memory allocation) and set lend 
!    M. Buehner: take care of case when bunch*loopdone exactly equals total number of profiles

  NPRF = 0
  count = 0
  lend = .true. ! set to false if at least 1 obs beyond this bunch

  ! loop over all header indices of the 'TO' family
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
     IF ( tvs_Is_idburp_inst(IDATYP,CINST) .and. lsensor(ltovsno (index_header))==id ) THEN
        count = count + 1
        IF ( count > loop_done * bunch .AND.  &
             count <= (loop_done+1) * bunch ) NPRF = NPRF + 1
        IF ( count > (loop_done+1) * bunch ) lend = .false.
     END IF
  END DO HEADER

  if ( count == 0 ) return
! ** find number of channels and RTTOV levels

  NCHN = coefs(id)%coef%fmv_chn
  
  NLEV = coefs(id)%coef%nlevels 
  allocate (xpres(NLEV))
  xpres(1:NLEV)=coefs(id)% coef% ref_prfl_p(1:NLEV)

  iextr=0
  if (nlev==44) iextr=1
  if (nlev==51) iextr=2
  if (nlev /= 43 .and. nlev/=44 .and. nlev/= 51) then
     Write(*,*) "Attention: modification necessaire dans HIRQC"
     call abort3d('hirqc')
  endif
 
  NLEVB=NLEV-iextr

  write(*,*) ' HIRQC - nchn ', nchn
  

  nlv_T= col_getNumLev(lcolumnhr,'TH')
  nch_sel= hir_get_nchan_selected(cinst)
! information to extract (transvidage)
! ------------------------------------
!
! ZTG(NPRF) -- guess skin temperatures (deg K)
! ZPS(NPRF) -- surface pressure (hPa)
! ZT(nlv_T,NPRF) -- temperature profiles on NWP model levels (deg K)
! ZHT(nlv_T,NPRF) -- height profiles on NWP model levels (m)
! ZLQ(nlv_T,NPRF) -- surface specific humidity in ln q (kg/kg)
! BTOBSERR(nch_sel) -- observation error standard deviation
! BTOBS(nch_sel,NPRF) -- observed brightness temperatures (deg K)
! BTCALC(nch_sel,NPRF) -- computed brightness temperatures (deg K)
! RCAL_CLR(nch_sel,NPRF) -- computed clear radiances (mw/m2/sr/cm-1)
! SFCTAU(nch_sel,NPRF) -- surface to space transmittances (0-1)
! RCLD(nch_sel,NPRF,NLEV) -- overcast cloudy radiances (mw/m2/sr/cm-1)
! TRANSM(nch_sel,NPRF,NLEV) -- layer to space transmittances (0-1)
! EMI_SFC(nch_sel,NPRF) -- surface emissivities (0-1)
! KSURF(NPRF) -- surface type in obs file (0, 1)
! CLFR(NPRF) -- cloud fraction (%)
! TOEXT(NLEV,NPRF) -- temperature profiles on RT model levels (deg K)
! ZHOEXT(NLEV,NPRF) -- height profiles on RT model levels (m)
! SUNZA(NPRF) -- sun zenith angle (deg)
! SATAZIM(NPRF) -- satellite azimuth angle (deg)
! SATZEN(NPRF) -- satellite zenith angle (deg)
! ALBEDO(NPRF) -- surface albedo (0-1)
! ICE(NPRF) -- ice fraction (0-1)
! LTYPE(NPRF) -- surface type (1,...,20)
! PCNT_WAT(NPRF) -- water fraction (0-1)
! PCNT_REG(NPRF) -- water fraction in the area (0-1)
! ROBS(nch_sel,NPRF) -- observed radiances (mW/m2/sr/cm-1)

  alloc_status(:) = 0
  allocate ( ZTG(NPRF),                       stat= alloc_status(1) )
  allocate ( ZPS(NPRF),                       stat= alloc_status(2) )
  allocate ( ZT(nlv_T,NPRF), stat= alloc_status(3) )
  allocate ( ZHT(nlv_T,NPRF),stat= alloc_status(4) )
  allocate ( ZLQ(nlv_T,NPRF),stat= alloc_status(5) )
  allocate ( BTOBSERR(nch_sel),              stat= alloc_status(6) )
  allocate ( BTOBS(nch_sel,NPRF),            stat= alloc_status(7) )
  allocate ( BTCALC(nch_sel,NPRF),           stat= alloc_status(8) )
  allocate ( RCAL_CLR(nch_sel,NPRF),         stat= alloc_status(9) )
  allocate ( SFCTAU(nch_sel,NPRF),           stat= alloc_status(10))
  allocate ( RCLD(nch_sel,NPRF,NLEVB),       stat= alloc_status(11))
  allocate ( TRANSM(nch_sel,NPRF,NLEVB),     stat= alloc_status(12))
  allocate ( EMI_SFC(nch_sel,NPRF),          stat= alloc_status(13))
  allocate ( KSURF(NPRF),                     stat= alloc_status(14))
  allocate ( CLFR(NPRF),                      stat= alloc_status(15))
  allocate ( TOEXT(NLEVB,NPRF),               stat= alloc_status(16))
  allocate ( ZHOEXT(NLEVB,NPRF),              stat= alloc_status(17))
  allocate ( SUNZA(NPRF),                     stat= alloc_status(18))
  allocate ( ALBEDO(NPRF),                    stat= alloc_status(19))
  allocate ( ICE(NPRF),                       stat= alloc_status(20))
  allocate ( LTYPE(NPRF),                     stat= alloc_status(21))
  allocate ( PCNT_WAT(NPRF),                  stat= alloc_status(22))
  allocate ( PCNT_REG(NPRF),                  stat= alloc_status(23))
  allocate ( ROBS(nch_sel,NPRF),             stat= alloc_status(24))
  allocate ( ZTS(NPRF),                       stat= alloc_status(26))
  allocate ( CLDFLAG(NPRF),                   stat= alloc_status(27))
  allocate ( REJFLAG(nch_sel,NPRF,0:BITFLAG),stat= alloc_status(28))
  allocate ( LEV_START(NPRF),                 stat= alloc_status(29))
  allocate ( NTOP_EQ(NPRF),                   stat= alloc_status(31))
  allocate ( NTOP_BT(nch_sel,NPRF),          stat= alloc_status(32))
  allocate ( NTOP_RD(nch_sel,NPRF),          stat= alloc_status(33))
  allocate ( NTOP_CO2(NCO2,NPRF),             stat= alloc_status(34))
  allocate ( PTOP_EQ(NPRF),                   stat= alloc_status(35))
  allocate ( PTOP_BT(nch_sel,NPRF),          stat= alloc_status(36))
  allocate ( PTOP_RD(nch_sel,NPRF),          stat= alloc_status(37))
  allocate ( PTOP_CO2(NCO2,NPRF),             stat= alloc_status(38))
  allocate ( FCLOUD_CO2(NCO2,NPRF),           stat= alloc_status(39))
  allocate ( HE(NPRF),                        stat= alloc_status(40))
  allocate ( ETOP(NPRF),                      stat= alloc_status(41))
  allocate ( VTOP(NPRF),                      stat= alloc_status(42))
  allocate ( ECF(NPRF),                       stat= alloc_status(43))
  allocate ( VCF(NPRF),                       stat= alloc_status(44))
  allocate ( NGOOD(NPRF),                     stat= alloc_status(45))
  allocate ( MINP(nch_sel,NPRF),             stat= alloc_status(46))
  allocate ( PMIN(nch_sel,NPRF),             stat= alloc_status(47))
  allocate ( DTAUDP1(nch_sel,NPRF),          stat= alloc_status(48))
  allocate ( TAMPON(NPRF),                    stat= alloc_status(49))
  allocate ( FATE(nch_sel,NPRF),             stat= alloc_status(50))
  allocate ( ICHREF(NPRF),                    stat= alloc_status(51))
  allocate ( ASSIM_ALL(NPRF),                 stat= alloc_status(53))
  if (liasi) then
     allocate ( INDX(NPRF),                      stat= alloc_status(54))
     allocate ( LEV_START_AVHRR(NPRF,NCLASSAVHRR),stat= alloc_status(55))
     allocate ( PTOP_EQ_AVHRR(NPRF,NCLASSAVHRR),  stat= alloc_status(56))
     allocate ( NTOP_EQ_AVHRR(NPRF,NCLASSAVHRR),  stat= alloc_status(57))
     allocate ( BTOBS_AVHRR(1:NIR,NPRF,NCLASSAVHRR),stat= alloc_status(58))
     allocate ( ICHREF_AVHRR(NPRF,NCLASSAVHRR)     ,stat= alloc_status(59))
     allocate ( CLDFLAG_AVHRR(NPRF,NCLASSAVHRR)    ,stat= alloc_status(60))
     allocate ( ROBS_AVHRR(1:NIR,NPRF,NCLASSAVHRR),stat= alloc_status(61))
     allocate ( RCAL_CLR_AVHRR(1:NIR,NPRF),stat= alloc_status(62))
     allocate ( EMI_SFC_AVHRR(1:NIR,NPRF),stat= alloc_status(63))
     allocate ( ZTS_AVHRR(NPRF,NCLASSAVHRR),stat= alloc_status(64))
     allocate ( SFCTAU_AVHRR(NIR,NPRF),           stat= alloc_status(65))
     allocate ( PTOP_BT_AVHRR(NIR,NPRF,NCLASSAVHRR), stat= alloc_status(66))
     allocate ( PTOP_RD_AVHRR(NIR,NPRF,NCLASSAVHRR), stat= alloc_status(67))
     allocate ( NTOP_BT_AVHRR(NIR,NPRF,NCLASSAVHRR), stat= alloc_status(68))
     allocate ( NTOP_RD_AVHRR(NIR,NPRF,NCLASSAVHRR), stat= alloc_status(69))
     allocate ( RCLD_AVHRR(NIR,NPRF,NLEVB), stat= alloc_status(70))
     allocate ( CFRAC_AVHRR(NPRF),             stat= alloc_status(74))
     allocate ( SATAZIM(NPRF),                 stat= alloc_status(75))
     allocate ( SATZEN(NPRF),                  stat= alloc_status(76))
     allocate ( SUNAZIM(NPRF),                 stat= alloc_status(85))
  endif
  allocate ( maxwf(nch_sel,NPRF),          stat= alloc_status(73))
  allocate ( ZVLEV(NLEVB),                  stat= alloc_status(77))
  allocate ( PTOP_MB(NPRF),                 stat= alloc_status(78))
  allocate ( NTOP_MB(NPRF),                 stat= alloc_status(79))
  allocate ( CFSUB(NPRF),                   stat= alloc_status(80))
  allocate ( GNCLDFLAG(NPRF),               stat= alloc_status(81))
  allocate ( ZLEVMOD(nlv_T,NPRF), stat= alloc_status(84))
 

  if( any(alloc_status /= 0) ) then
     write(*,*) ' hirqc : memory allocation error'
     call abort3d('hirqc        ')
  end if

  DO JL = 1, NLEVB
     ZVLEV(JL) = XPRES(JL+iextr)
  END DO
  CO2MIN=minloc( abs( ZVLEV(:) - pco2min ) )
  CO2MAX=minloc( abs( ZVLEV(:) - pco2max ) )


  BTOBS(:,:)    = -1.d0
  BTCALC(:,:)   = -1.d0
  RCAL_CLR(:,:) = -1.d0
  SFCTAU(:,:)   = -1.d0
  RCLD(:,:,:)   = -1.d0
  TRANSM(:,:,:) = -1.d0
  EMI_SFC(:,:)  = -1.d0

  REJFLAG(:,:,:) = 0

  NOBHIR = 0
  NOBTOV = 0
  count = 0

  ! loop over all header indices of the 'TO' family
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER_2: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER_2

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)

     IF ( tvs_Is_idburp_tovs(idatyp) ) NOBTOV = NOBTOV + 1

     IF ( tvs_Is_idburp_inst(IDATYP,CINST) .and. lsensor(ltovsno (index_header))==id) THEN

        count = count + 1
        
        IF ( count > loop_done * bunch .AND.  &
             count <= (loop_done+1) * bunch ) THEN

           NOBHIR = NOBHIR + 1
          
           if (liasi) then
              INDX(NOBHIR)=index_header
              iclass=1
              do iobs=OBS_CF1,OBS_CF7
                 avhrr_bgck(INDEX_HEADER)%CFRAC(iclass)=obs_headElem_i(lobsSpaceData,iobs,index_header)
                 iclass=iclass+1
              enddo
              iclass=1
              ichn=1
              do iobs=OBS_M1C1,OBS_M7C6
                 avhrr_bgck(INDEX_HEADER)%radmoy(iclass,ichn)=obs_headElem_r(lobsSpaceData,iobs,index_header)
                 ichn=ichn+1
                 if (ichn>NCHANAVHRR) then
                    ichn=1
                    iclass=iclass+1
                 endif
              enddo
              iclass=1
              ichn=1
              do iobs=OBS_S1C1,OBS_S7C6
                 avhrr_bgck(INDEX_HEADER)%radstd(iclass,ichn)=obs_headElem_r(lobsSpaceData,iobs,index_header)
                 ichn=ichn+1
                 if (ichn>NCHANAVHRR) then
                    ichn=1
                    iclass=iclass+1
                 endif
              enddo
              SUNAZIM(NOBHIR) = 0.01d0 * obs_headElem_i(lobsSpaceData,OBS_SAZ,index_header)
           end if

           ZTG(NOBHIR) = col_getElem(lcolumnhr,1,INDEX_HEADER,'TG')
           ZPS(NOBHIR) = col_getElem(lcolumnhr,1,INDEX_HEADER,'P0') &
                                                             * MPC_MBAR_PER_PA_R8

           DO JL = 1, nlv_T
              ZT(JL,NOBHIR) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'TT')
              ZHT(JL,NOBHIR) = col_getHeight(lcolumnhr,JL,INDEX_HEADER,'TH') / RG
              ZLQ(JL,NOBHIR) = col_getElem(lcolumnhr,JL,INDEX_HEADER,'HU')
              ZLEVMOD(JL,NOBHIR)= col_getPressure(lcolumnhr,JL,INDEX_HEADER,'TH') &
                                                             * MPC_MBAR_PER_PA_R8
           END DO

           IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,index_header)
           IDATEND = obs_headElem_i(lobsSpaceData,OBS_NLV,index_header) + IDATA - 1
           BAD=.false.
           if (lcris) BAD=( obs_headElem_i(lobsSpaceData,OBS_GQF,index_header)/=0 .or. &
                obs_headElem_i(lobsSpaceData,OBS_GQL,index_header) /=0)
           if (liasi) BAD=( obs_headElem_i(lobsSpaceData,OBS_GQF,index_header)/=0 .or. &
                obs_headElem_i(lobsSpaceData,OBS_GQL,index_header) >1) 
   
                DO INDEX_BODY= IDATA, IDATEND
                   IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1 ) THEN
                    ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
                    ICHN = MAX(0,MIN(ICHN,JPCHMAX+1))
                    chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
                    BTOBSERR(chan_indx) = obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY)
                    BTOBS(chan_indx,NOBHIR) = obs_bodyElem_r(lobsSpaceData,OBS_VAR,INDEX_BODY)

! *** Flag check on observed BTs ***
                    IF (.not.liasi .and. BTEST(obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY),2)) REJFLAG(chan_indx,NOBHIR,9) = 1
                    IF (BAD) REJFLAG(chan_indx,NOBHIR,9) = 1

! *** Gross check on observed BTs ***
                    IF (BTOBS(chan_indx,NOBHIR)<150.d0) REJFLAG(chan_indx,NOBHIR,9) = 1

                    IF (BTOBS(chan_indx,NOBHIR)>350.d0) REJFLAG(chan_indx,NOBHIR,9) = 1
                 END IF
              END DO

              DO JC = 1, NCHN
                 ICHN = ichan(JC,ID)
                 chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
                 BTCALC(chan_indx,NOBHIR) = radiance_d(nobtov)%bt(jc)
                 RCAL_CLR(chan_indx,NOBHIR) = radiance_d(nobtov)%clear(jc)
                 SFCTAU(chan_indx,NOBHIR) = transmission_d(nobtov)%tau_total(jc)
                 DO JL = 1, NLEVB
                    RCLD(chan_indx,NOBHIR,JL) = radiance_d(nobtov)%overcast(jl+iextr-1,jc)
                    TRANSM(chan_indx,NOBHIR,JL) = transmission_d(nobtov)%tau_levels(jl+iextr,jc)
                 END DO
                 EMI_SFC(chan_indx,NOBHIR) = emissivity(JC,NOBTOV)
! *** Gross check on computed BTs ***
                 IF (BTCALC(chan_indx,NOBHIR)<150.d0) REJFLAG(chan_indx,NOBHIR,9) = 1
                 IF (BTCALC(chan_indx,NOBHIR)>350.d0) REJFLAG(chan_indx,NOBHIR,9) = 1
              END DO


           KSURF(NOBHIR) = profiles(nobtov)%skin%surftype
!Test pour detecter le isatzen manquant (-1) ou anormal
! (angle negatif ou superieur a 75 degres )
           isatzen= obs_headElem_i(lobsSpaceData,OBS_SZA,INDEX_HEADER)
           if ( isatzen < 9000 .or. &
                isatzen > 16500 ) then
              DO JC = 1, NCHN
                 ICHN = ichan(JC,ID)
                 chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
                 REJFLAG(chan_indx,NOBHIR,9) = 1
              ENDDO
           endif
!**************************************************************
           CLFR(NOBHIR) = 0.
           if (lairs) CLFR(NOBHIR) = obs_headElem_i(lobsSpaceData,OBS_CLF,INDEX_HEADER)

           DO JL = 1, NLEVB
              TOEXT(JL,NOBHIR) = profiles(nobtov)%t(jl+iextr)
              ZHOEXT(JL,NOBHIR) = profiles_qc(nobtov)%z(jl+iextr)
           END DO

           SUNZA(NOBHIR) = profiles_qc(nobtov)%sunza
           if (liasi) then
              SATAZIM(NOBHIR) = profiles(nobtov)%azangle 
              SATZEN(NOBHIR) = profiles(nobtov)%zenangle
           endif
           ALBEDO(NOBHIR) = profiles_qc(nobtov)%albedo
           ICE(NOBHIR) = profiles_qc(nobtov)%ice
           LTYPE(NOBHIR) = profiles_qc(nobtov)%ltype
           IF(LTYPE(NOBHIR).EQ.20) KSURF(NOBHIR)=2
           PCNT_WAT(NOBHIR) = profiles_qc(nobtov)%pcnt_wat
           PCNT_REG(NOBHIR) = profiles_qc(nobtov)%pcnt_reg
           
        END IF

     END IF

  END DO HEADER_2


! ** find TOA radiances converted from observed BT's

  ROBS(:,:) = -1.d0

  profils: DO JN = 1, NPRF
     channels: DO JC = 1, NCHN
        ICHN = ichan(JC,ID)
        chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
        IF ( REJFLAG(chan_indx,JN,9) == 1 ) CYCLE channels
        t_effective =  coefs(id)%coef%ff_bco(jc) &
             + coefs(id)%coef%ff_bcs(jc) * BTOBS(chan_indx,jn)
        ROBS(chan_indx,jn) =  coefs(id)%coef%planck1(jc) / &
             ( Exp( coefs(id)%coef%planck2(jc)/t_effective ) - 1.d0 )
     END DO channels
  END DO profils


! ** set height fields to 'height above ground' fields

  DO JN = 1, NPRF
     DO JL = 1, NLEVB
        ZHOEXT(JL,JN) = ZHOEXT(JL,JN) - ZHT(nlv_T,JN)
     END DO
     DO JL = 1, nlv_T
        ZHT(JL,JN) = ZHT(JL,JN) - ZHT(nlv_T,JN)
     END DO
  END DO


!**********************************************************************************************

!* ///// ---------------------------------------------------- /////
!* ///// DETERMINATION OF THE CLEAR/CLOUDY PROFILES (CLDFLAG) /////
!* ///// ---------------------------------------------------- /////

  CLDFLAG(:) = 0


!* -- REFERENCE FOR WINDOW CHANNEL

  IWINDO     = hir_get_chindx_fr_chn(CINST,IWINDOW)
  IWINDO_ALT = hir_get_chindx_fr_chn(CINST,IWINDOW_ALT)

  ICHREF(:)  = IWINDO
  DO JN = 1, NPRF
     IF ( REJFLAG(IWINDO,JN,9) == 1 ) THEN
        ICHREF(JN) = IWINDO_ALT
        IF ( REJFLAG(IWINDO_ALT,JN,9) == 1 ) THEN
           ICHREF(JN) = -1
           CLDFLAG(JN) = -1
           REJFLAG(:,JN,9) = 1
           write(*,*) 'WARNING'
           write(*,*) 'WINDOW AND ALTERNATE WINDOW CHANNEL OBSERVATIONS'
           write(*,*) 'HAVE BEEN REJECTED.                             '
           write(*,*) 'ALL '//cinst//' OBSERVATIONS FROM THIS PROFILE REJECTED'
        END IF
     END IF
  END DO
      

!* -- CLOUD TOP BASED ON MATCHING OBSERVED BRIGHTNESS TEMPERATURE 
!* -- AT A REFERENCE SURFACE CHANNEL WITH BACKGROUND TEMPERATURE PROFILE (PTOP_EQ)
!* -- ON GUESS VERTICAL LEVELS.

  LEV_START(:) = 0

!iopt2=1 : calcul de la hauteur en hPa PTOP_MB et du NTOP_MB correspondant
  CALL CLOUD_HEIGHT (PTOP_MB,NTOP_MB, btobs,cldflag,zt, &
       zht,zps,zlevmod,nlv_T,nch_sel,nprf,ichref,lev_start,iopt2)

!iopt1=2 : calcul de la hauteur em metres PTOP_EQ et du NTOP_EQ correspondant
  CALL CLOUD_HEIGHT (PTOP_EQ,NTOP_EQ, btobs,cldflag,zt, &
       zht,zps,zlevmod,nlv_T,nch_sel,nprf,ichref,lev_start,iopt1)

  if (liasi) then
 ! appel de RTTOV pour calculer les radiances des 3 canaux IR (3b, 4 et 5) de AVHRR 3
     
     allocate ( avhrr_surfem1   (3 * NPRF ) ,stat=alloc_status(1))

     call get_avhrr_emiss(emi_sfc,coefs(id) %coef%ff_cwn,coefs(id) % coef%fmv_chn,nprf,avhrr_surfem1)

     call tovs_rttov_AVHRR_for_IASI(indx,nprf,avhrr_surfem1,SATELLITE(id))

     deallocate ( avhrr_surfem1  ,stat=alloc_status(1))

     DO JN=1,NPRF
        IOBS=INDX(JN)
        call convert_avhrr(profiles_qc(IOBS)%sunza, avhrr_bgck(IOBS) )
        call stat_avhrr(avhrr_bgck(IOBS))
     ENDDO
     
     LEV_START_AVHRR(:,:) = 0
     cldflag_avhrr(:,:)=0
     DO JC=1,NCLASSAVHRR
        DO JN=1,NPRF
           IOBS=INDX(JN)
           btobs_avhrr(:,JN,JC)= avhrr_bgck(IOBS) % TBMOY(JC,:)
           robs_avhrr(1:NIR,JN,JC)= avhrr_bgck(IOBS) % RADMOY(JC,NVIS+1:NIR+NVIS)
           RCAL_CLR_AVHRR(:,JN) = avhrr_bgck(IOBS) % RADCLEARCALC(:)
           EMI_SFC_AVHRR(:,JN) = avhrr_bgck(IOBS) % EMISS(:)
           SFCTAU_AVHRR(:,JN) = avhrr_bgck(IOBS) % TRANSMSURF(:)
        
           DO JL=1,NLEVB
              RCLD_AVHRR(:,JN,JL) = avhrr_bgck(IOBS) % RADOVCALC(JL+iextr-1,:)
           ENDDO
           
           IF (btobs_avhrr(2,JN,JC) >100.d0 ) THEN
              ichref_avhrr(JN,JC)=2
           ELSE IF (btobs_avhrr(3,JN,JC) >100.d0 ) THEN
              ichref_avhrr(JN,JC)=3
           ELSE
              ichref_avhrr(JN,JC)=-1
              cldflag_avhrr(JN,JC)=-1
           ENDIF
        ENDDO

        CALL CLOUD_HEIGHT (PTOP_EQ_AVHRR(:,JC),NTOP_EQ_AVHRR(:,JC), btobs_avhrr(:,:,JC),cldflag_avhrr(:,JC),zt, &
             zht,zps,zvlev,nlv_T,NIR,nprf,ichref_avhrr(:,JC),lev_start_avhrr(:,JC),iopt1)
         
     ENDDO
  end if
      
!* -- CLEAR/CLOUDY PROFILE DETECTION USING THE GARAND & NADON ALGORITHM

  CALL GARAND1998NADON (CLDFLAG, btobs,ztg,zt, &
       zht,nlv_T,nch_sel,nprf,ptop_eq,ntop_eq,ichref)

  if (liasi) then
     DO JC=1,NCLASSAVHRR
        CALL GARAND1998NADON (CLDFLAG_AVHRR(:,jC), btobs_avhrr(:,:,JC),ztg,zt, &
             zht,nlv_T,NIR,nprf,ptop_eq_avhrr(:,JC),ntop_eq_avhrr(:,JC),ichref_avhrr(:,JC))
     ENDDO
  end if

!* -- FURTHER TESTS TO REMOVE POTENTIAL CLOUDY PROFILES
! *** TEST # A ***
! *** In daytime, set cloudy if cloud fraction over 5% ***
  CFSUB(:)=-1.d0
  if (lairs) then
     DO JN =1, NPRF
        IF ( CLDFLAG(JN) == 0 .AND. CLFR(JN) > 5.d0 .AND. SUNZA(JN) < 90.d0 ) THEN
           CLDFLAG(JN) = 1
           CFSUB(JN)=0.01d0*CLFR(JN) !conversion % -> 0-1
        ENDIF
     ENDDO
  endif
! *** TEST # B ***
! *** Set cloudy if temperature difference between guess (ZTG)     ***
! *** and estimated true (ZTS) skin temperatures is over threshold ***

  CALL ESTIM_TS(ZTS, ztg,emi_sfc,rcal_clr,robs, &
       sfctau,cldflag,ichref,nch_sel,nchn,nprf,id,CINST)

  WHERE ( CLDFLAG(:) == 0 .AND. KSURF(:) == 1 &
       .AND. ABS(ZTS(:)-ZTG(:)) > DTW ) CLDFLAG(:) = 1 

  WHERE ( CLDFLAG(:) == 0 .AND. KSURF(:) /= 1 &
       .AND. ABS(ZTS(:)-ZTG(:)) > DTL ) CLDFLAG(:) = 1


  if (liasi) then

     DO JC=1,NCLASSAVHRR
        CALL ESTIM_TS_AVHRR(ZTS_AVHRR(:,JC), ztg,emi_sfc_avhrr,rcal_clr_avhrr,robs_avhrr(:,:,JC), &
             sfctau_avhrr,CLDFLAG_AVHRR(:,jC),ichref_avhrr(:,JC),NIR,nprf)

     ENDDO

     DO JC=1,NCLASSAVHRR
        WHERE ( CLDFLAG_AVHRR(:,JC) == 0 .AND. KSURF(:) == 1 &
             .AND. ABS(ZTS_AVHRR(:,JC)-ZTG(:)) > DTW ) CLDFLAG_AVHRR(:,JC) = 1

        WHERE ( CLDFLAG_AVHRR(:,JC) == 0 .AND. KSURF(:) /= 1 &
             .AND. ABS(ZTS_AVHRR(:,JC)-ZTG(:)) > DTL ) CLDFLAG_AVHRR(:,JC) = 1

     ENDDO

!criteres AVHRR utilisant les canaux visibles (de jour seulement)
     DO JN=1,NPRF
        IF (sunza(jn)<sunzenmax) THEN 
           ANISOT=1.d0
           deltaphi=abs(SATAZIM(JN) - SUNAZIM(JN) )
           
           IF (deltaphi>180.d0) deltaphi=360.d0 - deltaphi
           
           IF (ALBEDO(JN)<0.17d0) THEN               
              CALL VISOCN(sunza(jn),satzen(jn),deltaphi,ANISOT,ZLAMB,ZCLOUD,IER)
              SEUIL_ALBED(1)=10.d0*max(1.d0,ANISOT) 
           ELSE
              SEUIL_ALBED(1)=100.d0*ALBEDO(JN) + 10.d0
           ENDIF

           IF (ANISOT<1.5d0) THEN !to avoid sun glint
              SCOS=COS ( sunza(jn) * MPC_DEGREES_PER_RADIAN_R8 )
              CALL  cor_albedo ( DEL, SCOS )
              SEUIL_ALBED(1)=SEUIL_ALBED(1) * DEL
              IOBS=INDX(JN)
              DO JC=1,NCLASSAVHRR
                 IF (avhrr_bgck(IOBS)%ALBEDMOY(JC,1) > SEUIL_ALBED(1) ) THEN
                    CLDFLAG_AVHRR(JN,JC) = 1
                 ENDIF
                  !static AVHRR thresholds v3
                 DO JL=1,NVIS
                    IF (avhrr_bgck(IOBS)%ALBEDMOY(JC,JL) > seuilalb_static(JL,KSURF(JN)) ) THEN
                       CLDFLAG_AVHRR(JN,JC) = 1
                    ENDIF
                 ENDDO
              ENDDO
              
           ENDIF
        ENDIF
     ENDDO

!Calcul de la pseudo fraction nuageuse AVHRR

     DO JN=1,NPRF
        IOBS=INDX(JN)
        CFRAC_AVHRR(JN)=0.d0
        DO JC=1,NCLASSAVHRR
           IF (CLDFLAG_AVHRR(JN,JC) == 1) CFRAC_AVHRR(JN)=CFRAC_AVHRR(JN) + avhrr_bgck(IOBS)%CFRAC(JC)
        ENDDO
     ENDDO

     CFSUB(:)=-1.0d0
     DO JN =1, NPRF
        IF ( CLDFLAG(JN) == 0 .AND. CFRAC_AVHRR(JN) > 5.d0 ) THEN
           CLDFLAG(JN) = 1
           CFSUB(JN)=0.01d0* MIN(CFRAC_AVHRR(JN),100.d0) !conversion % -> 0-1 avec seuil car parfois CFRAC_AVHRR(JN)=101
        ENDIF
     ENDDO

!AVHRR Homogeneity criteria
     DO JN=1,NPRF
        IOBS=INDX(JN)
        IF (CLDFLAG(JN) == 0) THEN
           IJOUR=1
           IF (SUNZA(JN)<90.d0) IJOUR=2
        ! 1 NUIT
        ! 2 JOUR
           IF (IJOUR==2) THEN
              DO JC=1,NVIS
                 IF (avhrr_bgck(IOBS)%ALBSTD_PIXELIASI(JC)> seuilalb_homog(JC,KSURF(JN)) ) CLDFLAG(JN)=1
              ENDDO
           ENDIF
           DO JC=NVIS+1,NVIS+NIR
              IF (avhrr_bgck(IOBS)%TBSTD_PIXELIASI(JC)>seuilbt_homog(JC,KSURF(JN),IJOUR)) CLDFLAG(JN)=1
           ENDDO
        ENDIF
     ENDDO
  endif

  GNCLDFLAG(:)=CLDFLAG(:)

!* ///// ------------------------------------------------------- /////
!* ///// DETERMINATION OF THE ASSIMILABLE OBSERVATIONS (REJFLAG) /////
!* ///// ------------------------------------------------------- /////

!      CLDFLAG(:) = 1

!* -- FIRST TESTS TO REJECT OBSERVATIONS


! *** TEST # 1 ***
! *** Do not assimilate where cloudy ***

  DO JN = 1, NPRF
     IF ( CLDFLAG(JN) == 1 ) then
        REJFLAG(:,JN,11) = 1
        REJFLAG(:,JN,23) = 1
     endif
  END DO


! *** TEST # 2 ***
! *** Gross check on valid BTs ***

!     already done


!* -- CLOUD TOP BASED ON MATCHING 
!* -- OBSERVED BRIGHTNESS TEMPERATURE WITH BACKGROUND TEMPERATURE PROFILES (PTOP_BT)
!* -- OR COMPUTED OBSERVED RADIANCES WITH BACKGROUND RADIANCE PROFILES (PTOP_RD)
!* -- ON RTTOV VERTICAL LEVELS

  LEV_START(:) = 0

  DO JCH = 1, NCH_HE
     ILIST_HE(JCH) = hir_get_chindx_fr_chn(CINST,ILIST1(JCH))
  END DO

  CALL CLOUD_TOP ( PTOP_BT,PTOP_RD,NTOP_BT,NTOP_RD, &
       btobs,toext,zhoext,rcal_clr,zps,robs,rcld,zvlev,nlevb, &
       nch_sel,nprf,cldflag,rejflag,bitflag,lev_start,iopt2,ihgt,ichref,nch_he,ilist_he)

  if (liasi) then
     LEV_START_AVHRR(:,:) = 0

     DO JC=1,NCLASSAVHRR
        CALL CLOUD_TOP_AVHRR ( PTOP_BT_AVHRR(:,:,JC),PTOP_RD_AVHRR(:,:,JC),NTOP_BT_AVHRR(:,:,JC),NTOP_RD_AVHRR(:,:,JC), &
             btobs_avhrr(:,:,JC),toext,zhoext,rcal_clr_avhrr,zps,robs_avhrr(:,:,JC),rcld_avhrr,zvlev,nlevb, &
             NIR,nprf,cldflag_avhrr(:,jc),lev_start_avhrr(:,JC),iopt2,ihgt,nn,ilist_avhrr)
     ENDDO
  endif

!* -- REFERENCE CHANNEL FOR CO2-SLICING

  DO JCH = 1, NCO2
     ILIST_CO2(JCH) = hir_get_chindx_fr_chn(CINST,ILIST2(JCH))
     ILIST_CO2_PAIR(JCH) = hir_get_chindx_fr_chn(CINST,ILIST2_PAIR(JCH))
  END DO

  DO JN = 1, NPRF
     cpt=0

     DO JCH=1,NCO2
        IF ( REJFLAG(ILIST_CO2(JCH),JN,9)==1 .or. &
             REJFLAG(ILIST_CO2_PAIR(JCH),JN,9)==1 ) cpt=cpt+1
     ENDDO
         
     IF (cpt==nco2) THEN
        CLDFLAG(JN) = -1
        REJFLAG(:,JN,9) = 1
        write(*,*) 'WARNING'
        write(*,*) 'CO2 REFERENCE AND ALTERNATE CHANNEL OBSERVATIONS'
        write(*,*) 'HAVE BEEN REJECTED.                             '
        write(*,*) 'ALL '//CINST//' OBSERVATIONS FROM THIS PROFILE REJECTED'
     ENDIF
  END DO

!* -- EQUIVALENT HEIGHT OF SELECTED WINDOW CHANNEL

  HE(:) = PTOP_RD( hir_get_chindx_fr_chn(CINST,ILIST1(2)) ,:)

  DO JN = 1, NPRF
     IF (ICHREF(JN)==IWINDO_ALT) HE(JN) = PTOP_RD( hir_get_chindx_fr_chn(CINST,ILIST1(3)) ,JN)
  END DO


!* -- CLOUD TOP BASED ON CO2 SLICING 

  DO JN = 1, NPRF
     LEV_START(JN) = MAX( MIN(LEV_START(JN),CO2MAX(1)), CO2MIN(1) )
  END DO



  CALL CO2_SLICING ( PTOP_CO2,NTOP_CO2,FCLOUD_CO2, &
       rcal_clr,rcld,robs,zps,zvlev,nlevb,nch_sel,nprf,cldflag,rejflag,bitflag, &
       lev_start,ichref,nco2,ilist_co2,ilist_co2_pair)


!* -- FIND CONSENSUS CLOUD TOP AND FRACTION
     
  CALL SELTOP ( ETOP,VTOP,ECF,VCF,NGOOD, he,ptop_co2,fcloud_co2, &
       CFSUB,PTOP_MB,zps,cldflag,gncldflag,nprf,nco2 )

  if (liasi) then
! Correction pour les nuages trop bas:
! en principe Pco2 < Heff.
! on cherche les cas pathologiques avec Pco2>Min(Heff(AVHRR))
     DO JN=1,NPRF
        IOBS=INDX(JN)
        minpavhrr(2:3)=12200
        ILOC(2:3)=-1      ! pour eviter les catastrophes...
        DO JC=1,NCLASSAVHRR
           IF (avhrr_bgck(IOBS)%CFRAC(JC)>0.d0) THEN
              IF (PTOP_RD_AVHRR(2,JN,JC)<minpavhrr(2)) THEN
                 ILOC(2)=JC
                 minpavhrr(2)=PTOP_RD_AVHRR(2,JN,JC)
              ENDIF
              IF (PTOP_RD_AVHRR(3,JN,JC)<minpavhrr(3)) THEN
                 ILOC(3)=JC
                 minpavhrr(3)=PTOP_RD_AVHRR(3,JN,JC)
              ENDIF
           ENDIF
        ENDDO
        IF ( ILOC(2)==-1 .or. ILOC(3)==-1) CYCLE ! pour eviter les catastrophes...
! on se limite aux cas "surs" ou les deux hauteurs effectives sont > a Pco2
! et ou un accord raisonnable existe entre les deux hauteurs effectives
        IF ( ILOC(2)==ILOC(3) .and. &
             minpavhrr(2) < ETOP(JN) .and. &
             minpavhrr(3) < ETOP(JN) .and. &
             ABS(minpavhrr(2)- minpavhrr(3))<25.d0 .and. &
             CLDFLAG_AVHRR(JN,ILOC(2))/=-1 .and. CLDFLAG_AVHRR(JN,ILOC(3))/=-1) THEN
        
           IF (ECF(JN)==0.d0 .and. CLDFLAG(JN)==1) THEN
! cas predetermine nuageux mais ramene a clair 
              ECF(JN)=0.01d0* min(100.d0,CFRAC_AVHRR(JN))
! cette ligne peut generer des fractions nuageuses inferieures a 20 %.
              ETOP(JN)=0.5d0*(minpavhrr(2) + minpavhrr(3))
           ENDIF

           IF (ECF(JN)>0.d0 .and. CLDFLAG(JN)==1) THEN
!cas predetermine nuageux pas ramene clair (==normal)
              ETOP(JN)=0.5d0*(minpavhrr(2) + minpavhrr(3))
           ENDIF

           IF (CLDFLAG(JN)==0) THEN
               !cas predetermine clair ... que faire
              CLDFLAG(JN)=1
              ETOP(JN)=0.5d0*(minpavhrr(2) + minpavhrr(3))
              ECF(JN)=0.01d0* min(100.d0,CFRAC_AVHRR(JN))
           ENDIF
        ENDIF
     ENDDO
  endif
!* -- FIND RADIATIVE TRANSFER MODEL LEVEL NEAREST TO TRIAL TOP (only compute one time)

  IF ( loop_done == 0 ) THEN
     
     DIFFTOP_MIN = 100000.d0
     IMODTOP     = 1

     DO JL = 1, NLEVB
        IF ( ABS(vco_trl%DPT_M-100.d0*ZVLEV(JL)) < DIFFTOP_MIN ) THEN
           DIFFTOP_MIN = ABS(vco_trl%DPT_M-100.d0*ZVLEV(JL))
           IMODTOP = JL
        END IF
     END DO

     write(*,*) 'TOIT DU MODELE (MB)'
     write(*,*) 0.01d0*vco_trl%DPT_M
     write(*,*) 'NIVEAU DU MODELE DE TRANSFERT RADIATIF LE PLUS PRES DU TOIT DU MODELE'
     write(*,*) IMODTOP

  END IF


!* -- FIND MINIMUM LEVEL OF SENSITIVITY FOR CHANNEL ASSIMILATION NOT SENSIBLE TO CLOUDS

  CALL MIN_PRES_new (MAXWF, MINP,PMIN,DTAUDP1, zps,transm,zvlev,cldflag,nlevb,nch_sel,nprf,imodtop )

!* -- ASSIMILATION OF OBSERVATIONS WHEN CLOUDY PROFILES

! *** TEST # 3 ***
! *** Assimilation above clouds (refinement of test 1)             ***
! *** Set security margin to 2x the std on height from CO2-slicing *** 

  TAMPON(:) = MAX(50.D0, 2.d0*VTOP(:))                                                          

  DO JC = 1, nch_sel        
     WHERE ( REJFLAG(JC,:,11) == 1 .AND. REJFLAG(JC,:,23) == 1 .and. ETOP(:) - TAMPON(:) > PMIN(JC,:) )
        REJFLAG(JC,:,11) = 0
        REJFLAG(JC,:,23) = 0
     end WHERE
  END DO


!     LOOK AT THE FATE OF THE OBSERVATIONS

  FATE(:,:) = SUM(REJFLAG(:,:,:),DIM=3)            


!     FURTHER REASONS TO REJECT OBSERVATIONS

  ILIST_SUN= hir_get_chindx_fr_chn(CINST,ICHN_SUN)

  DO JC = 1, nch_sel
     DO JN = 1, NPRF

        IF ( FATE(JC,JN) == 0 ) THEN

! *** TEST # 4 ***
! *** Background check, do not assimilate if O-P > 3sigma ***

           IF ( ABS(BTOBS(JC,JN)-BTCALC(JC,JN)) > 3.d0*BTOBSERR(JC) ) THEN
              REJFLAG(JC,JN,9)  = 1
              REJFLAG(JC,JN,16) = 1
           END IF

! *** TEST # 5 ***
! *** Do not assimilate shortwave channels during the day ***

           IF ( JC >= ILIST_SUN .AND. SUNZA(JN) < NIGHT_ANG ) then
              REJFLAG(JC,JN,11) = 1
              REJFLAG(JC,JN,7)  = 1
           END IF

! *** TEST # 6 ***
! *** Do not assimilate surface channels over land ***

           IF ( MINP(JC,JN) == NLEVB .or. ZPS(JN)-PMIN(JC,JN) < 100.d0 ) THEN
              IF ( KSURF(JN) == 0 ) THEN
                 REJFLAG(JC,JN,11) = 1    !!! comment this line if assimilation under conditions
                 REJFLAG(JC,JN,19) = 1    !!! comment this line if assimilation under conditions
                 IF ( PCNT_WAT(JN) > 0.01d0 .OR. PCNT_REG(JN) > 0.1d0 .OR. EMI_SFC(JC,JN) < 0.97d0 ) THEN
                    REJFLAG(JC,JN,11) = 1
                    REJFLAG(JC,JN,19) = 1
                 END IF

! *** TEST # 7 ***
! *** Do not assimilate surface channels over water under conditions ***

              ELSE IF ( KSURF(JN) == 1 ) THEN
                 IF ( PCNT_WAT(JN) < 0.99d0 .OR. PCNT_REG(JN) < 0.97d0 .OR. &
                      ICE(JN) > 0.001d0 .OR. ALBEDO(JN) >= 0.17d0 .OR. EMI_SFC(JC,JN) < 0.9d0 ) THEN
                    REJFLAG(JC,JN,11) = 1   
                    REJFLAG(JC,JN,19) = 1   
                 END IF

! *** TEST # 8 ***
! *** Do not assimilate surface channels over sea ice ***
   
              ELSE IF ( KSURF(JN) == 2 ) THEN
                 REJFLAG(JC,JN,11) = 1
                 REJFLAG(JC,JN,19) = 1

              END IF
           END IF

        END IF

! *** TEST # 9 ***
! *** Do not assimilate if jacobian has a significant contribution over model top ***

          ! Condition valid if model top at 10mb or lower only
        IF ( NINT(vco_trl%DPT_M) >= 1000 ) THEN
           IF ( REJFLAG(JC,JN,9) /= 1 .AND. DTAUDP1(JC,JN)  > 0.50d0 ) THEN
              REJFLAG(JC,JN,11) = 1
              REJFLAG(JC,JN,21) = 1
           END IF
        END IF
       
          ! Condition valid if model top at 10mb or lower only
        IF ( NINT(vco_trl%DPT_M) >= 1000 ) THEN
           IF ( REJFLAG(JC,JN,9) /= 1 .AND. TRANSM(JC,JN,1) < 0.99d0 ) THEN
              REJFLAG(JC,JN,11) = 1
              REJFLAG(JC,JN,21) = 1 
           END IF
        END IF

          ! Condition valid if model top is higher than 10 mb
        IF ( NINT(vco_trl%DPT_M) < 1000 ) THEN
           IF ( REJFLAG(JC,JN,9) /= 1 .AND. TRANSM(JC,JN,1) < 0.95d0 ) THEN
              REJFLAG(JC,JN,11) = 1
              REJFLAG(JC,JN,21) = 1 
           END IF
        END IF

! *** TEST # 10 ***
! *** Do not assimilate blacklisted channels ***
          
        IF ( hir_get_assim_chan(CINST,JC) == 0 ) REJFLAG(JC,JN,8) = 1

     END DO
  END DO

!* -- FOR EACH PROFILE, ARE ALL NON-BLACKLISTED CHANNELS ASSIMILATED

  ASSIM_ALL(:) = .true.
  FATE(:,:) = SUM(REJFLAG(:,:,:),DIM=3)            

  prf: DO JN = 1, NPRF
     chn: DO JC = 1, nch_sel
        IF ( REJFLAG(JC,JN,8) == 0 ) THEN
           IF ( FATE(JC,JN) /= 0 ) THEN
              ASSIM_ALL(JN) = .false.
              EXIT chn
           END IF
        END IF
     END DO chn
  END DO prf

!******************************************************************************************

!* -- PUT REJECT FLAGS INTO CMA VARIABLE --
!* ----------------------------------------

  NOBHIR = 0
  count = 0

      ! loop over all header indices of the 'TO' family
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER_3: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER_3


         IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
         IF ( tvs_Is_idburp_inst(IDATYP,CINST)  .and. lsensor(ltovsno (index_header))==id) THEN
           count = count + 1
           IF ( count > loop_done * bunch .AND. &
                count <= (loop_done+1) * bunch ) THEN 
              NOBHIR = NOBHIR + 1
              IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,INDEX_HEADER)
              IDATEND = obs_headElem_i(lobsSpaceData,OBS_NLV,INDEX_HEADER) + IDATA - 1
              if  (.not.ASSIM_ALL(NOBHIR)) then
                 call obs_headSet_i(lobsSpaceData, OBS_ST1, index_header,ibset(obs_headElem_i(lobsSpaceData,OBS_ST1,INDEX_HEADER),6) )
              endif
!* -- ADDITION OF BACKGROUND CHECK PARAMETERS TO BURP FILE
!* ------------------------------------------------
              call obs_headSet_r(lobsSpaceData, OBS_ETOP, index_header, ETOP(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_VTOP, index_header, VTOP(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_ECF,  index_header, 100._8*ECF(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_VCF,  index_header, 100._8*VCF(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_HE,   index_header, HE(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_ZTSR, index_header, ZTS(nobhir) )
              call obs_headSet_i(lobsSpaceData, OBS_NCO2, index_header, NGOOD(nobhir))
              call obs_headSet_r(lobsSpaceData, OBS_ZTM,  index_header, ZT(nlv_T,nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_ZTGM, index_header, ZTG(nobhir) )
              call obs_headSet_r(lobsSpaceData, OBS_ZLQM, index_header, EXP(ZLQ(nlv_T,nobhir)) )
              call obs_headSet_r(lobsSpaceData, OBS_ZPS,  index_header, 100._8*ZPS(nobhir) )
              call obs_headSet_i(lobsSpaceData, OBS_STYP, index_header, KSURF(nobhir) )

              DO INDEX_BODY= IDATA, IDATEND
                 IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1 ) THEN
                    ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
                    ICHN = MAX(0,MIN(ICHN,JPCHMAX+1))
                    chan_indx=hir_get_chindx_fr_chn(CINST,ichn)
                    call obs_bodySet_r(lobsSpaceData,OBS_SEM,INDEX_BODY,EMI_SFC(chan_indx,NOBHIR))
                    DO NFLG = 0, BITFLAG
                       IF ( REJFLAG(chan_indx,NOBHIR,NFLG) == 1 ) &
                            call obs_bodySet_i(lobsSpaceData,OBS_FLG,INDEX_BODY,IBSET(obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY),NFLG))
                    END DO
                 END IF
              END DO
           END IF
        END IF
     END DO HEADER_3

  deallocate (ZTG,ZPS,ZTS,ZT,ZHT,ZLQ)
  deallocate (BTOBSERR,BTOBS,BTCALC,RCAL_CLR,SFCTAU)
  deallocate (ROBS,RCLD,TRANSM,EMI_SFC)
  deallocate (TOEXT,ZHOEXT,SUNZA)
  deallocate (ALBEDO,ICE,PCNT_WAT,PCNT_REG)
  deallocate (KSURF,LTYPE)
  deallocate (CLDFLAG,REJFLAG,LEV_START)
  deallocate (NTOP_EQ,NTOP_BT,NTOP_RD)
  deallocate (NTOP_CO2,NGOOD)
  deallocate (PTOP_EQ,PTOP_BT,PTOP_RD)
  deallocate (PTOP_CO2,FCLOUD_CO2,HE)
  deallocate (ETOP,VTOP,ECF,VCF)
  deallocate (MINP,FATE)
  deallocate (PMIN,DTAUDP1,TAMPON)
  deallocate (ICHREF)
  deallocate (ASSIM_ALL,ZVLEV,PTOP_MB,NTOP_MB,CFSUB)
  deallocate ( MAXWF )
  deallocate (GNCLDFLAG)
  deallocate (ZLEVMOD,xpres)
  if (liasi) then
     deallocate ( LEV_START_AVHRR,PTOP_EQ_AVHRR,NTOP_EQ_AVHRR,BTOBS_AVHRR)
     deallocate ( ICHREF_AVHRR )
     deallocate ( CLDFLAG_AVHRR )
     deallocate ( ROBS_AVHRR)
     deallocate ( RCAL_CLR_AVHRR )
     deallocate ( EMI_SFC_AVHRR)
     deallocate ( ZTS_AVHRR)
     deallocate ( SFCTAU_AVHRR)
     deallocate ( PTOP_BT_AVHRR)
     deallocate ( PTOP_RD_AVHRR)
     deallocate ( NTOP_BT_AVHRR)
     deallocate ( NTOP_RD_AVHRR)
     deallocate ( RCLD_AVHRR)
     deallocate ( INDX )
     deallocate (satazim,satzen,sunazim)
     deallocate ( CFRAC_AVHRR )
  endif

END SUBROUTINE HIRQC

End module MULTI_IR_BGCK_MOD
