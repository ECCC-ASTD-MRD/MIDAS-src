Module MULTIIRBGCHECK

!************************************************************************
!*
!*       MODULE MULTI_IR_BGCHECK
!*       -------------------
!*
!*       PURPOSE: VARIABLES FOR MULTISPECTRAL INFRARED BACKGROUND CHECK
!*                  AND QUALITY CONTROL
!*
!*       AUTHOR:   A. BEAULNE (CMDA/SMC) February 2006
!*
!*       REVISION: adapted to IASI and CrIS by S. Heilliette
!*
!*
!************************************************************************
 Use tovs_nl_mod, only : jplev,rttov_coefs,transmission_Type,tvs_Is_idburp_tovs, &
      tvs_Is_idburp_airs, tvs_Is_idburp_iasi, tvs_Is_idburp_cris, &
      radiance_d,lsensor,coefs,nchan,NSENSORS,PLATFORM,SATELLITE,INSTRUMENT,NOBTOV

  implicit none
  save
  public

! Module parameters

  INTEGER ,PARAMETER :: NCLASSAVHRR=7
  INTEGER ,PARAMETER :: NIR=3,NVIS=3
  INTEGER ,PARAMETER :: NCHANAVHRR=NIR+NVIS

  ! Reference (and alternate) window channel for clear / cloudy profile detection
  ! (subroutine cloud_height)

  INTEGER, PARAMETER        :: IWINDOW_AIRS = 787, IWINDOW_ALT_AIRS = 950
  INTEGER, PARAMETER        :: IWINDOW_IASI = 1090, IWINDOW_ALT_IASI = 1133
  INTEGER, PARAMETER        :: IWINDOW_CRIS = 427, IWINDOW_ALT_CRIS = 529

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the "background profile matching" method (subroutine cloud_top)

  INTEGER, PARAMETER        :: NCH_HE = 4

  INTEGER, PARAMETER        :: ILIST1_AIRS(NCH_HE) = (/ 528, 787, 950, 2209 /)

  INTEGER, PARAMETER        :: ILIST1_IASI(NCH_HE) = (/ 705, 1090, 1133, 7475 /)

  INTEGER, PARAMETER        :: ILIST1_CRIS(NCH_HE) = (/ 279, 427, 529, 1290 /)

  ! Number of channels (and their values) to use for cloud top height detection
  ! with the CO2-slicing method. IREFR is the reference channel number (and alternate).
  ! (subroutine co2_slicing)


  INTEGER, PARAMETER        :: NCO2 = 13

  INTEGER, PARAMETER         :: ILIST2_AIRS(NCO2) = (/ 204, 221, 232, 252, 262, 272,  &
                                                       299, 305, 310, 355, 362, 375, 375 /)

  INTEGER, PARAMETER         :: ILIST2_PAIR_AIRS(NCO2) = (/ 252, 262, 272, 299, 305, 310,  &
                                                            355, 362, 375, 375, 262, 252, 204/)

  INTEGER, PARAMETER         :: ILIST2_IASI(NCO2) = (/ 252, 269, 285, 309, 320, 332, &
                                                       363, 371, 375, 433, 442, 459, 459 /)

  INTEGER, PARAMETER         :: ILIST2_PAIR_IASI(NCO2) = (/ 309, 320, 332,363, 371, 375, &
                                                            433, 442, 459, 459, 320, 309, 252 /)

  INTEGER, PARAMETER        :: ILIST2_CRIS(NCO2) = (/ 99, 116, 138, 133, 158, 154, &
                                                     123, 143, 168, 163, 175, 198, 198 /)

  INTEGER, PARAMETER        :: ILIST2_PAIR_CRIS(NCO2) = (/ 133, 158, 154, 123, 143, 168, &
                                                           163, 175, 198, 198, 158, 133, 99 /)

  ! Cloud top units : (1) mb, (2) meters
  ! (subroutines cloud_height (IOPT1) and cloud_top (IOPT2))

  INTEGER, PARAMETER        :: IOPT1 = 2   ! verify subr input if iopt1 changes
  INTEGER, PARAMETER        :: IOPT2 = 1

  ! Cloud top based on which background profile matching (subroutine cloud_top)
  ! (0) brightness temperature, (1) radiance, (2) both

  INTEGER, PARAMETER        :: IHGT = 2

  ! Maximum delta temperature allowed between guess and true skin temperature
  ! over water (DTW) and land (DTL)   (subroutine airsqc)

  REAL(8), PARAMETER        :: DTW = 1.5D0
  REAL(8), PARAMETER        :: DTL = 4.0D0

  ! Minimum and maximum RTTOV levels for LEV_START variable entering CO2 slicing
  ! In mb, between 50mb and 325mb (subroutine co2_slicing)

  Real(8), PARAMETER        :: PCO2MIN = 56.73D0, PCO2MAX = 321.5D0

  ! First channel affected by sun (for channels used only at night)
  ! (subroutine airsqc)

  INTEGER, PARAMETER       :: ICHN_SUN_AIRS = 1865
  INTEGER, PARAMETER       :: ICHN_SUN_IASI = 5446
  INTEGER, PARAMETER       :: ICHN_SUN_CRIS = 1147

  ! Minimum solar zenith angle for night (between 90 and 180)
  ! (subroutine airsqc)

  REAL(8), PARAMETER       :: NIGHT_ANG = 100.D0

  ! Maximum number of profiles for one call to airs quality control
  ! (subroutine tovs_rttov)

  INTEGER, PARAMETER       :: BUNCH_AIRS = 120
  INTEGER, PARAMETER       :: BUNCH_IASI = 120
  INTEGER, PARAMETER       :: BUNCH_CRIS = 120

  ! Highest flag in post files (value of N in 2^N)
  ! Currently 21

  INTEGER, PARAMETER       :: BITFLAG = 29


  type( rttov_coefs ) :: coefs_avhrr

  TYPE avhrr_bgck_iasi
     SEQUENCE   
     REAL(8)              :: RADMOY(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: RADSTD(NCLASSAVHRR,NCHANAVHRR)
     REAL(8)              :: CFRAC(NCLASSAVHRR)
     REAL(8)              :: TBMOY(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: TBSTD(NCLASSAVHRR,NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBEDMOY(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: ALBEDSTD(NCLASSAVHRR,1:NVIS)
     REAL(8)              :: TBSTD_PIXELIASI(NVIS+1:NVIS+NIR)
     REAL(8)              :: ALBSTD_PIXELIASI(1:NVIS)
     REAL(8)              :: RADCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: TBCLEARCALC(NVIS+1:NVIS+NIR)
     REAL(8)              :: RADOVCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMCALC(jplev,NVIS+1:NVIS+NIR)
     REAL(8)              :: TRANSMSURF(NVIS+1:NVIS+NIR)
     REAL(8)              :: EMISS(NVIS+1:NVIS+NIR)
  END TYPE avhrr_bgck_iasi

  TYPE prof_qc
     SEQUENCE
     REAL(8)              :: LAT      ! latitude (-90 to 90)
     REAL(8)              :: LON      ! longitude (0 to 360)
     REAL(8), POINTER     :: Z(:)     ! height field (m)
     REAL(8)              :: SUNZA    ! sun zenith angle (deg)
     REAL(8)              :: ALBEDO   ! surface albedo (0-1)
     REAL(8)              :: ICE      ! ice cover (0-1) 
     REAL(8)              :: SNOW     ! snow cover (0-1)
     REAL(8)              :: PCNT_WAT ! water percentage in pixel containing profile (0-1)
     REAL(8)              :: PCNT_REG ! water percentage in an area around profile (0-1)
     INTEGER              :: LTYPE    ! surface type (1,...,20)
  END TYPE prof_qc

  type(avhrr_bgck_iasi)  , allocatable :: avhrr_bgck(:)      ! avhrr parameters for IASI quality control
  type( prof_qc )     ,     allocatable :: profiles_qc(:)    ! profiles buffer used in airsqc call
  type(transmission_Type) :: transmission                    ! transmissions full structure buffer used in rttov calls
  type(transmission_Type) , allocatable :: transmission_d(:) ! transmissions organized by profile
  real(8)                 , allocatable :: emissivity(:,:)   ! surface emissivities organized by profiles and channels
contains

SUBROUTINE BGCK_IR_SETUP(lobsSpaceData)
#if defined (DOC)
!
!  s/r BGCK_IR_SETUP : Memory allocation for the Hyperspectral Infrared
!                background check variables
!          (original name of routine: sutovalo)
!
! Revision:

!           S.  Heilliette
!            - creation from tovs_setup_allo  December 2013
#endif

  use obsSpaceData_mod

  IMPLICIT NONE
!implicits

  type(struct_obs) :: lobsSpaceData

  Integer :: alloc_status(2)

  INTEGER :: KRTID
  INTEGER ::  JO, IDATYP,NCMAX
  INTEGER ::  ISENS, NC, NL
  INTEGER ::  ICHN
  INTEGER ::  NOBIASI
  integer ::  index_header

!     1. Determine the number of IASI profiles to be assimilated.
!     .  ---------------------------------------------------
 
  NOBIASI = 0

  ! loop over all header indices of the 'TO' family
  ! Set the header list
  ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)
     
     IF ( .not.  tvs_Is_idburp_tovs(IDATYP) ) cycle HEADER   ! Proceed to the next header_index

     IF ( tvs_Is_idburp_iasi(IDATYP) ) NOBIASI = NOBIASI + 1

  ENDDO HEADER

  write(*,*) ' BGCK_IR_SETUP: nobiasi = ', nobiasi
!-----------------------------------------------------------------------

!     2. Memory allocation for background check related variables
!     .  -----------------------------------------------------

  allocate(profiles_qc(NOBTOV) , stat= alloc_status(1))
  If( alloc_status(1) /= 0) then
     WRITE(*,FMT=9201)
  9201   FORMAT(' BGCK_IR_SETUP: Memory Allocation Error')
     CALL ABORT3D('BGCK_IR_SETUP')
  End If

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nl = coefs(isens)%coef % nlevels
     allocate( profiles_qc(jo) % z  ( nl ) ,stat= alloc_status(1))
        
     If( alloc_status(1)/=0 ) then
         WRITE(*,FMT=9201)
         CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ radiance by profile

  alloc_status(:) = 0


  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     nl = coefs(isens) % coef % nlevels

     allocate( radiance_d(jo)  % overcast  (nl-1,nc) ,stat= alloc_status(1))
     radiance_d(jo)  % overcast  (:,:) = 0.d0
     
    
     If( alloc_status(1) /= 0 ) then
         WRITE(*,FMT=9201)
         CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ transmission by profile

  alloc_status(:) = 0
  allocate( transmission_d(NOBTOV),stat= alloc_status(1))

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     nl = coefs(isens) % coef % nlevels

     !! allocate transmittance from surface and from pressure levels
     allocate( transmission_d(jo)  % tau_total ( nc ) ,stat= alloc_status(1))
     allocate( transmission_d(jo)  % tau_levels(nl,nc) ,stat= alloc_status(2))

     If( any(alloc_status /= 0) ) then
        WRITE(*,FMT=9201)
        CALL ABORT3D('BGCK_IR_SETUP')
     End If
  end do

!___ emissivity by profile

  ncmax = 1

  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     if (nc>ncmax) ncmax=nc
  end do

  allocate( emissivity (ncmax,NOBTOV) ,stat=alloc_status(1))
       
  If( alloc_status(1) /= 0 ) then
      WRITE(*,FMT=9201)
      CALL ABORT3D('BGCK_IR_SETUP')
  End If



  DO KRTID = 1, NSENSORS

    IF ( PLATFORM(KRTID) == 10 .AND. &
         SATELLITE (KRTID) == 2 .AND. &
         INSTRUMENT(KRTID) == 16 ) THEN

       allocate ( avhrr_bgck(NOBIASI), stat= alloc_status(1))

       If( alloc_status(1)/=0 ) then
          WRITE(*,FMT=9201)
          CALL ABORT3D('BGCK_IR_SETUP')
       End If

       EXIT

    END IF

 END DO

END SUBROUTINE BGCK_IR_SETUP


End module MULTIIRBGCHECK
