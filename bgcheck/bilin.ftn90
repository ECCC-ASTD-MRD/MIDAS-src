      SUBROUTINE BILIN(lcolumn,statevector,lobsSpaceData)
!*
!***s/r BILIN  - Horizontal interpolation of the model variables
!*               in grid-point space to observation points.
!*               Bilinear interpolation from the 4 nearest grid points.
!*     .         (based on HOR4 from the ARPEGE/IFS model)
!*
!*Author  : J. Pailleux  ECMWF    90-01-11
!*     .    Luc Fillion  RPN/AES  Jan 1993
!
!**    Purpose:  Build GOMU, GOMV, GOMT, GOMGZ, GOMQ and GOMPS  with the model variables at the
!*               observation points from the model variables in grid-points
!*               space using bilinear interpolation.
!*
      use MathPhysConstants_mod
      use obsSpaceData_mod
      use columnData_mod
      use gaussGrid_mod
      use gridStateVector_mod
      IMPLICIT NONE
#include "pardim.cdk"
      type(struct_columnData) :: lcolumn
      type(struct_gsv) :: statevector
      type(struct_obs) :: lobsSpaceData
      INTEGER   JLEV, JK, JK2, JGL, JLON, JOBS
      INTEGER   ILON, ILOS, IMIDDLE, ISYM, ILA, IMAX, IERR
      REAL*8    DLMEAN, DLMEAS, DLLAO, DLLOO, DLDLON, DLDLOS
      REAL*8    DLDXN, DLDXS, DLDY, DLW1, DLW2, DLW3, DLW4
      real*8, allocatable ::zgd(:,:,:)
      real*8, pointer :: uu_column(:),vv_column(:),hu_column(:),gz_column(:)
      real*8, pointer :: tt_column(:),tr_column(:),ps_column(:),tg_column(:)

      allocate(zgd(0:(statevector%ni+2),1:statevector%nk,(-1):(statevector%nj+2)),STAT=ierr)
      write(*,*) 'allocated zgd:',ierr,statevector%ni,statevector%nj,statevector%nk,statevector%nlev,col_getNumCol(lcolumn)
      call flush(6)
!C
!C*    1. EXPAND GRID-POINTS ARRAYS OF GD BY REPEATING MERIDIANS
!C     NILON(JGL), 1, AND 2 INTO MERIDIANS 0, NILON(JGL)+1,
!C     AND NILON(JGL+2) AND ALSO TWO PARALLELS NEAR THE POLES.
!C     ----------------------------------------------------------
!C
!C*    1.0 TRANSFORM WIND IMAGES INTO PHYSICAL WINDS
!C
      DO JLEV = 1, statevector%NLEV
         DO JGL = 1, statevector%NJ
            DO JLON = 1, statevector%NI
               statevector%uu3d(JLON,JLEV,JGL) = gaus_CONPHY(JGL) * statevector%uu3d(JLON,JLEV,JGL)
               statevector%vv3d(JLON,JLEV,JGL) = gaus_CONPHY(JGL) * statevector%vv3d(JLON,JLEV,JGL)
            ENDDO
         ENDDO
      ENDDO

      ZGD(:,:,:)=0.0d0
      ZGD(1:STATEVECTOR%NI,1:statevector%nk,1:STATEVECTOR%NJ)=statevector%gd3d(1:STATEVECTOR%NI,1:statevector%nk,1:STATEVECTOR%NJ)
!C
!C*    1.1 EXTRA MERIDIANS
!C
!C     MERIDIAN NILON(JGL) DUPLICATED INTO MERIDIAN 0
!C     MERIDIAN 1  DUPLICATED INTO MERIDIAN NILON(JGL) + 1
!C     MERIDIAN 2  DUPLICATED INTO MERIDIAN NILON(JGL) + 2
!C
      DO JK = 1, statevector%nk
         DO JGL = 1, STATEVECTOR%NJ
            IMAX = STATEVECTOR%NI
            ZGD(0     ,JK,JGL) = ZGD(STATEVECTOR%NI,JK,JGL)
            ZGD(IMAX+1,JK,JGL) = ZGD( 1,JK,JGL)
            ZGD(IMAX+2,JK,JGL) = ZGD( 2,JK,JGL)
         ENDDO
      ENDDO
!C
!C*    1.2 EXTRA PARALLELS
!C
      DO JK = 1, statevector%nk
!C
!C     COMPUTATION OF VALUES AT NORTH AND SOUTH POLES.
!C
         DLMEAN = 0.
         DLMEAS = 0.
         IMAX = STATEVECTOR%NI
         DO JLON = 1, IMAX
            DLMEAN = DLMEAN + ZGD(JLON,JK,1)
            DLMEAS = DLMEAS + ZGD(JLON,JK,STATEVECTOR%NJ)
         ENDDO
         DLMEAN = DLMEAN / STATEVECTOR%NI
         DLMEAS = DLMEAS / STATEVECTOR%NI
         IMAX = STATEVECTOR%NI
         DO JLON = 0, IMAX + 2
            ZGD(JLON,JK,0)    = DLMEAN
            ZGD(JLON,JK,STATEVECTOR%NJ+1) = DLMEAS
         ENDDO
!C
!C     COMPUTATION OF VALUES FOR PARALLELS -1 AND NJ + 2 (WITH SYMETRIZATION)
!C
         IMIDDLE = STATEVECTOR%NI / 2
         DO JLON = 0, IMIDDLE
            ISYM = JLON + IMIDDLE
            ZGD(JLON,JK,-1)   = ZGD(ISYM,JK,1)
            ZGD(JLON,JK,STATEVECTOR%NJ+2) = ZGD(ISYM,JK,STATEVECTOR%NJ)
         ENDDO
         IMAX = STATEVECTOR%NI
         DO JLON = IMIDDLE + 1, IMAX + 2
            ISYM = JLON - IMIDDLE
            ZGD(JLON,JK,-1)   = ZGD(ISYM,JK,1)
            ZGD(JLON,JK,STATEVECTOR%NJ+2) = ZGD(ISYM,JK,STATEVECTOR%NJ)
         ENDDO

      ENDDO
      write(*,*) 'zgd=',zgd(120,:,60)
      write(*,*) 'gd3d=',statevector%gd3d(120,:,60)
      write(*,*) 'uu3d=',statevector%uu3d(120,:,60)
!C
!C*    2. LOOP OVER ALL THE OBSERVATIONS
!C     ---------------------------------
!C
      DO JOBS = 1, col_getNumCol(lcolumn)
         DLLAO   = obs_elem_r4(lobsSpaceData,'LAT ',JOBS)
         DLLOO   = obs_elem_r4(lobsSpaceData,'LON ',JOBS)
!C
!C*    2.1. LOCATE FIRST LATITUDE ROW NUMBER (ILA) TO THE NORTH
!C*    OF ZLAO, AND THE TWO LONGITUDE POINT NUMBERS IMMEDIATELY
!C*    TO THE WEST (ILON AND ILOS).
!C
         ILA=obs_elem_i(lobsSpaceData,'TLA ',JOBS)

         IF(DLLOO.LT.0.) DLLOO = DLLOO + 2.*RPI
         IF(DLLOO.GE.2.*RPI) DLLOO = DLLOO - 2.*RPI
         DLDLON = 2.*RPI/STATEVECTOR%NI
         DLDLOS = 2.*RPI/STATEVECTOR%NI
         ILON = INT(DLLOO/DLDLON) + 1
         ILOS = INT(DLLOO/DLDLOS) + 1
!C
!C*    2.2 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
!C
         DLDXN = DLLOO/DLDLON + 1. - ILON
         DLDXS = DLLOO/DLDLOS + 1. - ILOS
         DLDY  = (gaus_RLATI(ILA)-DLLAO)/(gaus_RLATI(ILA)-gaus_RLATI(ILA+1))
         DLW1  = (1.-DLDXN)*(1.-DLDY)
         DLW2  = DLDXN*(1.-DLDY)
         DLW3  = (1.-DLDXS)*DLDY
         DLW4  = DLDXS*DLDY
!C
!C*    2.3 Interpolate the model state to the obs point
!C
         uu_column => col_getColumn(lcolumn,jobs,'UU')
         vv_column => col_getColumn(lcolumn,jobs,'VV')
         hu_column => col_getColumn(lcolumn,jobs,'HU')
         gz_column => col_getColumn(lcolumn,jobs,'GZ')
         tt_column => col_getColumn(lcolumn,jobs,'TT')
         tr_column => col_getColumn(lcolumn,jobs,'TR')
         ps_column => col_getColumn(lcolumn,jobs,'PS')
         tg_column => col_getColumn(lcolumn,jobs,'TG')
         DO JK = 1, statevector%nlev
           if(NGEXIST(nguu).eq.1) then
             jk2=jk+ngposit(nguu)-1
             uu_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
           if(NGEXIST(ngvv).eq.1) then
             jk2=jk+ngposit(ngvv)-1
             vv_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
           if(NGEXIST(ngq).eq.1) then
             jk2=jk+ngposit(ngq)-1
             hu_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
           if(NGEXIST(nggz).eq.1) then
             jk2=jk+ngposit(nggz)-1
             gz_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
           if(NGEXIST(ngtt).eq.1) then
             jk2=jk+ngposit(ngtt)-1
             tt_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
           if(NGEXIST(ngtr).eq.1) then
             jk2=jk+ngposit(ngtr)-1
             tr_column(JK) =   DLW1*zgd(ILON,JK2,ILA)  &
                  + DLW2*zgd(ILON+1,JK2,ILA)  &
                  + DLW3*zgd(ILOS,JK2,ILA+1)  &
                  + DLW4*zgd(ILOS+1,JK2,ILA+1)
           endif
         enddo
         if(NGEXIST(ngps).eq.1) then
           jk2=ngposit(ngps)
           ps_column(1) =   DLW1*zgd(ILON,jk2,ILA)  &
                + DLW2*zgd(ILON+1,jk2,ILA)  &
                + DLW3*zgd(ILOS,jk2,ILA+1)  &
                + DLW4*zgd(ILOS+1,jk2,ILA+1)
         endif
         if(NGEXIST(ngtg).eq.1) then
           jk2=ngposit(ngtg)
           tg_column(1) =   DLW1*zgd(ILON,jk2,ILA)  &
                + DLW2*zgd(ILON+1,jk2,ILA)  &
                + DLW3*zgd(ILOS,jk2,ILA+1)  &
                + DLW4*zgd(ILOS+1,jk2,ILA+1)
         endif
      ENDDO

      deallocate(zgd,STAT=ierr)
      write(*,*) 'deallocated zgd:',ierr
      call flush(6)

      RETURN
      END SUBROUTINE BILIN
