subroutine convert_avhrr(avhrr_in,sunzen,avhrr_out)
! conversion des radiance IR en temperatures de brillance
! et des radiances visibles en "albedo"
use mod_tovs ,only : avhrr_var, avhrr_bgck_iasi, NIR, NVIS, NCLASSAVHRR

implicit none
type (avhrr_var) ,intent(in) :: avhrr_in
real(8) ,intent(in) :: sunzen
type (avhrr_bgck_iasi) ,intent(out) :: avhrr_out

integer :: ICL
REAL (8) :: tb(NIR),dtbsdrad(NIR)
REAL (8) :: FREQ(NIR),OFFSET(NIR),SLOPE(NIR)

DATA FREQ / 0.2687000000D+04 , 0.9272000000D+03 , 0.8377000000D+03 /
DATA OFFSET / 0.2066990000D+01 , 0.5512600000D+00 , 0.3471600000D+00 /
DATA SLOPE / 0.9965770000D+00  , 0.9985090000D+00  , 0.9989470000D+00 /

DO ICL=1,NCLASSAVHRR
   call calcbt(avhrr_in % radmoy(ICL,4:6), tb, dtbsdrad,freq,offset,slope)
   avhrr_out % tbmoy(ICL,4:6)=tb(1:3)
   avhrr_out % tbstd(ICL,4:6)=avhrr_in % radstd(ICL,4:6) * dtbsdrad(1:3)
   call calcreflect(avhrr_in % radmoy(ICL,1:3) ,sunzen,avhrr_out % ALBEDMOY(ICL,1:3) )
   call calcreflect(avhrr_in % radstd(ICL,1:3) ,sunzen,avhrr_out % ALBEDSTD(ICL,1:3) )

ENDDO

contains
subroutine calcreflect(rad,sunzen,reflect)
Use MathPhysConstants_mod ,only : MPC_PI_R8, MPC_RADIANS_PER_DEGREE_R8
implicit none

REAL (8) , INTENT(IN) ,dimension(nvis) :: rad
REAL (8) , INTENT(IN) :: sunzen
REAL (8) , INTENT(out),dimension(nvis) :: reflect ! reflectivite en %
!************
REAL (8) ,DIMENSION(NVIS) :: SOLAR_FILTERED_IRRADIANCE
DATA SOLAR_FILTERED_IRRADIANCE /139.873215,232.919556,14.016470/
!# equivalent widths, integrated solar irradiance,  effective central wavelength
!0.084877,139.873215,0.632815
!0.229421,232.919556,0.841679
!0.056998,14.016470,1.606119
! pour la definition de l'albedo voir http://calval.cr.usgs.gov/PDF/Rao.CRN_IJRS.24.9.2003_Chander.pdf
REAL (8) :: RADB ! radiance en W/m2/str
!
integer :: i
!**************************************************************

Do i = 1, nvis
   if (rad(i)>= 0.0 ) THEN
      radb=rad(i) / 1000.0
      reflect(i)=(MPC_PI_R8*radb)/SOLAR_FILTERED_IRRADIANCE(I)
      IF (sunzen < 90.0 ) reflect(i)= reflect(i) / COS(sunzen*MPC_RADIANS_PER_DEGREE_R8)
   else
      reflect(i)=-1
   end if
End Do

end subroutine calcreflect

subroutine calcbt(rad,tb,dtbsdrad,freq,offset,slope)
implicit none
INTEGER,parameter  :: nchan=3
Real(8) ,parameter :: c1= 1.19106590D-05   ! first planck constant
Real(8) ,parameter :: c2= 1.438833D0     ! second planck constant 
REAL (8) , INTENT(IN) ,dimension(nchan) :: rad,freq,offset,slope
REAL (8) , INTENT(out) ,dimension(nchan) :: tb,dtbsdrad
!************
integer :: i
REAL (8) ::  radtotal,tstore,planck1,planck2


Do i = 1, nchan
   if (rad(i)>1.d-20) THEN
      planck2= c2 * freq(I)
      planck1= c1 * ( freq(I) **3 ) 
      tstore = planck2 / Log( 1+planck1/rad(i) )
      tb(i) = ( tstore - offset(i) ) / slope(i)
     
      radtotal = rad(i)
   
      dtbsdrad(i) = planck1 * tstore**2 / ( planck2 * radtotal * ( radtotal + planck1 ) )
       
      dtbsdrad(i) = dtbsdrad(i) / slope(i)

      else
         tb(i) =0.d0
         dtbsdrad(i) = 0.d0
      end if

End Do

end subroutine calcbt

function dplanck(nu,t,offset,slope)
!    fonction de planck en double precision
!    nu en cm-1 t en Kelvin  planck en Watt / ( m2 strd cm-1 )
!    c en m/s  h en J.s  k en J/K
implicit none
real (8) :: nu,nu0,t,scale,offset,slope
real (8) :: dplanck,c,h,k,tt

c=299792458.D0
k=1.3806505D-23
h=6.62606876D-34
scale=100.d0
dplanck=-1.d0

if (t>0.d0) then
   nu0=nu*scale
   tt=t*slope+offset
   dplanck=scale*2.d0*h*c**2*nu0**3/(dexp(h*c/k*nu0/tt)-1.d0)
endif

return

end function dplanck


end subroutine convert_avhrr
