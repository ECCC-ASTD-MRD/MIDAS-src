!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_LT(statevector,lcolumn,lcolumng,lobsSpaceData)
  use MathPhysConstants_mod
  use mpi
  use gridStateVector_mod
  use gaussGrid_mod
  use obsSpaceData_mod
  use columnData_mod 
  implicit none
  !
  !Purpose: Adjoint of Localisation (3D) / Adjoint Model (4D) operator
  !Compute adjoint grided increments from adjoint profiled increments
  !  ->In 3D mode : Call the adjoint of the bilinear interpolator
  !  ->In 4D mode : Send adjoint profiled increments to the ADJM and wait
  !    for the grided adjoint increments
  !  ->Results are saved in COMGD
  !
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
  !
  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_gsv) :: statevector
  ! Local declarations
  type(struct_columnData) :: lcolumn_g
  integer :: ilev1,ilev2,deltalev,numheader_mpiglobal
  integer :: mythread,numthread,omp_get_num_threads,omp_get_thread_num
   
  call tmg_start(51,'VAR_CH')
  if(col_varExist('GZ')) call att2phi(lcolumn,lcolumng)
  call tmg_stop(51)

  call tmg_start(75,'PROF->GD')
  call gsv_zero(statevector)

  IF(mpi_myid == 0) THEN
    write(*,*)'ODA_LT- Adjoint of horizontal interpolation GD --> MVO'
  endif

  numheader_mpiglobal=obs_numheader_mpiglobal(lobsSpaceData)
  call tmg_start(77,'EXPNDMVO')
  call col_allocate(lcolumn_g,numheader_mpiglobal,col_getNumLev(lcolumn,'MM'),col_getNumLev(lcolumn,'TH'))
  call col_expandToMpiGlobal(lcolumn,lcolumn_g,lobsSpaceData)
  call tmg_stop(77)

!$OMP PARALLEL PRIVATE(ilev1,ilev2,deltalev,mythread,numthread)
  mythread=omp_get_thread_num()+1
  numthread=omp_get_num_threads()
  deltalev=ceiling(real(col_getNumLev(lcolumn))/real(numthread))
  ilev1=1+(mythread-1)*deltalev
  ilev2=min(col_getNumLev(lcolumn),mythread*deltalev)
  if(gsv_varExist('UU'))  call gd2mvoad('UU',ilev1,ilev2)
  if(gsv_varExist('VV'))  call gd2mvoad('VV',ilev1,ilev2)
  if(gsv_varExist('HU'))  call gd2mvoad('HU',ilev1,ilev2)
  if(gsv_varExist('TT'))  call gd2mvoad('TT',ilev1,ilev2)
  if(gsv_varExist('GZ'))  call gd2mvoad('GZ',ilev1,ilev2)
!$OMP END PARALLEL

  ilev1=1
  ilev2=1
  if(gsv_varExist('P0'))  call gd2mvoad('P0',ilev1,ilev2)
  if(gsv_varExist('TG'))  call gd2mvoad('TG',ilev1,ilev2)

  ! Conversion of wind images to physical winds
  call uvwi2uv(statevector)

  call col_deallocate(lcolumn_g)

  call tmg_stop (75)

  CONTAINS

      SUBROUTINE GD2MVOAD (cdvarname,klev1,klev2)
!*
!***s/r GD2MVOAD  - Adjoint of the horizontal interpolation of the model variables
!*     .            in grid-point space to observation locations.
!*     .           Simple multiplication by the weights of
!*     .           the horizontal bilinear interpolation.
!*     .           (adapted from BILINAD)
!*
!*
!*Author  : P. GAUTHIER *ARMA/MSC JULY 2002
!*
!*Revision:
!*           Bin He   *ARMA/MRB   JULY 2009
!*           --  MPI version , restore Global array     
!*
!**    Purpose:  Update the estimate of GD from the gradient components
!*               at the observation points which have been stored in
!*               lcolumn
!*
!* Arguments
!*     CDVARNAME: identificator of the variable to be treated
!*     KLEV     : number of levels (typically 1 for 2D-fields and LCOLUMN_NLEV for 3D-fields)
!*
!*     Arguments
!*
      character(len=2) :: cdvarname
      integer klev1,klev2
!*
!*     Local Variables
!*
      INTEGER   JLEV, JLAT, JLON, JOBS, JSTEP, JK
      INTEGER   ILON, ILOS, ILA, IMIDDLE, ISYM
      REAL*8    DLMEAN, DLMEAS, DLLAO, DLLOO, DLDLON, DLDLOS, DLDLON2, DLDLOS2
      REAL*8    DLDXN, DLDXS, DLDY, DLW1, DLW2, DLW3, DLW4, DInterpWeight

      real*8 :: zfield(0:(statevector%ni+2),klev1:klev2,(-1):(statevector%nj+2))
      real*8, pointer :: field_ptr(:,:,:,:)
      real*8,pointer :: zprofil(:)
      real*8 :: dldlat2(-1:gaus_nj)

      field_ptr => gsv_getField(statevector,cdvarname)

      DLDLON2=1./(2.*MPC_PI_R8/STATEVECTOR%NI)
      DLDLOS2=1./(2.*MPC_PI_R8/STATEVECTOR%NI)

      do ila=-1,(gaus_nj+1)
        DLDLAT2(ILA)=1.0d0/(gaus_RLATI(ILA)-gaus_RLATI(ILA+1))
      enddo

      do jstep=1,statevector%numStep

        zfield(:,:,:) = 0.0D0
!C
!C*    2. LOOP OVER ALL THE OBSERVATIONS
!C     ---------------------------------
!C
        Observations: DO JOBS = 1, numheader_mpiglobal
          if(col_getTimeInterpWeight(lcolumn_g,jobs,jstep).gt.0.0d0) then

            zprofil => col_getColumn(lcolumn_g,jobs,cdvarname)

            DLLAO   = real(obs_elem_mpiglobal_r8(lobsSpaceData,'LAT ',JOBS), 8)
            DLLOO   = real(obs_elem_mpiglobal_r8(lobsSpaceData,'LON ',JOBS), 8)
!C
!C     *    2.1. LOCATE FIRST LATITUDE ROW NUMBER (ILA) TO THE NORTH
!C     *    OF ZLAO, AND THE TWO LONGITUDE POINT NUMBERS IMMEDIATELY
!C     *    TO THE WEST (ILON AND ILOS)
!C
            ILA=obs_elem_mpiglobal_i(lobsSpaceData,'TLA ',JOBS)

            IF(DLLOO.LT.0.) DLLOO = DLLOO + 2.*MPC_PI_R8
            IF(DLLOO.GE.2.*MPC_PI_R8) DLLOO = DLLOO - 2.*MPC_PI_R8
            ILON = INT(DLLOO*DLDLON2) + 1
            ILOS = INT(DLLOO*DLDLOS2) + 1
!C
!C     *    2.2 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
!C
            DInterpWeight=col_getTimeInterpWeight(lcolumn_g,jobs,jstep)
            DLDXN = DLLOO*DLDLON2 + 1. - ILON
            DLDXS = DLLOO*DLDLOS2 + 1. - ILOS
            DLDY  = (gaus_RLATI(ILA)-DLLAO)*DLDLAT2(ILA)
            DLW1  = DInterpWeight * (1.-DLDXN)*(1.-DLDY)
            DLW2  = DInterpWeight * DLDXN*(1.-DLDY)
            DLW3  = DInterpWeight * (1.-DLDXS)*DLDY
            DLW4  = DInterpWeight * DLDXS*DLDY

            do jlev = klev1, klev2
              ZFIELD(ILON,jlev,ILA)     =   ZFIELD(ILON,jlev,ILA)      &
                 + DLW1 * ZPROFIL(jlev)
              ZFIELD(ILON+1,jlev,ILA)   =   ZFIELD(ILON+1,jlev,ILA)    &
                 + DLW2 * ZPROFIL(jlev)
              ZFIELD(ILOS,jlev,ILA+1)   =   ZFIELD(ILOS,jlev,ILA+1)    &
                 + DLW3 * ZPROFIL(jlev)
              ZFIELD(ILOS+1,jlev,ILA+1) =   ZFIELD(ILOS+1,jlev,ILA+1)  &
                 + DLW4 * ZPROFIL(jlev)
            enddo

          endif

        enddo OBSERVATIONS
!C
!C
!C     1. REARRANGE GRID-POINTS ARRAYS GD0, BY CARRYING GRADIENTS
!C     .  CONTRIBUTIONS OF MERIDIAN 0, NI+1 AND NI
!C     .  INTO MERIDIANS NI, 1, AND 2. SIMILAR TREATMENT NEAR POLES
!C
!C
!C     1.2  EXTRA PARALLELS
!C
!C     TREATMENT OF GRADIENTS FOR PARALLELS -1 AND NJ + 2 (WITH SYMETRIZATION)
!C
        LEVELS: DO JLEV = KLEV1, KLEV2
           IMIDDLE = STATEVECTOR%NI / 2
           DO JLON = 0, IMIDDLE
              ISYM = JLON + IMIDDLE
              ZFIELD(ISYM,jlev,1) =   ZFIELD(JLON,jlev,-1)   &
                   + ZFIELD(ISYM,jlev,1)
              ZFIELD(ISYM,jlev,STATEVECTOR%NJ) =  ZFIELD(JLON,jlev,STATEVECTOR%NJ+2) &
                   + ZFIELD(ISYM,jlev,STATEVECTOR%NJ)
           ENDDO

           DO JLON = IMIDDLE + 1, STATEVECTOR%NI + 2
              ISYM = JLON - IMIDDLE
              ZFIELD(ISYM,JLEV,1) =   ZFIELD(JLON,JLEV,-1)    &
                   + ZFIELD(ISYM,JLEV,1)
              ZFIELD(ISYM,JLEV,STATEVECTOR%NJ) =  ZFIELD(JLON,JLEV,STATEVECTOR%NJ+2)  &
                   + ZFIELD(ISYM,JLEV,STATEVECTOR%NJ)
           ENDDO
!C
!C     TREATMENT OF THE GRADIENTS AT NORTH AND SOUTH POLES.
!C
           DLMEAN = 0.
           DLMEAS = 0.
           DO JLON = 0, STATEVECTOR%NI + 2
              DLMEAN = DLMEAN + ZFIELD(JLON,jlev,0)
              DLMEAS = DLMEAS + ZFIELD(JLON,jlev,STATEVECTOR%NJ+1)
           enddo

           DLMEAN = DLMEAN/STATEVECTOR%NI
           DLMEAS = DLMEAS/STATEVECTOR%NI
           DO JLON = 1, STATEVECTOR%NI  
              ZFIELD(JLON,jlev,1)  = DLMEAN + ZFIELD(JLON,jlev,1)
              ZFIELD(JLON,jlev,STATEVECTOR%NJ) = DLMEAS + ZFIELD(JLON,jlev,STATEVECTOR%NJ)
           enddo

        ENDDO LEVELS
!C
!C     1.1  EXTRA MERIDIANS
!C
        DO JLAT = 1, STATEVECTOR%NJ
           DO JLEV = KLEV1, KLEV2
              ZFIELD(STATEVECTOR%NI,JLEV,JLAT) =   ZFIELD(0,JLEV,JLAT)  &
                   + ZFIELD(STATEVECTOR%NI,JLEV,JLAT)
              ZFIELD(1,JLEV,JLAT)    =   ZFIELD(STATEVECTOR%NI+1,JLEV,JLAT) &
                   + ZFIELD(1,JLEV,JLAT)
              ZFIELD(2,JLEV,JLAT)    =   ZFIELD(STATEVECTOR%NI+2,JLEV,JLAT) &
                   + ZFIELD(2,JLEV,JLAT)
           ENDDO
        ENDDO
!*
!*     Adjoint of the identity (change of norm)
!*
        DO JLAT = 1, STATEVECTOR%NJ
           DO JLEV = KLEV1, KLEV2
              DO JLON = 1, STATEVECTOR%NI
                 ZFIELD(JLON,JLEV,JLAT) = ZFIELD(JLON,JLEV,JLAT) *  &
                      STATEVECTOR%NI / gaus_RWT(JLAT)
              ENDDO
           ENDDO
        ENDDO
!C
!C     Transfer local results to global array
!C
        field_ptr(1:statevector%ni,klev1:klev2,1:statevector%nj,jstep) = zfield(1:statevector%ni,klev1:klev2,1:statevector%nj)

      enddo  ! jstep

      END SUBROUTINE GD2MVOAD   

end subroutine oda_LT
