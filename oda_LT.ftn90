!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_LT(statevector,lcolumn,lcolumng,lobsSpaceData)
  use MathPhysConstants_mod
  use mpi
  use gridStateVector_mod
  use obsSpaceData_mod
  use columnData_mod 
  use timeCoord_mod
  implicit none

  !
  ! Purpose: Adjoint of Localisation (3D)
  !          Compute adjoint grided increments from adjoint profiled increments
  !

  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs)        :: lobsSpaceData
  type(struct_gsv)        :: statevector

  integer :: ilev1,ilev2,deltalev,ierr,myLatP1
  integer :: mythread,numthread,omp_get_num_threads,omp_get_thread_num

  myLatP1 = min(statevector % myLatEnd + 1, statevector % nj)

  !
  !- 2.  Variable conversions
  !

  !- 2.2 Rotated wind to Meteorological wind
  if ( gsv_varExist('UU') .and. gsv_varExist('VV') .and. statevector % hco % Rotated ) then
     write(*,*) 'uvrot2uvAdj Active' 
     call uvrot2uvAdj('UU', 'VV', col_getNumLev(lcolumn)) ! IN
  end if
  
  !- 2.1 Mass fields (TT,PS,HU) to hydrostatic geopotential
  if (col_varExist('GZ') ) call att2phi(lcolumn,lcolumng)
  
  !
  !- 1.  Interpolation to obs location
  !
  if ( mpi_myid == 0 ) THEN
     write(*,*) ' ODA_LT - Adjoint of horizontal interpolation GD --> MVO'
  endif
  
  !- 1.2 3D fields interpolation
!$OMP PARALLEL PRIVATE(ilev1,ilev2,deltalev,mythread,numthread)
  mythread=omp_get_thread_num()+1
  numthread=omp_get_num_threads()
  deltalev=ceiling(real(col_getNumLev(lcolumn))/real(numthread))
  ilev1=1+(mythread-1)*deltalev
  ilev2=min(col_getNumLev(lcolumn),mythread*deltalev)
  if(gsv_varExist('UU'))  call gd2mvoad('UU',ilev1,ilev2)
  if(gsv_varExist('VV'))  call gd2mvoad('VV',ilev1,ilev2)
  if(gsv_varExist('HU'))  call gd2mvoad('HU',ilev1,ilev2)
  if(gsv_varExist('TT'))  call gd2mvoad('TT',ilev1,ilev2)
  if(gsv_varExist('GZ'))  call gd2mvoad('GZ',ilev1,ilev2)
!$OMP END PARALLEL

  !- 1.3 2D fields interpolation
  ilev1=1
  ilev2=1
  if(gsv_varExist('P0'))  call gd2mvoad('P0',ilev1,ilev2)
  if(gsv_varExist('TG'))  call gd2mvoad('TG',ilev1,ilev2)

  !- 1.1 Communicate extra latitude needed for interpolation
  call tmg_start(38,'INTERP_BARR')
  call rpn_comm_barrier("GRID",ierr)
  call tmg_stop(38)
  call tmg_start(39,'INTERP_COMM')
  if (mpi_nprocs /= 1) call gsv_commLatAd(statevector)
  call tmg_stop(39)

CONTAINS

!--------------------------------------------------------------------------
! GD2MVOAD
!--------------------------------------------------------------------------
  SUBROUTINE GD2MVOAD (varName,klev1,klev2)
    !*
    !***s/r GD2MVOAD  - Adjoint of the horizontal interpolation of the model variables
    !*                  in grid-point space to observation locations.
    !*                  Simple multiplication by the weights of
    !*                  the horizontal bilinear interpolation.
    !*                  (adapted from BILINAD)
    !*
    !**    Purpose:  Update the estimate of GD from the gradient components
    !*               at the observation points which have been stored in
    !*               lcolumn
    !*
    !* Arguments
    !*     VARNAME: identificator of the variable to be treated
    !*     KLEV     : number of levels

    implicit none
    
    character(len=*), intent(in) :: varName
    integer,          intent(in) :: klev1,klev2
    
    INTEGER   JLEV, JLAT, JLON, headerIndex, JSTEP, JK
    INTEGER   ILON, ILA, ILO
    REAL*8    DLDX, DLDY, DLW1, DLW2, DLW3, DLW4, DInterpWeight
    real(8) :: xpos, ypos, lat, lon, latrot, lonrot

    real(8) :: zfield(1:statevector % ni+1, klev1:klev2,statevector % myLatBeg:myLatP1)

    real*8, pointer :: field_ptr(:,:,:,:)
    real*8, pointer :: column_ptr(:,:)


    if (col_getNumCol(LCOLUMN) > 0) column_ptr => col_getAllColumns(lcolumn,varName)

    field_ptr  => gsv_getField(statevector,varName)

    ! Note: We assume here the all the obs between the poles and the last grid points
    !       (i.e. outside the grid) have been moved within the grid previously

    do jstep = 1, statevector % numStep

      zfield(:,:,:) = 0.0D0
      
      !
      !- 2.  LOOP OVER ALL THE OBSERVATIONS
      !
      DO headerIndex = 1, col_getNumCol(lcolumn)

        if ( tim_getTimeInterpWeight(headerIndex,jstep) > 0.0d0 .and. &
             .not.btest(obs_headElem_i(lobsSpaceData,OBS_ST1,headerIndex),5) ) then

          !- 2.1 Find the obs position within the analysis grid
          call col_getLatLon( lcolumn, headerIndex,                & ! IN
                              Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT

          !- Make sure we are within bounds
          if ( ypos < real(statevector % myLatBeg,8) .or. &
               ypos > real(myLatP1               ,8) .or. &
               xpos < 1.d0                           .or. &
               xpos > real(statevector % ni + 1  ,8) ) then
            write(*,*) 'oda_LT: Obs outside local domain for job = ', headerIndex
            write(*,*) '  obs position  = ', xpos, ypos
            write(*,*) '  domain bounds = ', statevector % myLatBeg, myLatP1, statevector % ni + 1

            ! if obs above or below latitude band, move it to the edge of this latitude band
            if( ypos < real(statevector % myLatBeg,8) ) ypos = real(statevector % myLatBeg,8)
            if( ypos > real(myLatP1               ,8) ) ypos = real(myLatP1               ,8)

            ! abort if obs is to the left or right of the analysis domain
            if( xpos < 1.d0                           .or. &
                xpos > real(statevector % ni + 1  ,8) ) call abort3d('oda_LT')
          end if

          !- 2.2 Find the lower-left grid point next to the observation
          if ( xpos /= real(statevector % ni + 1,8) ) then
            ILON = floor(xpos)
          else
            ILON = floor(xpos) - 1
          end if

          if ( ypos /= real(myLatP1,8) ) then
            ILA = floor(ypos)
          else
            ILA = floor(ypos) - 1
          end if

          !- 2.3 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
          DLDX = xpos - real(ILON,8)
          DLDY = ypos - real(ILA,8)

          DInterpWeight = tim_getTimeInterpWeight(headerIndex,jstep)
          
          DLW1  = DInterpWeight * (1.-DLDX) * (1.-DLDY)
          DLW2  = DInterpWeight *     DLDX  * (1.-DLDY)
          DLW3  = DInterpWeight * (1.-DLDX) *     DLDY
          DLW4  = DInterpWeight *     DLDX  *     DLDY

          !- 2.4 Interpolate the model state to the obs point
          do jlev = klev1, klev2
            ZFIELD(ILON  ,jlev,ILA  ) = ZFIELD(ILON  ,jlev,ILA  )    &
                                        + DLW1 * column_ptr(jlev,headerIndex)
            ZFIELD(ILON+1,jlev,ILA  ) = ZFIELD(ILON+1,jlev,ILA  )    &
                                        + DLW2 * column_ptr(jlev,headerIndex)
            ZFIELD(ILON  ,jlev,ILA+1) = ZFIELD(ILON  ,jlev,ILA+1)    &
                                        + DLW3 * column_ptr(jlev,headerIndex)
            ZFIELD(ILON+1,jlev,ILA+1) = ZFIELD(ILON+1,jlev,ILA+1)    &
                                        + DLW4 * column_ptr(jlev,headerIndex)
          end do

        end if

      end do ! Obs

      !
      !- 1.  EXPAND GRID-POINTS ARRAYS OF GD BY REPEATING MERIDIAN
      !      1 into INTO MERIDIAN NI+1
      DO JLAT = statevector % myLatBeg, myLatP1
        DO JLEV = KLEV1, KLEV2
          ZFIELD(1,JLEV,JLAT) =   ZFIELD(STATEVECTOR%NI+1,JLEV,JLAT) &
                                + ZFIELD(1               ,JLEV,JLAT)
        END DO
      END DO

      !
      !- 0. Transfer local results to global array
      !
      field_ptr(1:statevector%ni,klev1:klev2,statevector%myLatBeg:myLatP1,jstep) = &
           zfield(1:statevector%ni,klev1:klev2,statevector%myLatBeg:myLatP1)

   end do ! jstep

 END SUBROUTINE GD2MVOAD

!--------------------------------------------------------------------------
! UVROT2UVADJ
!--------------------------------------------------------------------------
  subroutine uvrot2uvAdj(UUvarName,VVvarName,klev)
    !
    !- uvrot2uv - Transforms tangential (U,V) wind components at observation
    !             locations on GEM rotated frame to the real sphere.
    use WindRotation_mod
    implicit none

    character(len=*), intent(in) :: UUvarName
    character(len=*), intent(in) :: VVvarName
    integer,          intent(in) :: klev
    
    real(8) :: lat, lon, latrot, lonrot, xpos, ypos
    real(8), pointer :: UUcolumn(:), VVcolumn(:)

    integer :: headerIndex

    !
    !- 1.  Loop over all the observation locations
    !
    do headerIndex = 1, col_getNumCol(lcolumn)

      !- 1.1 Extract (rotated) wind profiles
      UUColumn => col_getColumn(lcolumn,headerIndex,UUvarName)
      VVColumn => col_getColumn(lcolumn,headerIndex,VVvarName)
       
      !- 1.2 Find the latitudes and longitudes
      call col_getLatLon( lcolumn, headerIndex,                  & ! IN
                          Lat, Lon, ypos, xpos, LatRot, LonRot )   ! OUT

      !- 1.3 Rotate Winds
      call uvr_RotateWindAdj( UUColumn, VVColumn,       & ! INOUT
                              Lat, Lon, LatRot, LonRot, & ! IN
                              'ToMetWind', klev )         ! IN

    end do

  end subroutine uvrot2uvAdj

end subroutine oda_LT
