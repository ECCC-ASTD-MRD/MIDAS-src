module profileData_mod
  implicit none
  save
!  private

!  public :: profileData

  type struct_profileData
    real*8,pointer :: gomobs(:,:)
    real*8,pointer :: gomu(:,:)
    real*8,pointer :: gomv(:,:)
    real*8,pointer :: gomt(:,:)
    real*8,pointer :: gomq(:,:)
    real*8,pointer :: gomoz(:,:)
    real*8,pointer :: gomgz(:,:)
    real*8,pointer :: gomtr(:,:)
    real*8,pointer :: gomes(:,:)
    real*8,pointer :: gomps(:,:)
    real*8,pointer :: gomtgr(:,:)
    real*8,pointer :: rppobs(:,:)
  end type struct_profileData

!  type(struct_profileData) :: profileData

    ! from commvo
    real*8,pointer :: gomobs(:,:)
    real*8,pointer :: gomu(:,:)
    real*8,pointer :: gomv(:,:)
    real*8,pointer :: gomt(:,:)
    real*8,pointer :: gomq(:,:)
    real*8,pointer :: gomoz(:,:)
    real*8,pointer :: gomgz(:,:)
    real*8,pointer :: gomtr(:,:)
    real*8,pointer :: gomes(:,:)
    real*8,pointer :: gomps(:,:)
    real*8,pointer :: gomtgr(:,:)
    real*8,pointer :: rppobs(:,:)
    real*8,pointer :: rmthobs(:)
    real*8,pointer :: rmtmobs(:)

    ! global version of commvo
    real*8,pointer :: gomu_g(:,:)
    real*8,pointer :: gomv_g(:,:)
    real*8,pointer :: gomt_g(:,:)
    real*8,pointer :: gomq_g(:,:)
    real*8,pointer :: gomoz_g(:,:)
    real*8,pointer :: gomgz_g(:,:)
    real*8,pointer :: gomtr_g(:,:)
    real*8,pointer :: gomps_g(:,:)
    real*8,pointer :: gomtgr_g(:,:)

    ! from commvo1
    real*8,pointer :: gomobs1(:,:)
    real*8,pointer :: gomu1(:,:)
    real*8,pointer :: gomv1(:,:)
    real*8,pointer :: gomt1(:,:)
    real*8,pointer :: gomq1(:,:)
    real*8,pointer :: gomoz1(:,:)
    real*8,pointer :: gomgz1(:,:)
    real*8,pointer :: gomtr1(:,:)
    real*8,pointer :: gomes1(:,:)
    real*8,pointer :: gomps1(:,:)
    real*8,pointer :: gomtgr1(:,:)

    ! from commvog
    real*8,pointer :: gomobsg(:,:)
    real*8,pointer :: gomug(:,:)
    real*8,pointer :: gomvg(:,:)
    real*8,pointer :: gomtg(:,:)
    real*8,pointer :: gomqg(:,:)
    real*8,pointer :: gomozg(:,:)
    real*8,pointer :: gomgzg(:,:)
    real*8,pointer :: gomtrg(:,:)
    real*8,pointer :: gomesg(:,:)
    real*8,pointer :: gompsg(:,:)
    real*8,pointer :: gomtgrg(:,:)

    real*8,pointer :: oltv(:,:,:),rtapfac(:,:)
    real*8,pointer :: ollq2es(:,:,:)
    real*8,pointer :: estdg(:,:), dlnesg(:,:)
    real*8,pointer :: rqgfac(:,:)

    ! from commvohr
    integer nlevtrl,nkgdimohr
    real*8,pointer ::  gomobshr(:,:)
    real*8,pointer ::  gomuhr(:,:)
    real*8,pointer ::  gomvhr(:,:)
    real*8,pointer ::  gomthr(:,:)
    real*8,pointer ::  gomqhr(:,:)
    real*8,pointer ::  gomozhr(:,:)
    real*8,pointer ::  gomgzhr(:,:)
    real*8,pointer ::  gomtrhr(:,:)
    real*8,pointer ::  gomeshr(:,:)
    real*8,pointer ::  gompshr(:,:)
    real*8,pointer ::  gomtgrhr(:,:)
    real*8,pointer ::  rppobshr(:,:)

    real*8,pointer ::  vlevhr(:)
    real*8,pointer ::  vhybhr(:)
    real*8,pointer ::  vmahr(:)
    real*8,pointer ::  vmbhr(:)
    real*8,pointer ::  vmchr(:)
    real*8,pointer ::  vmdhr(:)
    real*8,pointer ::  vmehr(:)
    real*8,pointer ::  vmfhr(:)

  contains

    SUBROUTINE prof_allocateGlobal(klev,nobtotp)
      implicit none
      #include "comstate.cdk"
      integer :: nobtotp,klev

      if(NGEXIST(nguu).eq.1) allocate(gomu_g(klev,nobtotp))
      if(NGEXIST(ngvv).eq.1) allocate(gomv_g(klev,nobtotp))
      if(NGEXIST(ngtt).eq.1) allocate(gomt_g(klev,nobtotp))
      if(NGEXIST(ngq ).eq.1) allocate(gomq_g(klev,nobtotp))
      if(NGEXIST(ngoz).eq.1) allocate(gomoz_g(klev,nobtotp))
      if(NGEXIST(nggz).eq.1) allocate(gomgz_g(klev,nobtotp))
      if(NGEXIST(ngtr).eq.1) allocate(gomtr_g(klev,nobtotp))
      if(NGEXIST(ngps).eq.1) allocate(gomps_g(1:1,nobtotp))
      if(NGEXIST(ngtg).eq.1) allocate(gomtgr_g(1:1,nobtotp))

    END SUBROUTINE prof_allocateGlobal 

    SUBROUTINE prof_deallocateGlobal
      implicit none
      #include "comstate.cdk"

      if(NGEXIST(nguu).eq.1) deallocate(gomu_g)
      if(NGEXIST(ngvv).eq.1) deallocate(gomv_g)
      if(NGEXIST(ngtt).eq.1) deallocate(gomt_g)
      if(NGEXIST(ngq ).eq.1) deallocate(gomq_g)
      if(NGEXIST(ngoz).eq.1) deallocate(gomoz_g)
      if(NGEXIST(nggz).eq.1) deallocate(gomgz_g)
      if(NGEXIST(ngtr).eq.1) deallocate(gomtr_g)
      if(NGEXIST(ngps).eq.1) deallocate(gomps_g)
      if(NGEXIST(ngtg).eq.1) deallocate(gomtgr_g)

    END SUBROUTINE prof_deallocateGlobal 


    SUBROUTINE prof_expandToMpiGlobal2(klev,nobtot,nobtotp)
!
!**s/r prof_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global profile object by gathering
!                the necessary data from all processors (to all processors).
!
      USE obsSpaceData_mod, only: locObsTag
      IMPLICIT NONE
      #include "comstate.cdk"

      integer, intent(in) :: nobtot       ! Actual number of observations
      integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot
      integer, intent(in) :: klev

      INTEGER :: i,iobs,ierr,nsize

      print*,'Entering prof_expandToMpiGlobal2:',nobtot,nobtotp  

      if(NGEXIST(nguu).eq.1) gomu_g(:,:)=0.0d0
      if(NGEXIST(ngvv).eq.1) gomv_g(:,:)=0.0d0
      if(NGEXIST(ngtt).eq.1) gomt_g(:,:)=0.0d0
      if(NGEXIST(ngq ).eq.1) gomq_g(:,:)=0.0d0
      if(NGEXIST(ngoz).eq.1) gomoz_g(:,:)=0.0d0
      if(NGEXIST(nggz).eq.1) gomgz_g(:,:)=0.0d0
      if(NGEXIST(ngtr).eq.1) gomtr_g(:,:)=0.0d0
      if(NGEXIST(ngps).eq.1) gomps_g(:,:)=0.0d0
      if(NGEXIST(ngtg).eq.1) gomtgr_g(:,:)=0.0d0
      DO i=1,NOBTOT
         iobs=locObsTag(i)
         if(NGEXIST(nguu).eq.1) gomu_g(:,iobs)  =gomu(:,i)
         if(NGEXIST(ngvv).eq.1) gomv_g(:,iobs)  =gomv(:,i)
         if(NGEXIST(ngtt).eq.1) gomt_g(:,iobs)  =gomt(:,i)
         if(NGEXIST(ngq ).eq.1) gomq_g(:,iobs)  =gomq(:,i)
         if(NGEXIST(ngoz).eq.1) gomoz_g(:,iobs) =gomoz(:,i)
         if(NGEXIST(nggz).eq.1) gomgz_g(:,iobs) =gomgz(:,i)
         if(NGEXIST(ngtr).eq.1) gomtr_g(:,iobs) =gomtr(:,i)
         if(NGEXIST(ngps).eq.1) gomps_g(1,iobs) =gomps(1,i)
         if(NGEXIST(ngtg).eq.1) gomtgr_g(1,iobs)=gomtgr(1,i)
      ENDDO  
      nsize=klev*NOBTOTP
      if(NGEXIST(nguu).eq.1) &
          CALL RPN_COMM_ALLReduce(gomu_g,gomu_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngvv).eq.1) &
          CALL RPN_COMM_ALLReduce(gomv_g,gomv_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtt).eq.1) &
          CALL RPN_COMM_ALLReduce(gomt_g,gomt_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngq ).eq.1) &
          CALL RPN_COMM_ALLReduce(gomq_g,gomq_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngoz).eq.1) &
          CALL RPN_COMM_ALLReduce(gomoz_g,gomoz_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(nggz).eq.1) &
          CALL RPN_COMM_ALLReduce(gomgz_g,gomgz_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtr).eq.1) &
          CALL RPN_COMM_ALLReduce(gomtr_g,gomtr_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      nsize=NOBTOTP
      if(NGEXIST(ngps).eq.1) &
          CALL RPN_COMM_ALLReduce(gomps_g,gomps_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtg).eq.1) &
          CALL RPN_COMM_ALLReduce(gomtgr_g,gomtgr_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving prof_expandToMpiGlobal2' 
      RETURN

    END SUBROUTINE prof_expandToMpiGlobal2

 
    SUBROUTINE prof_expandToMpiGlobal(nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r prof_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global profile object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

    USE obsSpaceData_mod, only: locObsTag
    IMPLICIT NONE

    integer, intent(in) :: nulout       ! standard output unit
    integer, intent(in) :: nobtot       ! Actual number of observations
    integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot

!   Declare Local Variables. 
    REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
    
    INTEGER :: i,iobs,ierr,sizeRMTMOBS  
!!---------------------------------------------------------------

!!  1.  Release some memory. 
    print*,'Entering prof_expandToMpiGlobal'  

!!  1.2 Added restore global array RMTMOBS
    ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
    IF(ierr /= 0)CALL ABORT3D(nulout,'Cant allocate Mem. to RMTMOBS_tmp,Abort!') 
    RMTMOBS_TMP=0.0D0 

!!  1.3 Retore global RMTMOBS
    DO i=1,NOBTOT
       iobs=locObsTag(i)
       RMTMOBS_tmp(iobs)=RMTMOBS(i)
    ENDDO  
    sizeRMTMOBS=NOBTOTP
    CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS, &
                            "mpi_double_precision","mpi_sum","GRID",ierr)


!!  DEALLOCATE(RMTMOBS)
    deallocate(rmtmobs)
    allocate(rmtmobs(nobtotp))
    RMTMOBS=RMTMOBS_tmp
    DEALLOCATE(RMTMOBS_tmp)

    print*,'Leaving prof_expandToMpiGlobal' 
    RETURN
  END SUBROUTINE prof_expandToMpiGlobal

end module profileData_mod
