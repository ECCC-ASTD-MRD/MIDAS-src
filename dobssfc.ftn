!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE DOBSSFC(PJO,CDFAM,lcolumnhr,lobsSpaceData)
#if defined (DOC)
*
***s/r DOBSSFC  - Computation of Jo and the residuals to the observations
*                 FOR SURFACE DATAFILES
*
*
*Author  : P. Koclas *CMC/AES  September 1994
*Revision:
*           P. Koclas *CMC/AES February 1995
*            - Minor modifications
*            - Allow for multiple data files.
*           P. KoCLAS CMC/CMSV AUGUST 1998
*            - ANALYSYS ON ETA COORDINATE
*           C. Charette ARMA/AES NOV 1998
*            - Extrapolation GZ below model orography.
*            - Adapt code to follow Luc Fillion's notes on 3dvar-eta
*              analysis. LLPRINT to print diagnostics
*           B. Brasnett CMC/CMDA NOV 1999
*            - Addition of variational quality control
*           C. Charette ARMA/AES Jun 2000
*            - Adapt code to process data with height as vertical coordinate.
*              Special care for surface temperature(12004) and for
*              sfc pressure(10004) and mean sea level pressure(10051)
*           C. Charette ARMA/AES Oct 2000
*            - Process elements 12203,11215,11216 at the reported height
*              rather than at the model surface. These observations are
*              no longer displaced to the model surface in SFCADJUSTZ.
*           C. Charette ARMA/SMC FEV. 2002
*            - Commented out the if(llprint...) statements within
*              the do loops. They were preventing vectorization.
*           S. Macpherson ARMA/MRD Sep 2009
*            - modifications for GPS surface observations
*
**    Purpose:  -Interpolate vertically the contents of commvo to
*                the pressure levels of the observations. Then
*                compute Jo.
*                A linear interpolation in ln(p) is performed.
*
*
*Arguments
*     PJO  :  CONTRIBUTION to Jo
*     CDFAM: FAMILY OF OBSERVATION
*
#endif
      use EarthConstants_mod
      use MathPhysConstants_mod
      use obsSpaceData_mod
      use columnData_mod 
      use bufr
      IMPLICIT NONE
      REAL*8 PJO
      CHARACTER(len=*) :: CDFAM
*implicits
#include "comfilt.cdk"
*
      type(struct_columnData) :: lcolumnhr
      type(struct_obs) :: lobsSpaceData
      INTEGER IPB,IPT
      INTEGER INDEX_HEADER
      INTEGER INDEX_BODY,ITYP
      INTEGER ICOUNT,JLIST,JCOUNT
      INTEGER, ALLOCATABLE :: IPOINTR(:)
      REAL*8 ZVAR,ZOER,ZCON
      REAL*8 ZEXP,zexpgz,ZGAMMA,ZTVG
      REAL*8 ZLEV,ZHHH,ZGAMAZ,ZSLOPE,GZHR
      REAL*8 columnVarB,LQTOES
      LOGICAL LLOK
      CHARACTER*2 VARTYPE
C
C     Temperature lapse rate for extrapolation of gz below model surface
C
      ZGAMMA = 0.0065 / GRAV
      zexp = 1.0/(MPC_RGAS_DRY_AIR_R8*ZGAMMA)
      ZEXPGZ = MPC_RGAS_DRY_AIR_R8*ZGAMMA
C

      allocate(IPOINTR(obs_numBody(lobsSpaceData)))

      ! loop over all header indices of the 'SF' family
      call obs_set_current_header_list(lobsSpaceData,CDFAM)
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
C
C*    1. Computation of (HX - Z)/SIGMA
C     .  -----------------------------
C
C     Process all data within the domain of the model
C
C
         LISTELEM: DO JLIST = 1,NELEMS
           ICOUNT = 0

           ! loop over all body indices for this index_header
           call obs_set_current_body_list(lobsSpaceData, index_header)
           BODY: do 
             index_body = obs_getBodyIndex(lobsSpaceData)
             if (index_body < 0) exit BODY

             LLOK=.FALSE.
             IF ( obs_elem_i(lobsSpaceData,'VCO ',INDEX_BODY) .EQ. 1 ) THEN
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
               IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NEPS .OR.
     &              ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS .OR.
     &              ITYP.EQ.BUFR_NESS  .OR. ITYP.EQ.BUFR_NEPN) THEN
                 LLOK=(obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1 .AND.
     &                ITYP .EQ. NLIST(JLIST))
               ELSE IF (ITYP.EQ.BUFR_NEZD .OR. ITYP.EQ.BUFR_NEFE) THEN
                 LLOK=.FALSE.
               ELSE
                 LLOK=(obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1 .AND.
     &                ITYP .EQ. NLIST(JLIST)        .AND.
     &                obs_elem_i(lobsSpaceData,'XTR ',INDEX_BODY)  .EQ. 0)
               ENDIF
               IF ( LLOK ) THEN
                 ICOUNT = ICOUNT + 1
                 IPOINTR(ICOUNT) = INDEX_BODY
               ENDIF
             ENDIF
           ENDDO BODY
C--------------T2m,(T-TD)2m,US,VS
C              In this section we always extrapolate linearly the trial
C              field at the model surface to the height of the
C              surface observation whether the observation is above or
C              below the model surface.
C              NOTE: For (T-TD)2m,US,VS we do a zero order extrapolation
C
           IF ((NLIST(JLIST).EQ.BUFR_NETS .OR. NLIST(JLIST).EQ.BUFR_NESS .OR.
     &          NLIST(JLIST).EQ.BUFR_NEUS .OR. NLIST(JLIST).EQ.BUFR_NEVS)
     &                                .AND. ICOUNT.GT.0)        THEN

             IF(NLIST(JLIST).EQ.BUFR_NETS) THEN
               ZSLOPE = ZGAMMA
             ELSE
               ZSLOPE = 0.0
             ENDIF

             DO JCOUNT = 1,ICOUNT
               INDEX_BODY = IPOINTR(JCOUNT)
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
               ZVAR = obs_elem_r(lobsSpaceData,'VAR ',INDEX_BODY)
               ZOER = obs_elem_r(lobsSpaceData,'OER ',INDEX_BODY)
               ZLEV = obs_elem_r(lobsSpaceData,'PPP ',INDEX_BODY)
               ZHHH = ZLEV * GRAV
               varType = vnl_vartypeFromVarnum(ITYP)
               IPT  = col_getNumLev(LCOLUMNHR,varType)-1 + col_getOffsetFromVarno(lcolumnhr,ityp)
               IPB  = IPT+1
               if(ityp.eq.bufr_ness) then
                 columnVarB=lqtoes(col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'HU'),
     +                             col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'TT'),
     +                             col_getPressure(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'TH'))
               else
                 columnVarB=col_getElem(lcolumnhr,IPB,INDEX_HEADER)
               endif
               GZHR=col_getHeight(lcolumnhr,col_getNumLev(LCOLUMNHR,varType),INDEX_HEADER,varType)
               call obs_set_r(lobsSpaceData,'OMA ',INDEX_BODY,
     +               (columnVarB
     +              - ZSLOPE*(ZHHH-GZHR)-ZVAR)
     +              / ZOER)
             ENDDO
C--------------Surface Pressure Mean sea level Pressure
C              In this section we always extrapolate linearly the trial
C              field at the model surface to the height of the
C              surface observation whether the observation is above or
C              below the model height
           ELSEIF ((NLIST(JLIST).EQ.BUFR_NEPS .OR.
     &            NLIST(JLIST).EQ.BUFR_NEPN).AND. ICOUNT.GT.0) THEN
             DO JCOUNT = 1,ICOUNT
               INDEX_BODY = IPOINTR(JCOUNT)
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
               ZVAR = obs_elem_r(lobsSpaceData,'VAR ',INDEX_BODY)
               ZOER = obs_elem_r(lobsSpaceData,'OER ',INDEX_BODY)
               ZLEV = obs_elem_r(lobsSpaceData,'PPP ',INDEX_BODY)
               ZHHH = ZLEV * GRAV
               varType = vnl_vartypeFromVarnum(ITYP)
               ZGAMAZ= ZGAMMA*(ZHHH-col_getHeight(lcolumnhr,col_getNumLev(LCOLUMNHR,varType),INDEX_HEADER,varType))
               ZTVG = (1.0 + MPC_DELTA_R8 * EXP(col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'HU')))
     &                 *col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'TT')
               ZCON = ((ZTVG-ZGAMAZ)/ZTVG)
               call obs_set_r(lobsSpaceData,'OMA ',INDEX_BODY,
     &              ((col_getElem(lcolumnhr,1,INDEX_HEADER,'P0')*ZCON**ZEXP)-ZVAR)/ZOER)
             ENDDO
           ENDIF
         ENDDO LISTELEM
C
C                 CONTRIBUTION TO Jo
C

         ! loop over all body indices for this index_header
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY_2: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY_2

            LLOK=.false.
            IF ( obs_elem_i(lobsSpaceData,'VCO ',INDEX_BODY) .EQ. 1 ) THEN
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
               ZOER = obs_elem_r(lobsSpaceData,'OER ',INDEX_BODY)
               IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NEPS .OR.
     &             ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS .OR.
     &             ITYP.EQ.BUFR_NESS  .OR. ITYP.EQ.BUFR_NEPN) THEN
                  LLOK=(obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1)
               ELSE IF (ITYP.EQ.BUFR_NEZD .OR. ITYP.EQ.BUFR_NEFE) THEN
                  LLOK=.FALSE.
               ELSE
                  LLOK=(obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1 .AND.
     &                  obs_elem_i(lobsSpaceData,'XTR ',INDEX_BODY)  .EQ. 0)
               ENDIF
               IF(LLOK)     THEN
                  PJO = PJO + obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)*
     1                  obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)
                  call obs_set_r(lobsSpaceData,'OMI ',INDEX_BODY, 
     +              obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY))
               ENDIF
            ENDIF
C
         ENDDO BODY_2

C
C     Process all geopotential data below model's orography
C
         ! loop over all body indices for this index_header
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY_3: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY_3

            LLOK=(obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1)
     &         .AND. (obs_elem_i(lobsSpaceData,'XTR ',INDEX_BODY) .EQ. 2)
     &         .AND. (obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY) .EQ. BUFR_NEGZ )
     &         .AND. (obs_elem_i(lobsSpaceData,'VCO ',INDEX_BODY) .EQ. 1)
            IF ( LLOK ) THEN
               ZVAR = obs_elem_r(lobsSpaceData,'VAR ',INDEX_BODY)
               ZOER = obs_elem_r(lobsSpaceData,'OER ',INDEX_BODY)
               ZLEV = obs_elem_r(lobsSpaceData,'PPP ',INDEX_BODY)
C
C                 CONTRIBUTION TO Jo
C
c
c  forward nonlinear model for geopotential data below model's orography
c
               ZTVG = (1.0 + MPC_DELTA_R8 * EXP(col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'HU')))
     &                     *col_getElem(lcolumnhr,col_getNumLev(LCOLUMNHR,'TH'),INDEX_HEADER,'TT')
               call obs_set_r(lobsSpaceData,'OMA ',INDEX_BODY,(col_getMountain(lcolumnhr,index_header)
     &                     + ZTVG/zgamma
     &                     *(1.-(zlev/col_getElem(lcolumnhr,1,index_header,'P0'))**zexpgz)
     &                     - zvar)/zoer)
               PJO =PJO+obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)
     +                     *obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)
               call obs_set_r(lobsSpaceData,'OMI ',INDEX_BODY,obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY))
               PJO =PJO+obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)
     +                            *obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY)
               call obs_set_r(lobsSpaceData,'OMI ',INDEX_BODY,obs_elem_r(lobsSpaceData,'OMA ',INDEX_BODY))
            ENDIF
C
         ENDDO BODY_3
C
      ENDDO HEADER
      deallocate(IPOINTR)

      RETURN
      END
