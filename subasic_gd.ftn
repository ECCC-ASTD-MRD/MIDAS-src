
!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine subasic_gd(statevectorg,lcolumnhr,numStep,datestamplist,indexAnalysis)
      use mpi
      use gridStateVector_mod
      use columnData_mod
      use HorizontalCoord_mod
*
#if defined (DOC)
*
***s/r subasic_gd - Get some background fields on analysis grid.
*                   These fields are needed for:
*                   Postprocessing diagnostic analysis increments on the analysis grid
*                   using TL observation operators.
*                   IMPORTANT: when numStep>1, each 3D background state is
*                   stored in statevectorg only when myid = timestep-1, i.e. 
*                   one 3D state per processor
*
*Author  : L. Fillion  *ARMA/AES - 13 nov 98
*          (used to be getfstg2.ftn)
*Arguments
*
#endif
      IMPLICIT NONE
      INTEGER INI,INJ,INK,IG1,IG2,IG3,IG4,IERR,numStep
      integer :: indexAnalysis
      INTEGER :: datestamplist(numStep)
      CHARACTER(len=2) :: CLTYPVAR
      CHARACTER(len=1) :: CLGRTYP
      CHARACTER(len=4) :: CLNOMVAR
      CHARACTER(len=12) :: CLETIKET
      INTEGER FNOM,FSTFRM,FCLOS,FSTOUV,FSTINF

      type(struct_gsv) :: statevectorg
      type(struct_columnData) :: lcolumnhr

      type(struct_vco), pointer :: vco_anl, vco_trl
      type(struct_hco), pointer :: hco_anl

      logical ltrial 
      integer datestamp,jfile,jstep
      integer anl_gid,ezqkdef
      REAL*8 zpsg(statevectorg%ni,statevectorg%nj)
      REAL*8 zttg(statevectorg%ni,statevectorg%nj,statevectorg%nlev)
      REAL*8 zqqg(statevectorg%ni,statevectorg%nj,statevectorg%nlev)
      real*8, pointer :: ps_ptr(:,:,:,:),tt_ptr(:,:,:,:),hu_ptr(:,:,:,:)
      integer ntrials, nultrl(500)  
      CHARACTER(len=2)   :: flnum 
      CHARACTER(len=3)   :: flnum2
      CHARACTER(len=128) :: trialfile 

      WRITE(*,FMT='(/,4X,"Starting SUBASIC_GD",//)')

      vco_anl => gsv_getVco(statevectorg)
      vco_trl => col_getVco(lcolumnhr)
!
! Open all of the Trial fields
!
      nultrl(:)=0
      ntrials=0 
      do 
         write(flnum,'(I2.2)') ntrials+1
         trialfile='./trlm_' // trim(flnum)
         if(indexAnalysis.gt.0) then
           write(flnum2,'(I3.3)') indexAnalysis
           trialfile = trim(trialfile) // '_' // trim(flnum2)
         endif
         inquire(file=trim(trialfile),exist=ltrial)
         if(ltrial) then
            ntrials=ntrials+1
            ierr=fnom(nultrl(ntrials),trim(trialfile),'RND+OLD+R/O',0)
            write(*,*) 'ITRIAL - File :', trim(trialfile)
            write(*,*) ' opened as unit file ',nultrl(ntrials)
            ierr =  fstouv(nultrl(ntrials),'RND+OLD')
         else if ( (.not. ltrial) .and. ntrials >0 ) then
            exit  
         else if ( (.not. ltrial) .and. ntrials == 0 ) then
            CALL ABORT3D('SUBASIC_GD:NO TRIAL FILE')
         endif 
      enddo 
!
!     Define horizontal analysis grid
!
      hco_anl => hco_Get('Analysis')
      anl_gid = hco_anl % EZscintID

!
!     Read trial fields and interpolate them (horizontal & vertical) to analysis grid
!
      CLETIKET = ' '
      CLTYPVAR = 'P'

      do jstep=1,numStep

        datestamp=datestamplist(jstep)
!
!       Surface-pressure
!
        write(*,*)'subasic_gd: reading P0'
        CLNOMVAR = 'P0'

        write(*,*) 'subasic_gd: datestamp = ',datestamp

        ! read the background P0, interpolate to analysis grid and put result on proc jstep-1
        ! NOTE: all processors participate in reading the file
        call vhfstfld(zpsg,statevectorg%ni,statevectorg%nj,anl_gid,
     &       1,clnomvar,datestamp,nultrl,ntrials,jstep)

        ! copy interpolated P0 to statevectorg
        if(mpi_myid.eq.(jstep-1)) then
          ps_ptr => gsv_getField(statevectorg,'P0')
          CALL INITGDG2(ps_ptr(:,:,:,1),zpsg,
     &                  statevectorg%ni,statevectorg%nj,1,CLNOMVAR)
        endif
!
!       Temperature
!
        write(*,*)'subasic_gd: reading TT'
        CLNOMVAR = 'TT'

        ! read the background TT, interpolate to analysis grid and put result on proc jstep-1
        ! NOTE: all processors participate in reading the file
        call vhfstfld(zttg,statevectorg%ni,statevectorg%nj,anl_gid,
     &       statevectorg%nlev,clnomvar,datestamp,nultrl,ntrials,jstep)

        ! copy interpolated TT to statevectorg
        if(mpi_myid.eq.(jstep-1)) then
          tt_ptr => gsv_getField(statevectorg,'TT')
          CALL INITGDG2(tt_ptr(:,:,:,1),zttg,
     &                  statevectorg%ni,statevectorg%nj,statevectorg%nlev,CLNOMVAR)
        endif
!
!       Specific-Humidity
!
        write(*,*)'subasic_gd: reading HU'
        CLNOMVAR = 'HU'

        ! read the background HU, interpolate to analysis grid and put result on proc jstep-1
        ! NOTE: all processors participate in reading the file
        call vhfstfld(zqqg,statevectorg%ni,statevectorg%nj,anl_gid,
     &       statevectorg%nlev,clnomvar,datestamp,nultrl,ntrials,jstep)

        ! copy interpolated HU to statevectorg
        if(mpi_myid.eq.(jstep-1)) then
          hu_ptr => gsv_getField(statevectorg,'HU')
          CALL INITGDG2(hu_ptr(:,:,:,1),zqqg,
     &                  statevectorg%ni,statevectorg%nj,statevectorg%nlev,CLNOMVAR)
        endif

      enddo ! jstep
!
!     Close the Trials files
!
      do jfile=1,ntrials
        ierr=fstfrm(nultrl(jfile))  
        ierr=fclos(nultrl(jfile))  
      enddo
      write(*,*) 'Trial files have been closed'

      RETURN
!-----------------------------------------------------------------------------------------------
      CONTAINS

      subroutine vhfstfld(pvar,ini_anl,inj_anl,ktrggid,knk,
     &                    varName,kstampv,kulfst,ktrials,kstep)
*
#if defined (DOC)
*
***s/r vhfstfld  - Interpolate background fields on analysis grid.
*                  These fields are need for posprocessing diagnostic
*                  analysis increments on the analysis grid using
*                  TL observation operators.
*
*Author  : S. Pellerin *ARMA/SMC May 2000
*
*Arguments
*    Output:
*      pvar(ini_anl,inj_anl,knk) : Interpolated Output variable 
*    Input:
*      ini_anl,inj_anl: dimensions of horizontal analysis grid
*      ktrggid        : grid id of output variable
*      knk            : Number of level of targetted variable
*      varName        : Variable nomvar 
*      kstampv        : Valid CMC date-time stamp values for reserch in
*                       fst source file
*      kulfst         : Unit of pre-opened standard file containing src fields
*      ktrials        :  number of trial files.
#endif
      use MathPhysConstants_mod
      use vGrid_Descriptors , only:vgrid_descriptor,vgd_levels,VGD_OK
      IMPLICIT NONE

      INTEGER ktrials,kstep
      INTEGER kulfst(ktrials)
      INTEGER INI_ANL,INJ_ANL,KNK,ktrggid,kstampv
      integer inlev
      real*8 pvar(ini_anl,inj_anl,knk)
      character(len=*) :: varName

      integer, parameter :: kmaxlev=200
      integer jlev,jlat,jlon,jcol
      integer :: iip1s(kmaxlev),iip1,iip2,iip3,itrlnlev,itrlgid
      integer ikey,ezgprm,vfstluk,ezsetopt
      integer ezdefset,iset
      integer ikind,imode,ip1style,ip1kind
      integer koutmpg
      real*8  zeta(kmaxlev)
      real*8, allocatable :: zhighvar(:,:)
      real*8, allocatable :: zlowvar(:,:,:)
      real*8, allocatable :: zpstrl(:,:),zps(:,:)
      real*8, pointer :: zprestrl(:,:,:),zpresanl(:,:,:)
      character*1 clstring
      integer status,tag,pe_send,pe_recv,nsize

      WRITE(*,FMT='(/,4X,"Starting VHFSTFLD",//)')

      ierr = ezsetopt('INTERP_DEGREE','LINEAR')
c
c     get field parameters from trial field
c
c     Special case for GZ which is present at both thermo and momentum
c     levels trial field file. 
c     We will process GZ on momentum levels only.
c     We will therefore get the parameters for UU which is present
c     on momentum levels.

      if (clnomvar .eq. 'GZ') then
        call getfldprm2(IIP1S,IIP2,IIP3,ITRLNLEV,CLETIKET,CLTYPVAR
     &       ,ITRLGID,'UU',kstampv,kmaxlev,kulfst
     &       ,ip1style,ip1kind,ktrials,koutmpg)
      else
        call getfldprm2(IIP1S,IIP2,IIP3,ITRLNLEV,CLETIKET,CLTYPVAR
     &       ,ITRLGID,clnomvar,kstampv,kmaxlev,kulfst
     &       ,ip1style,ip1kind,ktrials,koutmpg)
      endif
c
c     Convert ip1 to real value P
      imode = -1
      ikind = ip1kind
      do jlev = 1,itrlnlev
        call VCONVIP( iip1s(jlev), zeta(jlev), ikind, imode, clstring,
     &       .false. )
      enddo

      call vsort(zeta,itrlnlev)
c
c     Convert real value P to IP
      imode = ip1style
      ikind = ip1kind
      do jlev = 1,itrlnlev
        call VCONVIP(iip1s(jlev),zeta(jlev),ikind,imode,clstring,.false.)
      enddo

      iset = ezdefset(ktrggid,itrlgid)

      ierr = ezgprm(itrlgid,clgrtyp,ini,inj,ig1,ig2,ig3,ig4)
      allocate(zhighvar(ini,inj))
      allocate(zlowvar(statevectorg%ni,statevectorg%nj,itrlnlev))

      write(*,*)'vhfstfld: reading ',clnomvar

      do JLEV = (1+mpi_myid),itrlnlev,mpi_nprocs
c
c Read the high-res trial field
c
        ikey = fstinf(koutmpg, INI, INJ, INK, kstampv, cletiket,
     &       iip1s(jlev), iip2, iip3,cltypvar,clnomvar)

        if (ikey.lt.0) then
          write(*,*) 'Problems finding variable '
     &         ,clnomvar,' at level ',iip1s(jlev),' in trial file'
          call abort3d('VHFSTFLD')
        endif

        ikey = VFSTLUK(zhighvar,ikey,INI,INJ,INK)
c
c Do horizontal interpolation
c
        if(trim(varName).ne.'UV') then
          call vezsint(zlowvar(:,:,jlev),zhighvar,
     +        statevectorg%ni,statevectorg%nj,1,ini,inj,1)
        else
          call abort3d(
     +      'vhfstfld: vector interpolation no longer supported')
        endif

      enddo !jlev
c
c Send all vertical levels to myid = kstep-1
c
      do jlev = 1,itrlnlev
        pe_send = mod(jlev-1,mpi_nprocs)
        pe_recv = kstep-1
        tag = pe_send+1
        nsize=ini_anl*inj_anl

        if(pe_send.ne.pe_recv) then

          if(mpi_myid.eq.pe_send) then
            call rpn_comm_send(zlowvar(:,:,jlev), 
     +           nsize,"mpi_double_precision",pe_recv,tag,"GRID",ierr)
          elseif(mpi_myid.eq.pe_recv) then
            call rpn_comm_recv(zlowvar(:,:,jlev), 
     +           nsize,"mpi_double_precision",pe_send,tag,"GRID",status,ierr)
          endif

        endif !pe_send<>0

      enddo !jlev

      deallocate(zhighvar)

      ! From now on, only the processor with the data does work
      if(mpi_myid.eq.kstep-1) then
c
c Do vertical interpolation:
c
        if (itrlnlev.gt.1) then

          write(*,*)
     &     'vhfstfld: Reading P0 trial field for vertical interpolation'

          call getfldprm(IIP1,IIP2,IIP3,INLEV,CLETIKET,CLTYPVAR,
     &                   ITRLGID,'P0',kstampv,kmaxlev,koutmpg,
     &                   ip1style,ip1kind)

          ikey = FSTINF(koutmpg, INI, INJ, INK, kstampv, cletiket,
     &                  iip1, iip2, iip3,cltypvar,'P0')

          if(ikey.lt.0) then
            write(*,*) ' ******* ERROR ******* '
            write(*,*) 'No P0 found in ',koutmpg
            call abort3d('VHFSTFLD')
          endif

          allocate(zpstrl(ini,inj))

          ikey = VFSTLUK(zpstrl, ikey, INI, INJ, INK)

          zpstrl(:,:)=zpstrl(:,:)*MPC_PA_PER_MBAR_R8

          allocate(zps(statevectorg%ni,statevectorg%nj))
c
c Interpolation of high res. P0 to low res. variable grid
c
          call vezsint(zps,zpstrl,
     +           statevectorg%ni,statevectorg%nj,1,ini,inj,1)

          status=vgd_levels(vco_anl%vgrid,ip1_list=vco_anl%ip1_M,
     &                      levels=zpresanl,sfc_field=zps,in_log=.false.)

          if(status.ne.VGD_OK)then
            call abort3d('ERROR with vgd_levels for anl levels')
          endif
c
c Computation of pressure values on trial profiles of the high
c resolution horizonal grid (I think there is a bug here, since 
c GZ is actually on momentum levels; the commented code corrects the
c bug, but to keep the same behaviour as before it isn't used yet.)
c (January, 2013, Mark Buehner)
c
!          if (trim(varName) .eq. 'GZ') then
!            status=vgd_levels(vco_trl%vgrid,ip1_list=vco_trl%ip1_M,
!     &                        levels=zprestrl,sfc_field=zps,in_log=.false.)
!          else
            status=vgd_levels(vco_trl%vgrid,ip1_list=vco_trl%ip1_T,
     &                        levels=zprestrl,sfc_field=zps,in_log=.false.)
!          endif

          if(status.ne.VGD_OK)then
             call abort3d('ERROR with vgd_levels for trl levels')
          endif

          call vintgd(pvar,zpresanl,knk,zlowvar,zprestrl,itrlnlev,ini_anl,inj_anl)

          deallocate(zpresanl)
          deallocate(zps)
          deallocate(zprestrl)

        else

          if (knk.ne.itrlnlev) then
            write(*,*) ' *********** ERROR ***********'
            write(*,*) 'Number of level inconsistancies'
            write(*,*) knk,' levels asked on output and '
            write(*,*) itrlnlev,' levels found in standard file'
            write(*,*) ' *********** ERROR ***********'
            call abort3d('VHFSTFLD')
          else
            jlev=1
            do jlat = 1, statevectorg%nj
              do jlon = 1, statevectorg%ni
                pvar(jlon,jlat,jlev) = zlowvar(jlon,jlat,jlev)
              enddo
            enddo
          endif

        endif
c
c End of vertical interpolation
c
      endif

      deallocate(zlowvar)

      write(*,*) 'END of VHFSTFLD'

      return
      END SUBROUTINE VHFSTFLD


      END SUBROUTINE SUBASIC_GD
