!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

#include "maincompileswitch.inc"
#include "compileswitches.inc"

module chem_setup_mod
!         
! PURPOSE: Provides pre-processing (setup) routines and 
!          related tools reqarding observation averaging kernels, 
!          and std. (fst) gridded format files.
!  
!
! Module managers: Mike Sitwell and Yves Rochon (ARQI/AQRD)
!
! Revisions:  
!   
! Public routines:
!
!       - "chm_setup": Routines and structure for setting and assignment 
!         of observation layer top and bottom levels (and averaging kernel matrices - tbc). 
!         See 'preproc.ftn90' and 'chm_obsoperators'. 
!
!       - "chm_apply_2dfieldr4_transform" applied to 2D field variable transformation if requested.
!
!       - "chm_checkfor_integlayer" needed to determine if vertical
!         integration required.
!
!       - "chm_find_avgkern" to find averaging kernel matrix associated to an obs
!
!       - "chm_get_layer_boundaries" to return layer boundaries for an observation. 
!
!       - "chm_get_avgkern" to return averaging kernel for an observation.
!
!       - "chm_var_maxnumber" to pass on value of chm_constituents_size
!
!       - "chm_add_efftemp_*" adds effective temperatures in obsfile and or 
!          obsdata subspace
!
!        - "chm_set_reference_obsdata" determines and stores reference 
!          profile at obs location if needed by the observation operators.
!
!       - "chm_get_ref_column" to extract and provide column from chm_ref_field 
!          associated to code.
!
!       - "chm_config_select_*" allows access to desired parameter in object 
!          chm_config
!
!       - "chm_config_set_int" allows setting of chm_config integer element 
!         outside this module
!
!       - "chm_diagn_only": Identify if data is to be assimilated or only used
!         for independent verifications.
!
!----------------------------------------------------------------------------------------
 
  use mpi_mod, only: mpi_myid, mpi_allgather_string
  use utilities_mod
  use obsSubSpaceData_mod
  use bufr
  use varNameList_mod
  use MathPhysConstants_mod
  use burpFiles_mod
  use physicsfunctions_mod
  use stateToColumn_mod, only: s2c_column_hbilin
  
  implicit none
  private
  
! public procedures
! -----------------

  public :: chm_setup, chm_apply_2dfieldr4_transform, chm_checkfor_integlayer
  public :: chm_find_avgkern, chm_get_layer_boundaries, chm_get_avgkern
  public :: chm_var_maxnumber, chm_diagn_only
  public :: chm_add_efftemp_obsfile, chm_add_efftemp_obsdata
  public :: chm_get_ref_column, chm_set_reference_obsdata
  public :: chm_config_select_float, chm_config_select_str
  public :: chm_config_select_logical, chm_config_select_int
  public :: chm_config_set_int
  
! public types (for use in chm_obsoperators_mod.ftn90)
! ----------------------------------------------------
  public :: struct_chm_obsoperators

! module constants
! -----------------
  integer, parameter :: chm_cfg_size=100           ! max size of config arrays
  integer, parameter :: chm_constituents_size=30   ! max size of constituents arrays
                                                   ! = max allowed value of "iconstituent_id" for Table 08046.
                                                   ! Value to be increased as needed up to a max of 6999 as values
                                                   ! > 7000 (and less 0) are assumed assigned to non-constituent fields  
  integer, parameter :: chm_filename_size=50       ! Max size of *_filename in chm_config
! module structures
! -----------------

  type :: struct_chm_obsoperators  
  
     !  Structure holding work variables for observation operators
     !     
     !  Variable               Description
     !  --------               -----------
     !  nobslev                Number of observations in the profile
     !  nmodlev                Number of model levels in the column
     !  varno                  BUFR descriptor element for obs units
     !  constituent_id         BUFR code element of local GRIB Table 08046 identifying the constituent
     !                         (similar to BUFR Table 08043)
     !  modelIndex             Obs operator index
     !                         0 - vertical interpolator
     !                         1 - layer averaging
     !                         2 - layer integration
     !  layer_identified       .true. if a layer (with identified layer boundaries)
     !                         .false if layer boundaries are not available.
     !  vmodpress              Model layer boundaries taken as middle between model level
     !  vlayertop              Layer top (final work values in Pa)
     !  vlayerbottom           Layer bottom (final work values in Pa)
     !  vweights               Second order Lagrangian interp integration weights
     !  zh                     Initial innovation model array (other than conversion constants)
     !  zhp                    Part of innovation operator not related to resolution.
     !  imodlev_top            Top level of non-zero values in zh
     !  imodlev_bot            Bottom level of non-zero values in zh
     !  trial                  Trial (background) profile at observation location
     !  tt                     Temperature profile on model levels (Kelvin)
     !  hu                     Specific humidity 
     !  gz                     Geopotential height on model levels (m)
     !  pp                     Pressure on model levels (Pa)
     !  lat                    Latitude of observation (radians)
     !  lon                    Longitude of observation (radians)
     !  obslev                 Observation profile level values (OBS_PPP)
     !  varName                Variable/obs nomvar
     !  stnid                  Observation station ID
     !  date                   YYYYMMDD (date of obs)
     !  hhmm                   HHMM (time of obs)
     !  obs_index              Observation index
     !                         Note: Depending on the data of interest, the index of a required array element or 
     !                               profile associated to an observation can be identified from (lat,long,date,hhmm,
     !                               stnid,optional task-dependent identifier if needed) or obs_index. 
     !                               The latter is for associations of data identified within
     !                               processing of individual CPUs. Each of the two index identifiers is represented 
     !                               by the unique character string identifier 'code' of struct_oss_obsdata
     !                               (e.g. see obsdata_get_header_code_r for use of (lat,long,date,hhmm,stnid)).
     !  vco                    Index of vertical coord type for obs
     !                           1 - Altitudes (m)
     !                           2 - Pressure (Pa)
     !                           3 - Channel index
     !                           4 - not provided with obs. Obs is for total column values.
     !                           5 - not provided with obs. Obs is a surface point value.
     !  iavgkern               Integer indicating if averaging kernels are to be applied. Value
     !                         of zero indicates no averaging kernel to be applied. Non-zero value
     !                         indicates index in chm_avgkern,chm_burp_avgkern arrays.
     !  apply_genoper          Indicates if the generalized observation operator should be applied
     !  column_bound           Boudary imporsed on a column measurement
     !  dtransform             Derivative for any transform that needs to be applied to a profile
     
     integer :: nobslev,nmodlev,modelIndex,constituent_id,vco,varno,date,hhmm,iavgkern,obs_index
     logical :: layer_identified,apply_genoper
     real(8) :: lat,lon,column_bound
     character(len=12) :: stnid
     character(len=4)  :: varName
     real(8), allocatable :: vlayertop(:),vlayerbottom(:),vmodpress(:),tt(:),gz(:),pp(:)
     real(8), allocatable :: zh(:,:),zhp(:,:),vweights(:,:),obslev(:),dtransform(:),hu(:)
     real(8), pointer     :: trial(:)
     integer, allocatable :: imodlev_top(:),imodlev_bot(:)

  end type struct_chm_obsoperators

  type :: struct_config    ! Most parameters set in chm_setup of chem_setup_mod.ftn90
     
     !  Structure to store general config information.
     !     
     !  Variable               Description
     !  --------               -----------
     !  generalized_operator   Flag indicatting if generalized observation operator should be used 
     !                         and selection of approach
     !
     !                            <=0: not applied
     !                            1: use trial field xb for mass weighted increment distribution
     !                            2: use a combination of the difference of an external reference xc 
     !                               and the trial field xb, i.e. mass weighted increment distribution 
     !                               as a(xc-xb) + b*xc where a and b depend on the size of 
     !                               sum[(xc-xb)/sig(xb)]^2 over the profile.
     !
     !  assim_num              Number of combinations (stnid, bufr element, multi/uni-level) 
     !                         identified for obs to be assimilated. All others will not
     !                         be assimilated. OmP and OmA diagnostics and output
     !                         will still be produced for non-assimilated (i.e. diagnostic-only) datasets.
     !                         (see routines chm_diagn_only, and oop_chm_nl in obsoperators_mod.ftn90)
     !
     !                           <0:  all are to be assimilated
     !                            0:  none are to be assimilated
     !                           >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
     !
     !  assim_varno            Bufr elements of obs sets for assimilation. A value of
     !                         0 implies that all are to be used.
     !
     !  assim_stnid            Stnids of obs sets for assimilation. '*' denote wild cards
     !       
     !  assim_nlev             0:  multi-level and uni-level
     !                         1:  uni_level
     !                         >1: multi-level 
     !
     !  diagn_pressmin         Bottom of top layer for diagnostics (in Pa).
     !
     !  diagn_save             Logical indicating gridded diagnostics are to be saved
     !                         in an ascii file in addition to overall diagnostics. 
     !                         (see routine chm_obsspace_diagnostic)
     !
     !  diagn_flag             Array specifying bits for identifying diagnostic-only (non-assim) observations for
     !                         observations that would otherwise be assimilated according to the assim_*
     !                         arrays. Those not included as part assim_* are automatically classified as diagnostic-only 
     !                         observations. This array allows screening of data specific to CH family observations 
     !                         as oppose to common screening for all other families done through the NLIST
     !                         array of the NAMFILT namelist (see file filterobs_mod.ftn90).
     !
     !  diagn_nflag            Number of bit flags to specify in diagn_flag array
     !
     !  amu                    Molecular mass of constituents in g/moles (needed for unit conversions)
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent.
     !
     !  tropo_mode             Integer indicating if special treatment is to be given to the troposphere
     !                         when assimilating total column measurements. Values indicate
     !                           0:  No special treatment given (default)
     !                           1:  Values of the adjoint model above obsoper%column_bound set to zero.
     !                               If specified, generalized innovation operator only applied below
     !                               obsoper%column_bound in the tangent linear model.
     !                           2:  Values of tangent linear model and adjoint model above 
     !                               obsoper%column_bound set to zero.
     !                         Array index refers to BUFR code element of Table 08046 (iconstituent_id)
     !                         identifying the constituent. Relevant for total column measurements only.
     !                         
     !  tropo_bound            Integer indicating which column top value to use if tropo_mode is non-zero.
     !                           0: Use fixed value of tropo_column_top
     !                           1: Use model determination of tropopause
     !                           2: Use model determination of PBL
     !                         Options 1 and 2 will default to the value set in tropo_column_top if the model
     !                         derived column top could not be determined. Relevant for total column measurements only.
     !             
     !  tropo_column_top       Default value to use for the column boundary (in Pa). Array index refers to BUFR code
     !                         element of Table 08046 (obsoper%constituent_id) identifying the constituent. 
     !                         Relevant for total column measurements only.
     !
     !  obsdata_maxsize        Max allowed size of work arrays (in terms of number of obs) associated to
     !                         ordered observation indices
     !
     !  low_cutoff             min value allowed for increments prior to storage in rebm expressed as a fraction
     !                         of the background field (generally < 1)
     !
     !  high_cutoff            max value allowed for increments prior to storage in rebm expressed as a multiple
     !                         of the background field (generally > 1)
     !
     !  transform              Index specifying form of analysis increment (and related adjoint operation)
     !                           -1: no transformation (dx given input trial field denoted as x)
     !                          >=0: Ensure positive values. Provide warning if 
     !                               non-positive values encountered.
     !                            1: dlnx
     !
     !  message_filename       File name for file containing various messages and warnings related to chemical
     !                         constituents that are not included in the listing file.
     !
     !  message_fileunit       File unit of 'message_filename'
     !
     !
     !  obsspace_diagn_filename  File name for file containing obs space diagnostics related to chemical
     !                           constituents.
     !
     !  obsspace_diagn_fileunit  File unit of 'obsspace_diagn_filename'
     
     logical :: diagn_save
     integer :: generalized_operator(0:chm_constituents_size)
     integer :: assim_num,tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
     integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size)
     integer :: obsdata_maxsize,diagn_nflag,diagn_flag(chm_cfg_size)
     integer :: transform(0:chm_constituents_size),message_fileunit,obsspace_diagn_fileunit
     real(8) :: diagn_pressmin
     real(8) :: amu(0:chm_constituents_size),tropo_column_top(0:chm_constituents_size)
     real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)
     character(len=9) :: assim_stnid(chm_cfg_size)
     character(len=50) :: message_filename,obsspace_diagn_filename 

  end type struct_config

  type :: struct_chm_info
     !  Information arrays retrieved from file obsinfo_chm regarding vertical levels 
     !  or averaging kernels
     !
     !  Variable               Description
     !  --------               -----------
     !  n_stnid                Number of sub-families (identified via STNIDs)
     !  stnids                 Sub-families (STNIDs; * are wild cards)
     !  bfr                    BUFR/BURP element in data block
     !  brp                    0: Set entirely from the ascii file being read. No 
     !                            initial values read from BURP files
     !                         1: Initial values in obs BURP files for constant number
     !                            of vertical levels (may be adjusted after input)
     !  vco                    Vertical coordinate type (1, 2, or 3, see bufr_read_mod)
     !
     !  ibegin                 Position index of start of data for given
     !                         sub-family.
     !  n_lvl                  Number of vertical levels 
     !  n_lat                  Number of latitudes
     !  lat                    Latitudes (degrees; ordered in increasing size)
     !
     !  vlayertop              Layer top 
     !  vlayerbottom           Layer bottom
     !  rak                    Averaging kernel matrices
     
     integer ::  n_stnid
     character(len=12), allocatable :: stnids(:)
     integer, allocatable :: bfr(:),brp(:)
     integer, allocatable :: vco(:),n_lat(:)
     integer, allocatable :: ibegin(:),n_lvl(:)
     real(8), allocatable :: rak(:),vlayertop(:),vlayerbottom(:)
     real(8), allocatable :: lat(:)
  
  end type struct_chm_info

  type :: struct_chm_griddata

     !  Structure storing gridded fields 
     !     
     !  Variable               Description
     !  --------               -----------
     !  field2d                Gridded 2 field
     !  field3d                Gridded 3 field (lon,lat,vlev)
     !  nlat                   number of latitudes
     !  nlon                   number of longitudes
     !  nlev                   number of vertical levels
     !  lat,lon                grid lat,lon in radians
     !  vlev                   vertical levels
     !  ivkind                 Index of vertical coordinate type. Defintion may vary according to source.
     !                         For fields read for RPN files and use of convip:
     !                             0: P is in height [m] (metres) with respect to sea level 
     !                             1: P is in sigma [sg] (0.0 -> 1.0) 
     !                             2: P is in pressure [mb] (millibars) 
     !                             3: P is in an arbitrary code 
     !                             4: P is in height [M] (metres) with respect to ground level 
     !                             5: P is in hybrid coordinates [hy] 
     !                             6: P is in theta [th] 
     !                         For use with obs                      
     
     real(8), pointer :: field2d(:,:),field3d(:,:,:),lat(:),lon(:),vlev(:)
     integer :: nlev,nlon,nlat,ivkind
  
  end type struct_chm_griddata

  type(struct_chm_info) :: chm_layers
  type(struct_chm_info) :: chm_avgkern
  type(struct_config)   :: chm_config

! Array of pointers to averaging kernels read from BURP file.
! Note: Ideally, these should be an element in the 'struct_chm_info' derived 
! types, but currently this result in an internal compiler error.

  type(struct_oss_obsdata), allocatable :: chm_burp_avgkern(:)

! Arrays containing input reference fields and fields interpolated 
! to obs locations

  type(struct_oss_obsdata)  :: chm_ref_trial
  type(struct_chm_griddata) :: chm_ref_fields(0:chm_constituents_size,2)

! Arrays to contain the calculated concentration-weighted effective temperature
! associated to total column data. It will be stored in the observation file.

  type(struct_oss_obsdata) :: chm_efftemp

contains

!---------------------------- Setup called from "preproc/suobs" -------------------------
!
  subroutine chm_setup(datestamp)
!
! Author   : Y. Rochon, Dec 2014 
! 
! Revisions: M. Sitwell, Feb 2015
!            - Removed references to earlier structure
!            Y. Rochon, Dec 2015
!            - Added call to chm_read_ref_fields and related optional input
!              'datestamp'
!          
! Purpose: Setup additional information required by constituent obs and not provided in
!          lobsSpaceData.
!
!----------------------------------------------------------------------------------------
  
  implicit none

  integer, intent(in), optional :: datestamp

  write(*,*) 'Begin chm_setup'

! Read miscellaneous flags and constants 

  call chm_read_misc
      
! Read top and bottom layer boundaries of partial (or total) column meausurements
  
  call chm_read_layers
      
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_layers
   
! Read averaging kernel matrices
  
  call chm_read_avgkern
  
! To deallocate space if required elsewhere, one should use
! call chm_dealloc_avgkern
  
 ! Read reference (e.g. climatological) fields
  
  if (present(datestamp)) then
     call chm_read_ref_fields(datestamp)
  else
     call chm_read_ref_fields()
  end if

! Allocation of chm_efftemp done in chm_setup instead of obsdata_add_data1d
! to ensure allocation is done for all processors, including those without associated data.
! This is to ensure that rpn_comm_allgather will work in routine obsdata_MPIGather.

  if (.not.associated(chm_efftemp%data1d)) then
      call oss_obsdata_alloc(chm_efftemp,chm_config%obsdata_maxsize,dim1=1)
      chm_efftemp%nrep=0
  end if

  write(*,*) 'Completed chm_setup'
  
  end subroutine chm_setup

!------------------------------------------------------------------------------------

  subroutine chm_read_misc
!
! Author   : Y. Rochon, ARQI/AQRD, Apr 2015 
!
! Purpose: Read and store miscellaneous flags and constants.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Aug 2015
!            - Incorporated input fields in chm_config
!            Y. Rochon, ARQI/AQRD, Sept 2015
!            - Added reading of variables related to options for attributing only 
!              tropospheric portion of the increment to total column observations
!            M. Sitwell, ARQI/AQRD, Oct 2015
!            - Moved amu from obsinfo_chm to namelist namchem    
!
! Output:
!
!   Read from NAMCHEM namelist
!
!        genoper             If generalized observation operator should be used and selection of approach
!                            <=0: not applied
!                            1: use trial field xb for mass weighted increment distribution
!                            2: use a combination of the difference of an external reference xc 
!                               and the trial field xb, i.e. mass weighted increment distribution 
!                               as a(xc-xb) + b*xc where a and b depend on the size of 
!                               sum[(xc-xb)/sig(xb)]^2 over the profile.
!
!        diagn_num           Prescribed (starting) number of (stnid, bufr, nlev) for the diagnostics calc
!
!        diagn_stnid         Prescribed (starting) list of stnid (with *s as needed) for the diagnostics calc
!                            with '*' denoting wild cards
!
!        diagn_varno         Prescribed (starting) list of bufr elments for the diagnostics calc
!
!        diagn_unilev        Prescribed (starting) list of logicals indicating uni-level obs for the diagnostics calc
!
!        diagn_pressmin      Bottom of top layer for diagnostics (in Pa).
!
!        diagn_save          Logical indicating gridded diagnostics are to be saved
!                            in an ascii file in addition to overall diagnostics. 
!
!        diagn_nset          Integer indicating grouping of diagnostics with
!                            1: group by stnid
!                            2: group by (stnid,bufr)
!                            3: group by (stnid,bufr,nlev)
!
!        diagn_all           Logical indicating if all combinations specified by diagn_nset are to be
!                            used in diagnostics or only those specified by the diagn_* arrays
!
!        diagn_flag          Array specifying bits for identifying diagnostic-only observations for
!                            observations that would otherwise be assimilated according to the assim_*
!                            arrays
!
!        diagn_nflag         Number of bit flags to specify in diagn_flag array
!
!        assim_num           Number combinations (stnid, bufr element, multi/uni-level) 
!                            identified for assimilation. All others will not
!                            be assimilated. OmP and OmA diagnostics and output
!                            will still be produced for non-assimilated datasets.
!                         
!                            <0:  all are to be assimilated
!                             0:  none are to be assimilated
!                            >0:  sets of (stnid,bufr,multi/uni-levels) to be assimilated
!
!        assim_varno         Bufr elements of obs sets for assimilation. A value of
!                            0 implies that all are to be used.
!
!        assim_stnid         Stnids of obs sets for assimilation. '*' denote wild cards
!
!        assim_nlev           0:  multi-level and uni-level
!                             1:  uni_level
!                            >1: multi-level 
!
!        tropo_mode          Integer indicating if special treatment is to be given to the troposphere
!                            when assimilating total column measurements. Values indicate
!                             0:  No special treatment given (default)
!                             1:  Values of the adjoint model above obsoper%column_bound set to zero.
!                                 If specified, generalized innovation operator only applied below
!                                 obsoper%column_bound in the tangent linear model.
!                             2:  Values of tangent linear model and adjoint model above
!                                 obsoper%column_bound set to zero.
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent. Relevant for total column measurements only.
!
!        tropo_bound         Integer indicating which column top value to use if tropo_mode is non-zero.
!                              0: Use fixed value of tropo_column_top
!                              1: Use model determination of tropopause
!                              2: Use model determination of PBL
!                            Options 1 and 2 will default to the value set in tropo_column_top if the model
!                            derived column top could not be determined. Relevant for total column measurements only.
!                         
!        tropo_column_top    Default value to use for the column boundary (in Pa). Array index refers to BUFR code
!                            element of Table 08046 (iconstituent_id) identifying the constituent.
!                            Relevant for total column measurements only.
!
!        amu                 Molecular mass  of constituents in g/moles (needed for unit conversions)
!                            Array index refers to BUFR code element of Table 08046 (iconstituent_id)
!                            identifying the constituent.
!
!       obsdata_maxsize      Max allowed size of work arrays (in terms of number of obs) associated to
!                            ordered observation indices
!
!       low_cutoff           min value allowed for increments prior to storage in rebm expressed as a fraction
!                            of the background field (generally < 1)
!
!       high_cutoff          max value allowed for increments prior to storage in rebm expressed as a multiple
!                            of the background field (generally > 1)
!
!       transform            Index specifying form of analysis increment (and related adjoint operation)
!                               -1: no transformation (dx given input trial field denoted as x)
!                              >=0: Ensure positive values. Provide warning if
!                                   non-positive values encountered.
!                                1: dlnx
!
!       message_filename     File name for file containing various messages and warnings related to chemical
!                            constituents that are not included in the listing file.
!
!       obsspace_diagn_filename 
!                            File name for file containing obs space diagnostics related to chemical constituents.
!
!---------------------------------------------------------------------------------------- 

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JELM, nulstat, ios, isize, nulnam, i
  integer :: genoper(0:chm_constituents_size)
  
  character(len=128) :: ligne  
  character(len=10)  :: namfile 

  integer :: assim_num,diagn_num,diagn_nset,obsdata_maxsize,diagn_nflag
  integer :: assim_varno(chm_cfg_size),assim_nlev(chm_cfg_size),diagn_flag(chm_cfg_size)
  integer :: diagn_varno(chm_cfg_size),tropo_mode(0:chm_constituents_size),tropo_bound(0:chm_constituents_size)
  character(len=9) :: assim_stnid(chm_cfg_size),diagn_stnid(chm_cfg_size)
  logical :: diagn_save,diagn_all,diagn_unilev(chm_cfg_size)
  real(8) :: diagn_pressmin,tropo_column_top(0:chm_constituents_size)
  real(8) :: amu(0:chm_constituents_size)
  real(8) :: low_cutoff(0:chm_constituents_size),high_cutoff(0:chm_constituents_size)
  integer :: transform(0:chm_constituents_size)
  character(len=50) :: message_filename,obsspace_diagn_filename

  EXTERNAL FNOM,FCLOS

  namelist /namchem/ genoper, &
                     assim_num,assim_stnid,assim_varno,assim_nlev,     &
                     diagn_num,diagn_stnid,diagn_varno,diagn_unilev,   &
                     diagn_save,diagn_all,diagn_nset,diagn_pressmin,   &
                     diagn_nflag,diagn_flag,                           &
                     tropo_mode,tropo_bound,tropo_column_top,amu,      &
                     low_cutoff,high_cutoff,transform,obsdata_maxsize, &
                     message_filename,obsspace_diagn_filename

  
  ! Default NAMCHEM values
  
  genoper(:)=0
  obsdata_maxsize=90000
  low_cutoff(:)=0.1
  high_cutoff(:)=10.0
  transform(:)=0   ! At least ensure positive values and provide related warning as needed.
  
  assim_num=-1  
  assim_stnid(:)='*********'
  assim_varno(:)=0
  assim_nlev(:)=0
 
  diagn_save=.false.
  diagn_all=.true. 
  diagn_pressmin=10.  !  0.1 hPa
  diagn_nset=2
  diagn_num=0
  diagn_stnid(:)='*********'
  diagn_varno(:)=0
  diagn_unilev(:)=.false.
  diagn_nflag=1
  diagn_flag(1)=6  ! this is for the 'in reserve' bit for a BURP marker
  diagn_flag(2:)=0

  tropo_mode(:) = 0
  tropo_bound(:) = 0
  tropo_column_top(:) = 0.0

  message_filename = 'chem_message_'
  obsspace_diagn_filename ='obsspace_diag_CH_'
  
  amu(:) = -1.0
  amu(0) = 48.0    ! Molecular mass in g/mole for O3
  amu(1) = 18.02   ! H2O
  amu(2) = 16.04   ! CH4
  amu(3) = 44.01   ! CO2
  amu(4) = 28.01   ! CO
  amu(5) = 46.01   ! NO2
  amu(6) = 44.01   ! N2O
  amu(7) = 30.03   ! HCHO=Formaldehyde
  amu(8) = 64.06   ! SO2
  amu(9) = 17.03   ! NH3
  amu(11) = 30.0   ! NO
  amu(26) = 1.0    ! PM2.5 - Not applicable
  amu(27) = 1.0    ! PM10  - Not applicable

  ! Read from namelist file NAMCHEM

  namfile=trim("flnml")
  nulnam=0
  ierr=FNOM(nulnam,namfile,'R/O',0)

  read(nulnam,nml=namchem,iostat=ios)
  if (ios.lt.-4.or.ios.gt.0) then 
      call utl_abort('chm_read_misc: Error in reading NAMCHEM namelist. iostat = ' // trim(utl_str(ios)) )   
  else if (mpi_myid.eq.0) then
      write(*,nml=namchem)   
  end if
  
  ierr=FCLOS(nulnam)      
  
  ! Set config values

  chm_config%generalized_operator(:) = genoper(:)
  chm_config%assim_num = assim_num
  chm_config%assim_varno = assim_varno
  chm_config%assim_stnid = assim_stnid
  chm_config%assim_nlev = assim_nlev 
  chm_config%diagn_pressmin = diagn_pressmin
  chm_config%diagn_save = diagn_save
  chm_config%diagn_nflag = diagn_nflag
  chm_config%diagn_flag = diagn_flag
  chm_config%tropo_mode = tropo_mode
  chm_config%tropo_bound = tropo_bound
  chm_config%tropo_column_top = tropo_column_top
  chm_config%amu = amu
  chm_config%obsdata_maxsize = obsdata_maxsize
  chm_config%low_cutoff = low_cutoff
  chm_config%high_cutoff = high_cutoff
  chm_config%transform = transform
  chm_config%message_filename = message_filename
  chm_config%obsspace_diagn_filename = obsspace_diagn_filename
  chm_config%message_fileunit = 0
  chm_config%obsspace_diagn_fileunit = 0
  
  ! Initialize oss_comboIDlist and add (stnid,varno) pairs from the namelist

  call oss_comboIdlist(initialize=.true., nset=diagn_nset, all_combos=diagn_all)
  do jelm=1,diagn_num
     call oss_comboIdlist(stnid_add=diagn_stnid(jelm), varno_add=diagn_varno(jelm), unilev_add=diagn_unilev(jelm))
  end do

  end subroutine chm_read_misc

!-----------------------------------------------------------------------------------------
!--------------------- Routines related to layer top & bottom levels----------------------

  subroutine chm_read_layers
!
! Author   : Y. Rochon, ARQI/AQRD, Dec 2014 
!            - Partially based on oer_read_obs_erreurs_conv.
!
! Revisions: 
!            M. Sitwell, ARQI/AQRD, Feb 2015
!            - Renaming of routine and removal of lines no longer required.
!          
! Purpose: Read and store top and bottom layer boundaries for CH sub-families
!
! Comments:
!
! A) The option of reading from BURP files is TBD. This will change the approach in allocating
!    the arrays size as the sizes will become dependent on the number of related obs for
!    which the BURP files will need to be read.
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS
  
! Initialization

  chm_layers%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '-------------------------------------------------'
    WRITE(*,*)   'chm_read_layers: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '-------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL utl_abort('chm_read_layers: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:13))).ne.'SECTION II:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_layers%stnids(chm_layers%n_stnid))
  allocate(chm_layers%vco(chm_layers%n_stnid))
  allocate(chm_layers%brp(chm_layers%n_stnid),chm_layers%ibegin(chm_layers%n_stnid))
  allocate(chm_layers%bfr(chm_layers%n_stnid),chm_layers%n_lvl(chm_layers%n_stnid))
  allocate(chm_layers%vlayertop(isize),chm_layers%vlayerbottom(isize))
 
  chm_layers%bfr(:)=0
  chm_layers%vco(:)=0
  chm_layers%brp(:)=0
  chm_layers%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,chm_layers%n_stnid
    chm_layers%ibegin(jelm)=icount+1

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_layers%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Vertical coord type (1, 2, or 3)
!        (3) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (4) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_layers%bfr(jelm),chm_layers%vco(jelm),  &
       chm_layers%brp(jelm),chm_layers%n_lvl(jelm)  
    
    if (icount+chm_layers%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL utl_abort('chm_read_layers: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (chm_layers%n_lvl(jelm).ge.1) then   
       do jlev=1,chm_layers%n_lvl(jelm)
          icount=icount+1
          
          ! Read top and bottom levels
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 chm_layers%vlayertop(icount),chm_layers%vlayerbottom(icount)
       end do
    end if

!    if (chm_layers%brp(jelm).eq.1) then
!    
!      Read from BURP files
!
!      .....
!
!    end if

  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL utl_abort('chm_read_layers: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_layers

!-----------------------------------------------------------------------------------------

  subroutine chm_get_layer_boundaries(cstnid,varno,ivco,nlev,default_top,default_bottom, &
                                      lfound,layertop,layerbottom)
!
! Author  : M. Sitwell, Y. Rochon, Feb 2015
! Revision: 
!
! Purpose: Return layer boundaries for an observation. Combination of STNID, BUFR element
!          and number of vertical levels to determine association to the observations.
!          Default values for top and bottom layers for total column measurements are to
!          be provided.
!
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - ivco            type of vertical coordinate (see burpread_mod.ftn90 or
!                     routine chm_obsoperators for definitions)
!   - nlev            number of levels in the observation
!   - default_top     default value for top layer for total column measurement
!   - default_bottom  default value for bottom layer for total column measurement
!
! Outputs:
!   - lfound          Logical being .true. if layer boundaries found.
!   - layertop        top layer values
!   - layerbottom     bottom layer values
! ---------------------------------------------------------------------------------------

    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in)           :: varno,ivco,nlev
    real(8), intent(in)           :: default_top,default_bottom
    real(8), intent(out)          :: layertop(nlev),layerbottom(nlev)
    logical, intent(inout)        :: lfound
    integer                       :: ISTNID,JN,start_index
    logical                       :: iset

    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0
    lfound=.false.

    DO JN=1,chm_layers%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_layers%stnids(JN) as wildcards
       iset = utl_stnid_equal(chm_layers%stnids(JN),CSTNID)

       ! Check if number of levels, code, and vertical coordinate type are equal.
       ! If number of levels is one and no vertical coordinate provided for total column measurement (i.e. IVCO.eq.4),
       ! then check of vertical coordinate type is disregarded afterwards.
       IF (iset) THEN
          IF ( varno.EQ.chm_layers%bfr(JN) .AND. NLEV.EQ.chm_layers%n_lvl(JN) .AND. &
              (IVCO.EQ.chm_layers%vco(JN).OR.IVCO.EQ.4) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

    IF (ISTNID.EQ.0) THEN
       ! If integrated layer information not found, if a total column measurement
       ! set to defaults, else do nothing

       if (chm_checkfor_integlayer(varno) .and. nlev.eq.1) then          
          lfound=.true.
          layertop(1) = default_top
          layerbottom(1) = default_bottom
       end if

    ELSE
       ! layer information has been found in ascii file
       lfound=.true.
       start_index = chm_layers%ibegin(ISTNID)
       layertop(:) = chm_layers%vlayertop(start_index:start_index+nlev-1)
       layerbottom(:) = chm_layers%vlayerbottom(start_index:start_index+nlev-1)  
    END IF

  end subroutine chm_get_layer_boundaries

!-------------------------------------------------------------------------------------------

  logical function chm_checkfor_integlayer(varno)
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose: Identify if obs is a vertically integrated constituent measurement.
!
! ---------------------------------------------------------------------------------------
  
  implicit none
  integer, intent(in) :: varno
 
  if (varno.eq.15198.or.varno.eq.15001.or.varno.eq.15005.or.varno.eq.15045.or. &
      varno.eq.15020.or.varno.eq.15021.or.varno.eq.15200.or. &
      varno.eq.15009.or.varno.eq.15012) then
      
      chm_checkfor_integlayer=.true.     
  else
      chm_checkfor_integlayer=.false.
  end if
  
  end function chm_checkfor_integlayer

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_layers
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for layer info
!
! ---------------------------------------------------------------------------------------

    implicit none

    if (chm_layers%n_stnid.eq.0) return

    call chm_dealloc_info(chm_layers)
 
  end subroutine chm_dealloc_layers

!-----------------------------------------------------------------------------------------
!-------------------- Routines related to averaging kernel matrices ----------------------
  
  subroutine chm_read_avgkern
!
! Author  : M. Sitwell, ARQI/AQRD, March 2015
!
! Revision: 
!
! Purpose:  Read averaging kernels from ascii file and BURP file if specified in ascii file
!
!-----------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    ! read the averaging kernel information from the ascii file
    call chm_read_avgkern_ascii

    ! set size of BURP file array
    allocate(chm_burp_avgkern(chm_avgkern%n_stnid))

    ! read from BURP file
    do istnid=1,chm_avgkern%n_stnid
       if (chm_avgkern%brp(istnid).eq.1) then
          
          ! retrieve data from stats blocks (with bkstp=14 and block_type='DATA')
          chm_burp_avgkern(istnid) = burp_read_all('CH',chm_avgkern%stnids(istnid), &
               15044, chm_avgkern%n_lvl(istnid), 2, 14, 'DATA', match_nlev=.true.)
          
       end if
    end do

  end subroutine chm_read_avgkern

!----------------------------------------------------------------------------------------

  subroutine chm_read_avgkern_ascii
!
! Author   : Y. Rochon, M. Sitwell, ARQI/AQRD, Feb 2015 
!            - Currently implemented for only one latitude band
!
! Revisions: 
!          
! Purpose: Read and store averaging kernel matricesfor CH sub-families
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  chm_avgkern%n_stnid=0

  INQUIRE(FILE='obsinfo_chm',EXIST=LnewExists)
  IF (.not.LnewExists )then
    WRITE(*,*)   '--------------------------------------------------'
    WRITE(*,*)   'chm_read_avgkern_ascii: COULD NOT FIND FILE obsinfo_chm!'
    WRITE(*,*)   '--------------------------------------------------'
    return
  ENDIF
!
! Check for available layer info.
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    open(unit=nulstat, file='obsinfo_chm', status='OLD')
  ELSE
    CALL utl_abort('chm_read_avgkern_ascii: COULD NOT OPEN FILE obsinfo_chm!')
  ENDIF

  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:14))).ne.'SECTION III:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space
   
  read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%n_stnid
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(chm_avgkern%stnids(chm_avgkern%n_stnid))
  allocate(chm_avgkern%brp(chm_avgkern%n_stnid),chm_avgkern%ibegin(chm_avgkern%n_stnid))
  allocate(chm_avgkern%bfr(chm_avgkern%n_stnid),chm_avgkern%n_lvl(chm_avgkern%n_stnid))
  allocate(chm_avgkern%rak(isize))
 
  chm_avgkern%bfr(:)=0
  chm_avgkern%brp(:)=0
  chm_avgkern%n_lvl(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=1
  STNIDLOOP: do jelm=1,chm_avgkern%n_stnid
    chm_avgkern%ibegin(jelm)=icount

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

!   Read STNID (* is a wildcard)
    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) chm_avgkern%stnids(jelm) 

!   Read (1) Obs BUFR element.
!        (2) Flag indication if avgkern provided from this ascii file or
!            to be read from the BURP file,
!        (3) Number of vertical levels
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%bfr(jelm),  &
       chm_avgkern%brp(jelm),chm_avgkern%n_lvl(jelm)  
    
    if (icount+chm_avgkern%n_lvl(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL utl_abort('chm_read_avgkern_ascii: READING PROBLEM.')    
    end if

    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! disregard data section if values to be specified in BUFR file
    if (chm_avgkern%brp(jelm).eq.1) cycle STNIDLOOP
    
    if (chm_avgkern%n_lvl(jelm).gt.1) then   
       do jlev=1,chm_avgkern%n_lvl(jelm)

          iend=icount+chm_avgkern%n_lvl(jelm)-1

          ! Read averaging kernel matrix   
          read(nulstat,*,iostat=ios,err=10,end=10) chm_avgkern%rak(icount:iend)

          icount=iend+1

       end do
    end if

 end do STNIDLOOP
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL utl_abort('chm_read_avgkern_ascii: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine chm_read_avgkern_ascii

!-----------------------------------------------------------------------------------------

  subroutine chm_dealloc_avgkern
!
! Author  : Y. Rochon, Dec 2014
! Revision: 
!
! Purpose: Deallocate temporary storage space used for averaging kernels
!
!---------------------------------------------------------------------------------------

    implicit none

    integer :: istnid

    if (chm_avgkern%n_stnid.eq.0) return

    if (allocated(chm_burp_avgkern)) then
       do istnid=1,chm_avgkern%n_stnid
          if (chm_avgkern%brp(istnid).eq.1) call oss_obsdata_dealloc(chm_burp_avgkern(istnid))
       end do
       deallocate(chm_burp_avgkern)
    end if

    call chm_dealloc_info(chm_avgkern)
  
  end subroutine chm_dealloc_avgkern

!-----------------------------------------------------------------------------------------

  function chm_find_avgkern(cstnid,varno,nlev) result(ISTNID)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Finds the averaging kernel for an observation if one is specified. Returns 0 if
!          either not found or not specified. Combination of STNID, BUFR element and number
!          of vertical levels to determine association to the observations.
!          
! Inputs:
!   - cstnid          station id
!   - varno           BUFR descriptor element
!   - nlev            number of levels in the observation
!
! Returns:
!   - ISTNID          Index of averaging kernel in chm_avgkern if found. Zero indicates
!                     averaging kernel not found.
! ---------------------------------------------------------------------------------------
    
    implicit none

    character(len=12), intent(in) :: cstnid
    integer, intent(in) :: varno,nlev
    integer :: ISTNID,JN
    logical :: iset

    ! Find stnid with same number of vertical levels, and same BUFR element
          
    ISTNID=0

    DO JN=1,chm_avgkern%n_stnid

       ! First compare STNID values allowing for * and blanks in 
       ! chm_avgkern%stnids(JN) as wildcards
       iset = utl_stnid_equal(chm_avgkern%stnids(JN),CSTNID)

       ! Check if number of levels and BUFR code are equal.
       IF (iset) THEN
          IF ( varno.EQ.chm_avgkern%bfr(JN) .AND. NLEV.EQ.chm_avgkern%n_lvl(JN) ) THEN
             ISTNID=JN
             exit
          END IF
       END IF
       
    END DO

  end function chm_find_avgkern

!-----------------------------------------------------------------------------------------

  subroutine chm_get_avgkern(istnid,stnid,nlev,zlat,zlon,idate,itime,avg_kern)
!
! Author  : M. Sitwell, March 2015
! Revision: 
!
! Purpose: Return averaging kernel for an observation.
!
! Inputs:
!   istnid          index of averaging kernel in chm_avgkern
!   nlev            number of observation levels
!   idate           YYYYMMDD
!   itime           HHMM
!
! Outputs:
!   avg_kern        the averaging kernel
!---------------------------------------------------------------------------------------

    implicit none

    integer, intent(in)  :: istnid,nlev,idate,itime
    real(8), intent(in)  :: zlat,zlon
    character(len=*), intent(in) :: stnid
    real(8), intent(out) :: avg_kern(nlev,nlev)
    integer :: start_index,end_index

    if (istnid.gt.0 .and. istnid.le.chm_avgkern%n_stnid) then
       
       if (chm_avgkern%brp(istnid).eq.0) then
          ! get averaging kernel from ascii file
          start_index = chm_avgkern%ibegin(ISTNID)
          end_index = nlev*(start_index+nlev-1)
          avg_kern = RESHAPE(chm_avgkern%rak(start_index:end_index),(/nlev,nlev/),ORDER =(/2,1/))
       else
          ! get averaging kernel from BURP file
          avg_kern = oss_obsdata_get_array2d(chm_burp_avgkern(istnid), oss_obsdata_get_header_code(zlon,zlat,idate,itime,stnid))
       end if

    else
       call utl_abort("chm_get_avgkern: Invalid station ID index.")
    end if

  end subroutine chm_get_avgkern

!-----------------------------------------------------------------------------------------
!-------------------------- Routines related to gridded reference fields  ----------------
  
  subroutine chm_read_ref_fields(datestamp)
!
! ****** NOT TESTED *********
!
! Author  : Y. Rochon, ARQI/AQRD, Feb 2015
!
! Revision: 
!
! Purpose:  Read reference fields as directed by the content of the ascii file obsinfo_chm.
!           Fields are provided in RPN/fst files specified in the obsinfo_chm file (with path and filename)
!
!           Reference fields can be in a separate RPN file with name provided by obsinfo_chm or in
!           monthly static background stats file (glbchemcov or bgcov; see 'isrc' below).
!
! Comments:
!
!     - Fields assumed to be of the same units as those of the corresponding input trial fields
!
!-----------------------------------------------------------------------------------------
    
    implicit none

    integer, intent(in), optional :: datestamp
    
    character(len=128) :: fname
    character(len=4) :: varName
    character(len=12) :: etiket
    integer :: i,id,nd,j,ndim,ijour,imonth,iday,itime,isrc
    real(8) :: day
    integer, external :: newdate
   
    integer, external :: FNOM, FCLOS
    integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount, iend
    logical :: LExists
    
    logical, parameter :: linterp=.true.
    
    integer :: ni, nj, nkeys, kind
    real(8), allocatable :: array1(:,:,:),array2(:,:,:),lvls(:),xlat(:),xlong(:) ! Allocated in chm_fst_read
  
    character (len=128) :: ligne

!   Initialize dimensions to zero

    chm_ref_fields(:,:)%nlon=0
    chm_ref_fields(:,:)%nlat=0
    chm_ref_fields(:,:)%nlev=1
    
    inquire(FILE='obsinfo_chm',EXIST=LExists)
    IF (.not.LExists )then
      WRITE(*,*)   '-----------------------------------------------------'
      WRITE(*,*)   'chm_read_ref_fields: COULD NOT FIND FILE obsinfo_chm!'
      WRITE(*,*)   '-----------------------------------------------------'
      return
    ENDIF

!   Check for file names containing ref fields

    NULSTAT=0
    IERR=FNOM(NULSTAT,'obsinfo_chm','SEQ',0)
    IF ( IERR .EQ. 0 ) THEN
       open(unit=nulstat, file='obsinfo_chm', status='OLD')
    ELSE
       CALL utl_abort('chm_read_ref_fields: COULD NOT OPEN FILE obsinfo_chm!')
    ENDIF

    ios=0
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    do while (trim(adjustl(ligne(1:14))).ne.'SECTION IV:') 
       read(nulstat,'(A)',iostat=ios,err=10,end=11) ligne
    end do    
    
!   Read number of constituents with associated input file(s)
   
    read(nulstat,*,iostat=ios,err=10,end=10) ndim
    if (ndim.le.0) go to 10
    
!   Initialization

    if (linterp.and.present(datestamp)) then
       ierr = newdate(datestamp,ijour,itime,-3)
       if (ierr<0) then
          Write(*,*) "Invalid datestamp ",datestamp,ijour,itime,ierr
          call utl_abort('chm_read_ref_fields')
       endif
       imonth = MOD(ijour/100,100)
       iday = MOD(ijour,100)
       day=iday+itime*1.0D-8
       if (day.gt.15.) then
          day=day-15.0
       else
          day=day+15.0
       end if
    endif
    
!   Get needed fields for each file(s)

    do i=1,ndim 

!      Read id,nd,isrc. id: constituent code; nd: number of sets; 1 or 2;
!      isrc: 1 for fname being in obsinfo_chm, 0 for glbchemcov (or bgcov if glbchemcov not present) 
       
       read(nulstat,*,iostat=ios,err=10,end=10)
       read(nulstat,*,iostat=ios,err=10,end=10) id,nd,isrc    
       varName=vnl_varnameFromVarnum(0,id)

       if (isrc.eq.1) then
          read(nulstat,*,iostat=ios,err=10,end=10) fname
       else
         inquire(file='./glbchemcov',exist=LExists)
         if (LExists) then
            fname='./glbchemcov'
         else
            inquire(file='./bgcov',exist=LExists)
            if(LExists) then
              fname='./bgcov'
            else               
               call utl_abort('chm_read_ref_fields: did not find file.')
            end if
          end if
       end if
       
       do j=1,nd
          read(nulstat,*,iostat=ios,err=10,end=10) etiket             
                           
          call utl_readFstField(trim(fname),varName,-1,imonth,-1,etiket,ni,nj,nkeys,array1,xlat=xlat,xlong=xlong,lvls=lvls,kind=kind)

          if (j.eq.1) then
              chm_ref_fields(id,1)%nlon=ni
              chm_ref_fields(id,1)%nlat=nj
              chm_ref_fields(id,1)%nlev=nkeys
              chm_ref_fields(id,1)%ivkind=kind   
                         
              allocate(chm_ref_fields(id,1)%field3d(ni,nj,nkeys))
              allocate(chm_ref_fields(id,1)%vlev(nkeys),chm_ref_fields(id,1)%lon(ni),chm_ref_fields(id,1)%lat(nj))
              
              chm_ref_fields(id,1)%lat(1:nj)=xlat(1:nj)*MPC_RADIANS_PER_DEGREE_R8
              chm_ref_fields(id,1)%lon(1:ni)=xlong(1:ni)*MPC_RADIANS_PER_DEGREE_R8
              where (chm_ref_fields(id,1)%lon(1:ni).lt.0.0) chm_ref_fields(id,1)%lon(1:ni)=2.0*MPC_PI_R8 + &
                                                            chm_ref_fields(id,1)%lon(1:ni)
              chm_ref_fields(id,1)%vlev(1:nkeys)=lvls(1:nkeys)              
          else
              chm_ref_fields(id,2)%nlon=ni
              chm_ref_fields(id,2)%nlat=nj
              chm_ref_fields(id,2)%nlev=nkeys
              chm_ref_fields(id,2)%ivkind=kind

              allocate(chm_ref_fields(id,2)%field3d(ni,nj,nkeys))
              allocate(chm_ref_fields(id,2)%vlev(nkeys),chm_ref_fields(id,2)%lon(ni),chm_ref_fields(id,2)%lat(nj))
              
              chm_ref_fields(id,2)%lat(1:nj)=xlat(1:nj)*MPC_RADIANS_PER_DEGREE_R8
              chm_ref_fields(id,2)%lon(1:ni)=xlong(1:ni)*MPC_RADIANS_PER_DEGREE_R8
              where (chm_ref_fields(id,2)%lon(1:ni).lt.0.0) chm_ref_fields(id,2)%lon(1:ni)=2.0*MPC_PI_R8 + &
                                                            chm_ref_fields(id,2)%lon(1:ni)
              chm_ref_fields(id,2)%vlev(1:nkeys)=lvls(1:nkeys)
          end if

          if (.not.linterp .or. (.not.present(datestamp))) then

             if (j.eq.1) then 
                 chm_ref_fields(id,1)%field3d(:,:,:) = array1(:,:,:)
             else
                 chm_ref_fields(id,2)%field3d(:,:,:) = array1(:,:,:)
             end if

          else

!            Following for interpolation as a function of days from mid-months.
             
             if (iday.gt.15) then
                 if (imonth.eq.12) then
                    call utl_readFstField(trim(fname),varName,-1,1,-1,etiket,ni,nj,nkeys,array2,lvls=lvls,kind=kind)
                else
                   call utl_readFstField(trim(fname),varName,-1,imonth+1,-1,etiket,ni,nj,nkeys,array2,lvls=lvls,kind=kind)
                end if
          
!               Linearly interpolate in time (approximately - assumes 30 day months)

                if (j.eq.1) then              
                   chm_ref_fields(id,1)%field3d(:,:,:) = (array1(:,:,:)*(30.0-day)+array2(:,:,:)*day)/30.0
                else
                   chm_ref_fields(id,2)%field3d(:,:,:) = (array1(:,:,:)*(30.0-day)+array2(:,:,:)*day)/30.0
                end if
             
             else if (iday.le.15) then
                if (imonth.eq.1) then
                   call utl_readFstField(trim(fname),varName,-1,12,-1,etiket,ni,nj,nkeys,array2,lvls=lvls,kind=kind)
                else
                   call utl_readFstField(trim(fname),varName,-1,imonth-1,-1,etiket,ni,nj,nkeys,array2,lvls=lvls,kind=kind)
                end if

!               Linearly interpolate in time (approximately - assumes 30 day months)

                if (j.eq.1) then
                   chm_ref_fields(id,1)%field3d(:,:,:) = (array2(:,:,:)*(30.0-day)+array1(:,:,:)*day)/30.0
                else
                   chm_ref_fields(id,2)%field3d(:,:,:) = (array2(:,:,:)*(30.0-day)+array1(:,:,:)*day)/30.0
                end if
             
             end if
          
          end if
 
          if (allocated(array1)) deallocate(array1)
          if (allocated(array2)) deallocate(array2)   
                 
       end do
    end do 
     
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL utl_abort('chm_read_ref_fields: READING PROBLEM')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    
    
  end subroutine chm_read_ref_fields
   
!----------------------------------------------------------------------------------------

  subroutine chm_set_reference_obsdata(obsoper)
!
! ***** NOT TESTED *****
!
! Author   : Y. Rochon, ARQI/AQRD May 2016
!
! Purpose: Determine and store reference profile at obs location if needed by
!          the observation operators.
!
! Arguments:
!
!   Input
!
!      obsoper%constituent_id  Constituent id
!      obsoper%nmodlev         Number of model levels for variables other than uu and vv
!      obsoper%pressmod        Model pressure array
!      obsoper%tt              Model temperature (Kelvin)
!      obsoper%gz              Model geopotential height (m)
!      obsoper%hu              Specific humidity 
!      obsoper%lat             Latitude (rad)
!      obsoper%lon             Longitude (rad)
!
!   Output
!
!      chem_ref_obsdata        Reference profile structure
!
!   Comments
! 
!----------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_obsoperators), intent(inout) :: obsoper
       
    integer :: i,istart,id
    real(8) :: tropo_press, refprof(obsoper%nmodlev),refprof2(obsoper%nmodlev),dt
    real(8), allocatable :: pressrefin(:)
    logical, allocatable :: lsuccess(:)
    
    if (obsoper%constituent_id.lt.0.or.obsoper%constituent_id.gt.chm_var_maxnumber()) return

    id=obsoper%constituent_id
    
    if (chm_config%generalized_operator(id).le.1) return           
    if (chm_ref_fields(id,1)%nlat.eq.0) return
    
    ! Set vertical levels of reference.
    ! Convert to pressure coordinate if needed.
    
    if (allocated(pressrefin)) deallocate(pressrefin)
    allocate(pressrefin(chm_ref_fields(id,1)%nlev))
    pressrefin(:)=chm_ref_fields(id,1)%vlev(1:chm_ref_fields(id,1)%nlev)

    if (allocated(lsuccess)) deallocate(lsuccess)
    allocate(lsuccess(chm_ref_fields(id,1)%nlev))
    lsuccess(:)=.true.
    
    if (chm_ref_fields(id,1)%ivkind.eq.2) then
        pressrefin(:)=pressrefin(:)*100. ! Conversion from hPa to Pa.
    else if (chm_ref_fields(id,1)%ivkind.eq.0) then
        where (pressrefin.lt.obsoper%gz(obsoper%nmodlev)) pressrefin=obsoper%gz(obsoper%nmodlev)
        pressrefin(:) = phf_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                        chm_ref_fields(id,1)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
    else if (chm_ref_fields(id,1)%ivkind.eq.4) then
        pressrefin(:)=pressrefin(:) + obsoper%gz(obsoper%nmodlev)
        pressrefin(:) = phf_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                        chm_ref_fields(id,1)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
    else if (chm_ref_fields(id,1)%ivkind.eq.1) then
        pressrefin(:)=pressrefin(:)*obsoper%pp(obsoper%nmodlev) ! Convert from sigma to Pa   
    else
       write(*,*) 'Vertical coordinate kind is ',chm_ref_fields(id,1)%ivkind
       call utl_abort('chm_get_reference_obsdata: Cannot handle vertical coordinate of this kind.')
    end if
    
    ! Interpolate to obs lat/long location and model level

    call s2c_column_hbilin(chm_ref_fields(id,1)%field3d,pressrefin, &
                    chm_ref_fields(id,1)%nlon,chm_ref_fields(id,1)%nlat,chm_ref_fields(id,1)%nlev, &
                    chm_ref_fields(id,1)%lon,chm_ref_fields(id,1)%lat,obsoper%lon,obsoper%lat, &
                    refprof,obsoper%pp,obsoper%nmodlev)
    
    if (chm_ref_fields(id,2)%nlat.gt.0.and.chm_ref_fields(id,2)%nlon.gt.0.and.chm_ref_fields(id,2)%nlev.gt.0) then
        
        if (any(obsoper%tt.le.0.0)) call utl_abort('chm_get_reference_obsdata: Missing TT for determining tropopause pressure')
        
        ! Get second reference field (for troposphere)
        
        tropo_press=-1.0
        
        if (all(obsoper%hu.ge.0.0D0)) then
           tropo_press=phf_get_tropopause(obsoper%nmodlev,obsoper%pp,obsoper%tt,obsoper%gz,hu=obsoper%hu)
        else
           tropo_press=phf_get_tropopause(obsoper%nmodlev,obsoper%pp,obsoper%tt,obsoper%gz)
         end if

        if (tropo_press.gt.0) then
            
           ! Set vertical levels of reference.
           ! Convert to pressure coordinate if needed
 
           if (allocated(pressrefin)) deallocate(pressrefin)
           allocate(pressrefin(chm_ref_fields(id,2)%nlev))    
           pressrefin(:)=chm_ref_fields(id,2)%vlev(1:chm_ref_fields(id,2)%nlev)

           if (allocated(lsuccess)) deallocate(lsuccess)
           allocate(lsuccess(chm_ref_fields(id,2)%nlev))
           lsuccess(:)=.true.

           if (chm_ref_fields(id,2)%ivkind.eq.2) then
               pressrefin(:)=pressrefin(:)*100. ! Conversion from hPa to Pa.
           else if (chm_ref_fields(id,2)%ivkind.eq.0) then
               where (pressrefin.lt.obsoper%gz(obsoper%nmodlev)) pressrefin=obsoper%gz(obsoper%nmodlev)
               pressrefin(:) = phf_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                               chm_ref_fields(id,2)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
           else if (chm_ref_fields(id,2)%ivkind.eq.4) then
               pressrefin(:)=pressrefin(:) + obsoper%gz(obsoper%nmodlev)
               pressrefin(:) = phf_convert_z_to_pressure(pressrefin,obsoper%gz,obsoper%pp, &
                               chm_ref_fields(id,2)%nlev,obsoper%nmodlev,obsoper%lat,lsuccess)
           else if (chm_ref_fields(id,2)%ivkind.eq.1) then
               pressrefin(:)=pressrefin(:)*obsoper%pp(obsoper%nmodlev) ! Convert from sigma to Pa        
           else 
               write(*,*) 'Vertical coordinate kind is ',chm_ref_fields(id,2)%ivkind
               call utl_abort('chm_get_reference_obsdata: Cannot handle vertical coordinate of this kind.')
           end if
      
           ! Interpolate to obs lat/long and model levels

           call s2c_column_hbilin(chm_ref_fields(id,2)%field3d,pressrefin, &
                    chm_ref_fields(id,2)%nlon,chm_ref_fields(id,2)%nlat, &
                    chm_ref_fields(id,2)%nlev,chm_ref_fields(id,2)%lon, &
                    chm_ref_fields(id,2)%lat,obsoper%lon,obsoper%lat,refprof2,obsoper%pp,obsoper%nmodlev)
    
        end if

        ! Combine with upper level profile
       
        do i=obsoper%nmodlev,3,-1
           if (obsoper%pp(i).lt.tropo_press) exit
           refprof(i)=refprof2(i)            
        end do
        istart=i
             
        ! Apply linear combination of four levels just above the tropopause
        
        do i=istart,max(2,istart-3),-1
            dt=(istart+1.0-i)/5.0
            refprof(i)=dt*refprof2(i) + (1.0-dt)*refprof(i)
        end do
                    
    end if 

    if (allocated(pressrefin)) deallocate(pressrefin)
    if (allocated(lsuccess)) deallocate(lsuccess) 

    ! ------- Save in chm_ref_trial ---------
       
    if (.not.associated(chm_ref_trial%data1d)) then
       call oss_obsdata_alloc(chm_ref_trial, chm_config%obsdata_maxsize, dim1=obsoper%nmodlev)
       chm_ref_trial%nrep = 0
    end if

    ! Here, nrep will count the number of filled elements in the data arrays
    chm_ref_trial%nrep = chm_ref_trial%nrep+1 

    if (chm_ref_trial%nrep.gt.chm_config%obsdata_maxsize) &
         call utl_abort('chm_get_ref_obsdata: Reach max size of array ' // trim(utl_str(chm_config%obsdata_maxsize)) )
  
    ! The obsoper%obs_index (header index) serves as the unique locator code 
    write(chm_ref_trial%code(chm_ref_trial%nrep),'(I22)') obsoper%obs_index

    ! Save profile in chm_ref_trial
    
    chm_ref_trial%data1d(:,chm_ref_trial%nrep) = refprof(:)

  end subroutine chm_set_reference_obsdata
 
!----------------------------------------------------------------------------------------

  function chm_get_ref_column(code) result(array)
!
! Author: Y. Rochon, ARQI/AQRD Feb 2017
!
! Purpose: Extract and provide column from chm_ref_field associated to code.
!
! Arguments:
!
!   Input
!
!      code         unique identifying code
!
!   Output
!
!      array        retrieved array from obsdata%data1d of dimension obsdata%dim1
!      stat         search success (0 - found; 1 = no data; 2 = not found)
! 
!----------------------------------------------------------------------------------------    
    implicit none
        
    character(len=*), intent(in) :: code
    real(8) :: array(chm_ref_trial%dim1)

    integer :: stat

    array = oss_obsdata_get_array1d(chm_ref_trial,code,stat)
    if (stat.gt.0) call utl_abort("chm_get_ref_column: Code not found - " // &
                                  trim(code))
    
  end function chm_get_ref_column

!---------------------------------------------------------------------------------------
!---------------------------------------------------------------------------------------
  
  subroutine chm_dealloc_info(info)
!
! Author  : M. Sitwell  May 2015
!
! Purpose: Deallocates struct_chm_info instance
!
!---------------------------------------------------------------------------------------
    
    implicit none

    type(struct_chm_info), intent(inout) :: info

    if (allocated(info%stnids))       deallocate(info%stnids)
    if (allocated(info%bfr))          deallocate(info%bfr)
    if (allocated(info%brp))          deallocate(info%brp)
    if (allocated(info%vco))          deallocate(info%vco)
    if (allocated(info%n_lat))        deallocate(info%n_lat)
    if (allocated(info%ibegin))       deallocate(info%ibegin)
    if (allocated(info%n_lvl))        deallocate(info%n_lvl)
    if (allocated(info%rak))          deallocate(info%rak)
    if (allocated(info%vlayertop))    deallocate(info%vlayertop)
    if (allocated(info%vlayerbottom)) deallocate(info%vlayerbottom)
    if (allocated(info%lat))          deallocate(info%lat)

  end subroutine chm_dealloc_info

!-------------------------------------------------------------------------------------------
 logical function chm_diagn_only(cstnid,varno,nobslev,flag)

! 
!   Purpose: Identify whether or not the obs set identified by 
!            the combination of (cstnidin, bufrin,nlevs) will
!            be assimilated or used for independent verifications.
!
!   Author: Y.J. Rochon, ARQI/AQRD, July 2015
!    
!   Revisions:
!
!   Input:
!
!       cstnid           Input station id
!       varno            Obs BUFR number
!       nobslev          Number of levels
!       flag             observation integer flag
!
!   Output:
!
!       chm_diagn_only    Indicating if assimilation to be skipped but data
!                         is to be used for independent verifications after 
!                         assimilation/minimization.
!
!-------------------------------------------------------------------------------------------
 
    implicit none

    integer, intent(in) :: varno,nobslev,flag
    character(len=*), intent(in) :: cstnid
  
    integer :: i,elemId
    
    if (chm_config%assim_num.lt.0) then
       ! assimilate all observations
       chm_diagn_only = .false.
    else if (chm_config%assim_num.eq.0) then
       ! assimilate no observations
       chm_diagn_only = .true.
    else
       ! check if this observation is listed in the chm_config%assim_* arrays
       elemId=0
       do i=1,chm_config%assim_num
          if (utl_stnid_equal(trim(chm_config%assim_stnid(i)),trim(cstnid))) then
             if (chm_config%assim_varno(i).eq.0.or.chm_config%assim_varno(i).eq.varno) then
                if (chm_config%assim_nlev(i).eq.0.or.(nobslev.eq.1.and.chm_config%assim_nlev(i).eq.1).or. &
                     (nobslev.gt.1.and.chm_config%assim_nlev(i).gt.1)) then
                   elemId=i
                   exit
                end if
             end if
          end if
       end do
       chm_diagn_only = elemId.eq.0
    end if
    
    if (chm_diagn_only) return

    ! check if the observation integer flag has a bit marked by chm_config%diagn_flag (same flagging as in filt_suprep)
    if (chm_config%diagn_nflag.gt.0) then
       do i=1,chm_config%diagn_nflag
          if (btest(flag, 13 - chm_config%diagn_flag(i) )) then
             chm_diagn_only = .true.
             return
          end if
       end do
    end if

  end function chm_diagn_only

!-------------------------------------------------------------------------------------------

  subroutine chm_apply_2dfieldr4_transform(iconstituent_id,varName,jlev,jstep,field,l_reverse)
!
! Author: Y. Rochon, Feb 2016
!
! Revisions:
!
! Purpose: Apply transform (or its inverse) of 2D field.
!          Called by routine readTrialField in file innovation_mod.ftn90. 
!
! Arguments:
!
!   In
!
!     iconstituent_id BUFR code element of Table 08046 identifying the constituent.
!     varName         Field name (nomvar)
!     l_reverse       Reverse/inverse transformation if present (default value .false.).
!     jlev            vertical level index
!     jstep           Time step index
!
!   InOut
!
!     field           2D field
!
! Comments:
!
! 1. The EnVar assumes that the input background error covariances are provided
!    for the transformed field if a variable transformation is requested!
!
!-----------------------------------------------------------------------------------

    implicit none
    
    integer, intent(in) :: iconstituent_id,jlev,jstep
    character(len=*), intent(in) :: varName
    logical, intent(in), optional :: l_reverse

    real(4), intent(inout) :: field(:,:)            

    integer :: i,j,ier,unit
    real(4) :: valmin
    integer, external :: fclos
    logical :: lrev
    
    if (iconstituent_id.lt.0.or.iconstituent_id.gt.chm_constituents_size) return
    
    if (chm_config%transform(iconstituent_id).lt.0) return
    
    if (present(l_reverse)) then
       lrev = l_reverse
    else
       lrev = .false.
    end if

    ! Check for non-positive values if forward transformation 

    if (.not.lrev) then

       call utl_open_asciifile(chm_config%message_filename,unit)

       do j=1,size(field,2)
          valmin=minval(field(:,j),mask=field(:,j).gt.0.0)
          if (valmin.gt.1.E30) valmin=1.E-20
          do i=1,size(field,1) 
             if (field(i,j).lt.valmin) then
                write(unit,'(A,G9.2,A,A)') "Unexpected/undesired negative value of ",field(i,j), " for input field ",trim(varName)
                write(unit,'(A,3I4,A,I3,A,G9.2)')  "at location (",i,j,jlev,") and step ",jstep,". Value replaced by ",valmin,"."                    
                field(i,j)=valmin
             end if
          end do
       end do
      
       ier=fclos(unit)
       
    end if

    ! Apply transformation
    
    select case(chm_config%transform(iconstituent_id))
    case(0)
       ! No tranformation
    case(1)

       ! Transform lnx to/from x or dlnx to/from dx
           
       if (.not.lrev) then
       
          ! Forward transformation
          
          field=log(field)
     
       else
    
          ! Reverse transformation          
       
          field=exp(field)
             
       end if
   
    case default
       call utl_abort('chm_apply_2dfieldr4_transform: Transformation #' // trim(utl_str(iconstituent_id)) // &
            ' for constituent ' // trim(utl_str(iconstituent_id)) // " and variable name " // trim(varname) // &
            ' is not defined.')
    end select
      
  end subroutine chm_apply_2dfieldr4_transform

!----------------------------------------------------------------------------------------
    
  integer function chm_var_maxnumber()  
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Pass on chm_constituents_size
!
!----------------------------------------------------------------------------------------

    implicit none
    
    chm_var_maxnumber=chm_constituents_size
    
   end function chm_var_maxnumber

!----------------------------------------------------------------------------------------
    
  function chm_config_select_str(stype) result(val) 
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Pass on associated chm_config%'stype'_filename
!
! In
!
!   stype     reference string for filename identifier
!
!----------------------------------------------------------------------------------------

    implicit none
    character(len=*), intent(in) :: stype
    character(len=chm_filename_size) :: val
    
    select case(trim(stype))    
    case('message')
       val=chm_config%message_filename
    case('obsspace_diagn')
       val=chm_config%obsspace_diagn_filename
    case default
       call utl_abort('chm_config_select_str: Selection not found ' // trim(stype))
    end select
    
  end function chm_config_select_str
  
!----------------------------------------------------------------------------------------
    
  function chm_config_select_int(stype,index)  result(val)
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Pass on associated chm_config%*'stype'*
!
! In
!
!   stype     reference string for integer-based identifier/value
!   index     array index (optional)
!
!----------------------------------------------------------------------------------------

    implicit none
    character(len=*), intent(in) :: stype
    integer, intent(in), optional :: index
    integer :: val
    
    select case(trim(stype))    
    case('message_unit')
       val=chm_config%message_fileunit
    case('obsdata_maxsize')
       val=chm_config%obsdata_maxsize
    case('genoper')
       if (present(index)) then
          val=chm_config%generalized_operator(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('tropo_mode')
       if (present(index)) then
          val=chm_config%tropo_mode(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('tropo_bound')
       if (present(index)) then
          val=chm_config%tropo_bound(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('transform')
       if (present(index)) then
          val=chm_config%transform(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case default
       call utl_abort('chm_config_select_int: Selection not found ' // trim(stype))
    end select
    
  end function chm_config_select_int

!----------------------------------------------------------------------------------------
    
  function chm_config_set_int(stype,val)  result(ier)
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Assign value to chm_config%*'stype'*
!
! In
!
!   stype     reference string for integer-based identifier/value
!   val       integer value to assign
!
!----------------------------------------------------------------------------------------

    implicit none
    character(len=*), intent(in) :: stype
    integer, intent(in) :: val
    integer :: ier
    
    ier=0
    select case(trim(stype))    
    case('message_unit')
       chm_config%message_fileunit=val
    case default
       ier=-1
       call utl_abort('chm_config_select_int: Selection not found ' // trim(stype))
    end select
    
  end function chm_config_set_int

!----------------------------------------------------------------------------------------
    
  function chm_config_select_float(stype,index)  result(val)
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Pass on associated chm_config%*'stype'*
!
! In
!
!   stype     reference string for float-based identifier/value
!   index     array index (optional)
!
!----------------------------------------------------------------------------------------

    implicit none
    character(len=*), intent(in) :: stype
    integer, intent(in), optional :: index
    real(8) :: val
    
    select case(trim(stype))    
    case('pressmin')
       val=chm_config%diagn_pressmin
    case('amu')
       if (present(index)) then
          val=chm_config%amu(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('tropo_column_top')
       if (present(index)) then
          val=chm_config%tropo_column_top(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('low_cutoff')
       if (present(index)) then
          val=chm_config%low_cutoff(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case('high_cutoff')
       if (present(index)) then
          val=chm_config%high_cutoff(index)
       else
          call utl_abort('chm_config_select_int: Missing index for ' // trim(stype))
       end if
    case default
       call utl_abort('chm_config_select_float: Selection not found ' // trim(stype))
    end select
    
  end function chm_config_select_float

!----------------------------------------------------------------------------------------
    
  function chm_config_select_logical(stype)  result(val)
!
! Author: Y. Rochon, ARQI/AQRD, Feb 2017
!
! Revisions:
!
! Purpose: Pass on associated chm_config%*'stype'*
!
! In
!
!   stype     reference string for logical-based identifier/value
!
!----------------------------------------------------------------------------------------

    implicit none
    character(len=*), intent(in) :: stype
    logical :: val
    
    select case(trim(stype))    
    case('diagn_save')
       val=chm_config%diagn_save
    case default
       call utl_abort('chm_config_select_logical: Selection not found ' // trim(stype))
    end select
    
  end function chm_config_select_logical

!-----------------------------------------------------------------------------------
!------------------ Routines associated to chm_efftemp -----------------------------

  subroutine chm_add_efftemp_obsdata(code,temp_eff)
!
! Author: Y. Rochon, ARQI/AQRD Feb 2017
!
! Purpose: Add effective temperature value to its obsdata object
!
! Arguments:
!
!   Input
!
!      code         unique identifying code
!      temp_eff     effective temperature
! 
!----------------------------------------------------------------------------------------    
    implicit none
        
    character(len=*), intent(in) :: code
    real(8), intent(in) :: temp_eff(:)

    call oss_obsdata_add_data1d(chm_efftemp,temp_eff,code,chm_config%obsdata_maxsize)
    
  end subroutine chm_add_efftemp_obsdata
   
!----------------------------------------------------------------------------------------
  subroutine chm_add_efftemp_obsfile()
!
! Author   : Y. Rochon, Feb 2017 
! 
! Revisions:
!          
! Purpose: Add effective temperatures in obs file.
!
!----------------------------------------------------------------------------------------

    implicit none
    
    integer :: ierr,nrep_modified,varno(1)

!   If needed, add effective temperature values in obs file for total column measurements

    call oss_obsdata_MPIallgather(chm_efftemp)
    
    if (chm_efftemp%nrep.gt.0) then
        varno(1)=12001
        nrep_modified = burp_update_all('CH',varno(1:max(1,chm_efftemp%dim2)),0,'INFO',chm_efftemp,multi='UNI') 
        write(*,*) 'chm_add_efftemp_obsfile: Added ',nrep_modified,' effective temperature values in the obs file.'
    end if 

  end subroutine chm_add_efftemp_obsfile

!-----------------------------------------------------------------------------------

end module chem_setup_mod
