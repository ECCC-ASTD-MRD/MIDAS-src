!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

module verticalCoord_mod
  use mpi_mod
  use MathPhysConstants_mod
  use Vgrid_Descriptors
  implicit none
  private

  ! public derived type
  public :: struct_vco
  ! public procedures
  public :: vco_SetupFromFile, vco_getNumLev
  ! public entities accessed through inheritance
  public :: vgd_get,vgd_levels,vgd_ok,vgd_dpidpis,vgd_write

  type struct_vco
     logical :: initialized=.false.
     integer :: nlev_T= 0
     integer :: nlev_M= 0
     real*8  :: dptop               ! Pressure at top level
     real*8  :: dprf                ! Reference pressure
     real*8  :: drcf1, drcf2        ! Expansion coefficients
     real*8  :: ip1_sfc, da_sfc, db_sfc  ! ip1, A, B values for the surface (Vcode=5005)
     integer,pointer,dimension(:) :: ip1_T,ip1_M   ! encoded IP1 levels (Thermo/Moment)
     real*8 ,pointer,dimension(:) :: da_T,db_T     ! A, B values for Thermo levels
     real*8 ,pointer,dimension(:) :: da_M,db_M     ! A, B values for Momentum levels
     real*8 ,pointer,dimension(:) :: db_dhyb_M,db_dhyb_T  ! factor needed for TLM/AD of tt2phi
     real*8 ,pointer,dimension(:) :: da_dhyb_M,da_dhyb_T  ! factor needed for TLM/AD of tt2phi
     real*8 ,pointer,dimension(:) :: dhyb_T,dhyb_M !decoded IP1 levels (Thermo/Momentum)
     type(vgrid_descriptor) :: vgrid
  end type struct_vco

  contains

  subroutine vco_allocate(vco)
    implicit none
    type(struct_vco), pointer :: vco
    integer :: ilnk,stat,nl_stat

    stat        = 0

    ilnk = vco_getNumLev(vco,'MM')
    allocate (vco%ip1_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%da_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%db_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%da_dhyb_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%db_dhyb_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%dhyb_M(ilnk),stat=nl_stat)
    stat = stat + nl_stat

    ilnk = vco_getNumLev(vco,'TH')
    allocate (vco%ip1_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%da_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%db_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%da_dhyb_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%db_dhyb_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat
    allocate (vco%dhyb_T(ilnk),stat=nl_stat)
    stat = stat + nl_stat

    if(stat .ne. 0 ) then
       call abort3d(' vco: problem with allocate in vco ')
    endif

  end subroutine vco_allocate


  subroutine vco_SetupFromFile(vco,templatefile,lprecision,etiket)
    !  s/r vco_SetupFromFile - Initialize structure for a standard file using vgrid_descriptors library.
    implicit none
    type(struct_vco),pointer :: vco
    character(len=*) :: templatefile
    logical :: lprecision
    character(len=*) :: etiket

    integer :: Vcode,kind,jlev,jlev2,stat,sigdigits,nultemplate,ierr,ikey
    integer :: fnom,fstouv,fstfrm,fclos,fstinf,fstprm
    integer :: vgd_nlev_M, vgd_nlev_T
    integer,   pointer :: vgd_ip1_M(:),vgd_ip1_T(:)
    real*8,    pointer :: vgd_da_M(:),vgd_da_T(:),vgd_db_M(:),vgd_db_T(:)
    integer :: ip1_sfc
    real    :: hyb_r4
    real*8  :: dl_ptop,dl_pref,dl_rcf1,dl_rcf2,zterm
    real*8  :: precision
    character(len=10) :: blk_S
    logical :: isExist_L, ip1_found
    integer :: ni,nj,nk
    character(len=4) :: nomvar_T, nomvar_M

    if(mpi_myid.eq.0) write(*,*) 'vco_SetupFromFile: TEMPLATEFILE=', templatefile
    inquire(file=templatefile,exist=isExist_L)
    if( isExist_L )then
      nultemplate=0
      ierr=fnom(nultemplate,templatefile,'RND+OLD+R/O',0)
      if( ierr .eq. 0 ) then
        if(mpi_myid.eq.0) write(*,*) ' opened as unit file ',nultemplate
        ierr =  fstouv(nultemplate,'RND+OLD')
      else
        call abort3d('vco_SetupFromFile: CANNOT OPEN TEMPLATE FILE!')
      endif
    else
      call abort3d('vco_SetupFromFile: CANNOT FIND TEMPLATE FILE!')
    endif

    if(.not.associated(vco)) allocate(vco)

    !==========================================================================
    ! Get vertical coordinate descriptors from standard file (vgd_new reads "!!" record)
  
    stat = vgd_new(vco%vgrid,unit=nultemplate,format="fst",ip1=-1,ip2=-1)
    if(stat.ne.VGD_OK)then
      call abort3d('ERROR with vgd_new')
    endif

    ! Print out vertical structure 
    if(mpi_myid.eq.0) then
      stat = vgd_print(vco%vgrid)
      if(stat.ne.VGD_OK)then
        call abort3d('ERROR with vgd_print')
      endif
    endif

    !==========================================================================
    ! Get version of the vertical coordinate

    stat = 0
    stat = vgd_get(vco%vgrid,key='ig_1 - vertical coord code',value=Vcode)
    if(stat.ne.VGD_OK) then
      call abort3d('vco: problem with vgd_get: key= ig_1 - vertical coord code')
    endif

    ! Get vgrid values for ip1, A and B
    stat = 0

    stat = vgd_get(vco%vgrid,key='vipm - vertical levels (m)',value=vgd_ip1_M)
    stat = stat + VGD_OK

    stat = vgd_get(vco%vgrid,key='ca_m - vertical a coefficient (m)',value=vgd_da_M)
    stat = stat + VGD_OK

    stat = vgd_get(vco%vgrid,key='cb_m - vertical b coefficient (m)',value=vgd_db_M)
    stat = stat + VGD_OK

    stat = vgd_get(vco%vgrid,key='vipt - vertical ip1 levels (t)',value=vgd_ip1_t)
    stat = stat + VGD_OK

    stat = vgd_get(vco%vgrid,key='ca_t - vertical a coefficient (t)',value=vgd_da_T)
    stat = stat + VGD_OK

    stat = vgd_get(vco%vgrid,key='cb_t - vertical b coefficient (t)',value=vgd_db_T)
    stat = stat + VGD_OK

    if(stat.ne.0) then
      call abort3d('vco: problem with vgd_get')
    endif

    vgd_nlev_M = size(vgd_ip1_M)
    vgd_nlev_T = size(vgd_ip1_T)

    !==========================================================================
    ! Set the number of vertical levels and allocate vco arrays

    vco%nlev_T = 0
    nomvar_T = 'TT  '
    do jlev = 1, vgd_nlev_T
      ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_T(jlev), -1, -1, ' ', nomvar_T)
      if(ikey.gt.0) vco%nlev_T = vco%nlev_T + 1
    enddo
    if(vco%nlev_T.eq.0) then
      if(mpi_myid.eq.0) write(*,*) 'vco: TT not found looking for UT to get nlev_T'
      nomvar_T = 'UT  '
      do jlev = 1, vgd_nlev_T
        ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_T(jlev), -1, -1, ' ', nomvar_T)
        if(ikey.gt.0) vco%nlev_T = vco%nlev_T + 1
      enddo
    endif

    vco%nlev_M = 0
    nomvar_M = 'UU  '
    do jlev = 1, vgd_nlev_M
      ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_M(jlev), -1, -1, ' ', nomvar_M)
      if(ikey.gt.0) vco%nlev_M = vco%nlev_M + 1
    enddo
    if(vco%nlev_M.eq.0) then
      if(mpi_myid.eq.0) write(*,*) 'vco: UU not found looking for PP to get nlev_M'
      nomvar_M = 'PP  '
      do jlev = 1, vgd_nlev_M
        ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_M(jlev), -1, -1, ' ', nomvar_M)
        if(ikey.gt.0) vco%nlev_M = vco%nlev_M + 1
      enddo
    endif

    if(mpi_myid.eq.0) write(*,*) 'vco: nlev_M, nlev_T=',vco%nlev_M,vco%nlev_T
    
    call vco_allocate(vco)

    !==========================================================================
    ! Define levels (ip1, A, B) for momentum levels

    ! Match up ip1 values from file and vgrid
    jlev2 = 0
    do jlev = 1, vgd_nlev_M
      ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_M(jlev), -1, -1, ' ', nomvar_M)
      if(ikey.gt.0) then
        jlev2 = jlev2 + 1
        if(jlev2.gt.vco%nlev_M) then
          call abort3d('vco: Problem with consistency between vgrid descriptor and template file (momentum)')
        endif
        vco%ip1_M(jlev2) = vgd_ip1_M(jlev)
        vco%da_M(jlev2)  = vgd_da_M(jlev)
        vco%db_M(jlev2)  = vgd_db_M(jlev)        
      else
        if(mpi_myid.eq.0) write(*,*) 'vco: did not find a momentum level in the template file, ip1 =',vgd_ip1_M(jlev)
      endif
    enddo

    !==========================================================================
    ! Define levels (ip1, A, B) for thermo levels

    ! Match up ip1 values from file and vgrid
    jlev2 = 0
    do jlev = 1, vgd_nlev_T
      ikey = fstinf(nultemplate, ni, nj, nk, -1 ,etiket, vgd_ip1_T(jlev), -1, -1, ' ', nomvar_T)
      if(ikey.gt.0) then
        jlev2 = jlev2 + 1
        if(jlev2.gt.vco%nlev_T) then
          call abort3d('vco: Problem with consistency between vgrid descriptor and template file (thermo)')
        endif
        vco%ip1_T(jlev2) = vgd_ip1_T(jlev)
        vco%da_T(jlev2)  = vgd_da_T(jlev)
        vco%db_T(jlev2)  = vgd_db_T(jlev)        
      else
        if(mpi_myid.eq.0) write(*,*) 'vco: did not find a thermo level in the template file, ip1 =',vgd_ip1_T(jlev)
      endif
    enddo

    !==========================================================================
    ! Define level (ip1, A, B) for surface (only used for Vcode=5005)

    ! determine IP1 of sfc (hyb=1.0)
    call convip(ip1_sfc, 1.0, 5, 2, blk_s, .false.) 
    ip1_found = .false.
    do jlev2 = 1, vgd_nlev_T
      if(ip1_sfc .eq. vgd_ip1_T(jlev2)) then
        ip1_found = .true.
        vco%ip1_sfc = vgd_ip1_T(jlev2)
        vco%da_sfc  = vgd_da_T(jlev2)
        vco%db_sfc  = vgd_db_T(jlev2)
      endif
    enddo
    if(.not.ip1_found) then
      write(*,*) 'vco: Could not find IP1=',ip1_sfc
      call abort3d('vco: No surface level found in Vgrid!!!')
    endif

    ! other stuff...
    stat = 0

    ! ptop should only be used for Vcode = 5001, set to negative for other cases
    dl_ptop = -1.0d0
    if(Vcode.eq.5001) then
      stat = vgd_get(vco%vgrid,key='ptop - pressure at top level (m)',value=dl_ptop)
      stat = stat + VGD_OK
      if(mpi_myid.eq.0) write(*,*) 'vco: vgd_get ptop vgd_ok= ',VGD_OK
    endif
    !
    stat = vgd_get(vco%vgrid,key='pref - reference pressure (m)',value=dl_pref)
    stat = stat + VGD_OK
    if(mpi_myid.eq.0) write(*,*) 'vco: vgd_get pref vgd_ok= ',VGD_OK
    !
    stat = vgd_get(vco%vgrid,key='rc_1 - coefficient value for rectification (m)',value=dl_rcf1)
    stat = stat + VGD_OK
    if(mpi_myid.eq.0) write(*,*) 'vco: vgd_get rc_1 vgd_ok= ',VGD_OK
    !
    if(stat.ne.0) then
      call abort3d('vco: problem with vgd_get')
    endif

    vco%dprf   = dl_pref
    vco%dptop  = dl_ptop
    vco%drcf1  = dl_rcf1
    !
    ! Set to zero the non-significant digits (due to conversion from real*4)
    !
    if(lprecision) then
      sigdigits=7
      if(vco%dptop .gt. 0.0d0) then
        precision=10.0d0**(sigdigits-int(log10(vco%dptop)))
        vco%dptop = real(nint(precision*vco%dptop),8)/precision
      endif
      precision=10.0d0**(sigdigits-int(log10(vco%dprf)))
      vco%dprf  = real(nint(precision*vco%dprf),8)/precision
      precision=10.0d0**(sigdigits-int(log10(vco%drcf1)))
      vco%drcf1 = real(nint(precision*vco%drcf1),8)/precision
    endif

    !==========================================================================
    ! Compute derivatives of a and b wrt hyb: only kept for backward compatibity

    do jlev = 1, vco%nlev_M
      call convip(vco%ip1_M(jlev),hyb_r4,kind,-1,blk_s,.false.)
      vco%dhyb_M(jlev) = hyb_r4
      if(mpi_myid.eq.0) write(*,*) 'vco: jlev,nk,ip1,hyb(moment)= ' & 
            ,jlev,vco%nlev_M,vco%ip1_M(jlev),vco%dhyb_M(jlev)
      if((vco%drcf1-1.0d0) .lt. epsilon(vco%drcf1)) then
        zterm = 1.0d0
      else
        zterm = (vco%dhyb_M(jlev) - vco%dptop/vco%dprf)
        if (zterm <= 0.0D0) then
          zterm = 0.0D0
        else
          zterm = (zterm /(1.0d0-vco%dptop/vco%dprf))**(vco%drcf1-1.0d0)
        endif 
      endif
      vco%db_dhyb_M(jlev)= vco%drcf1 * zterm
      vco%da_dhyb_M(jlev)= vco%dprf*(1.0d0 - vco%db_dhyb_M(jlev))
    enddo

    do jlev = 1,vco%nlev_T
      call convip( vco%ip1_T(jlev),hyb_r4,kind,-1,blk_s,.false.)
      vco%dhyb_T(jlev) = hyb_r4
      if(mpi_myid.eq.0) write(*,*) 'vco: jlev,nk,ip1,hyb(thermo)= ' &
            ,jlev,vco%nlev_T,vco%ip1_T(jlev),vco%dhyb_T(jlev)
      if((vco%drcf1-1.0d0) .lt. epsilon(vco%drcf1)) then
        zterm = 1.0d0
      else
        zterm = (vco%dhyb_T(jlev) - vco%dptop/vco%dprf)
        if (zterm <= 0.0d0 ) then
          zterm=0.0d0
        else
          zterm = (zterm  /(1.0d0-vco%dptop/vco%dprf))**(vco%drcf1-1.0d0)
        endif 
      endif
      vco%db_dhyb_T(jlev)= vco%drcf1 * zterm
      vco%da_dhyb_T(jlev)= vco%dprf*(1.0d0 - vco%db_dhyb_T(jlev))
    enddo

    !==========================================================================

    vco%initialized=.true.

    ierr =  fstfrm(nultemplate)
    ierr =  fclos (nultemplate)

  end subroutine vco_SetupFromFile


  function vco_getNumLev(vco,varType) result(nlev)
    implicit none
    type(struct_vco), intent(inout) :: vco
    character(len=*), intent(in)    :: varType
    integer                         :: nlev
    integer                         :: stat
    integer, pointer                :: ip_ptr(:)

    if(varType.eq.'MM') then
      nlev = vco%nlev_M
    elseif(varType.eq.'TH') then
      nlev = vco%nlev_T
    elseif(varType.eq.'SF') then
      nlev = 1
    else
      call abort3d('vco_getNumLev: Unknown variable type! ' // varType)
    endif

  end function vco_getNumLev


end module VerticalCoord_mod
