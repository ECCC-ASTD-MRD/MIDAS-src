!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Tangent linear of computation of radiance with rttov_tl
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!
!revision 001  : a. beaulne *cmda/msc  june 2006
!                  - addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda   april 2008
!                  - adapt to CSR
!revision 003  : s. heilliette
!                  - adapt to IASI
!         S. heilliette:
!                  - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
subroutine tovs_rttov_tl(lobsSpaceData)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use obsSpaceData_mod
  use columnData_mod
  Use rttov_const, only : sensor_id_mw,gas_id_watervapour,surftype_land, &
       surftype_seaice
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_tl.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: joff,ilev
  integer :: isurface
  integer :: nlevels
  integer :: len_nchannels
  integer :: nchannels_max
  integer :: alloc_status(6)
  integer :: rttov_err_stat                          ! rttov error return code
  integer,external :: omp_get_num_threads
  integer :: nthreads, max_nthreads
  integer :: j, i, krtid, io, jf, iobs, iobs1, jch
  integer :: jj
  integer :: ival, iplatform, isat, knpf
  integer :: jo, jdata, idata, idatend, idatyp
  integer :: jn, jl, ig
  integer :: instrum
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)
  integer :: nrank, ichn

  integer :: errorstatus
  integer,allocatable :: iptobs  (:) 

  real*8, allocatable :: surfem1       (:) 
  type(rttov_emissivity), allocatable :: emissivity_local (:)
  type(rttov_emissivity), allocatable :: emissivity_tl (:)
 

  type(rttov_radiance)    :: radiancedata_d     ! radiances full structure buffer used in rttov calls
  type(rttov_radiance)    :: radiancedata_tl    ! tl radiances full structure buffer used in rttov calls
  type(rttov_transmission) :: transmission       ! transmission
  type(rttov_transmission) :: transmission_tl    ! transmission tl
  type(rttov_profile)   , allocatable :: profilesdata_tl (:) ! tl profiles buffer used in rttov calls
  type(rttov_chanprof) , allocatable :: chanprof (:)
  logical ,save        :: first=.true.
  logical              :: init

  logical, allocatable :: calcemis  (:)
  integer ::  asw

         
  if (NOBTOV == 0) return       ! exit if there are not tovs data

!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!     

!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel
  alloc_status(1)=0
  allocate ( iptobs(NOBTOV),stat=alloc_status(1) )

!
!     2.  Computation of hx for tovs data only
!     .   ------------------------------------


! Loop over all sensors specified by user

  binst:  do krtid = 1, nsensors

     nlevels=coefs(krtid)%coef % nlevels
     
     sensor_type = coefs(krtid) % coef % id_sensor
     iplatform = coefs(krtid) % coef % id_platform
     isat = coefs(krtid) % coef % id_sat
     instrum = coefs(krtid) % coef % id_inst
!  loop over all obs.

     knpf = 0
     bobs: do iobs = 1, NOBTOV

!    Currently processed sensor?

        if ( lsensor(iobs) == krtid ) then
           knpf = knpf + 1
           iptobs(knpf) = iobs
        endif
     enddo bobs

     if (knpf == 0) cycle binst

!     set nthreads to actual number of threads which will be used.

     nthreads = min(max_nthreads, knpf)  

!     .  2.2  Prepare all input variables required by rttov.
!     .       ---------------------------------------------------------
     alloc_status(:)=0

!     compute max possible values for nchannels using knpf, i.e. maximum number of profiles.
     nchannels_max = knpf * nchan(krtid)

     allocate ( surfem1      (nchannels_max)      ,stat=alloc_status(1))
     allocate ( chanprof     (nchannels_max)      ,stat=alloc_status(2))
     allocate ( emissivity_local (nchannels_max)  ,stat=alloc_status(3))
     allocate ( emissivity_tl(nchannels_max)      ,stat=alloc_status(4))
     allocate ( calcemis     (nchannels_max)      ,stat=alloc_status(5))
     allocate ( profilesdata_tl(knpf)             ,stat=alloc_status(6))  ! profilesdata tl

     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_rttov_tl: alloc_status = ', alloc_status(:)
        write(*,'(" tovs_rttov_tl:  arrays #2 memory allocation error")')
        call utl_abort('tovs_rttov_tl')
     end if
!     get Hyperspecral IR emissivities
      
     if ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
        surfem1(:) = 0.98d0
        do jn = 1, knpf
           iobs1 = iptobs(jn)
           jo = lobsno(iobs1)
           idata    = obs_headElem_i(lobsSpaceData,OBS_RLN,jo)
           idatend  = obs_headElem_i(lobsSpaceData,OBS_NLV,jo) + idata - 1
           do jdata = idata, idatend
              if(obs_bodyElem_i(lobsSpaceData,OBS_ASS,jdata)==1) then
                 ichn = nint(obs_bodyElem_r(lobsSpaceData,OBS_PPP,jdata))
                 ichn = max(0,min(ichn,jpchmax+1))
                 do nrank = 1, nchan(krtid)
                    if ( ichn == ichan(nrank,krtid) ) exit
                 end do
                 surfem1 ( nrank + (jn-1)*nchan(krtid) ) = obs_bodyElem_r(lobsSpaceData,OBS_SEM,jdata)
              end if
           end do
        end do
     end if

     ichn = 0
     Do j = 1 , knpf
        DO  jch = 1,nchan(krtid)
           ichn = ichn +1
           chanprof(ichn)%prof=j
           chanprof(ichn)%chan=jch
        End Do
     End Do

     init=.true.
     asw=1 ! 1 to allocate,0 to deallocate
         ! allocate transmitance structure
      call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
           nchanprof=nchannels_max,asw=asw,init=init )
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
      call rttov_alloc_transmission(rttov_err_stat,transmission_tl,nlevels=nlevels,   &
           nchanprof=nchannels_max,asw=asw,init=init )
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
     ! allocate radiance structures
      call rttov_alloc_rad ( rttov_err_stat, nchannels_max, radiancedata_d,nlevels,asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
      call rttov_alloc_rad ( rttov_err_stat,nchannels_max,radiancedata_tl,nlevels,asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif

      len_nchannels = nchan(krtid)
      do  j = 1 , knpf
         joff=len_nchannels*(j-1)
         isurface = profiles(iptobs(j)) % skin % surftype 
         if     (sensor_type == sensor_id_mw ) then
            if ( isurface == surftype_land .or. &
                 isurface == surftype_seaice     ) then
               calcemis(joff+1:joff+len_nchannels ) = .false.
               surfem1 (joff+1:joff+len_nchannels ) = 0.75d0
            else
               calcemis(joff+1:joff+len_nchannels ) = .true.
               surfem1 (joff+1:joff+len_nchannels ) = 0.d0
            endif
         elseif ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
            calcemis(joff+1:joff+len_nchannels ) = .false. 
         elseif ( tvs_Is_Instrum_Geostationary(instrum) ) then
            calcemis(joff+1:joff+len_nchannels ) = .true.
            surfem1 (joff+1:joff+len_nchannels ) = 0.d0
         else
            call utl_abort('tovs_rttov_tl. invalid sensor type')
         endif
      enddo
      ! Build the list of channels/profiles indices
      emissivity_local(:)%emis_in = surfem1(:)
       
      ! allocate profiledata_tl structures
     
      call rttov_alloc_prof (rttov_err_stat,knpf,profilesdata_tl,nlevels, &
           opts(krtid),asw=asw,coefs=coefs(krtid),init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in profiles tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif

     !.. fill profilesdata_tl arrays

      call rttov_copy_prof( profilesdata_tl(1:knpf), profiles_tl( iptobs(1:knpf) ) )

     !.. climatological moisture clip for profilesdata and profilesdata_tl arrays

! Modifie par S.Heilliette
! pour utiliser le bon profil min ou max pour chaque instrument
! au lieu du premier (AIRS) habituellement en mode analyse
! ne doit rien changer en mode background check
      ig=coefs(krtid)%coef%fmv_gas_pos(gas_id_watervapour)
      do  j = 1 , knpf
         jj = iptobs(j)
         do  jl = 1 , coefs(krtid) %coef% nlevels
            if     ( profiles(jj) % q(jl)  &
                 .le. coefs(krtid)%coef%lim_prfl_gmin(jl,ig)  ) then
               profiles(jj) % q(jl)    = coefs(krtid)%coef%lim_prfl_gmin(jl,ig)           
               profilesdata_tl(j) % q(jl) = 0.0d0
            elseif ( profiles(jj) % q(jl)  &
                 .ge. coefs(krtid)%coef%lim_prfl_gmax(jl,ig)   ) then
               profiles(jj) % q(jl)    =  coefs(krtid)%coef%lim_prfl_gmax(jl,ig)       
               profilesdata_tl(j) % q(jl) = 0.0d0
            endif
         enddo
      end do
 
!     .  2.3  Compute tl radiance with rttov_tl
!     .       ---------------------------------

    errorstatus   = 0
    emissivity_tl(:)%emis_in = 0.0d0
    call tmg_start(87,'rttov_tl')
    call rttov_parallel_tl(         &
         errorstatus,               & ! out
         chanprof,                  & ! in
         opts(krtid),               & ! in
         profiles(iptobs(1:knpf)),  & ! in
         profilesdata_tl,           & ! inout
         coefs(krtid),              & ! in
         transmission,              & ! inout
         transmission_tl,           & ! inout
         radiancedata_d,            & ! inout
         radiancedata_tl,           & ! inout
         calcemis,                  & ! in
         emissivity_local,          & ! in
         emissivity_tl,             & ! inout
         nthreads=nthreads )          ! in
               
    if (errorstatus /= 0) then
       Write(*,*) "Error in rttov_parallel_tl",errorstatus
       write(*,*) 'temperature           profile=',profiles(iptobs(1)) % t(:)
       write(*,*) 'temperature increment profile=',profilesdata_tl(1) % t(:)
       call utl_abort('tovs_rttov_tl')
    endif

    call tmg_stop(87)

!     .  2.4  Store hx in the structure radiance_tl
!     .       ------------------------------------
 
    do jn = 1, knpf
       io = iptobs(jn)
       joff=nchan(krtid)*(jn-1)
       radiance_tl(io) % bt(:) = radiancedata_tl % bt(joff+1:joff+nchan(krtid))
    enddo
!     de-allocate memory

    asw=0 ! 1 to allocate,0 to deallocate
    ! deallocate transmitance structures
    call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
         nchanprof=nchannels_max,asw=asw )
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in transmittance deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif

    call rttov_alloc_transmission(rttov_err_stat,transmission_tl,nlevels=nlevels,   &
         nchanprof=nchannels_max,asw=asw )
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in transmittance tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
    ! deallocate radiance structures
    call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_d,nlevels,asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in radiance deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
    call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_tl,nlevels,asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in radiance tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
 ! deallocate profilesdatat_tl structure
    
    call rttov_alloc_prof (rttov_err_stat,knpf,profilesdata_tl,nlevels, &
         opts(krtid),asw=asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in profiles tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif

    alloc_status(:) = 0
    
    deallocate ( surfem1         ,stat=alloc_status(1) )
    deallocate ( chanprof        ,stat=alloc_status(2) )
    deallocate ( emissivity_local,stat=alloc_status(3) )
    deallocate ( emissivity_tl   ,stat=alloc_status(4) )
    deallocate ( calcemis        ,stat=alloc_status(5) )
    deallocate ( profilesdata_tl ,stat=alloc_status(6) )

    if( any(alloc_status /= 0) ) then
       write(*,*) ' tovs_rttov_tl: alloc_status = ', alloc_status(:)
       write(*,'(" tovs_rttov_tl: arrays #2 memory deallocation error")')
       call utl_abort('tovs_rttov_tl ')
    end if

 end do binst

 deallocate ( iptobs )

end subroutine tovs_rttov_tl
