!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Tangent linear of computation of radiance with rttov_tl
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!
!revision 001  : a. beaulne *cmda/msc  june 2006
!                  - addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda   april 2008
!                  - adapt to CSR
!revision 003  : s. heilliette
!                  - adapt to IASI
!         S. heilliette:
!                  - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
subroutine tovs_rttov_tl(lobsSpaceData)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use obsSpaceData_mod
  use columnData_mod
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_tl.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: isurface
  integer :: nlevels
  integer :: count_tb
  integer :: alloc_status(6)
  integer :: rttov_err_stat                          ! rttov error return code
  integer,external :: omp_get_num_threads
  integer :: nthreads, max_nthreads
  integer :: sensor_id, iobs
  integer :: count_profile
  integer :: profile_index, index_tb
  integer :: instrum
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)
  integer :: channel_index

  integer :: errorstatus
  integer,allocatable :: iptobs  (:) 

  real*8, allocatable :: surfem1       (:) 
  type(rttov_emissivity), allocatable :: emissivity_local (:)
  type(rttov_emissivity), allocatable :: emissivity_tl (:)
 

  type(rttov_radiance) :: radiancedata_d     ! radiances full structure buffer used in rttov calls
  type(rttov_radiance) :: radiancedata_tl    ! tl radiances full structure buffer used in rttov calls
  type(rttov_transmission) :: transmission       ! transmission
  type(rttov_transmission) :: transmission_tl    ! transmission tl
  type(rttov_profile)  , allocatable :: profilesdata_tl (:) ! tl profiles buffer used in rttov calls
  type(rttov_chanprof) , allocatable :: chanprof (:)
  logical ,save        :: first=.true.
  logical              :: init

  logical, allocatable :: calcemis  (:)
  integer ::  asw
         
  if (TVS_NOBTOV == 0) return       ! exit if there are not tovs data
  write(*,*) "tovs_rttov_tl Debut"


!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!     

!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel
  alloc_status(1)=0
  allocate ( iptobs(TVS_NOBTOV),stat=alloc_status(1) )

!
!     2.  Computation of hx for tovs data only
!     .   ------------------------------------


! Loop over all sensors specified by user

  sensor_loop:  do sensor_id = 1, tvs_nsensors

     nlevels=coefs(sensor_id)%coef % nlevels
     
     sensor_type = coefs(sensor_id) % coef % id_sensor
     instrum = coefs(sensor_id) % coef % id_inst
!  loop over all obs.

     count_profile = 0
     obs_loop: do iobs = 1, TVS_NOBTOV

!    Currently processed sensor?

        if ( tvs_lsensor(iobs) == sensor_id ) then
           count_profile = count_profile + 1
           iptobs(count_profile) = iobs
        endif
     enddo obs_loop

     if (count_profile == 0) cycle sensor_loop

!     set nthreads to actual number of threads which will be used.

     nthreads = min(max_nthreads, count_profile)  

!     .  2.2  Prepare all input variables required by rttov.
!     .       ---------------------------------------------------------
     

!     compute max possible values for nchannels
     count_tb = TVS_COUNT_RADIANCES(iptobs, count_profile, lobsSpaceData)
     
     if ( count_tb == 0 ) cycle  sensor_loop

     alloc_status(:)=0
     allocate ( surfem1      (count_tb)       ,stat=alloc_status(1))
     allocate ( chanprof     (count_tb)       ,stat=alloc_status(2))
     allocate ( emissivity_local (count_tb)   ,stat=alloc_status(3))
     allocate ( emissivity_tl(count_tb)       ,stat=alloc_status(4))
     allocate ( calcemis     (count_tb)       ,stat=alloc_status(5))
     allocate ( profilesdata_tl(count_profile),stat=alloc_status(6))  ! profilesdata tl
     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_rttov_tl: alloc_status = ', alloc_status(:)
        write(*,'(" tovs_rttov_tl:  arrays #2 memory allocation error")')
        call utl_abort('tovs_rttov_tl')
     end if
!     get Hyperspecral IR emissivities
      
     if ( tvs_Is_Instrum_Hyperspectral(instrum) ) call TVS_GetHIREmissivities(sensor_id, iptobs, count_profile, lobsSpaceData, surfem1)

     call TVS_GET_CHANPROF(sensor_id, iptobs, count_profile, lobsSpaceData, chanprof)

     init=.true.
     asw=1 ! 1 to allocate,0 to deallocate
           ! allocate transmitance structure
      call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
           nchanprof=count_tb,asw=asw,init=init )
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
      call rttov_alloc_transmission(rttov_err_stat,transmission_tl,nlevels=nlevels,   &
           nchanprof=count_tb,asw=asw,init=init )
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
     ! allocate radiance structures
      call rttov_alloc_rad ( rttov_err_stat, count_tb, radiancedata_d,nlevels,asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif
      call rttov_alloc_rad ( rttov_err_stat,count_tb,radiancedata_tl,nlevels,asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif


      call TVS_GetOtherEmissivities(chanprof, iptobs, count_tb, sensor_type, instrum, surfem1, calcemis)

      emissivity_local(:)%emis_in = surfem1(:)
       
      ! allocate profiledata_tl structures
     
      call rttov_alloc_prof (rttov_err_stat,count_profile,profilesdata_tl,nlevels, &
           opts(sensor_id),asw=asw,coefs=coefs(sensor_id),init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in profiles tl allocation",rttov_err_stat
         call utl_abort('tovs_rttov_tl')
      endif

     !.. fill profilesdata_tl arrays

      call rttov_copy_prof( profilesdata_tl(1:count_profile), profiles_tl( iptobs(1:count_profile) ) )
 
!     .  2.3  Compute tl radiance with rttov_tl
!     .       ---------------------------------

    errorstatus   = 0
    emissivity_tl(:)%emis_in = 0.0d0
    call tmg_start(87,'rttov_tl')
    call rttov_parallel_tl(         &
         errorstatus,               & ! out
         chanprof,                  & ! in
         opts(sensor_id),           & ! in
         profiles(iptobs(1:count_profile)),  & ! in
         profilesdata_tl,           & ! inout
         coefs(sensor_id),          & ! in
         transmission,              & ! inout
         transmission_tl,           & ! inout
         radiancedata_d,            & ! inout
         radiancedata_tl,           & ! inout
         calcemis,                  & ! in
         emissivity_local,          & ! in
         emissivity_tl,             & ! inout
         nthreads=nthreads )          ! in
               
    if (errorstatus /= 0) then
       Write(*,*) "Error in rttov_parallel_tl",errorstatus
       write(*,*) 'temperature           profile=',profiles(iptobs(1)) % t(:)
       write(*,*) 'temperature increment profile=',profilesdata_tl(1) % t(:)
       call utl_abort('tovs_rttov_tl')
    endif

    call tmg_stop(87)

!     .  2.4  Store hx in the structure radiance_tl
!     .       ------------------------------------
    do index_tb = 1, count_tb
       profile_index = chanprof(index_tb)%prof
       channel_index = chanprof(index_tb)%chan
       iobs = iptobs(profile_index)
       radiance_tl(iobs) % bt(channel_index) =  radiancedata_tl % bt(index_tb)
    enddo

!     de-allocate memory

    asw=0 ! 1 to allocate,0 to deallocate
    ! deallocate transmitance structures
    call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
         nchanprof=count_tb,asw=asw )
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in transmittance deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif

    call rttov_alloc_transmission(rttov_err_stat,transmission_tl,nlevels=nlevels,   &
         nchanprof=count_tb,asw=asw )
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in transmittance tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
    ! deallocate radiance structures
    call rttov_alloc_rad (rttov_err_stat,count_tb,radiancedata_d,nlevels,asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in radiance deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
    call rttov_alloc_rad (rttov_err_stat,count_tb,radiancedata_tl,nlevels,asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in radiance tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif
 ! deallocate profilesdatat_tl structure
    
    call rttov_alloc_prof (rttov_err_stat,count_profile,profilesdata_tl,nlevels, &
         opts(sensor_id),asw=asw)
    if (rttov_err_stat/=0) THEN
       Write(*,*) "Error in profiles tl deallocation",rttov_err_stat
       call utl_abort('tovs_rttov_tl')
    endif

    alloc_status(:) = 0
    
    deallocate ( surfem1         ,stat=alloc_status(1) )
    deallocate ( chanprof        ,stat=alloc_status(2) )
    deallocate ( emissivity_local,stat=alloc_status(3) )
    deallocate ( emissivity_tl   ,stat=alloc_status(4) )
    deallocate ( calcemis        ,stat=alloc_status(5) )
    deallocate ( profilesdata_tl ,stat=alloc_status(6) )

    if( any(alloc_status /= 0) ) then
       write(*,*) ' tovs_rttov_tl: alloc_status = ', alloc_status(:)
       write(*,'(" tovs_rttov_tl: arrays #2 memory deallocation error")')
       call utl_abort('tovs_rttov_tl ')
    end if

 end do sensor_loop

 deallocate ( iptobs )


end subroutine tovs_rttov_tl
