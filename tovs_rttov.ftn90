!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Computation of forward radiance with rttov_direct
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!revision 001  : a. beaulne *cmda/msc  june 2006
!                  - modifications for AIRS : store new variables and add bgcheck
!                  - add new surface emissivities for IR sensors
!revision 002  : r. sarrazin cmda   april 2008
!                  - adapt to CSR
!revision 003  : s. heilliette
!                  - adapt to IASI
!revision 004  : s. heilliette
!                 - adaptation to rttov 10.0 (october 2010)
!revision 005  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!--------------------------------------------------------------------------
subroutine tovs_rttov(lcolumnhr,lobsSpaceData,bgckMode)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use mod_rttov_emis_atlas
  use multi_ir_bgck_mod
  use obsSpaceData_mod
  use columnData_mod
  use emissivities_mod
  Use rttov_const, only : sensor_id_mw,gas_id_watervapour,surftype_land, &
       surftype_seaice
  Use mod_rttov_emis_atlas, only : atlas_type_ir
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_direct.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_print_profile.interface"
#include "rttov_get_emis.interface"
#include "rttov_setup_emis_atlas.interface"

  type(struct_obs) :: lobsSpaceData
  type(struct_columnData) :: lcolumnhr
  logical :: bgckMode

  
  integer :: joff,ilev, ichn
  integer :: isurface
  integer :: nlevels
  integer :: len_nchannels
  integer :: nchannels_max
  integer :: alloc_status(9)
  integer :: errorstatus                     ! rttov error return code
  integer :: rttov_err_stat
  integer ,external :: omp_get_num_threads
  integer :: nthreads,max_nthreads
  integer :: j, i, k, krtid, io, jf, iobs, iobs1
  integer :: jch
  integer :: ival, iplatform, isat, knpf
  integer :: jo, jdata, idata, idatend, idatyp
  integer :: jn, jl, jj
  integer :: instrum
  integer :: sensor_type        ! sensor type (1=infrared; 2=microwave; 3=high resolution,4=polarimetric)
  integer :: nrank
  integer ,allocatable:: iptobs  (:)  
 
  type (rttov_emissivity), allocatable :: emissivity_local (:)    ! emissivity structure with input and output
  type (rttov_chanprof), allocatable :: chanprof (:)
  type (rttov_radiance) :: radiancedata_d

  type (rttov_emis_atlas_data),allocatable,save :: Atlas(:)
  logical ,save        :: first=.true.
  logical              :: init
  integer              :: asw,imonth,ig
  logical, allocatable :: calcemis  (:)
  real*8, allocatable  :: surfem1 (:)
  real*8, allocatable  :: surfem2 (:) !, emissivity_std(:)
!  integer, allocatable :: emissivity_flg(:)
!*****************************************************************
  
  write(*,*) "Entering tovs_rttov subroutine"
  write(*,*) "luse_uwiremis=",luse_uwiremis

  if (NOBTOV == 0) return                  ! exit if there are not tovs data

!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!           
!$omp parallel
  max_nthreads = omp_get_num_threads()
!$omp end parallel

  allocate(iptobs(NOBTOV),stat=alloc_status(1))

  if( alloc_status(1)/=0 ) then
     write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
     write(*,'(" tovs_rttov: arrays #1 memory allocation error")')
     call utl_abort('tovs_rttov        ')
  end if

!     1.1   Read surface information
!     .     ------------------------

  if ( bgckMode ) call EMIS_READ_CLIMATOLOGY

!
!     2.  Computation of hx for tovs data only
!     .   ------------------------------------


! Loop over all sensors specified by user

  binst:do krtid = 1, nsensors
   
     nlevels=coefs(krtid)% coef % nlevels
  
     sensor_type = coefs(krtid) % coef % id_sensor
     iplatform = coefs(krtid) % coef % id_platform
     isat = coefs(krtid) % coef % id_sat
     instrum = coefs(krtid) % coef % id_inst
    
!  loop over all obs.

     knpf = 0
     bobs: do iobs = 1, NOBTOV

!    Currently processed sensor?

        if ( lsensor(iobs) == krtid ) then
           knpf = knpf + 1
           iptobs(knpf) = iobs
        endif
     enddo bobs

     if (knpf == 0) cycle binst

!     .  2.1  Calculate the actual number of threads which will be used.
!     .       ----------------------------------------------------------

     nthreads = min(max_nthreads, knpf )  

!     .  2.2  Prepare all input variables required by rttov.
!     .       ---------------------------------------------------------

     nchannels_max = knpf * nchan(krtid)
     alloc_status(:)=0
     allocate ( surfem1          (nchannels_max) ,stat=alloc_status(2))
     allocate ( chanprof         (nchannels_max) ,stat=alloc_status(3))
     allocate ( emissivity_local (nchannels_max) ,stat=alloc_status(4))
     allocate ( calcemis         (nchannels_max) ,stat=alloc_status(5))
     if (luse_uwiremis) then
        allocate ( surfem2(nchannels_max)        ,stat=alloc_status(6) )
        !           allocate ( emissivity_std(nchannels_max) ,stat=alloc_status(7) )
        !           allocate ( emissivity_flg(nchannels_max) ,stat=alloc_status(8) )
     endif
     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
        write(*,'(" tovs_rttov: arrays #2 memory allocation error")')
        call utl_abort('tovs_rttov')
     endif
!     get Hyperspectral IR emissivities

     if ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
        surfem1(:) = 0.
        if ( bgckMode ) then
           call EMIS_GET_IR_EMISSIVITY (SURFEM1,nchan(krtid),krtid,knpf,nchannels_max,iptobs)
        else
           surfem1(:) = 0.98d0
           do jn = 1, knpf
              iobs1 = iptobs(jn)
              jo = lobsno(iobs1)
              idata    = obs_headElem_i(lobsSpaceData,OBS_RLN,jo)
              idatend  = obs_headElem_i(lobsSpaceData,OBS_NLV,jo) + idata - 1
              do jdata = idata, idatend
                 if(obs_bodyElem_i(lobsSpaceData,OBS_ASS,jdata)==1) then
                    ichn = nint(obs_bodyElem_r(lobsSpaceData,OBS_PPP,jdata))
                    ichn = max(0,min(ichn,jpchmax+1))
                    do nrank = 1, nchan(krtid)
                       if ( ichn == ichan(nrank,krtid) ) exit
                    end do
                    surfem1 ( nrank + (jn-1)*nchan(krtid) ) = obs_bodyElem_r(lobsSpaceData,OBS_SEM,jdata)
                 end if
              end do
           end do
        end if
     end if

     ichn = 0
     Do j = 1 , knpf
        DO  jch = 1,nchan(krtid)
           ichn = ichn +1
           chanprof(ichn)%prof=j
           chanprof(ichn)%chan=jch
        End Do
     End Do

     asw=1 ! 1 to allocate,0 to deallocate
       ! allocate transmitance structure

     call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
          nchanprof=nchannels_max,asw=asw,init=.true. )
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in transmittance allocation",rttov_err_stat
        call utl_abort('tovs_rttov')
     ENDIF

       ! allocate radiance structure

     call rttov_alloc_rad (rttov_err_stat,nchannels_max, radiancedata_d,nlevels,asw,init=.true.)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in radiance allocation",rttov_err_stat
        call utl_abort('tovs_rttov')
     ENDIF
         
     !.. climatological moisture clip for profiles array

! Modifie par S.Heilliette
! pour utiliser le bon profil min ou max pour chaque instrument
! au lieu du premier (AIRS) habituellement en mode analyse
! ne doit rien changer en mode background check
     ig=coefs(krtid)%coef%fmv_gas_pos(gas_id_watervapour)
     do  j = 1 , knpf
        jj = iptobs(j)
        do  jl = 1 , nlevels
           if     ( profiles(jj) % q(jl)  &
                .le. coefs(krtid)%coef%lim_prfl_gmin(jl,ig)   ) then
              profiles(jj) % q(jl)  = coefs(krtid)%coef%lim_prfl_gmin(jl,ig)
           elseif ( profiles(jj) % q(jl)  &
                .ge. coefs(krtid)%coef%lim_prfl_gmax(jl,ig)  ) then
              profiles(jj) % q(jl)  = coefs(krtid)%coef%lim_prfl_gmax(jl,ig)
           endif
        enddo
        if (ldbgtov) call rttov_print_profile( profiles(jj) )
     end do
       
     len_nchannels = nchan(krtid)
      
     do  j = 1 , knpf  
        joff=len_nchannels*(j-1)
        isurface = profiles(iptobs(j)) % skin % surftype 
        if     (sensor_type == sensor_id_mw ) then
           if ( isurface == surftype_land .or. &
                isurface == surftype_seaice     ) then
              calcemis(joff+1:joff+len_nchannels) = .false.
              surfem1 (joff+1:joff+len_nchannels ) = 0.75d0
           else
              calcemis(joff+1:joff+len_nchannels) = .true.
              surfem1 (joff+1:joff+len_nchannels) = 0.d0
           endif
        elseif ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
           calcemis(joff+1:joff+len_nchannels) = .false. 
        elseif ( tvs_Is_Instrum_Geostationary(instrum) ) then
           calcemis(joff+1:joff+len_nchannels) = .true.
           surfem1 (joff+1:joff+len_nchannels) = 0.d0
        else
           Write(*,*) sensor_type,instrum
           call utl_abort('tovs_rttov. invalid sensor type')
        endif
     enddo
     if (luse_uwiremis .and. tvs_Is_Instrum_Hyperspectral(instrum) .and. bgckMode) then
        if (first) then
           if (.not. allocated (Atlas)) allocate(Atlas(nsensors))
           call rttov_setup_emis_atlas( rttov_err_stat,       &! out
                      opts(krtid),                            &! in
                      profiles(1)%date(2) ,                   &! in
                      atlas_type_ir,                          &! in
                      atlas(krtid),                           &! in
                      ir_atlas_ang_corr = .false.,            &! in
                      ir_atlas_read_std = .false.,            &! in
                      coefs = coefs(krtid)  )
           if (rttov_err_stat/=0) THEN
              Write(*,*) "Error in rttov_atlas_setup ",rttov_err_stat
              call utl_abort('tovs_rttov')
           ENDIF
           first=.false.
        endif

        call rttov_get_emis( rttov_err_stat      , &   ! out
             opts(krtid)                         , &   ! in
             chanprof(1:nchannels_max)           , &   ! in
             profiles(iptobs(1:knpf))            , &   ! in
             coefs(krtid)                        , &   ! in
             Atlas(krtid)                        , &   ! in
             surfem2(1:nchannels_max)     ) ! out
           !               emis_std=emissivity_std(1:nchannels), &   ! out, optional (not CNRM atlas)
           !               emis_flag=emissivity_flg(1:nchannels)  )  ! out, optional (IR atlas only)

           if (rttov_err_stat/=0) THEN
              Write(*,*) "Error in rttov_get_emis ",rttov_err_stat
              call utl_abort('tovs_rttov')
           ENDIF
              
           do j=1,knpf !loop on profiles
              jj = iptobs(j)
              do k=1,nchannels_max !loop on channels
                 if (chanprof(k)%prof==j) then
                   ! surftype: 0 land, 1 sea, 2 sea-ice
                   ! this logic is primitive and could be improved for example using
                   ! additional criteria based on emissivity_std and emissivity_flg
                   !Definition of emis_flag:
                   ! emis_flag:Flag_0 = "0 = sea, no MOD11 data" ;
                   ! emis_flag:Flag_1 = "1 = land where BF method was applied" ;
                   ! emis_flag:Flag_2 = "2 = land where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! emis_flag:Flag_3 = "3 = contains inland water or coastline by the sea/land mask where the BF method was used" ;
                   ! emis_flag:Flag_4 = "4 = contains inland water or coastline by the sea/land mask where data was filled with average original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! emis_flag:Flag_5 = "5 = contains coastline by land fraction where the BF method was used" ;
                   ! emis_flag:Flag_6 = "6 = contains coastline by land fraction where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! other information that could be useful for quality control can be found in the in the profile_qc structure
                   ! Now we have the "traditionnal" emissivity in surfem1(:)
                   ! and University of Wisconsin emissivity in surfem2(:)
                    if (profiles(jj)% skin % surftype == 0 .and. &
                         surfem2(k)>0.5 ) then
                       emissivity_local(k)%emis_in = surfem2(k)
                    else
                       emissivity_local(k)%emis_in = surfem1(k)
                    endif
                 endif
              enddo
           enddo
        else
           emissivity_local(:)%emis_in = surfem1(:)
        endif
        
!     .  2.3  Compute radiance with rttov direct
!     .       ----------------------------------

        errorstatus = 0

        call rttov_parallel_direct(       &
             errorstatus,                 & ! out
             chanprof,                    & ! in
             opts(krtid),                 & ! in
             profiles(iptobs(1:knpf)),    & ! in
             coefs(krtid),                & ! in
             transmission,                & ! inout
             radiancedata_d,              & ! inout
             calcemis=calcemis,           & ! in
             emissivity=emissivity_local, & ! inout
             nthreads=nthreads      )   

        if (errorstatus /= 0) then
           Write(*,*) "Error in rttov_parallel_direct",errorstatus
           call utl_abort('tovs_rttov')
        endif
                                                       
!     .  2.4  Store hx in the structure radiance_d
!     .       ------------------------------------
        
 
        do jn = 1, knpf
           io = iptobs(jn)
           joff=len_nchannels*(jn-1)
           radiance_d(io) % bt(:) =        &
                radiancedata_d % bt(joff+1:joff+len_nchannels)
           radiance_d(io) % clear(:) =  &
                radiancedata_d %clear(joff+1:joff+len_nchannels)
           if ( bgckMode ) then
              do jl = 1, nlevels - 1
                 radiance_d(io) % overcast(jl,:) =   &
                      radiancedata_d % overcast(jl,joff+1:joff+len_nchannels)
              enddo
              do jl = 1, nlevels
                 transmission_d(io) % tau_levels(jl,:) = &
                      transmission % tau_levels(jl,joff+1:joff+len_nchannels)
              end do
              
              transmission_d(io) % tau_total(:) = &
                   transmission % tau_total(joff+1:joff+nchan(krtid))
              emissivity(1:nchan(krtid),io) = emissivity_local(joff+1:joff+len_nchannels)%emis_out
              
           endif
        enddo


!     de-allocate memory
      
  
        asw=0 ! 1 to allocate,0 to deallocate
        ! transmittance deallocation
        call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
             nchanprof=nchannels_max,asw=asw )
        if (rttov_err_stat/=0) THEN
           Write(*,*) "Error in transmittance deallocation",rttov_err_stat
           call utl_abort('tovs_rttov')
        ENDIF
        ! radiance deallocation       
        call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_d,nlevels,asw)
        if (rttov_err_stat/=0) THEN
           Write(*,*) "Error in radiance deallocation",rttov_err_stat
           call utl_abort('tovs_rttov')
        ENDIF
        
        alloc_status(:) = 0
        
        deallocate ( surfem1           ,stat=alloc_status(1) )
        deallocate ( chanprof          ,stat=alloc_status(2) )
        deallocate ( calcemis          ,stat=alloc_status(3) )
        deallocate ( emissivity_local  ,stat=alloc_status(4) )
        if (luse_uwiremis) then
           deallocate ( surfem2         ,stat=alloc_status(5) )
!           deallocate ( emissivity_std  ,stat=alloc_status(7) )
!           deallocate ( emissivity_flg  ,stat=alloc_status(8) )
        endif

        if( any(alloc_status /= 0) ) then
           write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
           write(*,'(" tovs_rttov: arrays #2 memory deallocation error")')
           call utl_abort('tovs_rttov')
        end if

     enddo binst

!     2.5. AIRS, IASI and quality controls
!     .    ------------------------------

    ! moved to bgcheck.ftn90

     deallocate(iptobs)

end subroutine tovs_rttov
