!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Computation of forward radiance with rttov_direct
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!revision 001  : a. beaulne *cmda/msc  june 2006
!                  - modifications for AIRS : store new variables and add bgcheck
!                  - add new surface emissivities for IR sensors
!revision 002  : r. sarrazin cmda   april 2008
!                  - adapt to CSR
!revision 003  : s. heilliette
!                  - adapt to IASI
!revision 004  : s. heilliette
!                 - adaptation to rttov 10.0 (october 2010)
!revision 005  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!--------------------------------------------------------------------------
subroutine tovs_rttov(lcolumnhr,lobsSpaceData,bgckMode)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use mod_rttov_emis_atlas
  use multi_ir_bgck_mod
  use obsSpaceData_mod
  use columnData_mod
  use emissivities_mod
  Use mod_rttov_emis_atlas, only : atlas_type_ir
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_direct.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_print_profile.interface"
#include "rttov_get_emis.interface"
#include "rttov_setup_emis_atlas.interface"

  type(struct_obs) :: lobsSpaceData
  type(struct_columnData) :: lcolumnhr
  logical :: bgckMode

  
  integer :: ichn
  integer :: isurface
  integer :: nlevels
  integer :: count_tb
  integer :: alloc_status(9)
  integer :: errorstatus                     ! rttov error return code
  integer :: rttov_err_stat
  integer ,external :: omp_get_num_threads
  integer :: nthreads,max_nthreads
  integer :: sensor_id, obs_index
  integer :: channel_index
  integer :: count_profile
  integer :: profile_index, level_index, jj, tb_index
  integer :: instrum
  integer :: sensor_type        ! sensor type (1=infrared; 2=microwave; 3=high resolution,4=polarimetric)
  integer ,allocatable:: iptobs  (:)  
 
  type (rttov_emissivity), allocatable :: emissivity_local (:)    ! emissivity structure with input and output
  type (rttov_chanprof), allocatable :: chanprof (:)
  type (rttov_radiance) :: radiancedata_d

  type (rttov_emis_atlas_data),allocatable,save :: Atlas(:)
  logical ,save        :: first=.true.
  logical              :: init
  integer              :: asw,imonth
  logical, allocatable :: calcemis  (:)
  real*8, allocatable  :: surfem1 (:)
  real*8, allocatable  :: surfem2 (:)
!*****************************************************************
  
  write(*,*) "Entering tovs_rttov subroutine"

  if (TVS_NOBTOV == 0) return                  ! exit if there are not tovs data

!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!           
!$omp parallel
  max_nthreads = omp_get_num_threads()
!$omp end parallel

  allocate(iptobs(TVS_NOBTOV),stat=alloc_status(1))

  if( alloc_status(1)/=0 ) then
     write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
     write(*,'(" tovs_rttov: arrays #1 memory allocation error")')
     call utl_abort('tovs_rttov')
  end if

!     1.1   Read surface information
!     .     ------------------------

  if ( bgckMode ) call EMIS_READ_CLIMATOLOGY

!
!     2.  Computation of hx for tovs data only
!     .   ------------------------------------


! Loop over all sensors specified by user

  sensor_loop:do sensor_id = 1, tvs_nsensors
   
     nlevels=coefs(sensor_id)% coef % nlevels
  
     sensor_type = coefs(sensor_id) % coef % id_sensor
     instrum = coefs(sensor_id) % coef % id_inst
    
!  loop over all obs.

     count_profile = 0
     obs_loop: do obs_index = 1, TVS_NOBTOV

!    Currently processed sensor?

        if ( tvs_lsensor(obs_index) == sensor_id ) then
           count_profile = count_profile + 1
           iptobs(count_profile) = obs_index
        endif
     enddo obs_loop

     if (count_profile == 0) cycle sensor_loop

!     .  2.1  Calculate the actual number of threads which will be used.
!     .       ----------------------------------------------------------

     nthreads = min(max_nthreads, count_profile )  

!     .  2.2  Prepare all input variables required by rttov.
!     .       ---------------------------------------------------------

     if (  bgckMode .and. tvs_Is_Instrum_Hyperspectral(instrum) ) then
        count_tb = count_profile * tvs_nchan(sensor_id)
     else
        count_tb = TVS_COUNT_RADIANCES(iptobs, count_profile, lobsSpaceData)
     endif

     if ( count_tb == 0 ) cycle  sensor_loop

     alloc_status(:)=0
     allocate ( surfem1          (count_tb) ,stat=alloc_status(2))
     allocate ( chanprof         (count_tb) ,stat=alloc_status(3))
     allocate ( emissivity_local (count_tb) ,stat=alloc_status(4))
     allocate ( calcemis         (count_tb) ,stat=alloc_status(5))
     if (luse_uwiremis) then
        allocate ( surfem2(count_tb)        ,stat=alloc_status(6) )
     endif
     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
        write(*,'(" tovs_rttov: arrays #2 memory allocation error")')
        call utl_abort('tovs_rttov')
     endif

!     get Hyperspectral IR emissivities

     if ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
        surfem1(:) = 0.
        if ( bgckMode ) then
           call EMIS_GET_IR_EMISSIVITY (SURFEM1,tvs_nchan(sensor_id),sensor_id,count_profile,count_tb,iptobs)
        else
           call TVS_GetHIREmissivities(sensor_id, iptobs, count_profile, lobsSpaceData, surfem1)
        end if
     end if

     if (  bgckMode .and. tvs_Is_Instrum_Hyperspectral(instrum) ) then
        ichn = 0
        Do profile_index = 1 , count_profile
           DO  channel_index = 1,tvs_nchan(sensor_id)
              ichn = ichn +1
              chanprof(ichn)%prof = profile_index
              chanprof(ichn)%chan = channel_index
           End Do
        End Do
     else
        call TVS_GET_CHANPROF(sensor_id, iptobs, count_profile, lobsSpaceData, chanprof)
     endif

     asw=1 ! 1 to allocate,0 to deallocate
       ! allocate transmitance structure

     call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
          nchanprof=count_tb,asw=asw,init=.true. )
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in transmittance allocation",rttov_err_stat
        call utl_abort('tovs_rttov')
     ENDIF

       ! allocate radiance structure

     call rttov_alloc_rad (rttov_err_stat,count_tb, radiancedata_d,nlevels,asw,init=.true.)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in radiance allocation",rttov_err_stat
        call utl_abort('tovs_rttov')
     ENDIF
      
     call TVS_GetOtherEmissivities(chanprof, iptobs, count_tb, sensor_type, instrum, surfem1, calcemis)

     if (luse_uwiremis .and. tvs_Is_Instrum_Hyperspectral(instrum) .and. bgckMode) then
        if (first) then
           if (.not. allocated (Atlas)) allocate(Atlas(tvs_nsensors))
           call rttov_setup_emis_atlas( rttov_err_stat,       &! out
                      opts(sensor_id),                        &! in
                      profiles(1)%date(2) ,                   &! in
                      atlas_type_ir,                          &! in
                      atlas(sensor_id),                       &! in
                      ir_atlas_ang_corr = .false.,            &! in
                      ir_atlas_read_std = .false.,            &! in
                      coefs = coefs(sensor_id)  )
           if (rttov_err_stat/=0) THEN
              Write(*,*) "Error in rttov_atlas_setup ",rttov_err_stat
              call utl_abort('tovs_rttov')
           ENDIF
           first=.false.
        endif

        call rttov_get_emis( rttov_err_stat    , &   ! out
             opts(sensor_id)                   , &   ! in
             chanprof(1:count_tb)              , &   ! in
             profiles(iptobs(1:count_profile)) , &   ! in
             coefs(sensor_id)                  , &   ! in
             Atlas(sensor_id)                  , &   ! in
             surfem2(1:count_tb)     ) ! out
       

           if (rttov_err_stat/=0) THEN
              Write(*,*) "Error in rttov_get_emis ",rttov_err_stat
              call utl_abort('tovs_rttov')
           ENDIF
              
           do profile_index=1,count_profile !loop on profiles
              jj = iptobs(profile_index)
              do tb_index=1,count_tb !loop on channels
                 if (chanprof(tb_index)%prof==profile_index) then
                   ! surftype: 0 land, 1 sea, 2 sea-ice
                   ! this logic is primitive and could be improved for example using
                   ! additional criteria based on emissivity_std and emissivity_flg
                   !Definition of emis_flag:
                   ! emis_flag:Flag_0 = "0 = sea, no MOD11 data" ;
                   ! emis_flag:Flag_1 = "1 = land where BF method was applied" ;
                   ! emis_flag:Flag_2 = "2 = land where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! emis_flag:Flag_3 = "3 = contains inland water or coastline by the sea/land mask where the BF method was used" ;
                   ! emis_flag:Flag_4 = "4 = contains inland water or coastline by the sea/land mask where data was filled with average original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! emis_flag:Flag_5 = "5 = contains coastline by land fraction where the BF method was used" ;
                   ! emis_flag:Flag_6 = "6 = contains coastline by land fraction where data was filled with average (original UWiremis bfemis_flag=2 or 3 or 4" ;
                   ! other information that could be useful for quality control can be found in the in the profile_qc structure
                   ! Now we have the "traditionnal" emissivity in surfem1(:)
                   ! and University of Wisconsin emissivity in surfem2(:)
                    if (profiles(jj)% skin % surftype == 0 .and. &
                         surfem2(tb_index)>0.5 ) then
                       emissivity_local(tb_index)%emis_in = surfem2(tb_index)
                    else
                       emissivity_local(tb_index)%emis_in = surfem1(tb_index)
                    endif
                 endif
              enddo
           enddo
        else
           emissivity_local(:)%emis_in = surfem1(:)
        endif
        
!     .  2.3  Compute radiance with rttov direct
!     .       ----------------------------------

        errorstatus = 0 
     
        call rttov_parallel_direct(       &
             errorstatus,                 & ! out
             chanprof,                    & ! in
             opts(sensor_id),             & ! in
             profiles(iptobs(1:count_profile)),  & ! in
             coefs(sensor_id),            & ! in
             transmission,                & ! inout
             radiancedata_d,              & ! inout
             calcemis=calcemis,           & ! in
             emissivity=emissivity_local, & ! inout
             nthreads=nthreads      )   

        if (errorstatus /= 0) then
           Write(*,*) "Error in rttov_parallel_direct",errorstatus
           call utl_abort('tovs_rttov')
        endif
                                                       
!     .  2.4  Store hx in the structure radiance_d
!     .       ------------------------------------

        do tb_index = 1, count_tb
           profile_index = chanprof(tb_index)%prof
           ichn = chanprof(tb_index)%chan
           obs_index = iptobs(profile_index)
           radiance_d(obs_index) % bt(ichn) =        &
                radiancedata_d % bt(tb_index)
           radiance_d(obs_index) % clear(ichn) =  &
                radiancedata_d %clear(tb_index)
           if ( bgckMode ) then
              do level_index = 1, nlevels - 1
                 radiance_d(obs_index) % overcast(level_index,ichn) =   &
                      radiancedata_d % overcast(level_index,tb_index)
              enddo
              do level_index = 1, nlevels
                 transmission_d(obs_index) % tau_levels(level_index,ichn) = &
                      transmission % tau_levels(level_index,tb_index)
              end do
              
              transmission_d(obs_index) % tau_total(ichn) = &
                   transmission % tau_total(tb_index)
              emissivity(ichn,obs_index) = emissivity_local(tb_index)%emis_out
              
           endif
 
        enddo

!     de-allocate memory
      
  
        asw=0 ! 1 to allocate,0 to deallocate
        ! transmittance deallocation
        call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
             nchanprof=count_tb,asw=asw )
        if (rttov_err_stat/=0) THEN
           Write(*,*) "Error in transmittance deallocation",rttov_err_stat
           call utl_abort('tovs_rttov')
        ENDIF
        ! radiance deallocation       
        call rttov_alloc_rad (rttov_err_stat,count_tb,radiancedata_d,nlevels,asw)
        if (rttov_err_stat/=0) THEN
           Write(*,*) "Error in radiance deallocation",rttov_err_stat
           call utl_abort('tovs_rttov')
        ENDIF
        
        alloc_status(:) = 0
        
        deallocate ( surfem1           ,stat=alloc_status(1) )
        deallocate ( chanprof          ,stat=alloc_status(2) )
        deallocate ( calcemis          ,stat=alloc_status(3) )
        deallocate ( emissivity_local  ,stat=alloc_status(4) )
        if (luse_uwiremis) then
           deallocate ( surfem2         ,stat=alloc_status(5) )
        endif

        if( any(alloc_status /= 0) ) then
           write(*,*) ' tovs_rttov: alloc_status = ', alloc_status(:)
           write(*,'(" tovs_rttov: arrays #2 memory deallocation error")')
           call utl_abort('tovs_rttov')
        end if

     enddo sensor_loop

!     2.5. AIRS, IASI and quality controls
!     .    ------------------------------

    ! moved to bgcheck.ftn90

     deallocate(iptobs)

end subroutine tovs_rttov
