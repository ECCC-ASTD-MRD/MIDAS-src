#!/bin/ksh

set -ex

## Voici les tests qu'il faudrait faire:
##   avec SQL:
##     -clipping horizontal standard
##     -clipping vertical (max seulement, min seulement, les deux)
##         -hPa  (ua)
##         -metres (pr,ro)
##         -canaux a garder
##         -canaux a enlever
##
##   avec BURP:
##     -clipping horizontal standard
##     -clipping avec les ni, nj
##
##   avec ASCII:
##     -clipping horizontal standard
##     -clipping avec les ni, nj, 
##     -clipping vertical (max seulement, min seulement, les deux)
##         -hPa  (ua)
##         -metres (pr,ro)
##         -canaux a garder
##         -canaux a enlever

if [ -z "$(which burp2rdb || true)" ]; then    
    set +xe
    . r.ssmuse.dot cmda
    set -ex
fi

DEBUG="oui"
DEBUG=""

clipobs=~afsderv/programs/ade.clipobs_burpvert/ade.clipobs_linux
clipobs=~afsderv/programs/bgck.clipobs/bgck.clipobs_linux
clipobs_ops=~afsiops/.ocm/regional/ovbin/i686/ade.clipobs
getlatlon=~afsderv/programs/ade.clipobs_burpvert/getlatlon.py

RDB_DBASE=$HOME/data/alef/clipobs/sql
DATE=2011021700
BANCO=$CMCADE/banco/derialt/r1
fstin=/data/dormrb04/arma/armaluc/public/lam4d_grids/grid_55km_649_672.fst
nomvar=TT

workdir=$HOME/data/alef/clipobs/$(date +%Y%m%d%H%M)
mkdir -pv ${workdir} ${RDB_DBASE}

cd ${workdir}

runclipobs () {

    set -ex

    clipobs_here=$1
    shift
    
    args=$*
    cat > gdbrunfile <<EOF
break ade.clipobs.c:brp_writerpt
run $args -fstin ${fstin} -nomvar ${nomvar}
EOF
    commande_debug="gdb ${clipobs_here} -x gdbrunfile"
    if [ -n "${DEBUG}" ]; then
#break ade.clipobs_regex.c:423
# on enleve les observations qui sortent du domaine
	${commande_debug}
    else
# on enleve les observations qui sortent du domaine
    ## ${obsclip} -fstin ${fstin} -nomvar ${nomvar} -burpin ${brpin} -burpout brpout_ninj
	## -fstin ${fstin} -nomvar ${nomvar} -burpin ${brpin} -burpout brpout_ninj -pilot 10 -max_i 20 -min_i 10 -min_j 10 -max_j 20
	set +e
	time ${clipobs_here} $args -fstin ${fstin} -nomvar ${nomvar}
	status=$?
	set -e
	echo "Voici la commande de debug:"
	echo -e "\n\ncd $PWD\n${commande_debug}\n\n"
	if [ $status -ne 0 ]; then
	    exit 1
	fi
    fi
} ## Fin de la fonction runclipobs

checkresult () {
    resultat=$1
    controle=$2

    burpdiff ${resultat} ${controle}
}

checkresult2 () {
    type=$1
    resultat=$2
    controle=$3
    
    ## "${type}" = SQL -o 
    if [ "${type}" = BURP ]; then
	liburp -enrgs $resultat | ${getlatlon} | sort -n > ${resultat}.latlon
	liburp -enrgs $controle | ${getlatlon} | sort -n > ${controle}.latlon

	set +e
	diff --report-identical-files ${resultat}.latlon ${controle}.latlon
	status=$?
	set -e
    elif [ "${type}" = SQL ]; then
	if [ ! -f sqldir ]; then
	    cat > sqldir <<EOF
.nullvalue NULL
.mode tabs
select id_stn,lat,lon,date,time,obsvalue,vcoord from header,data where data.id_obs=header.id_obs;
EOF
	fi
	
	cat sqldir | d.sqlite -noheader ${resultat} | sort -g > ${resultat}.sqllist
	cat sqldir | d.sqlite -noheader ${controle} | sort -g > ${controle}.sqllist

	set +e
	diff --report-identical-files ${resultat}.sqllist ${controle}.sqllist
	status=$?
	set -e

    elif [ "${type}" = ASCII ]; then
	set +e
	diff --report-identical-files $resultat $controle
	status=$?
	set -e
    else
	echo "Fonction checkresult: Le choix '$type' n'est pas parmi les choix possibles: SQL, BURP ou ASCII"
	exit 1
    fi

    if [ "${status}" -ne 0 ]; then
	echo "Les fichiers $resultat et $controle ne sont pas identiques!!!"
	## exit 1
    else
	echo "Les fichiers $resultat et $controle sont identiques!!!"
    fi
}


#for brpin in ${BANCO}/${DATE}_*; do
##     fam=$(basename $brpin | cut -d_ -f2-)
## for fam in ai airs go pr ro sc sf sw to_amsua to_amsub ua; do
for fam in to_amsub ua go pr ro sc sf sw ai to_amsua airs; do
    brpin=${BANCO}/${DATE}_${fam}
    if [ "$fam" = to_amsua ]; then
	typ=amsua
    elif [ "$fam" = to_amsub ]; then
	typ=amsub
    elif [ "$fam" = sc ]; then
	typ=scat
    else
	typ=$fam
    fi

    REGROUP=""
    DO_RESUME_WITH_RDB2BURP=""
    if [ "$typ" = amsua -o "$typ" = amsub -o "$typ" = airs -o "$typ" = ssmi ]; then
	REGROUP='-regrup'
    else
	DO_RESUME_WITH_RDB2BURP="-with-resume derialt"
    fi

    ## clipping en BURP
    runclipobs ${clipobs} -burpin ${brpin} -burpout $(basename $brpin).burpclip
    cp gdbrunfile gdbrunfile.$(basename ${brpin}).burp
    time burp2rdb -in $(basename $brpin).burpclip -out $(basename $brpin).burpclip.sql -type ${typ}
    
    if [ "${fam}" != to_amsua -a "${fam}" != to_amsub -a "${fam}" != airs -a "${fam}" != ssmi ]; then
	runclipobs ${clipobs_ops} -burpin ${brpin} -burpout $(basename $brpin).burpclip_ops
    fi

    ## clipping en SQL
    if [ ! -f ${RDB_DBASE}/rdb${typ} ]; then
	time burp2rdb -in ${brpin} -out ${RDB_DBASE}/rdb${typ} -type ${typ}
    fi
    rdbgen -f rdb${typ}_out -type $typ
    runclipobs ${clipobs} -rdbin ${RDB_DBASE}/rdb${typ} -rdbout rdb${typ}_out
    cp gdbrunfile gdbrunfile.$(basename ${brpin}).sql

    rdbgen -f rdb${typ}_out_ops -type $typ
    runclipobs ${clipobs_ops} -rdbin ${RDB_DBASE}/rdb${typ} -rdbout rdb${typ}_out_ops

    time rdb2burp -in rdb${typ}_out -out $(basename $brpin).sqlclip -type ${typ} ${REGROUP} ${DO_RESUME_WITH_RDB2BURP}
    if [ -z "${DO_RESUME_WITH_RDB2BURP}" ]; then
	editbrp -s ${brpin} -d $(basename $brpin).sqlclip -i<<EOF
 DESIRE('>>*******')
EOF
    fi
    time rdb2burp -in rdb${typ}_out_ops -out $(basename $brpin).sqlclip_ops -type ${typ} ${REGROUP} ${DO_RESUME_WITH_RDB2BURP}
    if [ -z "${DO_RESUME_WITH_RDB2BURP}" ]; then
	editbrp -s ${brpin} -d $(basename $brpin).sqlclip_ops -i<<EOF
 DESIRE('>>*******')
EOF
    fi

    if [ -n "${REGROUP}" ]; then
	burpfile=$(basename $brpin).burpclip.degrup
	sqlfile=$(basename $brpin).sqlclip.degrup
	degrup -s $(basename $brpin).burpclip -d ${burpfile}
	degrup -s $(basename $brpin).sqlclip  -d ${sqlfile}
    else
	burpfile=$(basename $brpin).burpclip
	sqlfile=$(basename $brpin).sqlclip
    fi
    checkresult2 BURP ${burpfile} ${sqlfile}
    checkresult2 SQL  $(basename $brpin).burpclip.sql rdb${typ}_out

    if [ -f $(basename $brpin).burpclip_ops ]; then
	if [ -n "${REGROUP}" ]; then
	    burpfile_ops=$(basename $brpin).burpclip_ops.degrup
	    degrup -s $(basename $brpin).burpclip_ops -d ${burpfile_ops}
	else
	    burpfile_ops=$(basename $brpin).burpclip_ops
	fi
	checkresult2 BURP ${burpfile_ops} ${burpfile}
    fi
    ## break;
done ## Fin du for brpin in ...
