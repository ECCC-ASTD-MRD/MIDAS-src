!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------


!--------------------------------------------------------------------------
! MODULE utilities_mod,(prefix="utl")
!
! Purpose: A utlity routines docker
!
! Subroutines:
!
! Dependencies:
!    none
!--------------------------------------------------------------------------
module utilities_mod
  implicit none
  save
  private

  ! public procedures
  public :: utl_EZUVINT, utl_EZGDEF, utl_CXGAIG, utl_FSTLIR, utl_FSTECR
  public :: utl_EZSINT, utl_EZSINT2, utl_findArrayIndex, utl_matSqrt
  public :: utl_writeStatus, utl_getfldprm, utl_abort

contains

  !--------------------------------------------------------------------------
  ! utl_EZUVINT
  !--------------------------------------------------------------------------
  function utl_EZUVINT(duuout, dvvout, duuin, dvvin, nio, nii) result(ierr)
    IMPLICIT NONE

    real*8 duuout(nio), dvvout(nio)
    real*4 duuin(nii) , dvvin(nii)
    integer iun, nio, nii

    integer ikey, ierr, ileni, ileno, jk1
    real, allocatable :: bufuuout4(:), bufvvout4(:)

    integer ezuvint
    external ezuvint

    allocate(bufuuout4(nio))
    allocate(bufvvout4(nio))

    ierr = ezuvint(bufuuout4, bufvvout4, duuin, dvvin)

    do jk1 = 1,nio
       duuout(jk1) = bufuuout4(jk1)
       dvvout(jk1) = bufvvout4(jk1)
    enddo

    deallocate(bufuuout4)
    deallocate(bufvvout4)

  end function utl_EZUVINT

  !--------------------------------------------------------------------------
  ! utl_EZGDEF
  !--------------------------------------------------------------------------
  FUNCTION utl_EZGDEF(ni, nj, grtyp, grtypref, ig1, ig2, ig3, ig4, ax, ay) result(vezgdef)
    IMPLICIT NONE

    integer vezgdef

    integer ni, nj, ig1, ig2, ig3, ig4
    real*8 ax(*), ay(*)
    character(len=*) :: grtyp, grtypref

    integer ier1,ier2,jk,ilenx,ileny
    real, allocatable :: bufax4(:), bufay4(:)

    integer ezgdef
    external ezgdef

    if      (grtyp .eq. 'Y') then
       ilenx=max(1,ni*nj)
       ileny=ilenx
    else if (grtyp .eq. 'Z') then
       ilenx=max(1,ni)
       ileny=max(1,nj)
    else
       write(*,'()') 'STOP in VEZGDEF: Grid type not supported'
       STOP
    endif

    allocate(bufax4(ilenx))
    allocate(bufay4(ileny))

    do jk = 1,ilenx
       bufax4(jk) = ax(jk)
    enddo
    do jk = 1,ileny
       bufay4(jk) = ay(jk)
    enddo

    ier2 = ezgdef(ni, nj, grtyp, grtypref, ig1, ig2, ig3, ig4, &
         bufax4, bufay4)

    deallocate(bufax4)
    deallocate(bufay4)

    vezgdef=ier2

  end FUNCTION utl_EZGDEF

  !--------------------------------------------------------------------------
  ! utl_CXGAIG
  !--------------------------------------------------------------------------
  SUBROUTINE utl_CXGAIG(grtyp, ig1, ig2, ig3, ig4, xlat0, xlon0, dlat, dlon) 
    IMPLICIT NONE

    integer ig1, ig2, ig3, ig4   
    real*8 xlat0, xlon0, dlat, dlon 
    character(len=*) :: grtyp 

    real xlat04, xlon04, dlat4, dlon4

    external cxgaig 

    xlat04=xlat0
    xlon04=xlon0
    dlat4=dlat
    dlon4=dlon

    call cxgaig(grtyp, ig1, ig2, ig3, ig4, xlat04, xlon04, dlat4, dlon4)

  end SUBROUTINE utl_CXGAIG

  !--------------------------------------------------------------------------
  ! utl_fstlir
  !--------------------------------------------------------------------------
  FUNCTION utl_FSTLIR(fld8, iun, ni, nj, nk, datev, etiket, &
       ip1, ip2, ip3, typvar, nomvar) result(vfstlir)
    IMPLICIT NONE

    integer vfstlir
    real*8 fld8(*)
    integer iun, ni, nj, nk, datev, ip1, ip2, ip3
    character(len=*) :: etiket
    character(len=*) :: nomvar
    character(len=*) :: typvar

    integer key1,key2, ierr, ilen, jk1, jk2, jk3, la
    real, allocatable :: buffer4(:)

    integer fstluk, fstinf
    external fstluk, fstinf

    !     Get field dimensions and allow memory for REAL copy of fld8.
    key1 = fstinf(iun, ni, nj, nk, datev, etiket, &
         ip1, ip2, ip3, typvar, nomvar)

    if(key1 >= 0) then
       ilen = ni*nj*nk
       allocate(buffer4(ilen))
       !     Read field
       key2 = fstluk(buffer4, key1, ni, nj, nk)
       if(key2 >= 0) then
          do jk3 = 1,nk
             do jk2 = 1,nj
                do jk1 = 1,ni
                   la=jk1+(jk2-1)*ni+(jk3-1)*ni*nj
                   fld8(la) = buffer4(la)
                enddo
             enddo
          enddo
       endif

       deallocate(buffer4)
    endif

    vfstlir=key1

  end FUNCTION utl_FSTLIR

  !--------------------------------------------------------------------------
  ! utl_fstecr
  !--------------------------------------------------------------------------
  FUNCTION utl_FSTECR(fld8, npak, iun, dateo, deet, &
       npas, ni, nj, nk, ip1, ip2, ip3, typvar, &
       nomvar, etiket, grtyp, ig1, ig2, ig3, ig4, & 
       datyp, rewrit) result(vfstecr)
    IMPLICIT NONE

    integer vfstecr
    real :: work
    integer, intent(in) :: ni,nj,nk
    real*8 fld8(ni,nj,nk)
    integer iun, datev, ip1, ip2, ip3, ig1, ig2, ig3, ig4
    integer npak, dateo, deet, npas, datyp
    logical :: rewrit  
    character(len=*) :: etiket 
    character(len=*) :: typvar
    character(len=*) :: grtyp 
    character(len=*) :: nomvar            

    integer ikey, ierr, jk1, jk2, jk3
    real, allocatable :: buffer4(:,:,:)

    integer fstecr
    external fstecr 

    allocate(buffer4(ni,nj,nk))

    do jk3 = 1,nk
       do jk2 = 1,nj
          do jk1 = 1,ni
             buffer4(jk1,jk2,jk3) = fld8(jk1,jk2,jk3)
          enddo
       enddo
    enddo

    ikey = fstecr(buffer4, work, npak, iun, dateo, deet, &
         npas, ni, nj, nk, ip1, ip2, ip3, typvar, nomvar, & 
         etiket, grtyp, ig1, ig2, ig3, ig4, datyp, rewrit)

    deallocate(buffer4)

    vfstecr=ikey

  end FUNCTION UTL_FSTECR

  !--------------------------------------------------------------------------
  ! utl_ezsint
  !--------------------------------------------------------------------------
  function utl_EZSINT(zout8, zin8, nio, njo, nko, nii, nji, nki) result(ierr)
    IMPLICIT NONE

    integer nii, nji, nki, nio, njo, nko     
    real*8 zout8(nio,njo,nko),zin8(nii,nji,nki)

    integer ierr, jk1, jk2, jk3
    real, allocatable :: bufferi4(:,:,:), buffero4(:,:,:)

    integer ezsint
    external ezsint

    allocate(bufferi4(nii,nji,nki))
    allocate(buffero4(nio,njo,nko))

    do jk3 = 1,nki
       do jk2 = 1,nji
          do jk1 = 1,nii
             bufferi4(jk1,jk2,jk3) = zin8(jk1,jk2,jk3)
          enddo
       enddo
    enddo

    ierr = ezsint(buffero4,bufferi4)

    do jk3 = 1,nko
       do jk2 = 1,njo
          do jk1 = 1,nio
             zout8(jk1,jk2,jk3) = buffero4(jk1,jk2,jk3)
          enddo
       enddo
    enddo

    deallocate(bufferi4)
    deallocate(buffero4)

  end function utl_EZSINT

  !--------------------------------------------------------------------------
  ! utl_ezsint2
  !--------------------------------------------------------------------------
  function utl_EZSINT2(zout8, zin4, nio, njo, nko, nii, nji, nki)  result(ierr)
    IMPLICIT NONE

    integer nii, nji, nki, nio, njo, nko     
    real*8 zout8(nio,njo,nko)
    real*4 zin4(nii,nji,nki)

    integer ierr, jk1, jk2, jk3
    real, allocatable :: buffero4(:,:,:)

    integer ezsint
    external ezsint

    allocate(buffero4(nio,njo,nko))

    ierr = ezsint(buffero4,zin4)

    do jk3 = 1,nko
       do jk2 = 1,njo
          do jk1 = 1,nio
             zout8(jk1,jk2,jk3) = buffero4(jk1,jk2,jk3)
          enddo
       enddo
    enddo

    deallocate(buffero4)

  end function utl_EZSINT2

  !--------------------------------------------------------------------------
  ! utl_findArrayIndex
  !--------------------------------------------------------------------------
  FUNCTION utl_findArrayIndex(KLIST, KLEN, KENTRY) result(isrcheq)
    implicit none
    !
    ! Find entry in list.
    !
    ! Arguments
    !     i   KLIST   : List.
    !     i   KLEN    : Dimension of list.
    !     i   KENTRY  : Entry.
    !     O   ISRCHEQ : Index of entry: (0, not found, >0, found)

    INTEGER :: ISRCHEQ
    INTEGER :: KENTRY, KLEN, JI
    INTEGER :: KLIST(KLEN)

    ISRCHEQ = 0
    DO JI=1,KLEN
       IF ( KLIST(JI) .EQ. KENTRY ) THEN
          ISRCHEQ = JI
          RETURN
       ENDIF
    ENDDO

  END FUNCTION UTL_FINDARRAYINDEX

  !--------------------------------------------------------------------------
  ! utl_matSqrt
  !--------------------------------------------------------------------------
  SUBROUTINE utl_MATSQRT(PA,KN,ZSIGN,print_information)
    !
    !**s/r MATSQRT     - Calculate square root of an error covariance
    !     .              matrix
    !
    ! Arguments
    !     .  PA(KN,KN)     :  on entry, the original matrix
    !     .                   on exit,  the sqrt     matrix
    !     .  KN            : order of the matrix
    IMPLICIT NONE
    !
    ! Arguments
    !
    INTEGER, intent(in) :: KN
    REAL(8), intent(inout) :: PA(KN,KN)
    REAL(8), intent(in) ::ZSIGN
    LOGICAL, intent(in) :: print_information
    !
    ! Local variables
    !
    INTEGER JI, J, INFO, IER, IWORK
    REAL*8 size_zwork
    REAL*8, allocatable :: ZWORK(:), ZRESULT(:,:), ZEIGENV2(:,:), ZEIGEN(:,:), ZEIGENV(:)

    if (print_information) then
       WRITE(*,*)' MATSQRT-Sqrt matrix of a symmetric matrix'
       WRITE(*,*)' zsign= ',zsign
       WRITE(*,*)'  -----------------------------------------------'
    end if
    !
    !     1. Computation of eigenvalues and eigenvectors
    !
    allocate(ZRESULT(KN,KN))
    allocate(ZEIGEN(KN,KN))
    allocate(ZEIGENV2(KN,KN))
    allocate(ZEIGENV(KN))

    DO JI=1,KN
       DO J=1,KN
          ZEIGEN(JI,J)=PA(JI,J)
       END DO
    END DO

    !! query the size of the 'zwork' vector by calling 'DSYEV' with 'iwork=-1'
    iwork=-1
    info = -1
    CALL DSYEV('V','U',KN, ZEIGEN,KN, ZEIGENV,size_ZWORK, IWORK, INFO )

    iwork=int(size_zwork)
    allocate(zwork(iwork))
    !! compute the eigenvalues
    CALL DSYEV('V','U',KN, ZEIGEN,KN, ZEIGENV,ZWORK, IWORK, INFO )
    deallocate(zwork)
    !
    if (print_information) then
       WRITE(*,'(1x,"ORIGINAL EIGEN VALUES: ")')
       WRITE(*,'(1x,10f7.3)') (ZEIGENV(JI),JI=1,KN)
    end if
    !
    !     2.  Take SQRT of eigenvalues
    !
    DO JI=1,KN
       DO J=1,KN
          ZEIGENV2(JI,J)= 0.0d0
       END DO
    END DO
    DO JI=1,KN
       ZEIGENV2(JI,JI)= ZEIGENV(JI)**(0.5d0*ZSIGN)
    END DO
    !
    if (print_information) then
       WRITE(*,'(1x,"SQRT OF ORIGINAL EIGEN VALUES: ")')
       WRITE(*,'(1x,10f7.3)') (ZEIGENV2(JI,JI),JI=1,KN)
    end if
    !
    IF (ZSIGN < 0. .and. print_information) THEN
       Write(*,'(A,1x,e14.6)') "Condition number:", &
            maxval(ZEIGENV)/minval(ZEIGENV)
    ENDIF
    CALL DGEMM('N','N',KN,KN,KN,1.0d0,ZEIGEN,KN,ZEIGENV2,KN, &
         0.0D0 ,ZRESULT,KN)

    CALL DGEMM('N','T',KN,KN,KN,1.0D0,ZRESULT,KN,ZEIGEN,KN, &
         0.0d0,PA,KN)


    !
    !     4. Deallocate local arrays
    !
    deallocate(ZRESULT,ZEIGEN,ZEIGENV2,ZEIGENV)

    if (print_information) then
       WRITE(*,*)'MATSQRT-----------Done--------------- '
       WRITE(*,*)' '
    end if

  END SUBROUTINE UTL_MATSQRT

  !--------------------------------------------------------------------------
  ! utl_writeSratus
  !--------------------------------------------------------------------------
  subroutine utl_writeStatus(cmsg)
    implicit none
    INTEGER  iulstatus,fnom,fclos, ierr
    character(len=*) :: cmsg
    character(len=22):: clmsg
    
    clmsg='VAR3D_STATUS='//cmsg
    iulstatus = 0
    IERR =  FNOM(iulstatus,'VAR3D_STATUS.dot','SEQ+FMT',0)
    rewind (iulstatus)
    WRITE(iulstatus,'(a22)') clmsg
    ierr = fclos(iulstatus)
    
  end subroutine utl_writeStatus

  subroutine utl_getfldprm(kip1s,kip2,kip3,knlev,cdetiket,cdtypvar,kgid, &
                           cdvar,kstampv,knmaxlev,kinmpg,kip1style,kip1kind, &
                           ktrials,koutmpg)
    implicit none

    integer kstampv,knmaxlev,knlev,kgid
    integer kip1s(knmaxlev),kip1style,kip1kind,kip2,kip3
    integer ktrials, koutmpg  
    integer kinmpg(ktrials)
    character(len=*) :: cdtypvar
    character(len=*) :: cdvar
    character(len=*) :: cdetiket

    !
    !*    Purpose: Get 3D grid parameters for a specific trial field
    !              and check for consitancies between grid parameters
    !              of the levels.
    !
    !Arguments
    !
    ! Input:
    !     cdvar   : variable name to get the vertical levels from
    !     kstampv : valid date time stamp of the variable
    !     knmaxlev: maximum number of levels
    !     kinmpg  : file unit of trial field
    !     ktrials :  number of trial files.  
    !
    ! Output:
    !     kip1s(knmaxlev) : list of ip1s of variable cdvar
    !     kip2            : ip2 for variable cdvar
    !     kip3            : ip3 for variable cdvar
    !     knlev           : number of levels of variable cdvar
    !     cdetiket        : etiket of field cdvar
    !     cdtypvar        : typvar of field cdvar
    !     kgid            : handle of the field descriptor
    !     kip1style       : style in which ip1 is encoded (15 or 31 bits)
    !     kip1kind        : kind of vertical coord encoded in ip1
    !     koutmpg         :  the unit which contains the selected records.  
    !

    integer fstinl,fstprm,ezqkdef,newdate
    integer ini,inj,ink,jlev,ier
    integer idateo, idateo2, idatyp, idatyp2, ideet, ideet2, idltf, &
         iextra1, iextra2, iextra3, iig12, iig22, &
         iig32, iig42, ilng, inbits,iig1,iig2,iig3,iig4, &
         inpas,inpas2, iswa, iubc, iip2, iip3
    !
    integer ipmode,idate2,idate3,idatefull
    integer k,ier1 
    real    zlev_r4
    character *12 cletiket
    character *4 clnomvar
    character *3 clnomvar_3
    character *2 cltypvar
    character *1 clgrtyp2,clgrtyp,clstring
    logical llflag
    integer ikeys(knmaxlev)
    !
    knlev = 0
    !
    do k=1,ktrials
       if(cdvar.eq.'U1') then
          clnomvar_3='UT1'
          ier = fstinl(kinmpg(k),INI,INJ, INK, kstampv, ' ', -1, -1, -1, &
               ' ',clnomvar_3,ikeys, knlev, knmaxlev)
       else if(cdvar.eq.'V1') then
          clnomvar_3='VT1'
          ier = fstinl(kinmpg(k),ini,inj, ink, kstampv, ' ', -1, -1, -1, &
               ' ',clnomvar_3,ikeys, knlev, knmaxlev)
       else
          ier = fstinl(kinmpg(k),INI,INJ, INK, kstampv, ' ', -1, -1, -1, &
               ' ',cdvar,IKEYS, KNLEV, knmaxlev)
       endif
       !
       if(knlev > 0 ) then
          ier1   = newdate(kstampv,idate2,idate3,-3)

          idatefull = idate2*100 + idate3/1000000
          idateo = -9999
          ideet = -9999
          inpas = -9999
          cdetiket = '-9999999'
          clgrtyp = '-'
          kip2 = -9999
          kip3 = -9999
          cdtypvar = '-'
          idatyp = -9999
          iig1 = -9999
          iig2 = -9999
          iig3 = -9999
          iig4 = -9999
          llflag = .true.
          koutmpg = kinmpg(k) 
          exit 
       endif
    enddo !! End of loop k   
    !
    if (knlev.gt.0) then
       do jlev = 1, knlev
          ier = fstprm(ikeys(jlev), idateo2, ideet2, inpas2, ini, inj, &
               ink,inbits,idatyp2, kip1s(jlev),iip2, iip3, &
               cltypvar,clnomvar,cletiket,clgrtyp2, iig12, iig22,iig32 &
               ,iig42,iswa,ilng,idltf,iubc,iextra1, iextra2, iextra3)
          llflag = (llflag.and.(idateo.eq.idateo2.or.idateo.eq.-9999))
          llflag = (llflag.and.(ideet.eq.ideet2.or.ideet.eq.-9999))
          llflag = (llflag.and.(inpas.eq.inpas2.or.inpas.eq.-9999))
          !          llflag = (llflag.and.(cdetiket.eq.cletiket.or.cdetiket.eq.
          !     &         '-9999999'))
          llflag = (llflag.and.(clgrtyp.eq.clgrtyp2.or.clgrtyp.eq.'-'))
          llflag = (llflag.and.(kip2.eq.iip2.or.kip2.eq.-9999))
          llflag = (llflag.and.(kip3.eq.iip3.or.kip3.eq.-9999))
          llflag = (llflag.and.(cdtypvar.eq.cltypvar.or.cdtypvar.eq.'-'))
          llflag = (llflag.and.(idatyp.eq.idatyp2.or.idatyp.eq.-9999))
          llflag = (llflag.and.(iig1.eq.iig12.or.iig1.eq.-9999))
          llflag = (llflag.and.(iig2.eq.iig22.or.iig2.eq.-9999))
          llflag = (llflag.and.(iig3.eq.iig32.or.iig3.eq.-9999))
          llflag = (llflag.and.(iig4.eq.iig42.or.iig4.eq.-9999))
          if (llflag) then
             idateo = idateo2
             ideet = ideet2
             inpas = inpas2
             cdetiket = cletiket
             clgrtyp = clgrtyp2
             kip2 = iip2
             kip3 = iip3
             cdtypvar = cltypvar
             idatyp = idatyp2
             iig1 = iig12
             iig2 = iig22
             iig3 = iig32
             iig4 = iig42
          else
             write(*,*) &
                  '****** Unit ', kinmpg &
                  ,' contains mixed dateo,deet,npas,etiket,grtyp,ip2,ip3' &
                  ,',typvar,datyp,ig1,ig2,ig3 and/or ig4 ' &
                  ,'for variable ',cdvar,' and datev, ',kstampv
             call utl_abort('GETFLDPRM2')
          endif
       enddo
       !
       kgid = ezqkdef(ini,inj,clgrtyp,iig1,iig2,iig3,iig4,koutmpg)
       !
       !-------Determine the style in which ip1 is encoded (15bits or 31 bits)
       !       A value <= 32767 (2**16 -1)  means that ip1 is compacted in 15 bits
       !       Determine the type of P which was encoded in IP1
       !
       if(kip1s(1) .le. 32767) then
          kip1style = 3
       else
          kip1style = 2
       endif
       !
       !-------Determine the type of P  (see doc. of convip)
       !
       ipmode = -1
       call CONVIP(kip1s(1),zlev_r4,KIP1KIND, &
            ipmode,clstring, .false. )
    else
       do k=1,ktrials
          ier = fstinl(kinmpg(k),ini,inj, ink, -1, ' ', -1, -1, -1, &
               ' ',cdvar,ikeys, knlev, knmaxlev)
       enddo
       write(*,*) 'Error - getfldprm2: no record found at time ' &
            ,idatefull,' for field ',cdvar,' but',knlev, &
            ' records found in unit ',kinmpg(k)
       call utl_abort('GETFLDPRM2')
    endif
    !
  end subroutine utl_getfldprm

  !--------------------------------------------------------------------------
  ! utl_abort
  !--------------------------------------------------------------------------
  subroutine utl_abort(message)
    
    implicit none
    character(len=*) :: message
    integer :: comm, ierr, rpn_comm_comm
    
    write(6,9000) message
9000 format(//,4X,"!!!---ABORT---!!!",/,8X,"VAR stopped in ",A)
    call flush(6)

    comm = rpn_comm_comm("WORLD")
    call mpi_abort( comm, 1, ierr )

  end subroutine utl_abort
  
end module utilities_mod
