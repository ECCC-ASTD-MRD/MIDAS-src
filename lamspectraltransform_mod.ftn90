!--------------------------------------------------------------------------
! > MODULE LamSpectralTransform (prefix="lst")
!
! - Subroutines
!    lst_Setup        (public)
!    lst_VarTransform (public)
!    lst_Laplacian    (public)
!    lst_ReshapeTrunc
!
! - Public variables
!    struct_lst
!
! - Dependencies
!    ffft8 and setfft8 routines in ARMNLIB
!--------------------------------------------------------------------------
module LamSpectralTransform_mod
  use mpivar_mod
  use MathPhysConstants_mod, only: MPC_RADIANS_PER_DEGREE_R8, MPC_PI_R8
  use earthconstants_mod,    only: RA
  implicit none
  save
  private

  ! public derived type
  public :: struct_lst
  ! public procedures
  public :: lst_Setup, lst_Laplacian, lst_VarTransform
  public :: lst_ReshapeTrunc

  type :: struct_lst
     integer              :: id              ! Transform ID number
     integer              :: nla             ! First dimension of VAR spectral array
     integer              :: nphase          ! Second dimension of VAR spectral array
     integer, allocatable :: k(:)            ! Total Wavenumber associated with each
                                             !  nla spectral coefficient
     integer, allocatable :: m(:)            ! Wavenumber in x associated with each
                                             !  nla spectral coefficient
     integer, allocatable :: n(:)            ! Wavenumber in y associated with each
                                             !  nla spectral coefficient
     real(8), allocatable :: Weight(:)       ! Weight associated with each
                                             !  nla spectral coefficient
     integer, allocatable :: nePerK(:)       ! Number of spectral element in each
                                             !  total wavenumber bands
     integer, allocatable :: ilaFromEK(:,:)  ! ila index associated to each spectral element
                                             !  of total wavenumber band
     real(8), allocatable :: NormFactor(:,:)
     real(8), allocatable :: NormFactorAd(:,:)
     integer              :: nlaGlobal       ! First dimension of VAR global spectral array
     integer, allocatable :: ilaGlobal(:)    ! Position of the local vector element in the global
                                             !  vector
  end type struct_lst

  type :: struct_lst_local
     integer                         :: ni
     integer                         :: nj
     integer                         :: mmax, nmax
     integer                         :: ktrunc
     integer                         :: nla
     integer                         :: nlaGlobal
     integer                         :: mymBeg, mymEnd, mymSkip, mymCount, maxmCount
     integer, allocatable            :: nla_Index(:,:)
     real(8), allocatable            :: lapxy(:)
     real(8), allocatable            :: ilapxy(:)
     integer, allocatable            :: allmBeg(:), allmEnd(:), allmSkip(:)
     integer, allocatable            :: mymIndex(:)
     logical                         :: allocated = .false.
     integer                         :: latPerPE, myLatBeg, myLatEnd
     integer                         :: myLevBeg, myLevEnd, myLevCount, maxLevCount
     integer, allocatable            :: allLevBeg(:) ,allLevEnd(:)
     character(len=10)               :: MpiMode
  end type struct_lst_local

  integer,parameter      :: nMaxLst = 10
  integer                :: nLstAlreadyAllocated = 0
  type(struct_lst_local) :: lst(nMaxLst)

  character(len=*), parameter     :: TransformType = 'SinCos'
  integer, parameter              :: nip = 2     ! Padding
  integer, parameter              :: njp = 2     ! Padding
  integer, parameter              :: nphase = 4  ! For Sin&Cos we have a) sin(m)sin(n)
                                                 !                     b) cos(m)cos(n)
                                                 !                     c) sin(m)cos(n)
                                                 !                     d) cos(m)sin(n)

contains

!--------------------------------------------------------------------------
! LST_SETUP
!--------------------------------------------------------------------------
  subroutine lst_Setup( lst_out, ni_in, nj_in, dlon_in, ktrunc_in,    &
                        MpiMode, maxlevels_in )
    implicit none

    integer,          intent(in)    :: ni_in, nj_in    
                                     ! Global Grid point data horizontal dimensions
    character(len=*), intent(in)    :: MpiMode
                                     ! MPI Strategy
    real(8),          intent(in)    :: dlon_in
                                     ! Grid Spacing in Radians
    integer,          intent(in)    :: ktrunc_in
                                     ! Spectral Truncation (global)
    integer, intent(in), optional   :: maxlevels_in
                                     ! Number of levels; Only needed when MpiMode = LatLev
    type(struct_lst), intent(out)   :: lst_out
                                     ! Parameters available to the outside world

    integer, allocatable            :: KfromMN(:,:)
    integer, allocatable            :: KfromMNglb(:,:)
    integer                         :: kmax, id
    integer                         :: m, n, k, ila, nfact
    integer                         :: ier, ilaglb, i, j, p
    real(8)                         :: a, b, r
    real(8)                         :: dlon, dx2, fac, ca, cp, cb, cq
    real(8)                         :: NormFactor1, NormFactor2, NormFactor3
    real(8)                         :: NormFactorAd1, NormFactorAd2, NormFactorAd3
    real(8)                         :: factor, factorAd

    !
    !- 1.  Set variables needed by the LAM Spectral Transform in VAR
    !
    nLstAlreadyAllocated = nLstAlreadyAllocated + 1
    if (nLstAlreadyAllocated <= nMaxLst) then
       id = nLstAlreadyAllocated
       lst_out % id = id
       print*
       print*,"lst_setup: Setting transform id = ",id
    else
       print*
       print*,"lst_setup: Too many Spectral Transforms!!!"
       stop
    end if

    lst(id) % ni = ni_in
    lst(id) % nj = nj_in
    lst(id) % ktrunc = ktrunc_in

    !  1.1 Check grid dimensions and set padding for the RPN DFT routines

    ! We need to padd the input array such as ...                              
    ! O O O O O O O O O
    ! O O O O O O O O O
    ! X X X X X X X O O
    ! X X X X X X X O O
    ! X X X X X X X O O
    ! X X X X X X X O O

    if (mod(lst(id) % ni,2) /= 0 .and. mod(lst(id) % nj,2) /= 0) then
       write(6,*) ' The regular Sin & Cos Transform requires that', &
                  ' dimensions be EVEN. Fields MUST be periodic' , &
                  ' but the last colum and row MUST NOT BE a '   , &
                  ' repetition of the first colum and row. '
       stop
    end if

    nfact = lst(id) % ni
    call ngfft( nfact ) ! INOUT
    if ( nfact /= lst(id) % ni ) then
       write(6,*) 'Error: A fast transform cannot be used in X'
       write(6,6130) lst(id) % ni, nfact
       stop
    end if

    nfact = lst(id) % nj
    call ngfft( nfact ) ! INOUT
    if ( nfact /= lst(id) % nj ) then
       write(6,*) 'Error: A fast transform cannot be used in Y'
       write(6,6140) lst(id) % nj, nfact
       stop
    end if

6130 FORMAT('N = ni = ', I4,' the nearest factorizable N = ',I4)
6140 FORMAT('N = nj = ', I4,' the nearest factorizable N = ',I4)

    !  1.2 Set the number of phases
    lst_out % nphase = nphase

    !- 1.3 Maximum of integer wavenumbers in x and y directions
    lst(id) % mmax = lst(id) % ni/2
    lst(id) % nmax = lst(id) % nj/2

    if      ( lst(id) % ktrunc > nint(sqrt(real(lst(id) % mmax)**2+real(lst(id) % nmax)**2)) ) then
      write(6,*)
      write(6,*) 'lst_Setup: Warning: Truncation is larger than sqrt(mmax^2+nmax^2)'
      write(6,*) '           NO TRUNCATION will be applied'
    else if ( lst(id) % ktrunc > min(lst(id) % mmax,lst(id) % nmax) ) then
      write(6,*)
      write(6,*) 'lst_Setup: Warning: Truncation is larger than min(mmax,nmax)'
      write(6,*) '           TRUNCATION will be applied only above mmax and/or nmax'
    else
      write(6,*)
      write(6,*) 'lst_Setup: TRUNCATION will be applied above k = ',lst(id) % ktrunc
    end if

    !- 1.4 MPI Strategy

    lst(id) % MpiMode = MpiMode
    select case ( trim(lst(id) % MpiMode) )
    case ('NoMpi')
       ! range of lats handled by this processor (ALL)
       lst(id) % latPerPE   = lst(id) % nj
       lst(id) % myLatBeg   = 1
       lst(id) % myLatEnd   = lst(id) % nj

       ! range of m handled by this processor (ALL)
       lst(id) % mymBeg     = 0
       lst(id) % mymEnd     = lst(id) % mmax
       lst(id) % mymSkip    = 1
       lst(id) % mymCount   = lst(id) % mmax + 1

       ! set a dummy range of levels handled by this processor
       lst(id) % myLevBeg   = -1
       lst(id) % myLevEnd   = -1
       lst(id) % myLevCount = 0

    case ('LatM')
       ! range of lats handled by this processor
       call mpivar_setup_latbands( lst(id) % nj,                                           & ! IN
                                   lst(id) % latPerPE,lst(id) % myLatBeg,lst(id) % myLatEnd) ! OUT

       ! range of m handled by this processor
       call mpivar_setup_m( lst(id) % mmax,                                                           & ! IN
                            lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip, lst(id) % mymCount ) ! OUT

       ! set a dummy range of levels handled by this processor
       lst(id) % myLevBeg   = -1
       lst(id) % myLevEnd   = -1
       lst(id) % myLevCount = 0

    case ('LatLev')   
       ! range of lats handled by this processor
       call mpivar_setup_latbands( lst(id) % nj,                                           & ! IN
                                   lst(id) % latPerPE,lst(id) % myLatBeg,lst(id) % myLatEnd) ! OUT

       ! range of m handled by this processor (ALL)
       lst(id) % mymBeg     = 0
       lst(id) % mymEnd     = lst(id) % mmax
       lst(id) % mymSkip    = 1
       lst(id) % mymCount   = lst(id) % mmax + 1

       ! range of levels handled by this processor
       if ( .not.present(maxlevels_in) ) then
        write(*,*)
        write(*,*) 'lst_setup: ERROR, number of levels must be specified with MpiMode LatLev'
        stop
      end if
      call mpivar_setup_levels( maxlevels_in,                                              & ! IN
                                lst(id) % myLevBeg,lst(id) % myLevEnd,lst(id) % myLevCount ) ! OUT

    case default
       print*
       print*,'Error: MpiMode Unknown ', trim(MpiMode)
       stop
    end select

    print*
    print*,' Je suis le processeur ', mpi_myid+1, ' sur un total de ', mpi_nprocs
    print*,'          mband info = ', lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip, lst(id) % mymCount 
    print*,'          level info = ', lst(id) % myLevBeg, lst(id) % myLevEnd, lst(id) % myLevCount
    
    allocate(lst(id) % mymIndex(lst(id) %mymBeg:lst(id) %mymEnd))
    lst(id) % mymIndex(:)=0
    do m = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
      if (m == lst(id) % mymBeg ) then
        lst(id) % mymIndex(m) = 1
      else
        lst(id) % mymIndex(m) = lst(id) % mymIndex(m-lst(id) % mymSkip) + 1
      end if
      write(*,*) 'lst_setup: mymIndex(',m,')=',lst(id) % mymIndex(m)
    end do

    if ( trim(lst(id) % MpiMode) /= 'NoMpi') then
      call rpn_comm_allreduce(lst(id) % mymCount,lst(id) % maxmCount, &
                                1,"MPI_INTEGER","MPI_MAX","GRID",ier)
      if ( mpi_myid == 0 ) print*,'MaxmCount =',lst(id) % maxmCount

      allocate(lst(id) % allmBeg(mpi_nprocs))
      call rpn_comm_allgather(lst(id) % mymBeg ,1,"mpi_integer",       &
                              lst(id) % allmBeg,1,"mpi_integer","GRID",ier)
      if ( mpi_myid == 0 ) print*,'AllmBeg =', lst(id) % allmBeg(:)

      allocate(lst(id) % allmEnd(mpi_nprocs))
      call rpn_comm_allgather(lst(id) % mymEnd ,1,"mpi_integer",       &
                              lst(id) % allmEnd,1,"mpi_integer","GRID",ier)
      if ( mpi_myid == 0 ) print*,'allmEnd =', lst(id) % allmEnd(:)
    
      allocate(lst(id) % allmSkip(mpi_nprocs))
      call rpn_comm_allgather(lst(id) % mymSkip ,1,"mpi_integer",       &
                              lst(id) % allmSkip,1,"mpi_integer","GRID",ier)
      if ( mpi_myid == 0 ) print*,'allmSkip = ', lst(id) % allmSkip(:)

      call rpn_comm_allreduce(lst(id) % myLevCount,lst(id) % maxLevCount, &
                                1,"MPI_INTEGER","MPI_MAX","GRID",ier)
      if ( mpi_myid == 0 ) print*,'MaxLevCount =',lst(id) % maxLevCount

      allocate(lst(id) % allLevBeg(mpi_nprocs))
      call rpn_comm_allgather(lst(id) % myLevBeg ,1,"mpi_integer",       &
                              lst(id) % allLevBeg,1,"mpi_integer","GRID",ier)
      if ( mpi_myid == 0 ) print*,'AllLevBeg =', lst(id) % allLevBeg(:)

      allocate(lst(id) % allLevEnd(mpi_nprocs))
      call rpn_comm_allgather(lst(id) % myLevEnd ,1,"mpi_integer",       &
                              lst(id) % allLevEnd,1,"mpi_integer","GRID",ier)
      if ( mpi_myid == 0 ) print*,'AllLevEnd =', lst(id) % allLevEnd(:)
    end if

    !- 1.5 Compute the Total Wavenumber associated with weach m,n pairs and
    !      the number of spectral element in the VAR array (nla) 
    !      FOR THE LOCAL PROCESSOR
    allocate( KfromMN(0:lst(id) % mmax,0:lst(id) % nmax) )
    KFromMN(:,:) = -1

    ! We follow here the method described in Denis et al., MWR, 2002
!    kmax = min(mmax,nmax)
    kmax=max(lst(id) % ni-1,lst(id) % nj-1)

    ila = 0
    do n = 0, lst(id) % nmax
      do m = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
!        a = real(m*kmax,8)/real(mmax,8)
!        b = real(n*kmax,8)/real(nmax,8)
         a = real(m,8)/real(lst(id) % ni-1,8)
         b = real(n,8)/real(lst(id) % nj-1,8)
!         r = sqrt( (a**2) + (b**2) )   ! Ellipse Shape if nmax /= mmax
!        k = ceiling(r)
         r = kmax * sqrt( (a**2) + (b**2) )
         k = nint(r)

        if ( k <= lst(id) % ktrunc ) then
          ila = ila +1
          KFromMN(m,n) = k
       end if
      end do
    end do

    lst(id) % nla      = ila
    lst_out % nla = lst(id) % nla ! Number of spectral element per phase in the VAR array

    if ( trim(lst(id) % MpiMode) /= 'NoMpi') then
       call rpn_comm_allreduce(lst(id) % nla,lst(id) % nlaGlobal,1,"mpi_integer","mpi_sum","GRID",ier)
       lst_out % nlaGlobal = lst(id) % nlaGlobal ! Number of spectral element per phase in the VAR global array
    else
       lst_out % nlaGlobal = lst(id) % nla
    end if

    allocate( KfromMNglb(0:lst(id) % mmax,0:lst(id) % nmax) )
    KFromMNglb(:,:) = KFromMN(:,:)
    if ( trim(lst(id) % MpiMode) /= 'NoMpi') then
      call rpn_comm_allreduce(KFromMNglb,KFromMNglb, &
                                (lst(id) % mmax+1)*(lst(id) % nmax+1),"MPI_INTEGER","MPI_MAX","GRID",ier)
    end if

    !- 1.6 VAR spectral element ordering &
    !      Total Wavenumbers and Weights associated with each spectral element
    !      FOR THE LOCAL PROCESSOR
    allocate( lst(id) % nla_Index(0:lst(id) % mmax,0:lst(id) % nmax) )

    allocate( lst_out % k(1:lst_out % nla) )
    allocate( lst_out % m(1:lst_out % nla) )
    allocate( lst_out % n(1:lst_out % nla) )
    allocate( lst_out % Weight(1:lst_out % nla) )
    allocate( lst_out % nePerK(0:lst(id) % ktrunc))
    allocate( lst_out % ilaFromEK(1:lst_out % nla,0:lst(id) % ktrunc))
    allocate( lst_out % ilaGlobal(1:lst_out % nla) )

    lst(id) % nla_Index(:,:) = -1
    lst_out % ilaFromEK(:,:) = -1
    lst_out % NEPerK(:)      =  0

    ila    = 0
    ilaglb = 0
    do n = 0, lst(id) % nmax
       do m = 0, lst(id) % mmax
        k    = KfromMN(m,n)

        if ( KfromMNglb(m,n) /= -1 ) ilaglb = ilaglb + 1 ! Global Index

        if ( k /= -1 ) then
          ila = ila+1

          ! Internal index
          lst(id) % nla_Index(m,n) = ila

          ! Outgoing (public) variables
          lst_out % nePerK(k) = lst_out % nePerK(k) + 1
          lst_out % ilaFromEK(lst_out % nePerK(k),k) = ila
          lst_out % k(ila) = k
          lst_out % m(ila) = m
          lst_out % n(ila) = n
          lst_out % ilaGlobal(ila) = ilaglb

          ! Spectral coefficient weight associated with this index
          if ( m == 0 .and. n == 0) then
            lst_out % Weight(ila) = 1.0d0
          else if (m /= 0 .and. n /= 0) then
            lst_out % Weight(ila) = 4.0d0
          else
            lst_out % Weight(ila) = 2.0d0
          end if

       end if

      end do
    end do

    deallocate( KfromMN )
    deallocate( KfromMNglb )

    !
    !- 3.  Set factors for parseval identity
    !
    allocate( lst_out % NormFactor  (lst(id) % nla,nphase))
    allocate( lst_out % NormFactorAd(lst(id) % nla,nphase))

    Normfactor1   = 1.0d0
    Normfactor2   = 0.5d0 * sqrt(2.0d0)
    Normfactor3   = 0.5d0
    NormfactorAd1 =      1.0d0  * real((lst(id) %ni * lst(id) %nj),8)
    NormfactorAd2 = sqrt(2.0d0) * real((lst(id) %ni * lst(id) %nj),8)
    NormfactorAd3 =      2.0d0  * real((lst(id) %ni * lst(id) %nj),8)

    do ila = 1,lst(id) % nla

      m = lst_out % m(ila)
      n = lst_out % n(ila)

      do p = 1, nphase
         if      ( p == 1) then
            i = 2*m+1
            j = 2*n+1
         else if ( p == 2) then
            i = 2*m+1
            j = 2*n+2
         else if ( p == 3) then
            i = 2*m+2
            j = 2*n+1
         else if ( p == 4) then
            i = 2*m+2
            j = 2*n+2
         else
            write(*,*) 'lst_Setup: Error in NormFactor'
            stop
         end if

         if ( i == 1 .or. j == 1) then  
            if ( i == 1 .and. j == 1) then
               factor   = Normfactor1
               factorAd = NormfactorAd1
            else
               factor   = Normfactor2
               factorAd = NormfactorAd2
            end if
         else
            factor   = Normfactor3
            factorAd = NormfactorAd3
         end if
         
         lst_out % NormFactor  (ila,p) = factor
         lst_out % NormFactorAd(ila,p) = factorAd
      end do
      
   end do

    !
    !- 3.  Set variables needed by Forward and Inverse Laplacian
    !
    allocate(lst(id) % lapxy (lst(id) % nla))
    allocate(lst(id) % ilapxy(lst(id) % nla))

    dlon = dlon_in
    dx2  = (RA*dlon)**2
    fac  = 2.d0/dx2

    do ila = 1,lst(id) % nla
      ca = 2.d0*MPC_PI_R8 * lst_out % m(ila)
      cp = cos(ca/lst(id) % ni)
      cb = 2.d0*MPC_PI_R8 * lst_out % n(ila)
      cq = cos(cb/lst(id) % nj)

      lst(id) % lapxy(ila) = fac * (cp + cq - 2.d0)
      if ( lst(id) % lapxy(ila) /= 0.d0 ) then
         lst(id) % ilapxy(ila) = 1.d0 / lst(id) % lapxy(ila)
      else
         lst(id) % ilapxy(ila) = 0.d0
      end if
    end do

    !
    !- 4. Finalized
    !
    lst(id) % allocated = .true.

  end subroutine lst_Setup

!--------------------------------------------------------------------------
! LST_VARTRANSFORM
!--------------------------------------------------------------------------
  subroutine lst_VarTransform( id, SpectralStateVar, GridState,        &
                               TransformDirection, nk)
    implicit none

    integer,          intent(in)    :: id
                                     ! LST ID
    integer,          intent(in)    :: nk
                                     ! Grid point data dimensions
    character(len=*), intent(in)    :: TransformDirection
                                     ! SpectralToGridPoint or
                                     ! GridPointToSpectral
    real(8),          intent(inout) :: GridState(lst(id) % ni,lst(id) % myLatBeg:lst(id) % myLatEnd,nk)
                                     ! 3D field in grid point space
 !   real(8),          intent(inout) :: SpectralStateVar(lst(id) % nla,nphase,nk)
    real(8),          intent(inout) :: SpectralStateVar(:,:,:)
                                     ! 3D spectral coefficients

    integer                         :: m, n, k, ni_l, nj_l, nip_l, njp_l
    integer                         :: kStart, kEnd

    integer                         :: j

    real(8), allocatable            :: Step1(:,:,:)
    real(8), allocatable            :: Step2(:,:,:)
    
    character(len=1)                :: TransformAxe

    !
    !- 0. Some tests...
    !
    call idcheck(id)

!    kStart = lbound(SpectralStateVar,3)
!    kEnd   = ubound(SpectralStateVar,3)
!    if (trim(lst(id) % MpiMode) == 'LatLev') then
!       if (kStart /= lst(id) % myLevBeg .or. kEnd /= lst(id) % myLevEnd) then
!         print*
!         print*, 'lst_VarTransform in LatLev mode: Invalid bounds for SpectralStateVar', kStart, kEnd, lst(id) % myLevBeg, lst(id) % myLevEnd  
!         stop
!       end if
!    else
!       if (kStart /= 1 .or. kEnd /= nk) then
!         print*
!         print*, 'lst_VarTransform: Invalid bounds for SpectralStateVar', kStart, kEnd 
!         stop
!       end if
!    end if

    !
    !- 1.  First pass
    !

    !- 1.1 Settings and Data Selection
    select case ( trim(TransformDirection) )
    case ('GridPointToSpectral')
       TransformAxe = 'i'
       ni_l  = lst(id) % ni
       nip_l = nip
       nj_l  = lst(id) % latPerPE
       njp_l = 0
       kStart= 1
       kEnd  = nk
    case ('SpectralToGridPoint')
       TransformAxe = 'j'
       ni_l  = 2*lst(id) % mymCount
       nip_l = 0
       nj_l  = lst(id) % nj
       njp_l = njp
       if (trim(lst(id) % MpiMode) == 'LatLev') then
         kStart= lst(id) % myLevBeg
         kEnd  = lst(id) % myLevEnd
       else
         kStart= 1
         kEnd  = nk
       end if
    case default
       print*
       print*,'Error: TranformDirection Unknown ', trim(TransformDirection)
       stop
    end select

    allocate( Step1(ni_l+nip_l,nj_l+njp_l,kStart:kEnd) )
    Step1(:,:,:) = 0.d0

    !- 1.2 Spectral transform
    if ( trim(TransformDirection) == 'SpectralToGridPoint' ) then
       call lst_ReshapeTrunc( Step1,             & ! OUT
                              SpectralStateVar,  & ! IN
                              'ToRPN', kStart, kEnd, id )    ! IN
    else
       Step1(1:lst(id) %ni,1:lst(id) % latPerPE,:) = GridState(1:lst(id) %ni,lst(id) % myLatBeg:lst(id) % myLatEnd,:)
    end if

    call lst_transform1d( Step1,                       & ! INOUT
                          TransformDirection,          & ! IN
                          TransformAxe,                & ! IN
                          ni_l, nj_l, nip_l, njp_l,    & ! IN
                          kStart, kEnd )                 ! IN

    !
    !- 2.0 Second pass
    !   

    !- 2.1 Settings
    if ( trim(TransformDirection) == 'GridPointToSpectral' ) then
       TransformAxe = 'j'
       ni_l  = 2*lst(id) % mymCount
       nip_l = 0
       nj_l  = lst(id) % nj
       njp_l = njp
       if (trim(lst(id) % MpiMode) == 'LatLev') then
         kStart= lst(id) % myLevBeg
         kEnd  = lst(id) % myLevEnd
       else
         kStart= 1
         kEnd  = nk
       end if
    else
       TransformAxe = 'i'
       ni_l  = lst(id) % ni
       nip_l = nip
       nj_l  = lst(id) % latPerPE
       njp_l = 0
       kStart= 1
       kEnd  = nk
    end if

    allocate( Step2(ni_l+nip_l,nj_l+njp_l,kStart:kEnd) )
    Step2(:,:,:) = 0.d0

    !- 2.2 Communication between processors
    
    if ( trim(TransformDirection) == 'GridPointToSpectral' ) then
       if      ( trim(lst(id) % MpiMode) == 'NoMpi') then
         Step2(:,1:lst(id) % nj,:) = Step1(:,1:lst(id) % nj,:)
       else if ( trim(lst(id) % MpiMode) == 'LatM') then
         call transpose_LatToM( Step2,        & ! OUT
                                Step1, nk, id ) ! IN
       else
         call transpose_LatToLev( Step2,    & ! OUT
                                  Step1, nk, id ) ! IN
       end if
    else
       if      ( trim(lst(id) % MpiMode) == 'NoMpi') then
         Step2(:,1:lst(id) % nj,:) = Step1(:,1:lst(id) % nj,:)
       else if ( trim(lst(id) % MpiMode) == 'LatM') then
         call transpose_MToLat( Step2,        & ! OUT
                                Step1, nk, id ) ! IN
       else
         call transpose_LevToLat( Step2,    & ! OUT
                                  Step1, nk, id ) ! IN
       end if
    end if

    !- 2.3 Spectral Transform

    call lst_transform1d( Step2,                      & ! INOUT
                          TransformDirection,         & ! IN
                          TransformAxe,               & ! IN
                          ni_l, nj_l, nip_l, njp_l,   & ! IN
                          kStart, kEnd )                ! IN

    if ( trim(TransformDirection) == 'GridPointToSpectral' ) then

       ! Truncation (if applicable) will occur in this step
       call lst_ReshapeTrunc( Step2,             &  ! IN
                              SpectralStateVar,  &  ! OUT
                              'ToVAR', kStart, kEnd, id )     ! IN
    else
       GridState(1:lst(id) %ni,lst(id) % myLatBeg:lst(id) %myLatEnd,:) = Step2(1:lst(id) %ni,1:lst(id) %latPerPE,:)
    end if

    deallocate( Step1, Step2 )

  end subroutine lst_VarTransform

!--------------------------------------------------------------------------
! LST_TRANSFORM1D
!--------------------------------------------------------------------------
  subroutine lst_transform1d( Field3d,            &
                              TransformDirection, &
                              TransformAxe,       &
                              ni_l, nj_l, nip_l, njp_l, kStart, kEnd)
    implicit none

    integer,          intent(in)        :: ni_l, nj_l, kStart, kEnd
                                         ! Grid point data dimensions
    integer,          intent(in)        :: nip_l, njp_l
                                         ! Extra point in spectral space
    character(len=*), intent(in)        :: TransformDirection
                                         ! SpectralToGridPoint or
                                         ! GridPointToSpectral
    character(len=*), intent(in)        :: TransformAxe
                                         ! 'i' or 'j'
    real(8),          intent(inout)     :: Field3d(1:ni_l+nip_l,1:nj_l+njp_l,kStart:kEnd)  
                                         ! InOut 3D field

    integer :: nit, njt
    integer :: way, type
    integer :: maxsize
    integer :: axe, n, nlot, nfact, np, lot, nk

    !
    !- 1.  Set some options
    !

    !- 1.1 Transform Direction
    select case ( trim(TransformDirection) )
    case ('GridPointToSpectral')
       way = -1
    case ('SpectralToGridPoint')
       way = +1
    case default
       print*
       print*,'Error: TranformDirection Unknown ', trim(TransformDirection)
       stop
    end select

    nk = kEnd - kStart + 1

    !
    !- 2.  Do the transforms in one direction
    !
    select case ( trim(TransformAxe) )
    case ('i')
       !- 2.1 First pass  --> Along INDEX "I"
       axe = 0
       n   = ni_l
       np  = nip_l
       nlot= nj_l
    case ('j')
       !- 2.2 Second pass --> Along INDEX "J"
       axe = 1
       n   = nj_l
       np  = njp_l
       nlot= ni_l
    case default
       print*
       print*,'Error: TranformAxe Unknown ', trim(TransformAxe)
       stop
    end select

    !- 1.2 Fast or Slow Fourier Transform ?
    nfact = n
    call ngfft( nfact ) ! INOUT

    if (nfact == n ) then
       call setfft8( n ) ! IN
    else
       print*,'This routine can only handle fast sin&cos FFT'
       stop
    end if

    select case ( trim(TransformAxe) )
    case ('i')
!$OMP PARALLEL DO PRIVATE(lot)
       do lot = 1, nlot
          call ffft8(Field3d(:,lot,:), 1, n+np, nk, way)
       end do
!$OMP END PARALLEL DO
    case ('j')
!$OMP PARALLEL DO PRIVATE(lot)
       do lot = 1, nlot
          call ffft8(Field3d(lot,:,:), 1, n+np, nk, way)
       end do
!$OMP END PARALLEL DO
    end select

    !*     subroutine ffft8( a, inc, jump, lot, isign )
    !*     a      is the array containing input & output data
    !*     inc    is the increment within each data 'vector'
    !*            (e.g. inc=1 for consecutively stored data)
    !*     jump   is the increment between the start of each data vector
    !*     lot    is the number of data vectors
    !*     isign  = +1 for transform from spectral to gridpoint
    !*            = -1 for transform from gridpoint to spectral

  end subroutine lst_transform1d

!--------------------------------------------------------------------------
! LST_Transpose_LatToM
!--------------------------------------------------------------------------
  SUBROUTINE transpose_LatToM(pgd2,pgd,nk,id)
    implicit none

    integer, intent(in)  :: id, nk

    real(8), intent(out) :: pgd2(2*lst(id) % mymCount,lst(id) % nj+njp  ,nk)
    real(8), intent(in)  :: pgd (lst(id) % ni+nip    ,lst(id) % latPerPE,nk)

    real(8) :: gd_recv(lst(id) % maxmCount,2,nk,lst(id) % nj)
    real(8) :: gd_send(lst(id) % maxmCount,2,nk,lst(id) % latPerPE,mpi_nprocs)

    integer :: yourid, jm, icount, nsize, ierr, jlev, jlat

!$OMP PARALLEL DO PRIVATE(yourid,jlat,jlev,icount,jm)
    do yourid = 0, mpi_nprocs-1
      do jlat = 1, lst(id) % latPerPE
        do jlev = 1, nk
          icount = 0
          do jm = lst(id) % allmBeg(yourid+1), lst(id) % allmEnd(yourid+1), lst(id) % allmSkip(yourid+1)
            icount = icount + 1
            gd_send(icount,1,jlev,jlat,yourid+1) = pgd(2*jm+1, jlat, jlev)
            gd_send(icount,2,jlev,jlat,yourid+1) = pgd(2*jm+2, jlat, jlev)
          end do
        end do
      end do
    end do
!$OMP END PARALLEL DO

    nsize = lst(id) % maxmCount*2*nk*lst(id) % latPerPE
    call rpn_comm_alltoall(gd_send,nsize,"mpi_double_precision",  &
                           gd_recv,nsize,"mpi_double_precision","GRID",ierr)

!$OMP PARALLEL DO PRIVATE(jlat,jlev,icount,jm)
    do jlat = 1, lst(id) % nj
      do jlev = 1, nk
        icount = 0
        do jm = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
          icount = icount + 1
          pgd2(2*lst(id) % mymIndex(jm)-1,jlat,jlev) = gd_recv(icount,1,jlev,jlat)
          pgd2(2*lst(id) % mymIndex(jm)  ,jlat,jlev) = gd_recv(icount,2,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

!    call tmg_stop(58)

  END SUBROUTINE transpose_LattoM

!--------------------------------------------------------------------------
! Transpose_MToLat
!--------------------------------------------------------------------------
  SUBROUTINE transpose_MtoLat(pgd,pgd2,nk,id)
    implicit none

    integer, intent(in)  :: id,nk

    real(8), intent(in)   :: pgd2(2*lst(id) % mymCount,lst(id) % nj+njp  ,nk)
    real(8), intent(out)  :: pgd (lst(id) % ni+nip    ,lst(id) % latPerPE,nk)

    real(8) :: gd_send(lst(id) % maxmCount,2,nk,lst(id) % nj)
    real(8) :: gd_recv(lst(id) % maxmCount,2,nk,lst(id) % latPerPE,mpi_nprocs)

    integer :: yourid, jm, icount, nsize, ierr, jlev, jlat

!    call rpn_comm_barrier("GRID",ierr)

!    call tmg_start(58,'TRANSPOSE')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,icount,jm)
    do jlat = 1, lst(id) % nj
      do jlev = 1, nk
        icount = 0
        do jm = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
          icount = icount+1
          gd_send(icount,1,jlev,jlat) = pgd2(2*lst(id) % mymIndex(jm)-1,jlat,jlev)
          gd_send(icount,2,jlev,jlat) = pgd2(2*lst(id) % mymIndex(jm)  ,jlat,jlev)
        end do
      end do
    end do
!$OMP END PARALLEL DO

    nsize = lst(id) % maxmCount*2*nk*lst(id) % latPerPE
    call rpn_comm_alltoall(gd_send,nsize,"mpi_double_precision",  &
                           gd_recv,nsize,"mpi_double_precision","GRID",ierr)

!$OMP PARALLEL DO PRIVATE(yourid,jlat,jlev,icount,jm)
    do yourid = 0, mpi_nprocs-1
      do jlat = 1, lst(id) % latPerPE
        do jlev = 1, nk
          icount = 0
          do jm = lst(id) % allmBeg(yourid+1), lst(id) % allmEnd(yourid+1), lst(id) % allmSkip(yourid+1)
            icount = icount+1
            pgd(2*jm+1,jlat,jlev) = gd_recv(icount,1,jlev,jlat,yourid+1)
            pgd(2*jm+2,jlat,jlev) = gd_recv(icount,2,jlev,jlat,yourid+1)
          end do
        end do
      end do
    end do
!$OMP END PARALLEL DO

!    call tmg_stop(58)

  END SUBROUTINE transpose_MtoLat

!--------------------------------------------------------------------------
! Transpose_LatToLev
!--------------------------------------------------------------------------
  SUBROUTINE transpose_LatToLev(pgd2,pgd,nk,id)
    implicit none

    integer, intent(in)  :: nk, id

    real(8), intent(out) :: pgd2(lst(id) % ni+nip,lst(id) % nj+njp  ,lst(id) % myLevBeg:lst(id) % myLevEnd)
    real(8), intent(in)  :: pgd (lst(id) % ni+nip,lst(id) % latPerPE,nk)

    real(8) :: gd_recv(lst(id) % ni+nip,lst(id)%maxLevCount,lst(id) % nj)
    real(8) :: gd_send(lst(id) % ni+nip,lst(id)%maxLevCount,lst(id) % latPerPE,mpi_nprocs)

    integer :: yourid, jm, icount, nsize, ierr, jlev, jlat, jlev2

!$OMP PARALLEL DO PRIVATE(yourid,jlat,jlev,jlev2,icount,jm)
    do yourid = 0, mpi_nprocs-1
      do jlat = 1, lst(id) % latPerPE
        do jlev = lst(id) % allLevBeg(yourid+1), lst(id) % allLevEnd(yourid+1)
          jlev2 = jlev - lst(id) % allLevBeg(yourid+1) + 1
          icount = 0
          do jm = 1, lst(id) % ni+nip
            icount = icount + 1
            gd_send(icount,jlev2,jlat,yourid+1) = pgd(jm, jlat, jlev)
          end do
        end do
      end do
    end do
!$OMP END PARALLEL DO

    nsize = (lst(id) % ni+nip)*lst(id) % maxLevCount*lst(id) % latPerPE
    call rpn_comm_alltoall(gd_send,nsize,"mpi_double_precision",  &
                           gd_recv,nsize,"mpi_double_precision","GRID",ierr)

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,icount,jm)
    do jlat = 1, lst(id) % nj
      do jlev = lst(id) % myLevBeg, lst(id) % myLevEnd
        jlev2 = jlev - lst(id) % myLevBeg + 1
        icount = 0
        do jm = 1, lst(id) % ni+nip
          icount = icount + 1
          pgd2(jm,jlat,jlev) = gd_recv(icount,jlev2,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

!    call tmg_stop(58)

  END SUBROUTINE transpose_LattoLev

!--------------------------------------------------------------------------
! Transpose_LevtoLat
!--------------------------------------------------------------------------
  SUBROUTINE transpose_LevtoLat(pgd,pgd2,nk,id)
    implicit none

    integer, intent(in)  :: id, nk

    real(8), intent(in)  :: pgd2(lst(id) % ni+nip, lst(id) % nj+njp  ,lst(id) % myLevBeg:lst(id) % myLevEnd)
    real(8), intent(out) :: pgd (lst(id) % ni+nip, lst(id) % latPerPE,nk)

    real(8) :: gd_send(lst(id) % ni+nip,lst(id)%maxLevCount,lst(id) % nj)
    real(8) :: gd_recv(lst(id) % ni+nip,lst(id)%maxLevCount,lst(id) % latPerPE,mpi_nprocs)

    integer :: yourid, jm, icount, nsize, ierr, jlev, jlat, jlev2

!    call rpn_comm_barrier("GRID",ierr)

!    call tmg_start(58,'TRANSPOSE')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,icount,jm)
    do jlat = 1, lst(id) % nj
      do jlev = lst(id) % myLevBeg, lst(id) % myLevEnd
        jlev2 = jlev - lst(id) % myLevBeg + 1
        icount = 0
        do jm = 1, lst(id) % ni+nip
          icount = icount+1
          gd_send(icount,jlev2,jlat) = pgd2(jm,jlat,jlev)
        end do
      end do
    end do
!$OMP END PARALLEL DO

    nsize = (lst(id) % ni+nip)*lst(id) % maxLevCount*lst(id) % latPerPE
    call rpn_comm_alltoall(gd_send,nsize,"mpi_double_precision",  &
                           gd_recv,nsize,"mpi_double_precision","GRID",ierr)

!$OMP PARALLEL DO PRIVATE(yourid,jlat,jlev,jlev2,icount,jm)
    do yourid = 0, mpi_nprocs-1
      do jlat = 1, lst(id) % latPerPE
        do jlev = lst(id) % allLevBeg(yourid+1), lst(id) % allLevEnd(yourid+1)
          jlev2 = jlev - lst(id) % allLevBeg(yourid+1) + 1
          icount = 0
          do jm = 1, lst(id) % ni+nip
            icount = icount+1
            pgd(jm,jlat,jlev) = gd_recv(icount,jlev2,jlat,yourid+1)
          end do
        end do
      end do
    end do
!$OMP END PARALLEL DO

!    call tmg_stop(58)

  END SUBROUTINE transpose_LevtoLat

!--------------------------------------------------------------------------
! LST_ReshapeTrunc
!--------------------------------------------------------------------------
  subroutine lst_ReshapeTrunc( SpectralStateRpn, SpectralStateVar,  &
                               Direction, kStart, kEnd, id )
    implicit none

    integer,          intent(in)    :: id, kStart, kEnd
    character(len=*), intent(in)    :: Direction ! ToVAR or ToRPN
    real(8),          intent(inout) :: SpectralStateRpn(2*lst(id) % mymCount,lst(id) % nj+njp,kStart:kEnd)
    real(8),          intent(inout) :: SpectralStateVar(lst(id) % nla     ,nphase,kStart:kEnd)

    integer k, m, n, ila

    select case ( trim(Direction) )
    case ('ToVAR')
      ! Truncation (if applicable) will be applied here
!$OMP PARALLEL
!$OMP DO PRIVATE (n,m,ila,k) 
      do n = 0, lst(id) % nmax
        do m = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
          ila = lst(id) % nla_Index(m,n)
          if ( ila /= -1 ) then
            do k = kStart, kEnd 
              SpectralStateVar(ila,1,k) = SpectralStateRpn(2*lst(id) % mymIndex(m)-1,2*n+1,k)
              SpectralStateVar(ila,2,k) = SpectralStateRpn(2*lst(id) % mymIndex(m)-1,2*n+2,k)
              SpectralStateVar(ila,3,k) = SpectralStateRpn(2*lst(id) % mymIndex(m)  ,2*n+1,k)
              SpectralStateVar(ila,4,k) = SpectralStateRpn(2*lst(id) % mymIndex(m)  ,2*n+2,k)
            end do
          end if
        end do
      end do
!$OMP END DO
!$OMP END PARALLEL

    case ('ToRPN')
      SpectralStateRpn(:,:,:) = 0.0d0
!$OMP PARALLEL
!$OMP DO PRIVATE (n,m,ila,k)
      do n = 0, lst(id) % nmax
        do m = lst(id) % mymBeg, lst(id) % mymEnd, lst(id) % mymSkip
          ila = lst(id) % nla_Index(m,n)
          if ( ila /= -1 ) then
            do k = kStart, kEnd
              SpectralStateRpn(2*lst(id) % mymIndex(m)-1,2*n+1,k) = SpectralStateVar(ila,1,k)
              SpectralStateRpn(2*lst(id) % mymIndex(m)-1,2*n+2,k) = SpectralStateVar(ila,2,k)
              SpectralStateRpn(2*lst(id) % mymIndex(m)  ,2*n+1,k) = SpectralStateVar(ila,3,k)
              SpectralStateRpn(2*lst(id) % mymIndex(m)  ,2*n+2,k) = SpectralStateVar(ila,4,k)
            end do
          end if
        end do
      end do
!$OMP END DO
!$OMP END PARALLEL

    case default
      write(6,*)
      write(6,*) 'lst_ReshapeTrunc: Unknown Direction', trim(Direction)
      stop
    end select

  end subroutine lst_ReshapeTrunc

!--------------------------------------------------------------------------
! LST_Laplacian
!--------------------------------------------------------------------------
  subroutine lst_Laplacian( id, GridState, Mode, nk)
    implicit none

    integer,          intent(in)    :: id
                                     ! LST ID
    integer,          intent(in)    :: nk
                                     ! Grid point data dimensions
    real(8),          intent(inout) :: GridState(lst(id) % ni,lst(id) % nj,nk)  
                                     ! 3D field in grid point space
    character(len=*), intent(in)    :: Mode
                                     ! Forward or Inverse

    real(8), allocatable            :: SpectralStateVar(:,:,:)
    real(8), allocatable            :: factor(:)

    integer :: k, ila, p

    character(len=24)   :: kind

    allocate( SpectralStateVar(lst(id) % nla,nphase,nk) )
    allocate( factor(lst(id) % nla) )

    call idcheck(id)

    !
    !- 1.  Set Mode-dependent factors
    !
    select case ( trim(Mode) )
    case ('Forward')
      factor(:) = lst(id) % lapxy(:)
    case ('Inverse')
      factor(:) = lst(id) % ilapxy(:)
    case default
      write(6,*)
      write(6,*) 'lst_Laplacian: Error: Mode Unknown ', trim(Mode)
      stop
    end select

    !
    !- 2. Grid Point Space -> Spectral Space
    !
    kind = 'GridPointToSpectral'
    call lst_VarTransform( id,                    & ! IN
                           SpectralStateVar,      & ! OUT
                           GridState,             & ! IN
                           kind, nk     )           ! IN    

    !
    !- 3. Laplacian (forward or inverse) Transform
    !
!$OMP PARALLEL
!$OMP DO PRIVATE (k,ila,p)
    do k = 1, nk
      do ila = 1, lst(id) % nla
        do p = 1, nphase
          SpectralStateVar(ila,p,k) = factor(ila) * SpectralStateVar(ila,p,k)
        end do
      end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    !
    !- 4. Spectral Space -> Grid Point Space
    !
    kind = 'SpectralToGridPoint'
    call lst_VarTransform( id,                    & ! IN
                           SpectralStateVar,      & ! IN
                           GridState,             & ! OUT
                           kind, nk     )           ! IN

    deallocate( SpectralStateVar )
    deallocate( factor )

  end subroutine lst_Laplacian

!--------------------------------------------------------------------------
!   IDCHECK
!--------------------------------------------------------------------------
  subroutine idcheck(id)
    implicit none

    integer, intent(in) :: id

    if ( .not. lst(id) % allocated) then
       print*
       print*,"lst_IDCHECK: Unknown transform ID ", id
       stop
    end if

  end subroutine idcheck

!--------------------------------------------------------------------------
!   NGFFT
!--------------------------------------------------------------------------
  subroutine ngfft(n)
    implicit none

    integer, intent(inout) :: n ! le plus petit entier >= n qui factorise

    integer, parameter :: l = 3
    integer :: k(l) , m
    data m , k / 8 , 2 , 3 , 5 /

    integer :: i, j

    if ( n <= m ) n = m + 1
    n = n - 1
1   n = n + 1
    i = n
2   do j = 1, l
       if (mod(i,k(j)) == 0 ) go to 4
    end do
    go to 1
4   i = i/k(j)
    if ( i /= 1 ) go to 2

  end subroutine ngfft

end module LamSpectralTransform_mod
