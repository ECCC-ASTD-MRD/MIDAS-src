!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any lanter version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Adjoint of filling tangent linear profiles structure by interpolating 
!!            contents of columnData to RTTOV space
!!
!! @author j. halle *cmda/aes  april 21, 2005
!
!revision 001  : j. halle  *cmda/smc  march 2007
!                    -fix zvlev for hybrid coordinate
!revision 002  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
subroutine tovs_fill_profiles_ad(column,columng)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use columnData_mod
  use obsSpaceData_mod
  use presProfileOperators_mod
  use utilities_mod
  use tovs_extrap_mod
  implicit none

  type(struct_columnData) :: column,columng

  type(struct_vco), pointer :: vco_anl
  integer, allocatable :: iptobs    (:) 
  integer, allocatable :: iptobscma (:) 

  integer :: alloc_status(15)
  logical :: diagTtop,TopAt10hPa
  integer :: omp_get_num_threads, nthreads
  integer :: istride, ilen, imodulo
  integer :: nlevels,nobmax
  integer :: sensor_id, iobs, stat
  integer :: ilowlvl_T,ilowlvl_M,count_profile,header_index,nlv_M,nlv_T
  integer :: profile_index, level_index, rttov_index
  integer :: status, Vcode
  integer :: jpmotop, jpmolev

  real(8), allocatable :: to_ad    (:,:)
  real(8), allocatable :: lqo_ad   (:,:)
  real(8), allocatable :: toext_ad (:,:)
  real(8), allocatable :: qoext_ad (:,:)
  real(8), allocatable :: zvlev    (:,:)
  real(8), allocatable :: dPdPs    (:,:)
  real(8), allocatable :: zt_ad    (:,:)
  real(8), allocatable :: zlq_ad   (:,:)
  real(8), allocatable :: zt       (:,:)
  real(8), allocatable :: zlq      (:,:)
  real(8), allocatable :: qoext    (:,:)
  real(8), allocatable :: zps_ad   (:)
  real(8), allocatable :: xpres    (:)

  real(8) :: zptop, zptopmbs

  real(8), pointer :: uu_column(:),vv_column(:),tt_column(:),hu_column(:),ps_column(:),tg_column(:)
  real(8), pointer :: TTb(:), HUb(:), Pres(:)
         
  if (tvs_nobtov == 0) return    ! exit if there are not tovs data


  !     1.    Set index for model's lowest level and model top
  !     .     ------------------------------------------------
  write(*,*) "tovs_fill_profiles_ad Debut"

  nlv_M = col_getNumLev(columng,'MM')
  nlv_T = col_getNumLev(columng,'TH')

  if (  col_getPressure(columng,1,1,'TH') < col_getPressure(columng,nlv_T,1,'TH') ) then
     ilowlvl_M = nlv_M
     ilowlvl_T = nlv_T
  else
     ilowlvl_M = 1
     ilowlvl_T = 1
  endif

  vco_anl => col_getVco(columng)
  status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode)
  diagTtop = (Vcode==5002)

  ! find model level top, within 0.000001 mbs.
  zptop    = col_getPressure(columng,1,1,'TH')
  zptopmbs = zptop/100.d0
  zptopmbs = zptopmbs - 0.000001d0

  TopAt10hPa = ( abs( zptopmbs - 10.0d0 ) <= .1d0 )

  !     1.1   Number of threads and memory allocation
  !     .     ---------------------------------------

!$omp parallel 
  nthreads = omp_get_num_threads()
!$omp end parallel
  
!
!     2.  Adjoint of fill profiles structure
!     .   ----------------------------------

  ! loop over all instruments
  sensor_loop: do sensor_id = 1, tvs_nsensors

     count_profile = 0

     bobs1: do iobs = 1,tvs_nobtov
        if (tvs_lsensor(iobs) /= sensor_id) cycle bobs1
        NOBMAX = iobs
        count_profile = count_profile + 1   
     enddo bobs1

     if (count_profile == 0) cycle sensor_loop

     nlevels=tvs_coefs(sensor_id) %coef%  nlevels
     allocate (xpres(nlevels))
     xpres = tvs_coefs(sensor_id)% coef % ref_prfl_p
     jpmotop = 1
     do level_index = 2, nlevels
        if ( zptopmbs >= xpres(level_index-1) .and.       &
             zptopmbs < xpres(level_index)        ) then
           jpmotop = level_index
           exit
        endif
     enddo

     jpmolev = (nlevels-jpmotop+1)

     alloc_status(:) = 0
     allocate (iptobs   (count_profile)        ,stat= alloc_status(1) )
     allocate (iptobscma(count_profile)        ,stat= alloc_status(2) )
     allocate (to_ad    (jpmolev,count_profile),stat= alloc_status(3) )
     allocate (lqo_ad   (jpmolev,count_profile),stat= alloc_status(4) )
     allocate (toext_ad (nlevels,count_profile),stat= alloc_status(5) )
     allocate (qoext_ad (nlevels,count_profile),stat= alloc_status(6) )
     allocate (zvlev    (nlv_T,count_profile)  ,stat= alloc_status(7) )
     allocate (dPdPs    (nlv_T,count_profile)  ,stat= alloc_status(8) )
     allocate (zt_ad    (nlv_T,count_profile)  ,stat= alloc_status(9) )
     allocate (zlq_ad   (nlv_T,count_profile)  ,stat= alloc_status(10))
     allocate (zt       (nlv_T,count_profile)  ,stat= alloc_status(11))
     allocate (zlq      (nlv_T,count_profile)  ,stat= alloc_status(12))
     allocate (qoext    (nlevels,count_profile),stat= alloc_status(13))
     allocate (zps_ad   (count_profile)        ,stat= alloc_status(14))

     call utl_checkAllocationStatus(alloc_status, " tovs_fill_profiles_ad")

     count_profile = 0 

! loop over all obs.
     bobs2: do iobs = 1, NOBMAX
        if (tvs_lsensor(iobs)/=sensor_id) cycle bobs2
        header_index = tvs_lobsno(iobs)

        count_profile = count_profile + 1

        TTb => col_getColumn(columng,header_index,'TT')
        HUb => col_getColumn(columng,header_index,'HU')
        Pres => col_getColumn(columng,header_index,'PR','TH')
        do level_index = 1, nlv_T
           zt   (level_index,count_profile) = TTb(level_index)
           zlq  (level_index,count_profile) = HUb(level_index)
           zvlev(level_index,count_profile) = Pres(level_index) *MPC_MBAR_PER_PA_R8
           dPdPs(level_index,count_profile) = col_getPressureDeriv(columng,level_index,header_index,'TH')
        enddo

        ! Fix pour eviter probleme au toit avec GEM 4
        ! (grosse variabilite de la temperature au dernier niveau thermo due 
        !  a l'extrapolation utilisee)
        if (diagTtop) then
           zt   (1,count_profile) =  zt   (2,count_profile) + tvs_mesosphereLapseRate *  &
                log( col_getPressure(columng,1,header_index,'TH') /  &
                col_getPressure(columng,2,header_index,'TH') )
           zlq  (1,count_profile) =  zlq  (2,count_profile)
        endif

        iptobs   (count_profile) = iobs
        iptobscma(count_profile) = header_index
     enddo bobs2

!     .  2.4  Adjoint of filling profiles_ad structure
!     .       ----------------------------------------
     do profile_index = 1, count_profile
        qoext(:,profile_index) =  tvs_profiles(iptobs(profile_index)) % q(:) !/ tvs_qMixratio2ppmv
     enddo

     do  profile_index =  1, count_profile
        header_index = iptobscma(profile_index)
        rttov_index = iptobs(profile_index)
        ps_column => col_getColumn(column,header_index,'P0')
        tg_column => col_getColumn(column,header_index,'TG')
        tt_column => col_getColumn(column,header_index,'TT')
        hu_column => col_getColumn(column,header_index,'HU')
        uu_column => col_getColumn(column,header_index,'UU')
        vv_column => col_getColumn(column,header_index,'VV')

        toext_ad(:,profile_index)      = profiles_ad(rttov_index) % t(:)
        qoext_ad(:,profile_index)      = profiles_ad(rttov_index) % q(:) 
        ps_column(1)       = profiles_ad(rttov_index) % s2m % p *MPC_MBAR_PER_PA_R8
        tg_column(1)       = profiles_ad(rttov_index) % skin % t
        tt_column(ilowlvl_T) = profiles_ad(rttov_index) % s2m % t
!!!        hu_column(ilowlvl_T) = qoext(ilowlvl_T,profile_index) * profiles_ad(rttov_index) % s2m % q * tvs_qMixratio2ppmv
!!!        hu_column(ilowlvl_T) = qoext(ilowlvl_T,profikle_index) * profiles_ad(rttov_index) % s2m % q 
        hu_column(ilowlvl_T) = 0.d0 
        uu_column(ilowlvl_M) = profiles_ad(rttov_index) % s2m % u
        vv_column(ilowlvl_M) = profiles_ad(rttov_index) % s2m % v
     end do

!     .  2.3  Adjoint of extrapolation of humidity profile (kg/kg)
!             above rlimlvhu (normally 300mbs or 70mbs)
!     .  
     if ( TopAt10hPa ) then
        if ( tvs_debug ) then
           do profile_index = 1, count_profile
              write(*,*)'qoext_ad*1000 avant aexthum4    = '
              write(*,'(1x,10f8.4)')(qoext_ad(level_index,profile_index)*1000.d0,level_index=1,nlevels)
              write(*,*)' '
           enddo
        endif
        call aexthum4 (count_profile,nlevels,xpres(1:nlevels),qoext_ad,qoext)
        if ( tvs_debug ) then
           do profile_index = 1, count_profile
              write(*,*)'qoext_ad*1000 apres aexthum4    = '
              write(*,'(1x,10f8.4)')(qoext_ad(level_index,profile_index)*1000.d0,level_index=1,nlevels)
              write(*,*)' '
           enddo
        endif
     endif

        ! adjoint of conversion lnq --> q
     lqo_ad(:,:) = 0.0d0
     do profile_index = 1, count_profile
        do level_index = 1, jpmolev
           lqo_ad(level_index,profile_index) = qoext_ad(nlevels-jpmolev+level_index,profile_index) * qoext(nlevels-jpmolev+level_index,profile_index)
        enddo
     enddo

!     .  2.2  Adjoint of extrapolation of temperature profile above 10mb
!     .       ----------------------------------------------------------
     to_ad(:,:) = 0.0d0
     if ( .not. TopAt10hPa ) then
        do profile_index = 1, count_profile
           to_ad(1:jpmolev,profile_index)=to_ad(1:jpmolev,profile_index)+toext_ad(jpmotop:nlevels,profile_index)
        enddo
     else
        call aextrap (to_ad,toext_ad,jpmolev,nlevels,count_profile)
     endif
 
!     .  2.1  Adjoint of vertical interpolation of model temperature and logarithm of
!             specific humidity to pressure levels required by tovs rt model
!     .       -----------------------------------------------------------------------

     zt_ad (:,:) = 0.0d0
     zlq_ad(:,:) = 0.0d0
     zps_ad(:)   = 0.0d0


     imodulo = mod(count_profile,nthreads)
     if ( imodulo == 0 ) then
        istride = max(1,(count_profile/nthreads))
     else
        istride = max(1,(count_profile/nthreads)+1)
     endif
     call tmg_start(75,'intavgad')
!$omp parallel
!$omp do private(profile_index,ilen)
     do profile_index=1,count_profile,istride
        ilen = min (count_profile-profile_index+1,istride)
        if ( ilen > 0) then
           
           call ppo_IntAvgAd(zvlev(:,profile_index:profile_index+ilen-1), dPdPs(:,profile_index:profile_index+ilen-1), &
                zt_ad(:,profile_index:profile_index+ilen-1), zt(:,profile_index:profile_index+ilen-1), &
                zps_ad(profile_index:profile_index+ilen-1), nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),to_ad(:,profile_index:profile_index+ilen-1))
           call ppo_IntAvgAd(zvlev(:,profile_index:profile_index+ilen-1),dPdPs(:,profile_index:profile_index+ilen-1), &
                zlq_ad(:,profile_index:profile_index+ilen-1), zlq(:,profile_index:profile_index+ilen-1), &
                zps_ad(profile_index:profile_index+ilen-1), nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels), lqo_ad(:,profile_index:profile_index+ilen-1))

        endif
     enddo
!$omp end do
!$omp end parallel
     call tmg_stop(75)
 
     ! Fix pour eviter probleme au toit avec GEM 4
     ! (grosse variabilite temperature au dernier niveau thermo due 
     !  a l'extrapolation utilisee)
     if ( diagTtop ) then
        do profile_index = 1, count_profile
           zt_ad (1,profile_index) = 0.d0
           zlq_ad(1,profile_index) = 0.d0
        enddo
     endif

        !     .  2.1  Store adjoints in columnData object
        !     .       -----------------------------------

     do  profile_index = 1 , count_profile 
        ps_column => col_getColumn(column,iptobscma(profile_index),'P0')
        tt_column => col_getColumn(column,iptobscma(profile_index),'TT')
        hu_column => col_getColumn(column,iptobscma(profile_index),'HU')
        
        ps_column(1) = ps_column(1) + zps_ad  (profile_index) * MPC_MBAR_PER_PA_R8
        do level_index = 1, col_getNumLev(column,'TH')
           tt_column(level_index) = tt_column(level_index) + zt_ad  (level_index,profile_index)
           hu_column(level_index) = hu_column(level_index) + zlq_ad (level_index,profile_index)
        enddo
     enddo

     alloc_status(:) = 0
     deallocate (iptobs   ,stat= alloc_status(1) )
     deallocate (iptobscma,stat= alloc_status(2) )
     deallocate (to_ad    ,stat= alloc_status(3) )
     deallocate (lqo_ad   ,stat= alloc_status(4) )
     deallocate (toext_ad ,stat= alloc_status(5) )
     deallocate (qoext_ad ,stat= alloc_status(6) )
     deallocate (zvlev    ,stat= alloc_status(7) )
     deallocate (dPdPs    ,stat= alloc_status(8) )
     deallocate (zt_ad    ,stat= alloc_status(9) )
     deallocate (zlq_ad   ,stat= alloc_status(10))
     deallocate (zt       ,stat= alloc_status(11))
     deallocate (zlq      ,stat= alloc_status(12))
     deallocate (qoext    ,stat= alloc_status(13))
     deallocate (zps_ad   ,stat= alloc_status(14))
     deallocate (xpres    ,stat= alloc_status(15))

     call utl_checkAllocationStatus(alloc_status, " tovs_fill_profiles_ad", .false.)

        !    next bunch !

     count_profile = 0

  enddo sensor_loop

  write(*,*) "tovs_fill_profiles_ad Fin"
  !     3.  Close up
  !     .   --------

contains

  SUBROUTINE AEXTHUM4(KNPF,KLAPF,PPRES,PAV,PAV5)
    !
    !*****aexthum4* - adjoint of extrapolation of upper level humidity profile.
    !                (adapted from exthumad by J. Eyre)
    !
    !     purpose.
    !     --------
    !          ad of routine
    !          to extend mixing ratio profile into stratosphere in
    !          a reasonable way.
    !
    !**   interface.
    !     ----------
    !          *call* *aexthum4(knpf,klapf,ppres,pav,pav5)*
    !               *knpf*:  no. of profiles to be processed.
    !               *klapf*: length of atm. profiles.
    !               *ppres*: pressure levels of atm. profiles.
    !               *pav*:   ad of humidity profiles.
    !               *pav5*:  humidity profiles.
    !
    !     method.
    !     -------
    !          take top tropospheric mixing ratio (e.g. near 300 mb) and
    !          extrapolate with given fall off into lower stratosphere
    !          (e.g. to 70 mb).  constrain mixing ratio to be >= zwmin
    !          (e.g. 0.000003 kg/kg).   in upper strat, mixing ratio = zwmin.
    !
    !     externals.
    !     ----------
    !          none.
    !

    use MathPhysConstants_mod
    use obsFilter_mod
    IMPLICIT none
    !
    integer :: klapf,knpf
    REAL(8) PPRES(*),PAV(KLAPF,*), PAV5(KLAPF,*)
    !
    REAL(8) :: ZPRES3(KLAPF)
    !
    real(8) zwmix,zwb
    real(8),parameter ::  ZP1 = 70.0D0 ! PRESS LIMITS (IN HPA) OF REGION to be extrapolated
    integer :: inlvw,j,jnpf
    
    !
    !          find top level of given profile
    DO J=KLAPF,1,-1
       IF (PPRES(J)<FILT_RLIMLVHU) THEN
          INLVW=J
          GOTO 120
       ENDIF
    end do
    !
    !** Null extrapolation case
    !
    RETURN
    !
    !          constants defining p**3 fall off around tropopause
120 DO J=1,INLVW
       ZPRES3(J)=(PPRES(J)/PPRES(INLVW+1))**3
    end do
    !
    DO JNPF=1,KNPF
       ZWB=0.D0
       DO J=1,INLVW
          ZWMIX=PAV(J,JNPF)
          PAV(J,JNPF)=0.D0
          IF (PPRES(J)>=ZP1) THEN
             IF (PAV5(J,JNPF)>MPC_MINIMUM_HU_R8) THEN
                ZWB=ZWB+ZWMIX*ZPRES3(J)
             ENDIF
          ENDIF
       end do
       PAV(INLVW+1,JNPF)=PAV(INLVW+1,JNPF)+ZWB
    end do
   

  END SUBROUTINE AEXTHUM4

end subroutine tovs_fill_profiles_ad
