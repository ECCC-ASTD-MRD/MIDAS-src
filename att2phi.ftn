!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE att2phi(lcolumn,lcolumng)
#if defined (DOC)
*
***s/r att2phi - adjoint of Temperature to phi transformation
*
*
*Author  : S. Pellerin *ARMA/AES September 1998
*
*Revision: L. Fillion *ARMA/AES - 24 nov 98
*        - Include ES option
*Revision: L. Charette *ARMA/AES - 08 dec 98
*        - Added llprint for diagnostics
*Revision: L. Fillion *ARMA/AES - 3 feb 1999
*        - Introduce adjoint of ps dependence of TLM
*Revision: C. Charette *ARMA/AES - 8 feb 1999
*        - Replaced zptop by lcolumng%rppobs(1,jobs)
*          and zpscon by lcolumng%ps(1,jobs)
*
*           JM Belanger CMDA/SMC  Dec 2000
*                   . 32 bits conversion
*                     (replace real constant by REAL*8 alpha in
*                      call to MATAPAT).
*           C. Charette ARMA/SMC FEV. 2002
*            - Commented out the if(llprint...) statements within
*              the do loops. They were preventing vectorization.
*           P. Koclas P. Koclas
*                -changed nesting of loops ( conversion to IBM)
*           C. Charette - ARMA/SMC - Jun. 2003
*                - Conversion to hybrid vertical coordinate
*
*     Purpose:  -call avtap for computation of adjoint of phi to adjoint
*                of tv transformation
**              -Computation of adjoint temperature variable and
*                adjoint of logarith of specific humidity due to virtual
*                temperature increments
#endif
      use MathPhysConstants_mod
      use columnData_mod 
      IMPLICIT NONE
*implicits
*------------------------------------------------------------------------
#include "comlun.cdk"
*
      type(struct_columnData) :: lcolumn,lcolumng
      type(struct_columnData) :: lcolumnt
      integer jobs,jlev
      logical llprint
      real*8 zcon, zalpha, psurf
      real*8 vma(lcolumn%nlev),vmb(lcolumn%nlev),vmc(lcolumn%nlev)
      real*8 vmd(lcolumn%nlev),vme(lcolumn%nlev),vmf(lcolumn%nlev)
*
      call col_allocate(lcolumnt,lcolumn%nlev,lcolumn%nobtot)
**
C
      llprint = .false.
c      llprint = .true.
c
      zalpha=0.0D0
      call matapat(vco_anl%dhyb_m,zalpha,lcolumn%nlev,vma,vmb,vmc,vmd,vme,vmf)
      call avtap
c
c*    Adjoint of preparation r.h.s. for TL-Hydrostatic equation
c     ---------------------------------------------------------
c
!$OMP PARALLEL DO PRIVATE(jobs,jlev,zcon)

      do jobs = 1, lcolumn%nobtot

        do jlev = 1, lcolumn%nlev
c
c        zcon = d(rtapfac)/d(ps)
c
          zcon   = (vco_anl%dpresbd_M(jlev)-vco_anl%db_M(jlev)*rtapfac(jlev,jobs))/lcolumng%rppobs(jlev,jobs)
          lcolumn%ps(1,jobs)=lcolumn%ps(1,jobs)+
     &          lcolumng%tt(jlev,jobs)*zcon * lcolumnt%tt(jlev,jobs)

          lcolumnt%tt(jlev,jobs)=rtapfac(jlev,jobs)*lcolumnt%tt(jlev,jobs)

        enddo
      enddo
!$OMP END PARALLEL DO
c
!$OMP PARALLEL DO PRIVATE(jobs,jlev)
        do jobs = 1, lcolumn%nobtot
          do jlev = 1, lcolumn%nlev
            lcolumn%tt(jlev,jobs) = lcolumn%tt(jlev,jobs)+
     &                        oltv(1,jlev,jobs)*lcolumnt%tt(jlev,jobs)
            lcolumn%hu(jlev,jobs) = lcolumn%hu(jlev,jobs)+
     &                        oltv(2,jlev,jobs)*lcolumnt%tt(jlev,jobs)
***************************************************************
c          if(llprint .and. jobs.le.15) then
c             write(nulout,*)'att2phi: jobs,jlev,OLTV(1,,),OLTV(2,,)'
c     &            , jobs,jlev,OLTV(1,jlev,jobs),OLTV(2,jlev,jobs)
c             write(nulout,*)'att2phi:gmt1,GMQ(lev,obs),GMT(lev,obs) '
c     &            ,lcolumnt%tt(jlev,jobs),lcolumn%hu(jlev,jobs),lcolumn%tt(jlev,jobs)
c             call flush(nulout)
c          endif
***************************************************************
          enddo
        enddo
!$OMP END PARALLEL DO

      call col_deallocate(lcolumnt)
c
      return

      contains

      SUBROUTINE AVTAP
*S/P AVTAP: Adjoint de VTAP
C
C AUTHOR: Luc Fillion - ARMA/AES CAN, 21 jul, 11 sep 98
C
C REVISION:
*           S. Pellerin - Sept 97 - Introduction of site constants
*                                 - Introduction of surface pressure
*                                   dependant factor (rtapfac) for eta
*                                   coordinates
*                                 - use of lcolumnt%tt for virtual temperature
* revision: Luc Fillion - ARMA/AES CAN, 3 feb 1999
*                  - Eliminate rtapfac
*           C.Charette  - ARMA sep 1999
*                  - Added LLPRINT
*           S. Pellerin *ARMA/SMC May 2000
*                  - Fix for F90 conversion
*           C. Charette ARMA/SMC FEV. 2002
*            - Commented out the if(llprint...) statements within
*              the do loops. They were preventing vectorization.
*           Bin He     - ARMA June 2005
*            - OpenMP optimization.
*           C. Charette ARMA/SMC jan. 2005
*            - Replaced print statements by write statements

      use MathPhysConstants_mod
      IMPLICIT NONE
C
      INTEGER  jobs, IKLEVM2, JK, IK
      REAL*8     ZAK, ZBK, ZCK, ZCON
      LOGICAL  LLPRINT
*implicits

      integer mythread,numthd,omp_get_thread_num,omp_get_num_threads
c
      LLPRINT = .FALSE.
      ZCON = -RGASD
      IKLEVM2 = lcolumn%nlev-2
!$OMP PARALLEL PRIVATE(jobs,jk,mythread,numthd,zak,zbk,zck)
      mythread=omp_get_thread_num()+1
      numthd=omp_get_num_threads()
      do jobs = mythread, lcolumn%nobtot,numthd
         do jk=1,lcolumn%nlev
            lcolumnt%tt(jk,jobs) = 0.0
         enddo
c
      do jk=iklevm2,1,-1
        ik = lcolumn%nlev-1-jk
        zak = -2.0*ZCON*vma(ik+1)
        zbk = -2.0*ZCON*vmb(ik+1)
        zck = -2.0*ZCON*vmc(ik+1)
!        do jobs = 1, lcolumn%nobtot
          lcolumnt%tt(ik,jobs)   = lcolumnt%tt(ik,jobs)+
     &                       lcolumn%gz(ik,jobs)*zak
          lcolumnt%tt(ik+1,jobs) = lcolumnt%tt(ik+1,jobs)+
     &                       lcolumn%gz(ik,jobs)*zbk
          lcolumnt%tt(ik+2,jobs) = lcolumnt%tt(ik+2,jobs)+
     &                       lcolumn%gz(ik,jobs)*zck
           lcolumn%gz(ik+2,jobs) = lcolumn%gz(ik+2,jobs)+lcolumn%gz(ik,jobs)
          lcolumn%gz(ik,jobs)  = 0.0
********************************************************
c          IF(LLPRINT .AND. JOBS.EQ.1) THEN
c             write(nulout,*)'avtap:ik,jobs,zak,zbk,zck= '
c     &            ,ik,jobs,zak,zbk,zck
c             write(nulout,*)
c     &            'avtap:ik,jobs,gmt1(ik,),gmt1(ik+1,),gmt1(ik+2,)= '
c     &       ,ik,jobs,lcolumnt%tt(IK,jobs),lcolumnt%tt(IK+1,jobs),lcolumnt%tt(IK+2,jobs)
c             write(nulout,*)'avtap:ik,jobs,lcolumn%gz(ik,),lcolumn%gz(ik+2,)= '
c     &            ,ik,jobs,lcolumn%gz(ik,jobs),lcolumn%gz(ik+2,jobs)
c             write(nulout,*)'avtap:ik,jobs= ',ik,jobs
c          ENDIF
**********************************************************
        enddo

      ZAK = -2.0*ZCON*VMA(lcolumn%nlev)
      ZBK = -2.0*ZCON*VMB(lcolumn%nlev)
      ZCK = -2.0*ZCON*VMC(lcolumn%nlev)
!      do jobs = 1, lcolumn%nobtot
        lcolumnt%tt(lcolumn%nlev-1,jobs) = lcolumnt%tt(lcolumn%nlev-1,jobs)+
     &             ZAK*lcolumn%gz(lcolumn%nlev-1,jobs)
        lcolumnt%tt(lcolumn%nlev,jobs)   = lcolumnt%tt(lcolumn%nlev,jobs)+
     &             ZBK*lcolumn%gz(lcolumn%nlev-1,jobs)
        lcolumnt%tt(lcolumn%nlev-2,jobs) = lcolumnt%tt(lcolumn%nlev-2,jobs)+
     &             ZCK*lcolumn%gz(lcolumn%nlev-1,jobs)
        lcolumn%gz(lcolumn%nlev-1,jobs)= 0.0
        lcolumn%gz(lcolumn%nlev,jobs)  = 0.0
********************************************************
c        IF(LLPRINT .AND. JOBS.EQ.1) THEN
c           write(nulout,*)'avtap:ik,jobs,zak,zbk,zck= ',
c     &          ik,jobs,zak,zbk,zck
c           write(nulout,*)
c     &        'avtap:ik,jobs,lcolumnt%tt(nf,),lcolumnt%tt(nf-1,),lcolumnt%tt(nf-2,)= '
c     &          ,lcolumn%nlev,jobs,lcolumnt%tt(LCOLUMN%NLEV,jobs),lcolumnt%tt(LCOLUMN%NLEV-1,jobs)
c     &          ,lcolumnt%tt(LCOLUMN%NLEV-2,jobs)
c           write(nulout,*)
c     &         'avtap:lcolumn%nlev,jobs,lcolumn%gz(lcolumn%nlev,),lcolumn%gz(lcolumn%nlev-1,)= '
c     &          ,lcolumn%nlev,jobs,lcolumn%gz(lcolumn%nlev,jobs),lcolumn%gz(lcolumn%nlev-1,jobs)
c           write(nulout,*)'avtap:lcolumn%nlev,jobs= ',lcolumn%nlev,jobs
c        ENDIF
**********************************************************
      enddo
!$OMP END PARALLEL
C
C
      RETURN
      END SUBROUTINE avtap


      end
