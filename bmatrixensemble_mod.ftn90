!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! MODULE BmatrixEnsemble (prefix="ben")
!!
!! *Purpose*: Performs transformation from control vector to analysis increment 
!!            using the spatially localized ensemble covariance matrix. This 
!!            module works for both global and limited-area applications.
!!
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble_mod
  use mpivar_mod
  use gridStateVector_mod
  use ensembleStateVector_mod
  use globalSpectralTransform_mod
  use lamSpectralTransform_mod
  use horizontalCoord_mod
  use verticalCoord_mod
  use timeCoord_mod
  use localizationFunction_mod
  use mathPhysConstants_mod
  use earthConstants_mod
  use variableTransforms_mod
  use utilities_mod
  use spectralFilter_mod
  implicit none
  save
  private

  ! public procedures
  public :: ben_Setup,ben_BSqrt,ben_BSqrtAd,ben_reduceToMPILocal,ben_reduceToMPILocal_r4,ben_expandToMPIGlobal,ben_expandToMPIGlobal_r4,ben_Finalize
  public :: ben_getScaleFactor, ben_getnEns, ben_getPerturbation, ben_getEnsMean

  logical             :: initialized = .false.

  integer,parameter   :: maxNumLevels=200
  real(8),allocatable :: scaleFactor_M(:), scaleFactor_T(:)

  integer             :: nj,ni,lonPerPE,myLonBeg,myLonEnd,latPerPE,myLatBeg,myLatEnd
  integer,allocatable :: allLonBeg(:), allLatBeg(:)
  integer             :: nLevInc_M,nLevInc_T,nkgdimInc,nLevEns_M,nLevEns_T,nkgdimEns,topLevIndex_M,topLevIndex_T
  integer             :: mynBeg,mynEnd,mynSkip,mynCount
  integer             :: mymBeg,mymEnd,mymSkip,mymCount
  integer             :: myMemberBeg,myMemberEnd,myMemberCount,maxMyMemberCount,nEnsOverDimension
  integer             :: nla_mpiglobal,nla_mpilocal,maxMyNla,nphase
  integer             :: cvDim_mpilocal,cvDim_mpiglobal
  integer             :: numStep, numStepAmplitude
  integer             :: gstID
  integer             :: numSubEns

  integer,external    :: get_max_rss, omp_get_thread_num

  ! Localizations
  integer, parameter  :: maxNumLocalLength = 20
  integer             :: nWaveBand
  
  type :: struct_ensLoc
     real(8),allocatable :: Horiz(:,:)
     real(8),allocatable :: Vert(:,:)
  end type struct_ensLoc
  type(struct_ensLoc), pointer :: ensLocal(:)

  ! Ensemble perturbations
  type(struct_ens), allocatable :: ensPerts(:)

  real(8), parameter :: rsq2 = sqrt(2.0d0)

  logical            :: HUcontainsLQ_gsv

  ! Vertical grid
  type(struct_vco),pointer :: vco_anl, vco_ens, vco_file => null()
  integer                  :: Vcode_anl, Vcode_ens

  ! Horizontal grid
  type(struct_hco), pointer :: hco_anl, hco_ens, hco_file ! Analysis and ensemble horizontal grid parameters

  ! LAM spectral transform
  type(struct_lst)          :: lst_ben    ! Spectral transform Parameters

  ! Global spectral transform
  integer, pointer    :: ilaList_mpiglobal(:)
  integer, pointer    :: ilaList_mpilocal(:)

  ! Amplitude advection
  real(8)              :: advectAmplitudeFactor
  integer, allocatable :: lonIndexAdvect(:,:,:,:)
  integer, allocatable :: latIndexAdvect(:,:,:,:)
  real(8), allocatable :: interpWeightAdvect_BL(:,:,:,:)
  real(8), allocatable :: interpWeightAdvect_BR(:,:,:,:)
  real(8), allocatable :: interpWeightAdvect_TL(:,:,:,:)
  real(8), allocatable :: interpWeightAdvect_TR(:,:,:,:)

  ! Namelist variables
  integer             :: nEns ! number of ensemble members
  real(8)             :: scaleFactor(maxNumLevels)
  real(8)             :: scaleFactorHumidity(maxNumLevels)
  integer             :: ntrunc
  character(len=256)  :: enspathname,ensfilebasename
  real(8)             :: hLocalize(maxNumLocalLength)
  real(8)             :: vLocalize(maxNumLocalLength)
  logical             :: TweakTG
  character(len=256)  :: LocalizationType
  integer             :: waveBandPeaks(maxNumLocalLength)
  logical             :: diagnostic
  character(len=2)    :: ctrlVarHumidity
  logical             :: advectAmplitude
  logical             :: removeSubEnsMeans

CONTAINS

!--------------------------------------------------------------------------
! BEN_setup
!--------------------------------------------------------------------------
  SUBROUTINE BEN_setup(hco_anl_in,vco_anl_in,cvDim_out,&
                       mode)
    implicit none
  
    type(struct_hco), pointer, intent(in) :: hco_anl_in
    type(struct_vco), pointer, intent(in) :: vco_anl_in

    character(len=*), intent(in), optional :: mode

    character(len=15) :: ben_mode

    real(8) :: zps

    real(8),allocatable :: pressureProfileEns_M(:)
    real(8),pointer :: pressureProfileInc_M(:)

    integer        :: cvDim_out
    integer        :: jlev,jn,jm,jvar,ila,return_code,status
    integer        :: fnom,fclos,ierr,nulnam
    integer        :: waveBandIndex
    integer        :: stamp_last,newdate,ndate,ntime
    character(len=256) :: ensFileName

    logical        :: lExists

    !namelist
    NAMELIST /NAMBEN/nEns,scaleFactor,scaleFactorHumidity,ntrunc,enspathname,ensfilebasename, &
                     hLocalize,vLocalize,tweakTG,LocalizationType,waveBandPeaks, &
                     diagnostic,ctrlVarHumidity,advectAmplitudeFactor,removeSubEnsMeans

    call tmg_start(12,'BEN_SETUP')

    !
    !- 1.1  Read namelist-dependent options
    !

    ! parameters from namelist
    scaleFactor(:)   = 0.0d0
    scaleFactorHumidity(:) = 1.0d0
    nEns             = 10
    ntrunc           = 30
    enspathname      = 'ensemble'
    ensfilebasename  = ''
    LocalizationType = 'LevelDependent'
    waveBandPeaks(:) =   -1.0d0
    diagnostic       = .false.
    hLocalize(:)     =   -1.0d0
    hLocalize(1)     = 2800.0d0
    vLocalize(:)     =   -1.0d0
    vLocalize(1)     =    2.0d0
    tweakTG          = .false.
    ctrlVarHumidity  = 'LQ'
    advectAmplitudeFactor = 0.0D0
    removeSubEnsMeans = .false.

    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namben,iostat=ierr)
    if (ierr.ne.0) call utl_abort('ben_setup: Error reading namelist')
    if (mpi_myid == 0) write(*,nml=namben)
    ierr = fclos(nulnam)

    ! If zero weight, skip rest of setup
    if ( sum(scaleFactor(:)) == 0.0d0 ) then
      if (mpi_myid == 0) write(*,*) 'ben_setup: scaleFactor=0, skipping rest of setup'
      cvDim_out = 0
      return
    endif

    write(*,*) 'ben_setup: enspathname = ', trim(enspathname)

    !
    !- 2.  Settings
    !
    
    !- 2.1 Mode
    if ( present(mode) ) then
       if ( trim(mode) == 'Analysis' .or. trim(mode) == 'BackgroundCheck') then
         ben_mode = trim(mode)
         if (mpi_myid == 0) write(*,*)
         if (mpi_myid == 0) write(*,*) 'ben_setup: Mode activated = ', trim(ben_mode)
       else
          write(*,*)
          write(*,*) 'mode = ', trim(mode)
          call utl_abort('ben_setup: unknown mode')
       end if
    else
       ben_mode = 'Analysis'
       if (mpi_myid == 0) write(*,*)
       if (mpi_myid == 0) write(*,*) 'ben_setup: Analysis mode activated (by default)'
    end if

    !- 2.2 Number of time step bins
    numStep = tim_nstepobsinc
    if (numStep /= 1.and.numStep /= 3.and.numStep /= 5.and.numStep /= 7) then
      call utl_abort('ben_setup: Invalid value for numStep (choose 1 or 3 or 5 or 7)!')
    endif

    !- 2.3 Horizontal grid
    hco_anl => hco_anl_in
    hco_ens => hco_anl ! ensemble members must be on analysis grid
    ni = hco_ens%ni
    nj = hco_ens%nj
    if (hco_ens%global) then
      if (mpi_myid == 0) write(*,*)
      if (mpi_myid == 0) write(*,*) 'ben_setup: GLOBAL mode activated'
    else
      if (mpi_myid == 0) write(*,*)
      if (mpi_myid == 0) write(*,*) 'ben_setup: LAM mode activated'
    endif

    !- 2.4 Vertical levels
    vco_anl => vco_anl_in
    if ( mpi_myid == 0 ) then
      call ens_fileName(ensFileName, ensPathName, ensFileBaseName, 1)
      call vco_SetupFromFile(vco_file, ensFileName) 
    endif
    call vco_mpiBcast(vco_file)
    vco_ens => vco_file ! IMPORTANT: assumes file is on correct vertical levels
    status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)
    status = vgd_get(vco_ens%vgrid,key='ig_1 - vertical coord code',value=Vcode_ens)
    if (Vcode_anl.ne.Vcode_ens) then
      write(*,*) 'ben_setup: vcode_anl = ', vcode_anl, ', vcode_ens = ', vcode_ens
      call utl_abort('ben_setup: vertical levels of ensemble not compatible with analysis grid')
    endif
    nLevEns_M = vco_ens%nLev_M
    nLevEns_T = vco_ens%nLev_T
    nLevInc_M = vco_anl%nLev_M
    nLevInc_T = vco_anl%nLev_T
    nkgdimInc = 2*nLevInc_M+2*nLevInc_T+2  ! assume 4 3d and 2 2d variables
    nkgdimEns = 2*nLevEns_M+2*nLevEns_T+2  ! assume 4 3d and 2 2d variables
    topLevIndex_M = nLevInc_M-nLevEns_M+1
    topLevIndex_T = nLevInc_T-nLevEns_T+1

    if (Vcode_anl == 5002) then
      if (nLevEns_T.ne.(nLevEns_M+1)) then
        write(*,*) 'ben_setup: nLevEns_T, nLevEns_M = ',nLevEns_T,nLevEns_M
        call utl_abort('ben_setup: Vcode=5002, nLevEns_T must equal nLevEns_M+1!')
      endif
    elseif (Vcode_anl == 5005) then
      if (nLevEns_T.ne.nLevEns_M) then
        write(*,*) 'ben_setup: nLevEns_T, nLevEns_M = ',nLevEns_T,nLevEns_M
        call utl_abort('ben_setup: Vcode=5005, nLevEns_T must equal nLevEns_M!')
      endif
    else
      write(*,*) 'Vcode_anl = ',Vcode_anl
      call utl_abort('ben_setup: unknown vertical coordinate type!')
    endif

    if (nLevEns_M.gt.nLevInc_M) then
      call utl_abort('ben_setup: ensemble has more levels than increment - not allowed!')
    endif

    if (nLevEns_M.lt.nLevInc_M) then
      if (mpi_myid == 0) write(*,*) 'ben_setup: ensemble has less levels than increment'
      if (mpi_myid == 0) write(*,*) '           some levels near top will have zero increment'
    endif

    !- 2.5 Bmatrix Weight
    allocate(scaleFactor_M(nLevEns_M))
    allocate(scaleFactor_T(nLevEns_T))
    do jlev = 1, nLevEns_T
      if (scaleFactor(jlev).gt.0.0d0) then 
        scaleFactor(jlev) = sqrt(scaleFactor(jlev))
      else
        scaleFactor(jlev) = 0.0d0
      endif
    enddo
    scaleFactor_T(1:nLevEns_T) = scaleFactor(1:nLevEns_T)
    if (Vcode_anl == 5002) then
      scaleFactor_M(1:nLevEns_M) = scaleFactor(2:(nLevEns_M+1))
    else
      scaleFactor_M(1:nLevEns_M) = scaleFactor(1:nLevEns_M)
    endif

    do jlev = 1, nLevEns_T
      if (scaleFactorHumidity(jlev).gt.0.0d0) then 
        scaleFactorHumidity(jlev) = sqrt(scaleFactorHumidity(jlev))
      else
        scaleFactorHumidity(jlev) = 0.0d0
      endif
    enddo

    !- 2.6 Spectral Transform
    if ( trim(ben_mode) == 'Analysis' ) then

      if (hco_ens%global) then

        ! Global Mode
        nphase = 2
        nla_mpiglobal = (ntrunc+1)*(ntrunc+2)/2

        call mpivar_setup_levels_npex(nEns,myMemberBeg,myMemberEnd,myMemberCount)
        call rpn_comm_allreduce(myMemberCount, maxMyMemberCount, &
                                1,"MPI_INTEGER","MPI_MAX","GRID",ierr)
        nEnsOverDimension = mpi_npex * maxMyMemberCount

        gstID = gst_setup(ni,nj,ntrunc,nEnsOverDimension)
        if (mpi_myid == 0) write(*,*) 'ben_setup: returned value of gstID = ',gstID

      else

        ! LAM mode
        call lst_Setup( lst_ben,                          & ! OUT
                        ni, nj, hco_ens%dlon, ntrunc,   & ! IN
                        'LatLonMN', nLevEns_M )             ! IN

        if (mpi_myid == 0) write(*,*) 'ben_setup: returned value of lstID = ', lst_ben%id
        nphase       = lst_ben%nphase
        nla_mpilocal = lst_ben%nla

      end if

    end if ! ben_mode

    !- 2.7 Distribute control vector over mpi processes according to member index and m
    if ( trim(ben_mode) == 'Analysis' ) then
      call mpivar_setup_m(ntrunc,mymBeg,mymEnd,mymSkip,mymCount)
      call mpivar_setup_n(ntrunc,mynBeg,mynEnd,mynSkip,mynCount)

      if (hco_ens%global) then
        ! compute arrays to facilitate conversions between ila_mpilocal and ila_mpiglobal
        call gst_ilaList_mpiglobal(ilaList_mpiglobal,nla_mpilocal,maxMyNla,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
        call gst_ilaList_mpilocal(ilaList_mpilocal,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
        write(*,*) 'ben_setup: nla_mpiglobal, nla_mpilocal, maxMyNla = ', nla_mpiglobal, nla_mpilocal, maxMyNla
      end if
    end if

    !- 2.8 Domain Partionning
    call mpivar_setup_latbands(nj,latPerPE,myLatBeg,myLatEnd)
    call mpivar_setup_lonbands(ni,lonPerPE,myLonBeg,myLonEnd)
    allocate(allLonBeg(mpi_npex))
    CALL rpn_comm_allgather(myLonBeg,1,"mpi_integer",       &
                            allLonBeg,1,"mpi_integer","EW",ierr)
    allocate(allLatBeg(mpi_npey))
    CALL rpn_comm_allgather(myLatBeg,1,"mpi_integer",       &
                            allLatBeg,1,"mpi_integer","NS",ierr)

    !- 2.9 Localization
    if ( trim(ben_mode) == 'Analysis' ) then
      call loc_setup('FifthOrder') ! IN
      if (trim(LocalizationType) == 'LevelDependent') then
         if (mpi_myid == 0) write(*,*)
         if (mpi_myid == 0) write(*,*) 'ben_setup: Level-Dependent (Standard) localization will be used'
         nWaveBand = 1
      else if (trim(LocalizationType) == 'ScaleDependent') then
         if (mpi_myid == 0) write(*,*)
         if (mpi_myid == 0) write(*,*) 'ben_setup: Scale-Dependent localization will be used'
         nWaveBand = count(waveBandPeaks .ge. 0)
         if ( nWaveBand <= 1 ) then
            call utl_abort('ben_setup: nWaveBand <= 1')
         end if
         ! You must provide nWaveBand wavenumbers in decreasing order
         ! e.g. For a 3 wave bands decomposition...
         !      wavenumber #1 = where the response function for wave band 1 (hgh res) reaches 1 
         !                      and stays at 1 for higher wavenumbers
         !      wavenumber #2 = where the response function for wave band 2 reaches 1
         !      wavenumber #3 = where the response function for wave band 3 (low res) reaches 1 
         !                      and stays at 1 for lower wavenumbers
         ! See FilterResponseFunction for further info...

         ! Make sure that the wavenumbers are in the correct (decreasing) order
         do waveBandIndex = 1, nWaveBand-1
            if ( waveBandPeaks(waveBandIndex)-waveBandPeaks(waveBandIndex+1) <= 0 ) then
               call utl_abort('ben_setup: waveBandPeaks are not in decreasing wavenumber order') 
            end if
         end do

         ! Make sure that we have valid localization length scales for each wave bands
         do  waveBandIndex = 1, nWaveBand
            if ( hLocalize(waveBandIndex) <= 0.0d0 ) then
               call utl_abort('ben_setup: Invalid HORIZONTAL localization length scale')
            end if
            if ( vLocalize(waveBandIndex) <= 0.0d0 ) then
               call utl_abort('ben_setup: Invalid VERTICAL localization length scale')
            end if
         end do

         ! Make sure the truncation is compatible with the waveBandPeaks
         if ( ntrunc < waveBandPeaks(1) ) then
            call utl_abort('ben_setup: The truncation is not compatible with the your scale-dependent localization')
         end if

      else
         call utl_abort('ben_setup: Invalid mode for LocalizationType')
      endif

      zps = 101000.D0
      status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_M, levels=pressureProfileInc_M, &
                           sfc_field=zps, in_log=.false.)
      if (status /= VGD_OK)then
        call utl_abort('ben_setup: ERROR from vgd_levels')
      end if

      allocate(pressureProfileEns_M(nLevEns_M))
      pressureProfileEns_M(1:nLevEns_M) = pressureProfileInc_M(topLevIndex_M:nLevInc_M)

      call setupLocalization(pressureProfileEns_M) ! IN

      deallocate(pressureProfileEns_M)
      deallocate(pressureProfileInc_M)
    end if

    !- 2.10 Control variables
    if      ( ctrlVarHumidity == 'LQ' ) then
       write(*,*)
       write(*,*) 'ben_setup: Humidity control variable = ', ctrlVarHumidity
       HUcontainsLQ_gsv = .true.
    else if ( ctrlVarHumidity == 'HU' ) then
       write(*,*)
       write(*,*) 'ben_setup: Humidity control variable = ', ctrlVarHumidity
       HUcontainsLQ_gsv = .false.
    else
       write(*,*)
       write(*,*) 'Unknown humidity control variable'
       write(*,*) 'Should be LQ or LU, found = ', ctrlVarHumidity
       call utl_abort('ben_setup')
    end if

    !
    !- 3.  Read/Process the Ensemble
    !
    
    ! Read the ensemble data
    call setupEnsemble()

    ! Pre-compute everything for advectAmplitude (only if numStep > 1)
    if(advectAmplitudeFactor==0.0D0 .or. numStep==1) then
      if(mpi_myid==0) write(*,*) 'ben_setup: advection not activated'
      advectAmplitude = .false.
      numStepAmplitude = 1
    else
      if(mpi_myid==0) write(*,*) 'ben_setup: advection activated'
      if(advectAmplitudeFactor < 0.0D0) advectAmplitudeFactor = 0.0D0 ! FOR TESTING
      advectAmplitude = .true.
      numStepAmplitude = numStep
      call setupAdvectAmplitude
    endif

    ! Special treatment for TG (skin temperature) ensemble perturbations
    if (tweakTG) call AdjustTGOverOpenWater() 

    ! Compute and write Std. Dev.
    if (diagnostic) call EnsembleDiagnostic('FullPerturbations')

    if ( trim(ben_mode) == 'Analysis' ) then

      ! Partitioned the ensemble perturbations into wave bands
      if (trim(LocalizationType) == 'ScaleDependent') then
        call EnsembleScaleDecomposition()
        if (diagnostic) call EnsembleDiagnostic('WaveBandPerturbations')
      endif

      if (hco_ens%global) then
        cvDim_mpiglobal = (ntrunc+1)*(ntrunc+1)*nLevEns_M*nEns
        cvDim_mpilocal  = 0

        do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if (jm.le.jn) then
              if (jm == 0) then
                ! controlVector only contains real part for jm=0
                cvDim_mpilocal = cvDim_mpilocal + 1*nLevEns_M*nEns
              else
                ! controlVector contains real and imag parts for jm>0
                cvDim_mpilocal = cvDim_mpilocal + 2*nLevEns_M*nEns
              endif
            endif
          enddo
        enddo
      else
        cvDim_mpiglobal = lst_ben%nlaGlobal * nphase * nLevEns_M * nEns
        cvDim_mpilocal  = nla_mpilocal      * nphase * nLevens_M * nEns
        write(*,*) 'cvDim_mpiglobal ', cvDim_mpiglobal, lst_ben%nlaGlobal, nphase, nLevEns_M, nEns
        write(*,*) 'cvDim_mpilocal  ', cvDim_mpilocal, nla_mpilocal, nphase, nLevEns_M, nEns
      endif
      cvDim_out = cvDim_mpilocal
    else
      cvDim_out = 9999 ! Dummy value > 0 to indicate to the background check (s/r compute_HBHT_ensemble) 
                       ! that Bens is used
    end if

    if ( cvDim_out == 0 ) then
      write(*,*) 'ben_setup: =========================================================='
      write(*,*) 'ben_setup: ERROR: This mpi task has zero dimension for the control vector.'
      write(*,*) 'ben_setup: This is probably because the number of mpi tasks is too large'
      write(*,*) 'ben_setup: relative to NTRUNC. Should be ok with NTRUNC >= 2*(npex or npex)'
      write(*,*) 'ben_setup: =========================================================='
      call utl_abort('ben_setup: ERROR! This mpi task has zero dimension for the control vector.')
    endif

    !
    !- 4.  Ending
    !
    initialized = .true.

    call tmg_stop(12)

  END SUBROUTINE BEN_setup

!--------------------------------------------------------------------------
! BEN_finalize
!--------------------------------------------------------------------------
  SUBROUTINE BEN_finalize()
    implicit none
    integer :: memberIndex, waveBandIndex, subEnsIndex

    if (initialized) then
       write(*,*) 'ben_finalize: deallocating B_ensemble arrays'
       do waveBandIndex = 1, nWaveBand
         call ens_deallocate(ensPerts(waveBandIndex))
       enddo
       deallocate(ensPerts)
    
       do waveBandIndex = 1, nWaveBand
          deallocate(ensLocal(waveBandIndex)%Horiz)
          deallocate(ensLocal(waveBandIndex)%Vert)
       end do
       deallocate(ensLocal)
    end if

  END SUBROUTINE BEN_finalize

!--------------------------------------------------------------------------
! ben_getScaleFactor
!--------------------------------------------------------------------------
  subroutine ben_getScaleFactor(scaleFactor_out)
    implicit none
    real(8) :: scaleFactor_out(:)
    integer :: jlev

    ! return value of 0 above highest level of ensemble
    do jlev = 1, (topLevIndex_T - 1)
      scaleFactor_out(jlev) = 0.0d0
    enddo
    ! return scale factor for thermo levels
    do jlev = topLevIndex_T, nLevInc_T
      scaleFactor_out(jlev) = scaleFactor_T(jlev-topLevIndex_T+1)
    enddo

  end subroutine ben_getScaleFactor

!--------------------------------------------------------------------------
! ben_getnEns
!--------------------------------------------------------------------------
  integer function ben_getnEns()
    !func getnEns - returns the number ensemble member
    implicit none
    ben_getnEns = nEns
  end function ben_getnEns

!--------------------------------------------------------------------------
! setupEnsemble
!--------------------------------------------------------------------------
  SUBROUTINE setupEnsemble()
    implicit none
 
    real(4), pointer     :: ptr4d_r4(:,:,:,:)
    real(8) :: multFactor
    integer :: jstep,jk,lev,waveBandIndex,memberIndex
    logical :: makeBiPeriodic
    character(len=4) :: varName

    write(*,*) 'setupEnsemble: Start'
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    !- 1. Memory allocation
    allocate(ensPerts(nWaveBand))
    do waveBandIndex = 1, nWaveBand
      call ens_allocate(ensPerts(waveBandIndex), nEns, numStep, hco_ens, vco_ens)
    enddo

    !- 2. Read ensemble
    makeBiPeriodic = (trim(LocalizationType) == 'ScaleDependent')
    call ens_readEnsemble(ensPerts(1), ensPathName, ensFileBaseName, makeBiPeriodic, ctrlVarHumidity)

    !- 3. From ensemble FORECASTS to ensemble PERTURBATIONS

    !- 3.1 remove mean
    call ens_computeMean( ensPerts(1), removeSubEnsMeans, numSubEns=numSubEns )
    call ens_removeMean( ensPerts(1) )

    !- 3.2 normalize and apply scale factors
!$OMP PARALLEL DO PRIVATE (jk,varName,lev,ptr4d_r4,jstep,memberIndex,multFactor)
    do jk = 1, ens_getNumK(ensPerts(1))
      varName = ens_getVarNameFromK(ensPerts(1),jk)
      lev = ens_getLevFromK(ensPerts(1),jk)

      if ( .not. ens_varExist(ensPerts(1), varName) ) cycle 

      ptr4d_r4 => ens_getRepack_r4(ensPerts(1),jk)

      do jstep = 1, numStep
        do memberIndex = 1, nEns

          if ( vnl_varLevelFromVarname(varName) == 'MM' ) then
            multFactor = scaleFactor_M(lev)
          elseif ( vnl_varLevelFromVarname(varName) == 'TH' ) then
            multFactor = scaleFactor_T(lev)
          else ! SF
            multFactor = scaleFactor_T(nLevEns_T)
          endif

          multFactor = multFactor/sqrt(1.0d0*dble(nEns-numSubEns))

          if (trim(varName) == 'HU') then
            multFactor = multFactor*scaleFactorHumidity(lev)
          endif

          ptr4d_r4(memberIndex,jstep,:,:) = real( real(ptr4d_r4(memberIndex,jstep,:,:),8)*multFactor, 4 )

        enddo ! memberIndex
      enddo ! jstep

    enddo ! jk
!$OMP END PARALLEL DO

    write(*,*) 'ben_setupEnsemble: finished adjusting ensemble members...'
 
  END SUBROUTINE setupEnsemble

!--------------------------------------------------------------------------
! ben_getPerturbation
!--------------------------------------------------------------------------
  SUBROUTINE ben_getPerturbation(statevector, memberIndexWanted,  &
                                 upwardExtrapolationMethod, waveBandIndexWanted, &
                                 undoNormalization)
    implicit none

    type(struct_gsv) :: statevector
    integer,          intent(in) :: memberIndexWanted
    character(len=*), intent(in) :: upwardExtrapolationMethod
    integer, optional, intent(in):: waveBandIndexWanted
    logical, optional :: undoNormalization

    real(8), pointer :: ptr4d_r8(:,:,:,:)
    real(4), pointer :: repack_r4(:,:,:,:)
    real(8) :: dnens2, scaleFactor_MT
    logical :: undoNormalization2
    integer :: waveBandIndex
    integer :: ji,jj,jstep,jk,lev,levInc,topLevOffset
    character(len=4) :: varName

    if ( trim(upwardExtrapolationMethod) /= "ConstantValue" ) then
       call utl_abort('ben_getPerturbation : Invalid value for upwardExtrapolationMethod')
    end if

    if ( present(waveBandIndexWanted) ) then
       waveBandIndex = waveBandIndexWanted
    else
       waveBandIndex = 1
    end if

    ! set default value for optional argument undoNormalization
    if ( present(undoNormalization) ) then
      undoNormalization2 = undoNormalization
    else
      undoNormalization2 = .false.
    endif

    do jk = 1, ens_getNumK(ensPerts(1))
      varName = ens_getVarNameFromK(ensPerts(1),jk)
      lev = ens_getLevFromK(ensPerts(1),jk)

      ptr4d_r8 => gsv_getField_r8(statevector, varName)
      repack_r4 => ens_getRepack_r4(ensPerts(waveBandIndex),jk)

!$OMP PARALLEL DO PRIVATE(jstep,topLevOffset,scaleFactor_MT,levInc,dnens2,jj,ji)
      do jstep = 1, numStep

        if ( vnl_varLevelFromVarname(varName) == 'MM' ) then
          topLevOffset = topLevIndex_M - 1
          scaleFactor_MT = scaleFactor_M(lev)
        elseif ( vnl_varLevelFromVarname(varName) == 'TH' ) then
          topLevOffset = topLevIndex_T - 1
          scaleFactor_MT = scaleFactor_T(lev)
        else ! SF
          topLevOffset = 0
          scaleFactor_MT = scaleFactor_T(nLevEns_T)
        endif

        levInc = lev + topLevOffset

        ! undo the normalization (optional)
        if (undoNormalization2) then
          if (scaleFactor_MT > 0.0d0) then
            dnens2 = sqrt(1.0d0*dble(nEns-1))/scaleFactor_MT
          else
            if (jstep == 1) then 
              write(*,*) 'scalefactor not positive, cannot undo normalization!'
              write(*,*) varName,scaleFactor_MT,lev
            endif
            dnens2 = 0.0d0
          endif
          if (varName == 'HU  ') then
            if (scaleFactorHumidity(lev).gt.0.0d0) then
              dnens2 = dnens2/scaleFactorHumidity(lev)
            else
              if (jstep == 1) then
                write(*,*) 'Humidity scalefactor not positive, cannot undo normalization!'
                write(*,*) varName,scaleFactorHumidity(lev),lev
              endif
            endif
          endif
        else
          dnens2 = 1.0d0
        endif

        do jj = myLatBeg, myLatEnd
          do ji = myLonBeg, myLonEnd
            ptr4d_r8(ji,jj,levInc,jstep) =   &
              dnens2*dble(repack_r4(memberIndexWanted,jstep,ji,jj))
          enddo
        enddo

        if ( topLevOffset > 0 .and. lev == 1) then
          ! Fill the gap between the ensemble lid and the analysis lid

          ! undo the normalization (optional)
          if (undoNormalization2) then
            if (scaleFactor(1) > 0.0d0) then
              dnens2 = sqrt(1.0d0*dble(nEns-1))/scaleFactor(1)
            else
              if (jstep == 1) then
                write(*,*) 'scalefactor(top) not positive, cannot undo normalization!'
                write(*,*) varName,scaleFactor(1)
              endif
              dnens2 = 0.0d0
            endif
            if (varName == 'HU  ') then
              if (scaleFactorHumidity(1) > 0.0d0) then
                dnens2 = dnens2/scaleFactorHumidity(1)
              else
                if (jstep == 1) then
                  write(*,*) 'Humidity scalefactor(top) not positive, cannot undo normalization!'
                  write(*,*) varName,scaleFactorHumidity(1)
                endif
              endif
            endif
          else
            dnens2 = 1.0d0
          endif

          do levInc = 1, topLevOffset
            ! using a constant value
            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                ptr4d_r8(ji,jj,levInc,jstep) = dnens2 *  &
                  dble(repack_r4(memberIndexWanted,jstep,ji,jj))
              enddo
            enddo
          enddo

        endif ! topLevOffset > 0

      enddo ! jstep
!$OMP END PARALLEL DO

    enddo ! jk

  END SUBROUTINE ben_getPerturbation

!--------------------------------------------------------------------------
! ben_getEnsMean
!--------------------------------------------------------------------------
  SUBROUTINE ben_getEnsMean(statevector, upwardExtrapolationMethod)
    implicit none

    type(struct_gsv) :: statevector
    character(len=*), intent(in) :: upwardExtrapolationMethod

    real(8), pointer :: ptr4d_out(:,:,:,:)
    real(8), pointer :: repack_mean(:,:,:)
    integer :: ji,jj,jstep,jk,lev,levInc,topLevOffset
    character(len=4) :: varName

    if (.not. initialized) then
      if (mpi_myid == 0) write(*,*) 'ben_getEnsMean: bMatrixEnsemble not initialized, returning zero vector'
      call gsv_zero(statevector)
      return
    endif

    if ( trim(upwardExtrapolationMethod) /= "ConstantValue" ) then
       call utl_abort('ben_getEnsMean : Invalid value for upwardExtrapolationMethod')
    end if

    do jk = 1, ens_getNumK(ensPerts(1))
      varName = ens_getVarNameFromK(ensPerts(1),jk)
      lev = ens_getLevFromK(ensPerts(1),jk)

      ptr4d_out => gsv_getField_r8(statevector, varName)
      repack_mean => ens_getRepackMean_r8(ensPerts(1), 1, jk)

!$OMP PARALLEL DO PRIVATE(jstep,topLevOffset,levInc,jj,ji)
      do jstep = 1, numStep

        if ( vnl_varLevelFromVarname(varName) == 'MM' ) then
          topLevOffset = topLevIndex_M - 1
        elseif ( vnl_varLevelFromVarname(varName) == 'TH' ) then
          topLevOffset = topLevIndex_T - 1
        else ! SF
          topLevOffset = 0
        endif

        levInc = lev + topLevOffset

        do jj = myLatBeg, myLatEnd
          do ji = myLonBeg, myLonEnd
            ptr4d_out(ji,jj,levInc,jstep) = repack_mean(jstep,ji,jj)
          enddo
        enddo

        if ( topLevOffset > 0 .and. lev == 1 ) then
          ! Fill the gap between the ensemble lid and the analysis lid

          do levInc = 1, topLevOffset
            ! using a constant value
            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                ptr4d_out(ji,jj,levInc,jstep) = repack_mean(jstep,ji,jj)
              enddo
            enddo
          enddo

        endif ! topLevOffset > 0

      enddo ! jstep
!$OMP END PARALLEL DO

    enddo ! jk

  END SUBROUTINE ben_getEnsMean

!--------------------------------------------------------------------------
! AdjustTGOverOpenWater
!--------------------------------------------------------------------------
  SUBROUTINE AdjustTGOverOpenWater()
    implicit none

    real(4), allocatable :: TrialLandSeaMask(:,:), TrialSeaIceMask(:,:)
    real(4), allocatable :: AnalLandSeaMask(:,:), AnalSeaIceMask(:,:)

    real(4), allocatable :: tgstdbg_tmp(:,:)
    real(4), pointer     :: repack_TG(:,:,:,:), repack_TT2m(:,:,:,:)

    integer :: jlat, jlon, jstep, memberIndex

    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4
    integer :: ierr,ipas,ntrials
    integer :: idateo
    integer :: fstprm,fstinf,iultg,fnom,fclos,fstouv,fstfrm
    integer :: TrlmNumberWanted
    integer :: fstlir, fstecr, key, fstinl, nultrl, ni_trial, nj_trial
    integer :: deet, npas, nbits, datyp
    integer :: swa, lng, dltf, ubc
    integer :: extra1, extra2, extra3
    
    integer :: ezdefset, ezqkdef, ezsint, ezsetopt, TrialGridID

    character(len=2)  :: typvar
    character(len=1)  :: grtyp
    character(len=4)  :: nomvar
    character(len=12) :: etiket

    character(len=2) :: flnum
    character(len=128) :: trialfile

    logical :: trialExists

    integer :: levTG, levTT2m

    if ( mpi_myid == 0 ) write(*,*)
    if ( mpi_myid == 0 ) write(*,*) 'Adjusting TG ensemble perturbations over Open Water'

    !- Read MG and GL in the middle of the assimilation time window
    if ( tim_nStepObs == 1 ) then
       TrlmNumberWanted = 1
    else
       TrlmNumberWanted = nint( (tim_nStepObs + 1.d0) / 2.d0)
    end if
    
    write(flnum,'(I2.2)') TrlmNumberWanted
    trialfile='./trlm_'//trim(flnum)
    inquire(file=trim(trialfile),exist=trialExists)

    if ( .not. trialExists ) then
       if ( mpi_myid == 0 ) write(*,*)
       if ( mpi_myid == 0 ) write(*,*) 'Trial file not found = ', trialfile
       if ( mpi_myid == 0 ) write(*,*) 'Look for an ensemble of trial files '
       
       trialfile='./trlm_'//trim(flnum)//'_0001'
       inquire(file=trim(trialfile),exist=trialExists)
       if ( .not. trialExists ) then
          if ( mpi_myid == 0 ) write(*,*) 'Ensemble trial file not found = ', trialfile
          call utl_abort('BMatrixEnsemble : DID NOT FIND A TRIAL FIELD FILE')
       end if
    end if

    nultrl = 0
    ierr = fnom(nultrl,trim(trialfile),'RND+OLD+R/O',0)
    ierr = fstouv(nultrl,'RND+OLD')

    !- Determine grid size and EZSCINT ID
    idateo    = -1
    etiket = ' '
    ip1      = -1
    ip2      = -1
    ip3      = -1
    typvar = ' '
    nomvar = 'MG'

    key = fstinf( nultrl,                                             & ! IN
                  ni_trial, nj_trial, ink,                            & ! OUT
                  idateo, etiket, ip1, ip2, ip3, typvar, nomvar ) ! IN

    if (key < 0) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to find trial field = ',nomvar
       call utl_abort('BMatrixEnsemble')
    end if

    ierr = fstprm( key,                                                 & ! IN
                   idateo, deet, npas, ni_trial, nj_trial, ink, nbits,  & ! OUT
                   datyp, ip1, ip2, ip3, typvar, nomvar, etiket,  & ! OUT
                   grtyp, ig1, ig2, ig3,                              & ! OUT
                   ig4, swa, lng, dltf, ubc, extra1, extra2, extra3 )     ! OUT

    allocate(TrialLandSeaMask(ni_trial, nj_trial))
    allocate(TrialSeaIceMask(ni_trial, nj_trial))

    idateo   = -1
    etiket = ' '
    ip1      = -1
    ip2      = -1
    ip3      = -1
    typvar = ' '
    nomvar = 'MG'
    ierr = fstlir(TrialLandSeaMask, nultrl, ini, inj, ink,  &
                  idateo ,etiket, ip1, ip2, ip3, typvar, nomvar)
    if ( ierr < 0 ) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to read trial field = ',nomvar
       call utl_abort('BMatrixEnsemble : fstlir failed')
    end if

    if (ini /= ni_trial .or. inj /= nj_trial) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Invalid dimensions for ...'
       write(*,*) 'nomvar      =', trim(nomvar)
       write(*,*) 'etiket      =', trim(etiket)
       write(*,*) 'ip1         =', ip1
       write(*,*) 'Found ni,nj =', ini, inj 
       write(*,*) 'Should be   =', ni_trial, nj_trial
       call utl_abort('bMatrixEnsemble')
    end if

    nomvar = 'GL'
    ierr = fstlir(TrialSeaIceMask, nultrl, ini, inj, ink,  &
                    idateo ,etiket, ip1, ip2, ip3, typvar, nomvar)
    if ( ierr < 0 ) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to read trial field = ',nomvar
       call utl_abort('BMatrixEnsemble : fstlir failed')
    end if

    if (ini /= ni_trial .or. inj /= nj_trial) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Invalid dimensions for ...'
       write(*,*) 'nomvar      =', trim(nomvar)
       write(*,*) 'etiket      =', trim(etiket)
       write(*,*) 'ip1         =', ip1
       write(*,*) 'Found ni,nj =', ini, inj 
       write(*,*) 'Should be   =', ni_trial, nj_trial
       call utl_abort('bMatrixEnsemble')
    end if

    TrialGridID  = ezqkdef( ni_trial, nj_trial, grtyp, ig1, ig2, ig3, ig4, nultrl )   ! IN
 
    ierr = fstfrm(nultrl)  
    ierr = fclos(nultrl)

    !- Interpolate to the Analysis Grid
    allocate(AnalLandSeaMask(hco_ens%ni, hco_ens%nj))
    allocate(AnalSeaIceMask(hco_ens%ni, hco_ens%nj))

    ierr = ezdefset( hco_ens%EZscintID, TrialGridID ) ! IN,  IN
    ierr = ezsetopt('INTERP_DEGREE', 'NEAREST') ! Nearest-neighbor interpolation

    ierr = ezsint  (AnalLandSeaMask, TrialLandSeaMask) ! OUT, IN
    ierr = ezsint  (AnalSeaIceMask , TrialSeaIceMask ) ! OUT, IN

    deallocate(TrialLandSeaMask)
    deallocate(TrialSeaIceMask)

    !- Modify the TG ensemble perturbations
    levTG   = 2 + 2*nLevEns_M + 2*nLevEns_T
    levTT2m = 2*nLevEns_M + nLevEns_T

    repack_TG => ens_getRepack_r4(ensPerts(1), levTG)
    repack_TT2m => ens_getRepack_r4(ensPerts(1), levTT2m)
    do jlat = myLatBeg, myLatEnd
       do jlon = myLonBeg, myLonEnd

          if ( AnalLandSeaMask(jlon,jlat) <= 0.1 .and. AnalSeaIceMask(jlon,jlat) <= 0.2 ) then
             ! We have an open water point. Replace TG perturbations by 2m T perturbations.
             ! This is done because the EnKF does not perturbed the SST => TG ens pert = 0 over open water.
             do jstep = 1, numStep
                do memberIndex = 1, nens
                   repack_TG(memberIndex,jstep,jlon,jlat) = repack_TT2m(memberIndex,jstep,jlon,jlat)
                enddo
             enddo
          end if
       end do
    end do

    !- Write the modified TG

    !allocate(tgstdbg_tmp(hco_ens%ni,hco_ens%nj))
    !tgstdbg_tmp(:,:) = 0.0
    !ptr4d_r4 => ens_getField_r4(ensPerts(1),1)
    !do jlat = myLatBeg, myLatEnd
    !   do jlon = myLonBeg, myLonEnd
    !      tgstdbg_tmp(jlon,jlat) = ptr4d_r4(jlon,jlat,levTG,1)
    !   end do
    !end do
    !call rpn_comm_allreduce(tgstdbg_tmp,tgstdbg_tmp,hco_ens%ni*hco_ens%nj,"mpi_real","mpi_sum","GRID",ierr)
    !
    !if ( mpi_myid == 0 ) then
    !
    !    iultg = 0
    !    ierr = fnom(iultg,'tg_enspert_tweaked.fst','RND',0)
    !    ierr = fstouv(iultg,'RND')
    !
    !    ini = hco_ens%ni
    !    inj = hco_ens%nj
    !    ink = 1
    !    ip1 = 0
    !    ip2 = 0
    !    ip3 = 0
    !    idateo = 0
    !    typvar = 'E'
    !    nomvar = 'TG'
    !    etiket = 'MOD_ENS_PERT'
    !    grtyp = 'G'
    !    ig1 = 0
    !    ig2 = 0
    !    ig3 = 0
    !    ig4 = 0
    !    idatyp = 1
    !
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, typvar,         &
    !                   nomvar,etiket,grtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    ! end if
    !
    ! tgstdbg_tmp(:,:) = 0.0
    ! ptr4d_r4 => ens_getField_r4(ensPerts(1),1)
    ! do jlat = myLatBeg, myLatEnd
    !    do jlon = myLonBeg, myLonEnd
    !       tgstdbg_tmp(jlon,jlat) = ptr4d_r4(jlon,jlat,levTT2m,1)
    !    end do
    ! end do
    ! call rpn_comm_allreduce(tgstdbg_tmp,tgstdbg_tmp,hco_ens%ni*hco_ens%nj,"mpi_real","mpi_sum","GRID",ierr)
    !
    ! if ( mpi_myid == 0 ) then
    !    typvar = 'E'
    !    nomvar = 'TT'
    !    etiket = 'RAW_ENS_PERT'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, 12000, ip2, ip3, typvar,         &
    !                   nomvar,etiket,grtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    do jlat = 1, hco_ens%nj
    !      do jlon = 1,hco_ens%ni
    !         tgstdbg_tmp(jlon,jlat) = AnalLandSeaMask(jlon,jlat)
    !      end do
    !    end do
    !    typvar = 'P'
    !    nomvar = 'MG'
    !    etiket = 'TRIAL2ANAL'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, typvar,         &
    !                   nomvar,etiket,grtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    do jlat = 1, hco_ens%nj
    !      do jlon = 1,hco_ens%ni
    !         tgstdbg_tmp(jlon,jlat) = AnalSeaIceMask(jlon,jlat)
    !      end do
    !    end do       
    !    typvar = 'P'
    !    nomvar = 'GL'
    !    etiket = 'TRIAL2ANAL'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, typvar,         &
    !                   nomvar,etiket,grtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    ierr = fstfrm(iultg)
    !    ierr = fclos(iultg)
    ! end if
    !
    ! deallocate(tgstdbg_tmp)

    deallocate(AnalLandSeaMask)
    deallocate(AnalSeaIceMask)

  END SUBROUTINE AdjustTGOverOpenWater

!--------------------------------------------------------------------------
! CheckEnsDim
!--------------------------------------------------------------------------
  SUBROUTINE CheckEnsDim(niEns,njEns,nkEns,nomvar)
    implicit none

    integer,      intent(in) :: niEns,njEns,nkEns
    character(*), intent(in) :: nomvar

    if ( niEns /= lonPerPE  .or. &
         njEns /= latPerPE  .or. &
         nkEns /= 1 ) then

       write(*,*) 'Variable :', trim(nomvar)
       write(*,*) 'i-dim = ', niEns, lonPerPE
       write(*,*) 'j-dim = ', njEns, latPerPE
       write(*,*) 'k-dim = ', nkEns, 1
       call utl_abort('Ensemble dimensions are incompatible with the topology and/or the analysis grid')
    endif

  END SUBROUTINE CheckEnsDim

!--------------------------------------------------------------------------
! EnsembleScaleDecomposition
!--------------------------------------------------------------------------
  SUBROUTINE EnsembleScaleDecomposition()
    implicit none

    integer :: waveBandIndex, memberindex, jstep, jk, jj, ji
    integer :: ila_filter, p, nla_filter, nphase_filter

    real(8), allocatable :: ResponseFunction(:,:)

    real(8), allocatable :: bandSum(:,:)
    real(8) :: totwvnb_r8

    real(8), allocatable :: ensPertSP(:,:,:)
    real(8), allocatable :: ensPertSPfiltered(:,:,:)
    real(8), allocatable :: ensPertGD(:,:,:)
    real(4), pointer     :: ptr4d_r4(:,:,:,:)

    integer, allocatable :: jn_vec(:)

    integer :: gstID2, jm, jn

    type(struct_lst)    :: lst_ben_filter ! Spectral transform Parameters for filtering

    character(len=19)   :: kind

    !
    ! --- Ensemble Perturbation Data at the Start  ---
    ! ensPerts(1          ,:) contains the full perturbations
    ! ensPerts(2:nWaveBand,:) already allocated but empty
    !
    ! --- Ensemble Perturbation Data at the End    ---
    ! ensPerts(nWaveBand,:) contains the largest scales
    ! ...
    ! ensPerts(1        ,:) contains the smallest scales
    !

    call utl_abort('EnsembleScaleDecomposition: this subroutine is not implemented yet!')

    if ( mpi_myid == 0 ) then
       write(*,*)
       write(*,*) 'Scale decomposition of the ensemble perturbations'
       write(*,*) '   number of WaveBands = ', nWaveBand
       write(*,*) '   WaveBand Peaks (total wavenumber)...'
       do waveBandIndex = 1, nWaveBand
          write(*,*) waveBandIndex, waveBandPeaks(waveBandIndex)
       end do
    end if

    !
    !- Setup a spectral transform for filtering (nk = nkgdimEns)
    !
    if (hco_ens%global) then
       ! Global mode
       gstID2 = gst_setup(ni,nj,ntrunc,nkgdimEns)
       if (mpi_myid == 0) write(*,*) 'BEN : returned value of gstID2 = ',gstID2
       nla_filter = nla_mpilocal ! should be recomputed here based on gstID2 info
       nphase_filter = 2
       allocate(jn_vec(nla_filter))
       ila_filter = 0
       do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if (jm.le.jn) then
               ila_filter = ila_filter + 1
               jn_vec(ila_filter) = jn
            end if
          enddo
       enddo
    else
       ! LAM mode
        call lst_Setup( lst_ben_filter,               & ! OUT
                        ni, nj, hco_ens%dlon, ntrunc, & ! IN
                        'LatLonMN', nkgdimEns )         ! IN
        nla_filter = lst_ben_filter%nla
        nphase_filter = lst_ben_filter%nphase
    end if

    !
    !- 1.  Scale decomposition for every wave band except for wave band #1
    !
    allocate(ResponseFunction(nla_filter,2:nWaveBand))
    allocate(ensPertSP(nla_filter,nphase_filter,nkgdimEns))
    allocate(ensPertSPfiltered(nla_filter,nphase_filter,nkgdimEns))
    allocate(ensPertGD(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nkgdimEns))

    ensPertSP(:,:,:) = 0.0d0
    ensPertSPfiltered(:,:,:) = 0.0d0

    !- 1.1 Pre-compute the response function for each wave band except for wave band #1
    do waveBandIndex = nWaveBand, 2, -1 ! Start with the largest scales
       do ila_filter = 1, nla_filter
          if (hco_ens%global) then
             totwvnb_r8 = real(jn_vec(ila_filter),8)
          else
             totwvnb_r8 = lst_ben_filter%k_r8(ila_filter)
          endif
          ResponseFunction(ila_filter,waveBandIndex) = spf_FilterResponseFunction(totwvnb_r8,waveBandIndex, waveBandPeaks, nWaveBand)
       end do
    end do
    if (hco_ens%global) deallocate(jn_vec)

    do jstep = 1, numStep ! Loop on ensemble time bin
       do memberIndex = 1, nEns ! Loop on ensemble member
!NOT IMPLEMENTED YET          ptr4d_r4 => ens_getField_r4(ensPerts(1),memberIndex)

          !- 1.2 GridPoint space -> Spectral Space
!$OMP PARALLEL DO PRIVATE (jk,jj,ji)
          do jk = 1, nkgdimEns
             do jj = myLatBeg, myLatEnd
                do ji = myLonBeg, myLonEnd
                   ensPertGD(ji,jj,jk) = dble(ptr4d_r4(ji,jj,jk,jstep))
                end do
             end do
          end do
!$OMP END PARALLEL DO
          if (hco_ens%global) then
             ! Global Mode
             call gst_setID(gstID2) ! IN
             call gst_reespe(ensPertSP, & ! OUT
                             ensPertGD)   ! IN
          else
             ! LAM mode
             kind = 'GridPointToSpectral'
             call lst_VarTransform( lst_ben_filter%id, & ! IN
                                    ensPertSP,           & ! OUT
                                    ensPertGD,           & ! IN 
                                    kind, nkgdimEns )      ! IN
          end if

          !- 1.3 Filtering and transformation back to grid point space 
          do waveBandIndex = nWaveBand, 2, -1 ! Start with the largest scales
             ! Filtering
!$OMP PARALLEL DO PRIVATE (jk,p,ila_filter)
             do jk = 1, nkgdimEns
                do p = 1, nphase_filter
                   do ila_filter = 1, nla_filter
                      ensPertSPfiltered(ila_filter,p,jk) = &
                           ensPertSP(ila_filter,p,jk) * ResponseFunction(ila_filter,waveBandIndex)
                   end do
                end do
             end do
!$OMP END PARALLEL DO

             ! Spectral Space -> GridPoint space
             if (hco_ens%global) then
                ! Global Mode
                call gst_setID(gstID2) ! IN
                call gst_speree(ensPertSPfiltered, & ! IN
                                ensPertGD)           ! OUT
             else
                ! LAM mode
                kind = 'SpectralToGridPoint'
                call lst_VarTransform( lst_ben_filter%id, & ! IN
                                       ensPertSPfiltered, & ! IN
                                       ensPertGD,         & ! OUT
                                       kind, nkgdimEns )    ! IN
             end if
!NOT IMPLEMENTED YET             ptr4d_r4 => ens_getField_r4(ensPerts(waveBandIndex),memberIndex)
!$OMP PARALLEL DO PRIVATE (jk,jj,ji)
             do jk = 1, nkgdimEns
                do jj = myLatBeg, myLatEnd
                   do ji = myLonBeg, myLonEnd
                      ptr4d_r4(ji,jj,jk,jstep) = sngl(ensPertGD(ji,jj,jk))
                   end do
                end do
             end do
!$OMP END PARALLEL DO

          end do ! waveBandIndex
       end do ! ensemble member
    end do ! time bins

    deallocate(ensPertGD)
    deallocate(ResponseFunction)
    deallocate(ensPertSP)
    deallocate(ensPertSPfiltered)

    !
    !- 2.  Isolate the smallest scales in waveBandIndex = 1 by difference in grid point space
    !
    allocate(bandSum(myLonBeg:myLonEnd,myLatBeg:myLatEnd))
    do jstep = 1, numStep
!$OMP PARALLEL DO PRIVATE (memberindex,jk,jj,ji,waveBandIndex,bandsum,ptr4d_r4)
       do memberIndex = 1, nEns
          do jk = 1, nkgdimEns
             bandSum(:,:) = 0.d0
             do waveBandIndex = 2, nWaveBand
!NOT IMPLEMENTED YET                ptr4d_r4 => ens_getField_r4(ensPerts(waveBandIndex),memberIndex)
                do jj = myLatBeg, myLatEnd
                   do ji = myLonBeg, myLonEnd
                     bandSum(ji,jj) = bandSum(ji,jj) + dble(ptr4d_r4(ji,jj,jk,jstep))
                   end do
                end do
             end do
!NOT IMPLEMENTED YET             ptr4d_r4 => ens_getField_r4(ensPerts(1),memberIndex)
             do jj = myLatBeg, myLatEnd
                do ji = myLonBeg, myLonEnd
                   ptr4d_r4(ji,jj,jk,jstep) = sngl(dble(ptr4d_r4(ji,jj,jk,jstep)) - bandSum(ji,jj))
                end do
             end do
          end do
       end do
!$OMP END PARALLEL DO
    end do
    deallocate(bandSum)

  END SUBROUTINE EnsembleScaleDecomposition

!--------------------------------------------------------------------------
! setupLocalization
!--------------------------------------------------------------------------
  SUBROUTINE setupLocalization(pressureProfile)
    implicit none

    real(8), intent(in) :: pressureProfile(:)

    real(8)  :: zlc,zr,zpole,zcorr

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr
    integer :: waveBandIndex

    real(8)  :: local_length(nLevEns_M)

    !
    !- 1. Allocation for the structure
    !
    allocate(ensLocal(nWaveBand))

    !
    !- 2. Setup Localization for each WaveBand
    !
    do waveBandIndex = 1, nWaveBand

       !- 2.1 Allocation
       allocate(ensLocal(waveBandIndex)%Horiz(0:ntrunc,nLevEns_M),stat=ierr)
       if (ierr.ne.0 ) then
          write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=9',ierr
          call utl_abort('aborting in ben: setupLocalization')
       endif

       allocate(ensLocal(waveBandIndex)%Vert(nLevEns_M,nLevEns_M),stat=ierr)
       if (ierr.ne.0 ) then
          write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=10',ierr
          call utl_abort('aborting in ben: setupLocalization')
       endif

       !- 2.2.  Compute HORIZONTAL localization correlation matrix

       !  2.1.2 Determine localization length scale for each vertical level
       if ( ( trim(LocalizationType) == 'LevelDependent' .and. hLocalize(2) < 0.0d0 ) .or. &
              trim(LocalizationType) == 'ScaleDependent' ) then
          ! vertically constant horizontal localization
          local_length(:) = hLocalize(waveBandIndex)
       else
          ! vertically varying horizontal localization (linear in log P)
          do jk = 1, nLevEns_M
             local_length(jk) = ( hLocalize(1)*( log(pressureProfile(jk       ))-log(pressureProfile(1 )) ) +    &
                                  hLocalize(2)*( log(pressureProfile(nLevEns_M))-log(pressureProfile(jk)) ) ) /  &
                                               ( log(pressureProfile(nLevEns_M))-log(pressureProfile(1)) )
             if (mpi_myid == 0) write(*,*) 'bmatrixEnsemble: localization length scale (',jk,') = ',local_length(jk)
          enddo
       endif

       !- 2.1.3 Compute matrix
       if (hco_ens%global) then
          call setupGlobalHLoc(local_length, waveBandIndex) ! IN
       else
          call setupLamHLoc(local_length, waveBandIndex) ! IN
       endif

       !- 1.3.  Compute VERTICAL localization correlation matrix
    
       !  1.3.1 Calculate 5'th order function
       ZLC = vLocalize(waveBandIndex)
       do jk1 = 1, nLevEns_M
          do jk2 = 1, nLevEns_M
             ZR = abs(log(pressureProfile(jk2)) - log(pressureProfile(jk1)))
             zcorr = loc_response(zr,zlc)
             !if (zcorr.lt.0.0d0) zcorr = 0.0d0
             ensLocal(waveBandIndex)%Vert(jk1,jk2) = zcorr
          enddo
       enddo

       !- 1.3.2 Compute sqrt of the matrix if vertical localization requested
       call utl_matSqrt(ensLocal(waveBandIndex)%Vert(1,1),nLevEns_M,1.0d0,.false.)

    end do

    !
    !- 3.  Ending
    !
    if (mpi_myid == 0) write(*,*) 'done setting up localization function'

  END SUBROUTINE setupLocalization

!--------------------------------------------------------------------------
! setupGlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupGlobalHLoc(local_length, waveBandIndex)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns_M)
    integer, intent(in)  :: waveBandIndex

    real(8) ::   zlc,zr,zpole,zcorr

    ! NOTE: arrays passed to spectral transform are dimensioned as follows
    !       gd: lat/lon tiles and sp: member index
    real(8) :: zsp_mpilocal(nla_mpilocal,nphase,nLevEns_M)
    real(8) :: zsp_mpiglobal(nla_mpiglobal,nphase,nLevEns_M)
    real(8) :: zsp_mympiglobal(nla_mpiglobal,nphase,nLevEns_M)
    real(8) :: zgd_gst(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr
    integer :: ila_mpiglobal,jla_mpilocal,gstID2

    if (local_length(1).gt.0.0d0) then

      gstID2 = gst_setup(ni,nj,ntrunc,nLevEns_M)

      zgd_gst(:,:,:) = 0.0d0
      do jk = 1, nLevEns_M
        ! Calculate 5th Order Correlation Functions in Physical Space
        zlc = 1000.0d0*local_length(jk)
        do jlat = myLatBeg, myLatEnd
          zr = ra * acos(gst_getrmu(jlat,gstID2))
          zcorr = loc_response(zr,zlc)
          do jlon = myLonBeg, myLonEnd
            zgd_gst(jlon,jlat,jk) = zcorr
          enddo
        enddo
      enddo

      ! Transform to spectral space
      zsp_mpilocal(:,:,:) = 0.0d0
      call gst_setID(gstID2)
      call gst_reespe(zsp_mpilocal,zgd_gst)

      ! Make mpiglobal in spectral space
      zsp_mympiglobal(:,:,:) = 0.0d0
      do jla_mpilocal = 1, nla_mpilocal
        ila_mpiglobal = ilaList_mpiglobal(jla_mpilocal)
        zsp_mympiglobal(ila_mpiglobal,:,:) = zsp_mpilocal(jla_mpilocal,:,:)
      enddo
      nsize = nla_mpiglobal*nphase*nLevEns_M
      zsp_mpiglobal(:,:,:) = 0.0d0
      call rpn_comm_allreduce(zsp_mympiglobal,zsp_mpiglobal,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)
      
      ! Copy over to EnsLocal(WaveBandIndex)%Horiz and truncate to NTRUNC
      do jk = 1, nLevEns_M
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = zsp_mpiglobal(jn+1,1,jk)
        enddo
      enddo

      ! Make sure it's one at the pole
      do jk = 1, nLevEns_M
        do  jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = abs(ensLocal(waveBandIndex)%Horiz(jn,jk))
        enddo
      enddo
      do jk = 1, nLevEns_M
        zpole = 0.d0
        do  jn = 0, ntrunc
          zpole = zpole + ensLocal(waveBandIndex)%Horiz(jn,jk)*sqrt((2.d0*jn+1.d0)/2.d0)
        enddo
        if (zpole.le.0.d0) then
          write(*,*)'POLE VALUE NEGATIVE IN setupGlobalHLoc jk=',jk
          call utl_abort('setupGlobalHLoc')
        endif
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = ensLocal(waveBandIndex)%Horiz(jn,jk)/zpole
        enddo
      enddo

      ! Convert back to correlations and take sqrt
      do jk = 1, nLevEns_M
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = sqrt( 0.5d0*ensLocal(waveBandIndex)%Horiz(jn,jk) * &
                                                       ((2.0d0/(2.0d0*jn+1.0d0))**0.5d0) )
        enddo
      enddo

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocal(waveBandIndex)%Horiz to 1.0 for wavenumber 0
       do jk = 1, nLevEns_M
          ensLocal(waveBandIndex)%Horiz(:,jk) = 0.0d0
          ensLocal(waveBandIndex)%Horiz(0,jk) = 1.0d0
       enddo
    endif

  END SUBROUTINE setupGlobalHLoc

!--------------------------------------------------------------------------
! setupLamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupLamHLoc(local_length, waveBandIndex)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns_M)
    integer, intent(in)  :: waveBandIndex

    real(8), allocatable :: sp(:,:,:)
    real(8), allocatable :: gd(:,:,:)
    real(8), allocatable :: SumWeight(:)

    real(8) :: sum

    type(struct_lst)     :: lst_hloc    ! Spectral transform Parameters

    integer :: k, p, e, ila, totwvnb

    character(len=19)   :: kind

    if ( local_length(1) > 0.d0 ) then
      !
      !- 1. Enforce HORIZONTAL LOCALIZATION
      !

      !- 1.1 Setup a non-MPI spectral transform
      call lst_Setup( lst_hloc,                       & ! OUT
                      ni, nj, hco_ens%dlon, ntrunc, & ! IN
                      'NoMpi')                          ! IN

      !- 1.2 Create a correlation function in physical space
      allocate (gd(ni,nj,nLevEns_M))

      call loc_CreateBiPerFunction( gd,                           & ! OUT
                                    local_length, hco_ens%dlon, & ! IN
                                    ni, nj, nLevEns_M )             ! IN

      !- 1.3 Transform to spectral space
      allocate (sp(lst_hloc%nla, nphase, nLevEns_M))

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns_M )     ! IN
 
      !- 1.4 Compute band mean
      allocate(SumWeight(0:ntrunc))
      SumWeight  (:)  = 0.d0

      ensLocal(waveBandIndex)%Horiz(:,:) = 0.d0
      do totwvnb = 0, ntrunc
         do e = 1, lst_hloc%nePerK(totwvnb)
            ila = lst_hloc%ilaFromEK(e,totwvnb)
            do p = 1, lst_hloc%nphase
               SumWeight(totwvnb) = SumWeight(totwvnb) + lst_hloc%Weight(ila)
               do k = 1, nLevEns_M
                  ensLocal(waveBandIndex)%Horiz(totwvnb,k) = ensLocal(waveBandIndex)%Horiz(totwvnb,k) + &
                                                             lst_hloc%Weight(ila) * abs(sp(ila,p,k))
                enddo
             enddo
         enddo
      enddo

      do totwvnb = 0, ntrunc
         if (SumWeight(totwvnb) /= 0.d0) then
            ensLocal(waveBandIndex)%Horiz(totwvnb,:) = ensLocal(waveBandIndex)%Horiz(totwvnb,:) / SumWeight(totwvnb)
         else
            ensLocal(waveBandIndex)%Horiz(totwvnb,:) = 0.d0
         endif
      enddo

      deallocate(SumWeight)

      !- 1.5 Normalization to one of correlation function from spectral densities: Part 1
!$OMP PARALLEL DO PRIVATE (totwvnb,k,sum)
      do k = 1, nLevEns_M
         sum = 0.0d0
         do totwvnb = 0, ntrunc
            sum = sum + real(totwvnb,8) * ensLocal(waveBandIndex)%Horiz(totwvnb,k)
         enddo
         do totwvnb = 0, ntrunc
            if ( sum /= 0.0d0 ) then
               ensLocal(waveBandIndex)%Horiz(totwvnb,k) = ensLocal(waveBandIndex)%Horiz(totwvnb,k) / sum
            else
               ensLocal(waveBandIndex)%Horiz(totwvnb,k) = 0.d0
            endif
         enddo
      enddo
!$OMP END PARALLEL DO

      !- 1.6 Normalization to one of correlation function from spectral densities: Part 2

      !- 1.6.1 Spectral transform of a delta function (at the center of the domain)
      gd(:,:,:) = 0.d0
      gd(ni/2,nj/2,:) = 1.d0

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns_M )     ! IN

      !- 1.6.2 Apply the correlation function
!$OMP PARALLEL DO PRIVATE (totwvnb,e,ila,p,k)
      do totwvnb = 0, ntrunc
         do e = 1, lst_hloc%nePerK(totwvnb)
            ila = lst_hloc%ilaFromEK(e,totwvnb)
            do p = 1, nphase
               do k = 1, nLevEns_M
                  sp(ila,p,k) = sp(ila,p,k) * ensLocal(waveBandIndex)%Horiz(totwvnb,k) * &
                                lst_hloc%NormFactor(ila,p) * lst_hloc%NormFactorAd(ila,p)
               enddo
            enddo
         enddo
      enddo
!$OMP END PARALLEL DO

      !- 1.6.3 Move back to physical space
      kind = 'SpectralToGridPoint'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! IN
                             gd,                 & ! OUT
                             kind, nLevEns_M )     ! IN

      !- 1.6.4 Normalize to 1
      do k = 1, nLevEns_M
         if ( gd(ni/2,nj/2,k) <= 0.d0 ) then
            write(*,*) 'setupLamHLoc: Problem in normalization ',gd(ni/2,nj/2,k)
            call utl_abort('aborting in setupLamHLoc')
         endif
         if ( mpi_myid == 0 ) then
           write(*,*) 'setupLamHLoc: Normalization factor = ', k, gd(ni/2,nj/2,k), 1.d0 / gd(ni/2,nj/2,k)
         endif
         ensLocal(waveBandIndex)%Horiz(:,k) = ensLocal(waveBandIndex)%Horiz(:,k) / gd(ni/2,nj/2,k)
      enddo

      !- 1.7 Take sqrt
      ensLocal(waveBandIndex)%Horiz(:,:) = sqrt(ensLocal(waveBandIndex)%Horiz(:,:))

      deallocate(sp)
      deallocate(gd)

    else
      !
      !- 2. NO HORIZONTAL LOCALIZATION: set ensLocal%Horiz to 1.0 for wavenumber 0
      !
      ensLocal(waveBandIndex)%Horiz(:,:) = 0.0d0
      ensLocal(waveBandIndex)%Horiz(0,:) = 1.0d0
    endif

  END SUBROUTINE setupLamHLoc

!--------------------------------------------------------------------------
! BEN_reduceToMPILocal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(8), intent(out) :: cv_mpilocal(cvDim_mpilocal)
    real(8), intent(in)  :: cv_mpiglobal(:)
    integer, intent(out) :: cvDim_mpilocal_out

    real(8), allocatable :: cv_allmaxmpilocal(:,:)

    integer, allocatable :: cvDim_allMpilocal(:), displs(:)

    integer, allocatable :: ilaGlobal(:), allnlaLocal(:)
    integer, allocatable :: allilaGlobal(:,:)

    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)

    integer :: jproc, cvDim_maxmpilocal
    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpilocal, ila_mpiglobal
    integer :: jm, jn, memberIndex, jlev, ierr, p, nlaMax

    cvDim_mpilocal_out = cvDim_mpilocal

    call rpn_comm_allreduce(cvDim_mpilocal, cvDim_maxmpilocal, &
         1,"MPI_INTEGER","MPI_MAX","GRID",ierr)

    allocate(cvDim_allMpiLocal(mpi_nprocs))
    call rpn_comm_allgather(cvDim_mpiLocal   ,1,"mpi_integer",       &
                            cvDim_allMpiLocal,1,"mpi_integer","GRID",ierr)

    ! assign part of mpiglobal vector from current mpi process

    if (hco_ens%global) then

       ! Global

       allocate(allnBeg(mpi_nprocs))
       call rpn_comm_allgather(mynBeg,1,"mpi_integer",       &
                               allnBeg,1,"mpi_integer","GRID",ierr)
       allocate(allnEnd(mpi_nprocs))
       call rpn_comm_allgather(mynEnd,1,"mpi_integer",       &
                               allnEnd,1,"mpi_integer","GRID",ierr)
       allocate(allnSkip(mpi_nprocs))
       call rpn_comm_allgather(mynSkip,1,"mpi_integer",       &
                               allnSkip,1,"mpi_integer","GRID",ierr)

       allocate(allmBeg(mpi_nprocs))
       call rpn_comm_allgather(mymBeg,1,"mpi_integer",       &
                               allmBeg,1,"mpi_integer","GRID",ierr)
       allocate(allmEnd(mpi_nprocs))
       call rpn_comm_allgather(mymEnd,1,"mpi_integer",       &
                               allmEnd,1,"mpi_integer","GRID",ierr)
       allocate(allmSkip(mpi_nprocs))
       call rpn_comm_allgather(mymSkip,1,"mpi_integer",       &
                               allmSkip,1,"mpi_integer","GRID",ierr)


       if (mpi_myid == 0) then

          allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,memberIndex,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
          do jproc = 0, (mpi_nprocs-1)
             cv_allmaxmpilocal(:,jproc+1) = 0.d0

             jdim_mpilocal = 0
             do memberIndex = 1, nEns

                do jlev = 1, nLevEns_M
                   do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
                      do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)

                         if (jm.le.jn) then

                            ! figure out index into global control vector
                            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                            if (jm == 0) then
                               ! for jm=0 only real part
                               jdim_mpiglobal = ila_mpiglobal
                            else
                               ! for jm>0 both real and imaginary part
                               jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                            endif
                            ! add offset for level
                            jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                            ! add offset for member index
                            jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M
                            
                            if (jm == 0) then
                               ! controlVector only contain real part for jm=0
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)
                            else
                               ! controlVector contains real and imag parts for jm>0
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal+1)
                            endif
                           
                            if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                               write(*,*)
                               write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                               write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                               call utl_abort('ben_reduceToMPILocal')
                            end if
                            if (jdim_mpiglobal > cvDim_mpiglobal) then
                               write(*,*)
                               write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                               write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                               call utl_abort('ben_reduceToMPILocal')
                            end if
 
                         endif
                      enddo
                   enddo
                enddo
                
             enddo

          enddo ! procs
!$OMP END PARALLEL DO

       else
          allocate(cv_allmaxmpilocal(1,1))
       end if

       deallocate(allnBeg)
       deallocate(allnEnd)
       deallocate(allnSkip)
       deallocate(allmBeg)
       deallocate(allmEnd)
       deallocate(allmSkip)

    else
       
      ! LAM
      call rpn_comm_allreduce(lst_ben%nla,nlaMax,1,"mpi_integer","mpi_max","GRID",ierr)

      if (mpi_myid == 0) then
         allocate(allnlaLocal(mpi_nprocs))
         allocate(allilaGlobal(nlaMax,mpi_nprocs))
      else
         allocate(allnlaLocal(1))
         allocate(allilaGlobal(1,1))
      end if
      
      allocate(ilaGlobal(nlaMax))
      ilaGlobal(:)             = -1
      ilaGlobal(1:lst_ben%nla) = lst_ben%ilaGlobal(:)
      
      call rpn_comm_gather(lst_ben%nla, 1, "mpi_integer",       &
                           allnlaLocal, 1, "mpi_integer", 0, "GRID", ierr)
      call rpn_comm_gather(ilaGlobal   , nlaMax, "mpi_integer",       &
                           allilaGlobal, nlaMax, "mpi_integer",0 ,"GRID", ierr)

      deallocate(ilaGlobal)

      if (mpi_myid == 0) then

         allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

         do jproc = 0, (mpi_nprocs-1)
            cv_allmaxmpilocal(:,jproc+1) = 0.d0
            do memberIndex = 1, nEns
               do jlev = 1, nLevEns_M
                  do ila_mpilocal = 1, allnlaLocal(jproc+1)
                     do p = 1, lst_ben%nphase

                        jdim_mpilocal = ( (jlev-1) * nEns * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                        ( (memberIndex-1) * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                                               ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                        ila_mpiglobal = allilaGlobal(ila_mpilocal,jproc+1)
                        if ( ila_mpiglobal <= 0 ) then 
                           write(*,*) 'ben_reduceToMPILocal: invalid ila_mpiglobal index ', ila_mpiglobal
                           call utl_abort('ben_reduceToMPILocal')
                        end if
                        jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                         ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                           ( (ila_mpiglobal-1) * lst_ben%nphase ) + p
  
                        if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_reduceToMPILocal')
                         end if
                         if (jdim_mpiglobal > cvDim_mpiglobal) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_reduceToMPILocal')
                         end if
                  
                         cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)

                     end do
                  end do
               end do
            end do
         end do
      else
         allocate(cv_allmaxmpilocal(1,1))
      end if

     deallocate(allnlaLocal)
     deallocate(allilaGlobal) 
      
   end if

   !- Distribute
   allocate(displs(mpi_nprocs))
   do jproc = 0, (mpi_nprocs-1)
      displs(jproc+1) = jproc*cvDim_maxMpiLocal ! displacement wrt cv_allMaxMpiLocal from which
                                                 ! to take the outgoing data to process jproc
   end do

   call rpn_comm_scatterv(cv_allMaxMpiLocal, cvDim_allMpiLocal, displs, "mpi_double_precision", &
                          cv_mpiLocal, cvDim_mpiLocal, "mpi_double_precision", &
                          0, "GRID", ierr)

   deallocate(displs) 
   deallocate(cv_allMaxMpiLocal)
   deallocate(cvDim_allMpiLocal)
   
 END SUBROUTINE BEN_reduceToMPILocal

!--------------------------------------------------------------------------
! BEN_reduceToMPILocal_r4
!--------------------------------------------------------------------------
  SUBROUTINE BEN_reduceToMPILocal_r4(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(4), intent(out) :: cv_mpilocal(cvDim_mpilocal)
    real(4), intent(in)  :: cv_mpiglobal(:)
    integer, intent(out) :: cvDim_mpilocal_out

    real(4), allocatable :: cv_allmaxmpilocal(:,:)

    integer, allocatable :: cvDim_allMpilocal(:), displs(:)

    integer, allocatable :: ilaGlobal(:), allnlaLocal(:)
    integer, allocatable :: allilaGlobal(:,:)

    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)

    integer :: jproc, cvDim_maxmpilocal
    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpilocal, ila_mpiglobal
    integer :: jm, jn, memberIndex, jlev, ierr, p, nlaMax

    cvDim_mpilocal_out = cvDim_mpilocal

    call rpn_comm_allreduce(cvDim_mpilocal, cvDim_maxmpilocal, &
         1,"MPI_INTEGER","MPI_MAX","GRID",ierr)

    allocate(cvDim_allMpiLocal(mpi_nprocs))
    call rpn_comm_allgather(cvDim_mpiLocal   ,1,"mpi_integer",       &
                            cvDim_allMpiLocal,1,"mpi_integer","GRID",ierr)

    ! assign part of mpiglobal vector from current mpi process

    if (hco_ens%global) then

       ! Global

       allocate(allnBeg(mpi_nprocs))
       call rpn_comm_allgather(mynBeg,1,"mpi_integer",       &
                               allnBeg,1,"mpi_integer","GRID",ierr)
       allocate(allnEnd(mpi_nprocs))
       call rpn_comm_allgather(mynEnd,1,"mpi_integer",       &
                               allnEnd,1,"mpi_integer","GRID",ierr)
       allocate(allnSkip(mpi_nprocs))
       call rpn_comm_allgather(mynSkip,1,"mpi_integer",       &
                               allnSkip,1,"mpi_integer","GRID",ierr)

       allocate(allmBeg(mpi_nprocs))
       call rpn_comm_allgather(mymBeg,1,"mpi_integer",       &
                               allmBeg,1,"mpi_integer","GRID",ierr)
       allocate(allmEnd(mpi_nprocs))
       call rpn_comm_allgather(mymEnd,1,"mpi_integer",       &
                               allmEnd,1,"mpi_integer","GRID",ierr)
       allocate(allmSkip(mpi_nprocs))
       call rpn_comm_allgather(mymSkip,1,"mpi_integer",       &
                               allmSkip,1,"mpi_integer","GRID",ierr)


       if (mpi_myid == 0) then

          allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,memberIndex,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
          do jproc = 0, (mpi_nprocs-1)
             cv_allmaxmpilocal(:,jproc+1) = 0.d0

             jdim_mpilocal = 0
             do memberIndex = 1, nEns

                do jlev = 1, nLevEns_M
                   do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
                      do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)

                         if (jm.le.jn) then

                            ! figure out index into global control vector
                            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                            if (jm == 0) then
                               ! for jm=0 only real part
                               jdim_mpiglobal = ila_mpiglobal
                            else
                               ! for jm>0 both real and imaginary part
                               jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                            endif
                            ! add offset for level
                            jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                            ! add offset for member index
                            jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M
                            
                            if (jm == 0) then
                               ! controlVector only contain real part for jm=0
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)
                            else
                               ! controlVector contains real and imag parts for jm>0
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)
                               jdim_mpilocal = jdim_mpilocal + 1
                               cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal+1)
                            endif
                           
                            if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                               write(*,*)
                               write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                               write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                               call utl_abort('ben_reduceToMPILocal')
                            end if
                            if (jdim_mpiglobal > cvDim_mpiglobal) then
                               write(*,*)
                               write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                               write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                               call utl_abort('ben_reduceToMPILocal')
                            end if
 
                         endif
                      enddo
                   enddo
                enddo
                
             enddo

          enddo ! procs
!$OMP END PARALLEL DO

       else
          allocate(cv_allmaxmpilocal(1,1))
       end if

       deallocate(allnBeg)
       deallocate(allnEnd)
       deallocate(allnSkip)
       deallocate(allmBeg)
       deallocate(allmEnd)
       deallocate(allmSkip)

    else
       
      ! LAM
      call rpn_comm_allreduce(lst_ben%nla,nlaMax,1,"mpi_integer","mpi_max","GRID",ierr)

      if (mpi_myid == 0) then
         allocate(allnlaLocal(mpi_nprocs))
         allocate(allilaGlobal(nlaMax,mpi_nprocs))
      else
         allocate(allnlaLocal(1))
         allocate(allilaGlobal(1,1))
      end if
      
      allocate(ilaGlobal(nlaMax))
      ilaGlobal(:)             = -1
      ilaGlobal(1:lst_ben%nla) = lst_ben%ilaGlobal(:)
      
      call rpn_comm_gather(lst_ben%nla, 1, "mpi_integer",       &
                           allnlaLocal, 1, "mpi_integer", 0, "GRID", ierr)
      call rpn_comm_gather(ilaGlobal   , nlaMax, "mpi_integer",       &
                           allilaGlobal, nlaMax, "mpi_integer",0 ,"GRID", ierr)

      deallocate(ilaGlobal)

      if (mpi_myid == 0) then

         allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

         do jproc = 0, (mpi_nprocs-1)
            cv_allmaxmpilocal(:,jproc+1) = 0.d0
            do memberIndex = 1, nEns
               do jlev = 1, nLevEns_M
                  do ila_mpilocal = 1, allnlaLocal(jproc+1)
                     do p = 1, lst_ben%nphase

                        jdim_mpilocal = ( (jlev-1) * nEns * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                        ( (memberIndex-1) * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                                               ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                        ila_mpiglobal = allilaGlobal(ila_mpilocal,jproc+1)
                        if ( ila_mpiglobal <= 0 ) then 
                           write(*,*) 'ben_reduceToMPILocal: invalid ila_mpiglobal index ', ila_mpiglobal
                           call utl_abort('ben_reduceToMPILocal')
                        end if
                        jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                         ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                           ( (ila_mpiglobal-1) * lst_ben%nphase ) + p
  
                        if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_reduceToMPILocal')
                         end if
                         if (jdim_mpiglobal > cvDim_mpiglobal) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_reduceToMPILocal')
                         end if
                  
                         cv_allmaxmpilocal(jdim_mpilocal,jproc+1) = cv_mpiglobal(jdim_mpiglobal)

                     end do
                  end do
               end do
            end do
         end do
      else
         allocate(cv_allmaxmpilocal(1,1))
      end if

     deallocate(allnlaLocal)
     deallocate(allilaGlobal) 
      
   end if

   !- Distribute
   allocate(displs(mpi_nprocs))
   do jproc = 0, (mpi_nprocs-1)
      displs(jproc+1) = jproc*cvDim_maxMpiLocal ! displacement wrt cv_allMaxMpiLocal from which
                                                 ! to take the outgoing data to process jproc
   end do

   call rpn_comm_scatterv(cv_allMaxMpiLocal, cvDim_allMpiLocal, displs, "mpi_real4", &
                          cv_mpiLocal, cvDim_mpiLocal, "mpi_real4", &
                          0, "GRID", ierr)

   deallocate(displs) 
   deallocate(cv_allMaxMpiLocal)
   deallocate(cvDim_allMpiLocal)
   
 END SUBROUTINE BEN_reduceToMPILocal_r4

!--------------------------------------------------------------------------
! BEN_expandToMPIGlobal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none

    real(8), intent(in)  :: cv_mpilocal(cvDim_mpilocal)
    real(8), intent(out) :: cv_mpiglobal(:)
    integer, intent(out) :: cvDim_mpiglobal_out

    real(8), allocatable :: cv_maxmpilocal(:)
    real(8), pointer     :: cv_allmaxmpilocal(:,:) => null()

    integer, allocatable :: cvDim_allMpilocal(:)

    integer, allocatable :: ilaGlobal(:), allnlaLocal(:)
    integer, allocatable :: allilaGlobal(:,:)

    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)

    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpiglobal, ila_mpilocal, cvDim_maxmpilocal
    integer :: jm, jn, jproc, memberIndex, jlev, ierr, p, nlaMax

    cvDim_mpiglobal_out = cvDim_mpiglobal

    !
    !- 1.  Gather all local control vectors onto mpi task 0
    !
    allocate(cvDim_allMpiLocal(mpi_nprocs))
    call rpn_comm_allgather(cvDim_mpiLocal   ,1,"mpi_integer",       &
                            cvDim_allMpiLocal,1,"mpi_integer","GRID",ierr)

    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_maxmpilocal,1,"mpi_integer","mpi_max","GRID",ierr)

    allocate(cv_maxmpilocal(cvDim_maxmpilocal))

    cv_maxmpilocal(:) = 0.0d0
    cv_maxmpilocal(1:cvDim_mpilocal) = cv_mpilocal(1:cvDim_mpilocal)

    nullify(cv_allmaxmpilocal)
    if (mpi_myid == 0) then
       allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))
    else
       allocate(cv_allmaxmpilocal(1,1))
    end if
    call rpn_comm_gather(cv_maxmpilocal,    cvDim_maxmpilocal, "mpi_double_precision",  &
                         cv_allmaxmpilocal, cvDim_maxmpilocal, "mpi_double_precision", 0, "GRID", ierr )

    deallocate(cv_maxmpilocal)

    !
    !- 2.  Reorganize gathered mpilocal control vectors into the mpiglobal control vector
    !
    if (hco_ens%global) then

       ! Global
       if (mpi_myid == 0) then
          allocate(allnBeg(mpi_nprocs))
          allocate(allnEnd(mpi_nprocs))
          allocate(allnSkip(mpi_nprocs))
          allocate(allmBeg(mpi_nprocs))
          allocate(allmEnd(mpi_nprocs))
          allocate(allmSkip(mpi_nprocs))
       else
          allocate(allnBeg(1))
          allocate(allnEnd(1))
          allocate(allnSkip(1))
          allocate(allmBeg(1))
          allocate(allmEnd(1))
          allocate(allmSkip(1))
       end if

       call rpn_comm_gather(mynBeg  ,1,"mpi_integer",       &
                            allnBeg ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mynEnd  ,1,"mpi_integer",       &
                            allnEnd ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mynSkip ,1,"mpi_integer",       &
                            allnSkip,1,"mpi_integer",0,"GRID",ierr)

       call rpn_comm_gather(mymBeg  ,1,"mpi_integer",       &
                            allmBeg ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mymEnd  ,1,"mpi_integer",       &
                            allmEnd ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mymSkip ,1,"mpi_integer",       &
                            allmSkip,1,"mpi_integer",0,"GRID",ierr)

       ! reorganize gathered mpilocal control vectors into the mpiglobal control vector
       if (mpi_myid == 0) then
         cv_mpiglobal(:) = 0.0d0

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,memberIndex,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
         do jproc = 0, (mpi_nprocs-1)
           jdim_mpilocal = 0
           do memberIndex = 1, nEns

             do jlev = 1, nLevEns_M
               do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
                 do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)
                   if (jm.le.jn) then

                     ! figure out index into global control vector
                     ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                     if (jm == 0) then
                       ! for jm=0 only real part
                       jdim_mpiglobal = ila_mpiglobal
                     else
                       ! for jm>0 both real and imaginary part
                       jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                     endif
                     ! add offset for level
                     jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                     ! add offset for member index
                     jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M

                     ! index into local control vector
                     if (jm == 0) then
                       ! only real component for jm=0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     else
                       ! both real and imaginary components for jm>0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal+1) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     endif

                     if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                        write(*,*)
                        write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                        write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                        call utl_abort('ben_expandToMPIGlobal')
                     end if
                     if (jdim_mpiglobal > cvDim_mpiglobal) then
                        write(*,*)
                        write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                        write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                        call utl_abort('ben_expandToMPIGlobal')
                     end if

                   endif
                 enddo
               enddo
             enddo
           enddo
         enddo ! jproc
!$OMP END PARALLEL DO

      endif ! myid == 0 

      deallocate(allnBeg)
      deallocate(allnEnd)
      deallocate(allnSkip)
      deallocate(allmBeg)
      deallocate(allmEnd)
      deallocate(allmSkip)

    else

      ! LAM
       call rpn_comm_allreduce(lst_ben%nla,nlaMax,1,"mpi_integer","mpi_max","GRID",ierr)

       if (mpi_myid == 0) then
          allocate(allnlaLocal(mpi_nprocs))
          allocate(allilaGlobal(nlaMax,mpi_nprocs))
       else
          allocate(allnlaLocal(1))
          allocate(allilaGlobal(1,1))
       end if

       allocate(ilaGlobal(nlaMax))
       ilaGlobal(:)             = -1
       ilaGlobal(1:lst_ben%nla) = lst_ben%ilaGlobal(:)

       call rpn_comm_gather(lst_ben%nla, 1, "mpi_integer",       &
                            allnlaLocal, 1, "mpi_integer", 0, "GRID", ierr)
       call rpn_comm_gather(ilaGlobal   , nlaMax, "mpi_integer",       &
                            allilaGlobal, nlaMax, "mpi_integer",0 ,"GRID", ierr)

       deallocate(ilaGlobal)

       if (mpi_myid == 0) then
          cv_mpiglobal(:) = 0.0d0

          do jproc = 0, (mpi_nprocs-1)
             do memberIndex = 1, nEns
                do jlev = 1, nLevEns_M
                   do ila_mpilocal = 1, allnlaLocal(jproc+1)
                      do p = 1, lst_ben%nphase

                         jdim_mpilocal = ( (jlev-1) * nEns * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                         ( (memberIndex-1) * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                                      ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                         ila_mpiglobal = allilaGlobal(ila_mpilocal,jproc+1)
                         if ( ila_mpiglobal <= 0 ) then 
                            write(*,*) 'ben_expandToMPIGlobal: invalid ila_mpiglobal index ', ila_mpiglobal
                            call utl_abort('ben_expandToMPIGlobal')
                         end if

                         jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                          ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                            ( (ila_mpiglobal-1) * lst_ben%nphase ) + p

                         if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_expandToMPIGlobal')
                         end if
                         if (jdim_mpiglobal > cvDim_mpiglobal) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_expandToMPIGlobal')
                         end if

                         cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                         
                      end do
                   end do
                end do
             end do
          end do

       end if

       deallocate(allnlaLocal)
       deallocate(allilaGlobal)

    end if

    deallocate(cv_allmaxmpilocal)
    deallocate(cvDim_allMpiLocal)

  end SUBROUTINE BEN_expandToMPIGlobal

!--------------------------------------------------------------------------
! BEN_expandToMPIGlobal_r4
!--------------------------------------------------------------------------
  SUBROUTINE BEN_expandToMPIGlobal_r4(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none

    real(4), intent(in)  :: cv_mpilocal(cvDim_mpilocal)
    real(4), intent(out) :: cv_mpiglobal(:)
    integer, intent(out) :: cvDim_mpiglobal_out

    real(4), allocatable :: cv_maxmpilocal(:)
    real(4), pointer     :: cv_allmaxmpilocal(:,:) => null()

    integer, allocatable :: cvDim_allMpilocal(:)

    integer, allocatable :: ilaGlobal(:), allnlaLocal(:)
    integer, allocatable :: allilaGlobal(:,:)

    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)

    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpiglobal, ila_mpilocal, cvDim_maxmpilocal
    integer :: jm, jn, jproc, memberIndex, jlev, ierr, p, nlaMax

    cvDim_mpiglobal_out = cvDim_mpiglobal

    !
    !- 1.  Gather all local control vectors onto mpi task 0
    !
    allocate(cvDim_allMpiLocal(mpi_nprocs))
    call rpn_comm_allgather(cvDim_mpiLocal   ,1,"mpi_integer",       &
                            cvDim_allMpiLocal,1,"mpi_integer","GRID",ierr)

    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_maxmpilocal,1,"mpi_integer","mpi_max","GRID",ierr)

    allocate(cv_maxmpilocal(cvDim_maxmpilocal))

    cv_maxmpilocal(:) = 0.0d0
    cv_maxmpilocal(1:cvDim_mpilocal) = cv_mpilocal(1:cvDim_mpilocal)

    nullify(cv_allmaxmpilocal)
    if (mpi_myid == 0) then
       allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))
    else
       allocate(cv_allmaxmpilocal(1,1))
    end if
    call rpn_comm_gather(cv_maxmpilocal,    cvDim_maxmpilocal, "mpi_real4",  &
                         cv_allmaxmpilocal, cvDim_maxmpilocal, "mpi_real4", 0, "GRID", ierr )

    deallocate(cv_maxmpilocal)

    !
    !- 2.  Reorganize gathered mpilocal control vectors into the mpiglobal control vector
    !
    if (hco_ens%global) then

       ! Global
       if (mpi_myid == 0) then
          allocate(allnBeg(mpi_nprocs))
          allocate(allnEnd(mpi_nprocs))
          allocate(allnSkip(mpi_nprocs))
          allocate(allmBeg(mpi_nprocs))
          allocate(allmEnd(mpi_nprocs))
          allocate(allmSkip(mpi_nprocs))
       else
          allocate(allnBeg(1))
          allocate(allnEnd(1))
          allocate(allnSkip(1))
          allocate(allmBeg(1))
          allocate(allmEnd(1))
          allocate(allmSkip(1))
       end if

       call rpn_comm_gather(mynBeg  ,1,"mpi_integer",       &
                            allnBeg ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mynEnd  ,1,"mpi_integer",       &
                            allnEnd ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mynSkip ,1,"mpi_integer",       &
                            allnSkip,1,"mpi_integer",0,"GRID",ierr)

       call rpn_comm_gather(mymBeg  ,1,"mpi_integer",       &
                            allmBeg ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mymEnd  ,1,"mpi_integer",       &
                            allmEnd ,1,"mpi_integer",0,"GRID",ierr)
       call rpn_comm_gather(mymSkip ,1,"mpi_integer",       &
                            allmSkip,1,"mpi_integer",0,"GRID",ierr)

       ! reorganize gathered mpilocal control vectors into the mpiglobal control vector
       if (mpi_myid == 0) then
         cv_mpiglobal(:) = 0.0d0

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,memberIndex,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
         do jproc = 0, (mpi_nprocs-1)
           jdim_mpilocal = 0
           do memberIndex = 1, nEns

             do jlev = 1, nLevEns_M
               do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
                 do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)
                   if (jm.le.jn) then

                     ! figure out index into global control vector
                     ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                     if (jm == 0) then
                       ! for jm=0 only real part
                       jdim_mpiglobal = ila_mpiglobal
                     else
                       ! for jm>0 both real and imaginary part
                       jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                     endif
                     ! add offset for level
                     jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                     ! add offset for member index
                     jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M

                     ! index into local control vector
                     if (jm == 0) then
                       ! only real component for jm=0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     else
                       ! both real and imaginary components for jm>0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal+1) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     endif

                     if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                        write(*,*)
                        write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                        write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                        call utl_abort('ben_expandToMPIGlobal')
                     end if
                     if (jdim_mpiglobal > cvDim_mpiglobal) then
                        write(*,*)
                        write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                        write(*,*) '       proc, jlev, jn, jm = ',jproc, jlev, jn, jm
                        call utl_abort('ben_expandToMPIGlobal')
                     end if

                   endif
                 enddo
               enddo
             enddo
           enddo
         enddo ! jproc
!$OMP END PARALLEL DO

      endif ! myid == 0 

      deallocate(allnBeg)
      deallocate(allnEnd)
      deallocate(allnSkip)
      deallocate(allmBeg)
      deallocate(allmEnd)
      deallocate(allmSkip)

    else

      ! LAM
       call rpn_comm_allreduce(lst_ben%nla,nlaMax,1,"mpi_integer","mpi_max","GRID",ierr)

       if (mpi_myid == 0) then
          allocate(allnlaLocal(mpi_nprocs))
          allocate(allilaGlobal(nlaMax,mpi_nprocs))
       else
          allocate(allnlaLocal(1))
          allocate(allilaGlobal(1,1))
       end if

       allocate(ilaGlobal(nlaMax))
       ilaGlobal(:)             = -1
       ilaGlobal(1:lst_ben%nla) = lst_ben%ilaGlobal(:)

       call rpn_comm_gather(lst_ben%nla, 1, "mpi_integer",       &
                            allnlaLocal, 1, "mpi_integer", 0, "GRID", ierr)
       call rpn_comm_gather(ilaGlobal   , nlaMax, "mpi_integer",       &
                            allilaGlobal, nlaMax, "mpi_integer",0 ,"GRID", ierr)

       deallocate(ilaGlobal)

       if (mpi_myid == 0) then
          cv_mpiglobal(:) = 0.0d0

          do jproc = 0, (mpi_nprocs-1)
             do memberIndex = 1, nEns
                do jlev = 1, nLevEns_M
                   do ila_mpilocal = 1, allnlaLocal(jproc+1)
                      do p = 1, lst_ben%nphase

                         jdim_mpilocal = ( (jlev-1) * nEns * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                         ( (memberIndex-1) * allnlaLocal(jproc+1) * lst_ben%nphase ) + &
                                                      ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                         ila_mpiglobal = allilaGlobal(ila_mpilocal,jproc+1)
                         if ( ila_mpiglobal <= 0 ) then 
                            write(*,*) 'ben_expandToMPIGlobal: invalid ila_mpiglobal index ', ila_mpiglobal
                            call utl_abort('ben_expandToMPIGlobal')
                         end if

                         jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                          ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                            ( (ila_mpiglobal-1) * lst_ben%nphase ) + p

                         if (jdim_mpilocal > cvDim_allMpiLocal(jproc+1)) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpilocal > cvDim_allMpiLocal(jproc+1)', jdim_mpilocal, cvDim_allMpiLocal(jproc+1)
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_expandToMPIGlobal')
                         end if
                         if (jdim_mpiglobal > cvDim_mpiglobal) then
                            write(*,*)
                            write(*,*) 'ERROR: jdim_mpiglobal > cvDim_mpiglobal', jdim_mpiglobal, cvDim_mpiglobal
                            write(*,*) '       proc, memberIndex, jlev, ila, p = ',jproc,memberIndex,jlev,ila_mpilocal,p
                            call utl_abort('ben_expandToMPIGlobal')
                         end if

                         cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                         
                      end do
                   end do
                end do
             end do
          end do

       end if

       deallocate(allnlaLocal)
       deallocate(allilaGlobal)

    end if

    deallocate(cv_allmaxmpilocal)
    deallocate(cvDim_allMpiLocal)

  end SUBROUTINE BEN_expandToMPIGlobal_r4

!--------------------------------------------------------------------------
! BEN_BSqrt
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrt(controlVector_in,statevector)
    implicit none

    real(8)    :: controlVector_in(cvDim_mpilocal) 
    type(struct_gsv) :: statevector

    real(8)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    real(8)    :: zsp1(nla_mpilocal,nphase,nEnsOverDimension)
    real(8), pointer :: ensAmplitudeAll_M(:,:,:,:,:)
    integer   :: ierr, jlev, jlat, memberIndex, waveBandIndex
    character(len=19)   :: kind

    call tmg_start(67,'BEN_BARR')
    if(mpi_doBarrier) call rpn_comm_barrier("GRID",ierr)
    call tmg_stop(67)

    if (.not. initialized) then
      if (mpi_myid == 0) write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if (sum(scaleFactor) == 0.0d0) then
      if (mpi_myid == 0) write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrt'
      return
    endif

    if (maxval(controlVector_in) == 0.0d0 .and. minval(controlVector_in) == 0.0d0) then
      if (mpi_myid == 0) write(*,*) 'bMatrixEnsemble: controlVector=0, skipping bSqrt'
      return
    endif

    if (mpi_myid == 0) write(*,*) 'ben_bsqrt: starting'
    if (mpi_myid == 0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))

    call gsv_zero(statevector)

    !
    !- Compute the analysis increment from Bens
    !
    do waveBandIndex = 1, nWaveBand !  Loop on WaveBand (for ScaleDependent Localization)

!$OMP PARALLEL DO PRIVATE (memberIndex)
      do memberIndex = 1, nEns
        zsp_all(:,:,:,memberIndex) = 0.0d0
      enddo
!$OMP END PARALLEL DO

      ! compute all ensemble amplitudes for this waveband in spectral space

      call localizationSqrt(controlVector_in, waveBandIndex, & ! IN
                            zsp_all )                          ! OUT

      ! transform to gridpoint space all ensemble amplitudes for this waveband

      zsp1(:,:,:) = 0.0d0

      do jlev = 1, nLevEns_M ! loop over all levels for the amplitudes

!$OMP PARALLEL DO PRIVATE (jlat)
        do jlat = myLatBeg, myLatEnd
          ensAmplitudeAll_M(:,:,:,jlat,jlev) = 0.0d0
        enddo
!$OMP END PARALLEL DO

        ! now transform amplitude to grid-point space

        call tmg_start(64,'BEN_SPECTRAL')

        zsp1(:,:,1:nEns) = zsp_all(:,:,jlev,:)

        if (hco_ens%global) then

          call gst_setID(gstID)
          call gst_speree_kij(zsp1,ensAmplitudeAll_M(:,1,:,:,jlev))

        else

          ! NOTE: not yet implemented for LAM configuration
          kind = 'SpectralToGridPoint'
          call utl_abort('ERROR: lam not yet supported!')
          !call lst_VarTransform( lst_ben%id,     & ! IN
          !                       zsp1,           & ! IN
          !                       ensAmplitude1,  & ! OUT
          !                       kind, nLevEns_M ) ! IN

        endif

        call tmg_stop(64)

      enddo ! Loop on levels

      ! now advect the initial time amplitudes

      if( advectAmplitude ) call advectAmplitude_tl( ensAmplitudeAll_M )

      ! now compute increment by multiplying amplitudes by member perturbations

      call addEnsMember_repack( ensAmplitudeAll_M, statevector,  & ! INOUT 
                                waveBandIndex )        ! IN

    enddo ! Loop on WaveBand

    if ( ctrlVarHumidity == 'HU') then
       ! convert HU to LQ
       call vtr_transform( statevector, & ! INOUT
                           'HUtoLQ_tlm' ) ! IN
    end if

    deallocate(ensAmplitudeAll_M)

    if (mpi_myid == 0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if (mpi_myid == 0) write(*,*) 'ben_bsqrt: done'

  END SUBROUTINE BEN_BSqrt

!--------------------------------------------------------------------------
! BEN_BSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrtAd(statevector,controlVector_out)
    implicit none

    real(8)    :: controlVector_out(cvDim_mpilocal) 
    type(struct_gsv) :: statevector

    real(8)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    real(8)    :: zsp1(nla_mpilocal,nphase,nEnsOverDimension)
    real(8), pointer :: ensAmplitudeAll_M(:,:,:,:,:)
    integer   :: ierr, jlev, jlat, memberIndex, waveBandIndex
    character(len=19)   :: kind

    call tmg_start(67,'BEN_BARR')
    if(mpi_doBarrier) call rpn_comm_barrier("GRID",ierr)
    call tmg_stop(67)

    if (.not. initialized) then
      if (mpi_myid == 0) write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if (sum(scaleFactor) == 0.0d0) then
      if (mpi_myid == 0) write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrtAd'
      return
    endif

    if (mpi_myid == 0) write(*,*) 'ben_bsqrtad: starting'
    if (mpi_myid == 0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))

    !
    !- Compute the analysis increment from Bens
    !
    if ( ctrlVarHumidity == 'HU') then
       ! convert HU to LQ
       call vtr_transform( statevector, & ! INOUT
                           'HUtoLQ_tlm' ) ! IN
    end if

    do waveBandIndex = 1, nWaveBand !  Loop on WaveBand (for ScaleDependent Localization)

      !  adjoint of compute increment by multiplying amplitudes by member perturbations

      call addEnsMemberAd_repack( statevector, ensAmplitudeAll_M,  & ! INOUT
                                  waveBandIndex)         ! IN

      if( advectAmplitude ) call advectAmplitude_ad( ensAmplitudeAll_M )

      ! adjoint of transform to gridpoint space all ensemble amplitudes for this waveband

      do jlev = 1, nLevEns_M ! loop over all levels for the amplitudes

        zsp1(:,:,:) = 0.0d0 ! needed, not everything is set

        call tmg_start(64,'BEN_SPECTRAL')

        if (hco_ens%global) then

          call gst_setID(gstID)
          call gst_reespe_kij(zsp1,ensAmplitudeAll_M(:,1,:,:,jlev))

        else

          ! NOTE: not yet implemented for LAM configuration
          kind = 'GridPointToSpectral'
          call utl_abort('ERROR: lam not yet supported!')
          !call lst_VarTransform( lst_ben%id,     & ! IN
          !                       zsp1,           & ! OUT
          !                       ensAmplitude1,  & ! IN
          !                       kind, nLevEns_M ) ! IN

        endif

        zsp_all(:,:,jlev,:) = zsp1(:,:,1:nEns)
        call tmg_stop(64)

      enddo

      ! adjoint of compute all ensemble amplitudes for this waveband in spectral space

      call localizationSqrtAd(zsp_all, waveBandIndex, & ! IN
                              controlVector_out )       ! OUT

    enddo ! Loop on WaveBand

    deallocate(ensAmplitudeAll_M)

    if (mpi_myid == 0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if (mpi_myid == 0) write(*,*) 'ben_bsqrtad: done'

  END SUBROUTINE BEN_BSqrtAd

!--------------------------------------------------------------------------
! setupAdvectAmplitude
!--------------------------------------------------------------------------
  SUBROUTINE setupAdvectAmplitude
    implicit none
    integer :: jlat0, jlon0, jlat, jlon, jlev, jsubStep, jstep, jstep0, ierr, gdxyfll
    integer :: nsize, jlat_mpiglobal, jlon_mpiglobal
    integer :: procID, procIDx, procIDy
    integer, allocatable :: numSubSteps(:)
    real(8) :: uu, vv, delT, subDelT, lonAdvect, latAdvect, delx, dely, sumWeight
    real(8) :: uu_p, vv_p, lonAdvect_p, latAdvect_p, Gcoef, Scoef
    real(4) :: lonAdvect_deg_r4, latAdvect_deg_r4, xpos_r4, ypos_r4
    real(8), allocatable :: uu_mpiglobal_tiles(:,:,:,:), uu_mpiglobal(:,:,:)
    real(8), allocatable :: vv_mpiglobal_tiles(:,:,:,:), vv_mpiglobal(:,:,:)
    logical :: verbose
    real(8) :: numGridPts
    real(8) :: latitudePatch
    real(8), pointer  :: ptr3d_r8(:,:,:)
    character(len=64) :: filename
    character(len=3)  :: filenumber
    type(struct_gsv) :: statevector_ensMean1

    !- Set some important values
    verbose = .false.
    numGridPts = 1.0d0 ! used to compute numSubStep
    latitudePatch = 80.0d0 ! this defines latitude where rotated grid used
    delT = 6.0D0*3600.0D0/real(numStep-1,8) ! time between winds (assume 6h window)

    !- Write out the ensemble mean to a standard file
    call ens_copyEnsMean(ensPerts(1),statevector_ensMean1,1)
    do jstep = 1, numStep
      write(filenumber,'(i3.3)') jstep
      filename = './ensmean_' // filenumber // '.fst'
      call gsv_writeToFileMPI(statevector_ensMean1,filename,'ENSMEAN',indexStep_in=jstep)
    enddo
    call gsv_deallocate(statevector_ensMean1)

    if(mpi_myid==0) write(*,*) 'setupAdvectAmplitude: starting'
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(numSubSteps(nj))

    allocate(lonIndexAdvect(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M,numStep))
    allocate(latIndexAdvect(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M,numStep))
    allocate(interpWeightAdvect_BL(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))
    allocate(interpWeightAdvect_BR(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))
    allocate(interpWeightAdvect_TL(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))
    allocate(interpWeightAdvect_TR(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M))
    interpWeightAdvect_BL(:,:,:,:) = 1.0d0
    interpWeightAdvect_BR(:,:,:,:) = 0.0d0
    interpWeightAdvect_TL(:,:,:,:) = 0.0d0
    interpWeightAdvect_TR(:,:,:,:) = 0.0d0

    allocate(uu_mpiglobal_tiles(numStep, lonPerPE, latPerPE, mpi_nprocs))
    allocate(uu_mpiglobal(numStep, ni, nj))
    allocate(vv_mpiglobal_tiles(numStep, lonPerPE, latPerPE, mpi_nprocs))
    allocate(vv_mpiglobal(numStep, ni, nj))
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    do jlev = 1, nLevEns_M ! loop over levels in amplitude field 

      if(mpi_myid==0) write(*,*) 'setupAdvectAmplitude: jlev = ', jlev
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      ! gather the global winds for this level
      nsize = lonPerPE*latPerPE*numStep
 
      ptr3d_r8 => ens_getRepackMean_r8(ensPerts(1),1,jlev + ens_getOffsetFromVarName(ensPerts(1),'UU'))
      call rpn_comm_allgather(ptr3d_r8(:,:,:), nsize, "mpi_double_precision",  &
                              uu_mpiglobal_tiles(:,:,:,:),     nsize, "mpi_double_precision",  &
                              "GRID", ierr )
      ptr3d_r8 => ens_getRepackMean_r8(ensPerts(1),1,jlev + ens_getOffsetFromVarName(ensPerts(1),'VV'))
      call rpn_comm_allgather(ptr3d_r8(:,:,:), nsize, "mpi_double_precision",  &
                              vv_mpiglobal_tiles(:,:,:,:),     nsize, "mpi_double_precision",  &
                              "GRID", ierr )

      ! rearrange gathered winds for convenience
      do procIDy = 0, (mpi_npey-1)
        do procIDx = 0, (mpi_npex-1)
          procID = procIDx + procIDy*mpi_npex

          do jlat = 1, latPerPE
            jlat_mpiglobal = jlat + allLatBeg(procIDy+1) - 1
            do jlon = 1, lonPerPE
              jlon_mpiglobal = jlon + allLonBeg(procIDx+1) - 1
              uu_mpiglobal(:, jlon_mpiglobal, jlat_mpiglobal) = uu_mpiglobal_tiles(:, jlon, jlat, procID+1)
              vv_mpiglobal(:, jlon_mpiglobal, jlat_mpiglobal) = vv_mpiglobal_tiles(:, jlon, jlat, procID+1)
            enddo
          enddo

        enddo
      enddo

      ! determine the number of time steps required as a function of latitude
      do jlat0 = 1, nj
        latAdvect = hco_ens%lat(jlat0)
        if(abs(latAdvect) < latitudePatch*MPC_RADIANS_PER_DEGREE_R8) then
          uu = maxval(abs(uu_mpiglobal(:,:,jlat0) /(RA*cos(latAdvect)))) ! in rad/s
          vv = maxval(abs(vv_mpiglobal(:,:,jlat0) / RA)) ! in rad/s
        else
          uu = maxval(abs(uu_mpiglobal(:,:,jlat0) / RA)) ! in rad/s
          vv = maxval(abs(vv_mpiglobal(:,:,jlat0) / RA)) ! in rad/s
        endif
        numSubSteps(jlat0) = max( 1,  &
                               nint( (delT * advectAmplitudeFactor * uu) / (numGridPts*(hco_ens%lon(2)-hco_ens%lon(1))) ),  &
                               nint( (delT * advectAmplitudeFactor * vv) / (numGridPts*(hco_ens%lat(2)-hco_ens%lat(1))) ) )
      enddo
      if(mpi_myid==0) write(*,*) 'min and max of numSubSteps',minval(numSubSteps(:)),maxval(numSubSteps(:))

      ! loop over all initial grid points within tile for determining back trajectories
      do jlat0 = myLatBeg, myLatEnd
        do jlon0 = myLonBeg, myLonEnd

          subDelT = delT/real(numSubSteps(jlat0),8)  ! in seconds

          ! compute backtrajectories starting at time jstep0
          do jstep0  = 1, numStep

            ! position at the initial time of back trajectory
            lonAdvect = hco_ens%lon(jlon0)  ! in radians
            latAdvect = hco_ens%lat(jlat0)
            jlon = jlon0  ! index
            jlat = jlat0
            xpos_r4 = real(jlon,4)
            ypos_r4 = real(jlat,4)

            ! initial positions in rotated coordinate system
            lonAdvect_p = 0.0d0
            latAdvect_p = 0.0d0
          
            if(mpi_myid==0 .and. verbose) &
            write(*,*) 'final lonAdvect,latAdvect=', &
                       lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                       latAdvect*MPC_DEGREES_PER_RADIAN_R8
            if(mpi_myid==0 .and. verbose) &
            write(*,*) 'numSubSteps=', numSubSteps(jlat0)

            ! time step of back trajectory, stepping backwards
            do jstep = (jstep0-1), 1, -1

              if(mpi_myid==0 .and. verbose) &
              write(*,*) 'jstep0,jstep,jlon,jlat=',jstep0,jstep,jlon,jlat

              do jsubStep = 1, numSubSteps(jlat0)

                ! perform one timestep of back trajectory
                if(abs(hco_ens%lat(jlat0)) < latitudePatch*MPC_RADIANS_PER_DEGREE_R8) then
                  ! points away from pole, handled normally

                  ! determine wind at current location (now at BL point)
                  uu = uu_mpiglobal(jstep,jlon,jlat)/(RA*cos(hco_ens%lat(jlat))) ! in rad/s
                  vv = vv_mpiglobal(jstep,jlon,jlat)/RA
                  ! apply user-specified scale factor to advecting winds
                  uu = advectAmplitudeFactor * uu
                  vv = advectAmplitudeFactor * vv

                  ! compute next position
                  lonAdvect = lonAdvect - subDelT*uu  ! in radians
                  latAdvect = latAdvect - subDelT*vv

                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) 'not near pole, lonAdvect,latAdvect,uu,vv=', &
                               lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                               latAdvect*MPC_DEGREES_PER_RADIAN_R8,uu,vv
                else
                  ! points near pole, handled in a special way

                  ! determine wind at current location (now at BL point)
                  uu = uu_mpiglobal(jstep,jlon,jlat) ! in m/s
                  vv = vv_mpiglobal(jstep,jlon,jlat)

                  ! transform wind vector into rotated coordinate system
                  Gcoef = ( cos(latAdvect)*cos(hco_ens%lat(jlat0)) + &
                            sin(latAdvect)*sin(hco_ens%lat(jlat0))*cos(lonAdvect-hco_ens%lon(jlon0)) ) / &
                          cos(latAdvect_p)
                  Scoef = ( sin(hco_ens%lat(jlat0))*sin(lonAdvect-hco_ens%lon(jlon0)) ) / &
                          cos(latAdvect_p)
                  uu_p = Gcoef * uu - Scoef * vv ! in m/s
                  vv_p = Scoef * uu + Gcoef * vv 

                  ! apply user-specified scale factor to advecting winds
                  uu_p = advectAmplitudeFactor * uu_p ! in m/s
                  vv_p = advectAmplitudeFactor * vv_p

                  ! compute next position (in rotated coord system)
                  lonAdvect_p = lonAdvect_p - subDelT*uu_p/(RA*cos(latAdvect_p))  ! in radians
                  latAdvect_p = latAdvect_p - subDelT*vv_p/RA

                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) '    near pole, uu_p,vv_p,Gcoef,Scoef=', &
                               uu_p, vv_p, Gcoef, Scoef

                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) '    near pole, lonAdvect_p,latAdvect_p=', &
                               lonAdvect_p*MPC_DEGREES_PER_RADIAN_R8, &
                               latAdvect_p*MPC_DEGREES_PER_RADIAN_R8

                  ! compute lon/lat in original coordinate system
                  lonAdvect = hco_ens%lon(jlon0) +                                                  &
                              atan2( cos(latAdvect_p)*sin(lonAdvect_p) ,                            &
                                     ( cos(latAdvect_p)*cos(lonAdvect_p)*cos(hco_ens%lat(jlat0)) -  &
                                       sin(latAdvect_p)*sin(hco_ens%lat(jlat0)) ) )
                  latAdvect = asin( cos(latAdvect_p)*cos(lonAdvect_p)*sin(hco_ens%lat(jlat0)) + &
                                    sin(latAdvect_p)*cos(hco_ens%lat(jlat0)) )

                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) '    near pole, lonAdvect,latAdvect=', &
                               lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                               latAdvect*MPC_DEGREES_PER_RADIAN_R8
                endif

                ! convert lon/lat position into index
                lonAdvect_deg_r4 = real(lonAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                latAdvect_deg_r4 = real(latAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                ierr = gdxyfll(hco_ens%EZscintID, xpos_r4, ypos_r4, &
                               latAdvect_deg_r4, lonAdvect_deg_r4, 1)

                ! determine the bottom-left grid point
                jlon = floor(xpos_r4)
                jlat = floor(ypos_r4)

                ! check if position is east of the grid
                if(floor(xpos_r4) > ni) then
                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) 'jstep0,jlon0,jlat0,lon,lat,jstep,x,y xpos_r4 > ni :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                  ! add 10*epsilon(real*4) to ensure do not go too far due to limited precision
                  lonAdvect = lonAdvect - 2.0D0*MPC_PI_R8 + 10.0D0*real(epsilon(1.0),8)
                  lonAdvect_deg_r4 = real(lonAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                  latAdvect_deg_r4 = real(latAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                  ierr = gdxyfll(hco_ens%EZscintID, xpos_r4, ypos_r4, &
                                 latAdvect_deg_r4, lonAdvect_deg_r4, 1)
                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) 'new                            xpos_r4 > ni :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                endif

                ! check if position is west of the grid
                if(floor(xpos_r4) < 1) then
                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) 'jstep0,jlon0,jlat0,lon,lat,jstep,x,y xpos_r4 <  1 :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                  ! subtract 10*epsilon(real*4) to ensure do not go too far due to limited precision
                  lonAdvect = lonAdvect + 2.0D0*MPC_PI_R8 - 10.0D0*real(epsilon(1.0),8)
                  lonAdvect_deg_r4 = real(lonAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                  latAdvect_deg_r4 = real(latAdvect,4)* MPC_DEGREES_PER_RADIAN_R4
                  ierr = gdxyfll(hco_ens%EZscintID, xpos_r4, ypos_r4, &
                                 latAdvect_deg_r4, lonAdvect_deg_r4, 1)
                  if(mpi_myid==0 .and. verbose) &
                  write(*,*) 'new                            xpos_r4 <  1 :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                endif

                ! longitude is still outside grid - should not happen!
                if(floor(xpos_r4) > ni) then 
                  write(*,*) '***still outside jlon > ni: jstep0,jstep,jsubStep,jlon0,jlat0,jlev,x,y,uu=', &
                                                          jstep0,jstep,jsubStep,jlon0,jlat0,jlev,xpos_r4,ypos_r4,uu
                  xpos_r4 = real(ni)
                  lonAdvect = hco_ens%lon(ni)
                endif
                if(floor(xpos_r4) <  1) then 
                  write(*,*) '***still outside jlon < 1 : jstep0,jstep,jsubStep,jlon0,jlat0,jlev,x,y,uu=', &
                                                      jstep0,jstep,jsubStep,jlon0,jlat0,jlev,xpos_r4,ypos_r4,uu
                  xpos_r4 = 1.0
                  lonAdvect = hco_ens%lon(1)
                endif

                ! if position is poleward of last lat circle, ensure valid lat index
                if(jlat > nj) then
                  if(verbose) &
                  write(*,*) 'jstep0,jlon0,jlat0,lon,lat,jstep,x,y ypos_r4 > nj :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                  ypos_r4 = real(nj)
                  latAdvect = hco_ens%lat(nj)
                endif

                ! if position is poleward of first lat circle, ensure valid lat index
                if(jlat < 1) then
                  if(verbose) &
                  write(*,*) 'jstep0,jlon0,jlat0,lon,lat,jstep,x,y ypos_r4 <  1 :', &
                              jstep0,jlon0,jlat0,lonAdvect*MPC_DEGREES_PER_RADIAN_R8, &
                              latAdvect*MPC_DEGREES_PER_RADIAN_R8,jstep,xpos_r4,ypos_r4
                  ypos_r4 = 1.0
                  latAdvect = hco_ens%lat(1)
                endif

                ! determine bottom left grid point again after possible adjustments
                jlon = floor(xpos_r4)
                jlat = floor(ypos_r4)

              enddo ! jsubStep

            enddo ! jstep

            ! store the final position of the back trajectory and interp weights
            lonIndexAdvect(jlon0,jlat0,jlev,jstep0) = jlon
            latIndexAdvect(jlon0,jlat0,jlev,jstep0) = jlat

            if(mpi_myid==0 .and. verbose) &
            write(*,*) 'final, initial jlon,jlat', jlon0,jlat0,jlon,jlat

            delx = real(xpos_r4,8) - real(jlon,8)
            dely = real(ypos_r4,8) - real(jlat,8)

            interpWeightAdvect_BL(jstep0,jlon0,jlat0,jlev) = min(max( (1.d0-delx) * (1.d0-dely), 0.0d0), 1.0d0)
            interpWeightAdvect_BR(jstep0,jlon0,jlat0,jlev) = min(max(       delx  * (1.d0-dely), 0.0d0), 1.0d0)
            interpWeightAdvect_TL(jstep0,jlon0,jlat0,jlev) = min(max( (1.d0-delx) *       dely , 0.0d0), 1.0d0)
            interpWeightAdvect_TR(jstep0,jlon0,jlat0,jlev) = min(max(       delx  *       dely , 0.0d0), 1.0d0)

            sumWeight = interpWeightAdvect_BL(jstep0,jlon0,jlat0,jlev) + &
                        interpWeightAdvect_BR(jstep0,jlon0,jlat0,jlev) + &
                        interpWeightAdvect_TL(jstep0,jlon0,jlat0,jlev) + &
                        interpWeightAdvect_TR(jstep0,jlon0,jlat0,jlev)
            if(sumWeight > 1.1d0) then
              write(*,*) 'sumWeight > 1.1 : ', sumWeight
              write(*,*) '          BL, BR, TL, TR=',interpWeightAdvect_BL(jstep0,jlon0,jlat0,jlev), &
                                                     interpWeightAdvect_BR(jstep0,jlon0,jlat0,jlev), &
                                                     interpWeightAdvect_TL(jstep0,jlon0,jlat0,jlev), &
                                                     interpWeightAdvect_TR(jstep0,jlon0,jlat0,jlev)
              write(*,*) '          jstep0, jlev, jlon0, jlat0, jlon, jlat, delx, dely  =', &
                                    jstep0, jlev, jlon0, jlat0, jlon, jlat, delx, dely

              interpWeightAdvect_BL(jstep0,jlon0,jlat0,jlev) = 0.25d0
              interpWeightAdvect_BR(jstep0,jlon0,jlat0,jlev) = 0.25d0
              interpWeightAdvect_TL(jstep0,jlon0,jlat0,jlev) = 0.25d0
              interpWeightAdvect_TR(jstep0,jlon0,jlat0,jlev) = 0.25d0

            endif

          enddo ! jstep0

        enddo ! jlon0
      enddo ! jlat0
    enddo ! jlev

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid==0) write(*,*) 'setupAdvectAmplitude: done'

  end SUBROUTINE setupAdvectAmplitude

!--------------------------------------------------------------------------
! advectAmplitude_tl
!--------------------------------------------------------------------------
  SUBROUTINE advectAmplitude_tl( ensAmplitudeAll_M )
    implicit none
    real(8)              :: ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)
    real(8), allocatable :: ensAmplitude1_mpiglobal_tiles(:,:,:,:)
    real(8), allocatable :: ensAmplitude1_mpiglobal(:,:,:)
    integer :: memberIndex, jstep, jlev, jlon, jlat, jlon2, jlat2, jlon2_p1, jlat2_p1, nsize, ierr
    integer :: procID, procIDx, procIDy, jlon_mpiglobal, jlat_mpiglobal

    allocate(ensAmplitude1_mpiglobal_tiles(nEns,lonPerPE,latPerPE,mpi_nprocs))
    allocate(ensAmplitude1_mpiglobal(nEns,ni,nj))

    do jlev = 1, nLevEns_M

      ! gather the global initial amplitude field on all tasks
      nsize = nEns*lonPerPE*latPerPE
      call rpn_comm_allgather(ensAmplitudeAll_M(1:nEns,1,:,:,jlev),        nsize, "mpi_double_precision",  &
                              ensAmplitude1_mpiglobal_tiles(:,:,:,:), nsize, "mpi_double_precision",  &
                              "GRID", ierr )

      ! rearrange gathered amplitudes for convenience
!$OMP PARALLEL DO PRIVATE (procIDy,procIDx,procID,jlat,jlon,jlat_mpiglobal,jlon_mpiglobal,memberIndex)
      do procIDy = 0, (mpi_npey-1)
        do procIDx = 0, (mpi_npex-1)
          procID = procIDx + procIDy*mpi_npex
          do jlat = 1, latPerPE
            jlat_mpiglobal = jlat + allLatBeg(procIDy+1) - 1
            do jlon = 1, lonPerPE
              jlon_mpiglobal = jlon + allLonBeg(procIDx+1) - 1
              do memberIndex = 1, nEns
                ensAmplitude1_mpiglobal(memberIndex,jlon_mpiglobal, jlat_mpiglobal) = &
                  ensAmplitude1_mpiglobal_tiles(memberIndex, jlon, jlat, procID+1)
              enddo ! memberIndex
            enddo ! jlon
          enddo ! jlat
        enddo ! procIDx
      enddo ! procIDy
!$OMP END PARALLEL DO
      
!$OMP PARALLEL DO PRIVATE (jlat,jlon,jlon2,jlat2,jlon2_p1,jlat2_p1,jstep,memberIndex)
      do jlat = myLatBeg, myLatEnd
        do jlon = myLonBeg, myLonEnd
          ! this is the bottom-left grid point
          jlon2 = lonIndexAdvect(jlon,jlat,jlev,jstep)
          jlat2 = latIndexAdvect(jlon,jlat,jlev,jstep)
          jlon2_p1 = mod(jlon2,ni)+1 ! assume periodic
          jlat2_p1 = min(jlat2+1,nj)
          do jstep = 2, numStep
            do memberIndex = 1, nEns
              ensAmplitudeAll_M(memberIndex,jstep,jlon,jlat,jlev) =   &
                interpWeightAdvect_BL(jstep,jlon,jlat,jlev)*ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2) +  &
                interpWeightAdvect_BR(jstep,jlon,jlat,jlev)*ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2) +  &
                interpWeightAdvect_TL(jstep,jlon,jlat,jlev)*ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2_p1) +  &
                interpWeightAdvect_TR(jstep,jlon,jlat,jlev)*ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2_p1)
            enddo ! memberIndex
          enddo ! jstep
        enddo ! jlon
      enddo ! jlat
!$OMP END PARALLEL DO

    enddo ! jlev

    deallocate(ensAmplitude1_mpiglobal_tiles)
    deallocate(ensAmplitude1_mpiglobal)

  END SUBROUTINE advectAmplitude_tl

!--------------------------------------------------------------------------
! advectAmplitude_ad
!--------------------------------------------------------------------------
  SUBROUTINE advectAmplitude_ad( ensAmplitudeAll_M )
    implicit none
    real(8)              :: ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)
    real(8), allocatable :: ensAmplitude1_mpiglobal(:,:,:)
    real(8), allocatable :: ensAmplitude1_mpiglobal_tiles(:,:,:,:)
    real(8), allocatable :: ensAmplitude1_mpiglobal_tiles2(:,:,:,:)
    integer :: memberIndex, jstep, jlev, jlon, jlat, jlon2, jlat2, jlon2_p1, jlat2_p1
    integer :: jlon_mpiglobal, jlat_mpiglobal, procID, procIDx, procIDy, ierr, nsize

    allocate(ensAmplitude1_mpiglobal(nEns,ni,nj))
    allocate(ensAmplitude1_mpiglobal_tiles(nEns,lonPerPE,latPerPE,mpi_nprocs))
    allocate(ensAmplitude1_mpiglobal_tiles2(nEns,lonPerPE,latPerPE,mpi_nprocs))

    do jlev = 1, nLevEns_M
      ensAmplitude1_mpiglobal(:,:,:) = 0.0d0

!$OMP PARALLEL DO PRIVATE (jlat,jlon,jlat2,jlon2,jlat2_p1,jlon2_p1)
      do jlat = myLatBeg, myLatEnd
        do jlon = myLonBeg, myLonEnd
          ! this is the bottom-left grid point
          jlon2 = lonIndexAdvect(jlon,jlat,jlev,jstep)
          jlat2 = latIndexAdvect(jlon,jlat,jlev,jstep)
          jlon2_p1 = mod(jlon2,ni)+1 ! assume periodic
          jlat2_p1 = min(jlat2+1,nj)
          do jstep = 2, numStep
            do memberIndex = 1, nEns
              ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2) = ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2) +  &
                interpWeightAdvect_BL(jstep,jlon,jlat,jlev)*ensAmplitudeAll_M(memberIndex,jstep,jlon,jlat,jlev)
              ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2) = ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2) +  &
                interpWeightAdvect_BR(jstep,jlon,jlat,jlev)*ensAmplitudeAll_M(memberIndex,jstep,jlon,jlat,jlev)
              ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2_p1) = ensAmplitude1_mpiglobal(memberIndex, jlon2   ,jlat2_p1) +  &
                interpWeightAdvect_TL(jstep,jlon,jlat,jlev)*ensAmplitudeAll_M(memberIndex,jstep,jlon,jlat,jlev)
              ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2_p1) = ensAmplitude1_mpiglobal(memberIndex, jlon2_p1,jlat2_p1) +  &
                interpWeightAdvect_TR(jstep,jlon,jlat,jlev)*ensAmplitudeAll_M(memberIndex,jstep,jlon,jlat,jlev)
            enddo ! memberIndex
          enddo ! jstep
        enddo ! jlon
      enddo ! jlat
!$OMP END PARALLEL DO

      ! redistribute the global initial time field across mpi tasks by tiles
!$OMP PARALLEL DO PRIVATE(procIDy,procIDx,procID,jlev,jlat,jlat_mpiglobal,jlon,jlon_mpiglobal)
      do procIDy = 0, (mpi_npey-1)
        do procIDx = 0, (mpi_npex-1)
          procID = procIDx + procIDy*mpi_npex
            do jlat = 1, latPerPE
              jlat_mpiglobal = jlat + allLatBeg(procIDy+1) - 1
              do jlon = 1, lonPerPE
                jlon_mpiglobal = jlon + allLonBeg(procIDx+1) - 1
                do memberIndex = 1, nEns
                  ensAmplitude1_mpiglobal_tiles(memberIndex, jlon, jlat, procID+1) =  &
                    ensAmplitude1_mpiglobal(memberIndex, jlon_mpiglobal, jlat_mpiglobal)
                enddo ! memberIndex
              enddo ! jlon
            enddo ! jlat
          enddo ! procIDx
        enddo ! procIDy
!$OMP END PARALLEL DO

      nsize = nEns*lonPerPE*latPerPE
      if(mpi_nprocs.gt.1) then
        call rpn_comm_alltoall(ensAmplitude1_mpiglobal_tiles, nsize,"mpi_double_precision",  &
                               ensAmplitude1_mpiglobal_tiles2,nsize,"mpi_double_precision","GRID",ierr)
      else
        ensAmplitude1_mpiglobal_tiles2(:,:,:,1) = ensAmplitude1_mpiglobal_tiles(:,:,:,1)
      endif

      do procID = 0, (mpi_nprocs-1)
!$OMP PARALLEL DO PRIVATE(jlev,jlat,jlat2,jlon,jlon2)
        do jlat = 1, latPerPE
          jlat2= jlat + myLatBeg - 1
          do jlon = 1, lonPerPE
            jlon2 = jlon + myLonBeg - 1
            do memberIndex = 1, nEns
              ensAmplitudeAll_M(memberIndex, 1, jlon2, jlat2, jlev) = ensAmplitudeAll_M(memberIndex, 1, jlon2, jlat2, jlev) +  &
                 ensAmplitude1_mpiglobal_tiles2(memberIndex, jlon, jlat, procID+1)
            enddo ! memberIndex
          enddo ! jlon
        enddo ! jlat
!$OMP END PARALLEL DO
      enddo ! procID

    enddo ! jlev

    deallocate(ensAmplitude1_mpiglobal)
    deallocate(ensAmplitude1_mpiglobal_tiles)
    deallocate(ensAmplitude1_mpiglobal_tiles2)

  END SUBROUTINE advectAmplitude_ad

!--------------------------------------------------------------------------
! addEnsMember
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMember(statevector_ensAmp, statevector_out, &
                          waveBandIndex)
    implicit none

    type(struct_gsv)    :: statevector_ensAmp(:)
    type(struct_gsv)    :: statevector_out
    integer, intent(in) :: waveBandIndex

    real(8), pointer    :: ensAmplitude_M(:,:,:,:)
    real(8), pointer    :: ensAmplitude_MT(:,:,:,:)
    real(8), target     :: ensAmplitude_T(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_T,numStepAmplitude)
    real(8), pointer    :: increment_out(:,:,:,:)
    real(4), pointer    :: ensMember_r4(:,:,:,:)

    integer     :: jvar, jlev, jlev2, jstep, jstep_amp, jj, ji, numVar, topLevOffset, numLev, memberIndex

    call utl_abort('ERROR: this subroutine is not used anymore')

    call tmg_start(62,'ADDMEM')

    do memberIndex = 1, nEns

    ensAmplitude_M => gsv_getField_r8(statevector_ensAmp(memberIndex))

    ! compute thermo level amplitudes from momentum level amplitudes
    if (Vcode_anl == 5002) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if (jlev == 1) then
          ! use top momentum level amplitudes for top thermo level
          ensAmplitude_T(:,:,jlev,:) = ensAmplitude_M(:,:,jlev,:)
        elseif (jlev == nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_T(:,:,jlev,:) = ensAmplitude_M(:,:,nLevEns_M,:)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_T(:,:,jlev,:) = 0.5d0*( ensAmplitude_M(:,:,jlev-1,:) +   &
                                               ensAmplitude_M(:,:,jlev,:) )
        endif
      enddo
!$OMP END PARALLEL DO

    elseif (Vcode_anl == 5005) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if (jlev == nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level (this is not correct, 
          ! but consistent with how it has been done until now)
          ensAmplitude_T(:,:,jlev,:) = ensAmplitude_M(:,:,jlev,:)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_T(:,:,jlev,:) = 0.5d0*( ensAmplitude_M(:,:,jlev,:) +   &
                                               ensAmplitude_M(:,:,jlev+1,:) )
        endif
      enddo
!$OMP END PARALLEL DO

    endif

    if (Vcode_anl == 5002 .or. Vcode_anl == 5005) then

      do jvar = 1, vnl_numvarmax 
        if (.not. gsv_varExist(statevector_out, vnl_varNameList(jvar))) cycle
        increment_out => gsv_getField_r8(statevector_out, vnl_varNameList(jvar))
!NOT IMPLEMENTED YET        ensMember_r4 => ens_getField_r4(ensPerts(waveBandIndex),memberIndex, &
!                                        vnl_varNameList(jvar))
        if (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'SF') then
          numLev = 1
          topLevOffset = 1
          ensAmplitude_MT(myLonBeg:, myLatBeg:, 1:        , 1:) =>   &
           ensAmplitude_M(myLonBeg:, myLatBeg:, nLevEns_M:, 1:)
        elseif (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'MM') then
          numLev = nlevEns_M
          topLevOffset = topLevIndex_M
          ensAmplitude_MT => ensAmplitude_M
        else
          numLev = nlevEns_T
          topLevOffset = topLevIndex_T
          ensAmplitude_MT => ensAmplitude_T
        endif

        call tmg_start(77,'ADDMEM_INNER')

        do jstep = 1, numStep
          if(advectAmplitude) then
            jstep_amp = jstep
          else
            jstep_amp = 1
          endif
!$OMP PARALLEL DO PRIVATE (jlev,jlev2,jj,ji)
          do jlev = 1, numLev                 ! levels for the amplitude and ensemble member
            jlev2 = jlev - 1 + topLevOffset   ! levels for the 1 variable increment field
            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                increment_out(ji,jj,jlev2,jstep) = increment_out(ji,jj,jlev2,jstep) +   &
                  ensAmplitude_MT(ji,jj,jlev,jstep_amp) * dble(ensMember_r4(ji,jj,jlev,jstep))
              enddo
            enddo
          enddo
!$OMP END PARALLEL DO
        enddo ! jstep

        call tmg_stop(77)

      enddo ! jvar

    else ! other Vcode

      write(*,*) 'addEnsMember: this Vcode not supported =',Vcode_anl
      call utl_abort('addEnsMember')

    endif

    enddo ! memberIndex

    call tmg_stop(62)

  END SUBROUTINE addEnsMember

!--------------------------------------------------------------------------
! addEnsMember_repack
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMember_repack(ensAmplitudeAll_M, statevector_out, &
                                 waveBandIndex)
    implicit none

    real(8), target    :: ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)
    type(struct_gsv)    :: statevector_out
    integer, intent(in) :: waveBandIndex

    real(8), allocatable, target :: ensAmplitudeAll_MT(:,:,:,:)
    real(8), pointer     :: ensAmplitudeAll_MT_ptr(:,:,:,:)
    real(8), pointer     :: increment_out(:,:,:,:)
    real(8), allocatable :: increment_out2(:,:,:)
    real(4), pointer     :: ensMemberAll_r4(:,:,:,:)
    integer     :: lev, lev2, jk, jstep, jstep_amp, jj, ji, topLevOffset, numLev, memberIndex
    character(len=4)     :: varName

    if (Vcode_anl /= 5002) call utl_abort('addEnsMember_repack: Only 5002 supported for now!')

    call tmg_start(62,'ADDMEM')

    allocate(ensAmplitudeAll_MT(nEns,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd))
    allocate(increment_out2(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd))

    do jk = 1, ens_getNumK(ensPerts(waveBandIndex))

      lev = ens_getLevFromK(ensPerts(1),jk)
      varName = ens_getVarNameFromK(ensPerts(1),jk)

!$OMP PARALLEL DO PRIVATE (jj)
      do jj = myLatBeg, myLatEnd
        increment_out2(:,:,jj) = 0.0d0
      enddo
!$OMP END PARALLEL DO

      call tmg_start(66,'ADDMEM_PREPAMP')
      if (vnl_varLevelFromVarname(varName) == 'MM') then

        ensAmplitudeAll_MT_ptr(1:,1:,myLonBeg:,myLatBeg:) => ensAmplitudeAll_M(1:nEns,:,:,:,lev)

      elseif (vnl_varLevelFromVarname(varName) == 'TH') then

        if (lev == 1) then
          ! use top momentum level amplitudes for top thermo level
          ensAmplitudeAll_MT_ptr(1:,1:,myLonBeg:,myLatBeg:) => ensAmplitudeAll_M(1:nEns,:,:,:,lev)
        elseif (lev == nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitudeAll_MT_ptr(1:,1:,myLonBeg:,myLatBeg:) => ensAmplitudeAll_M(1:nEns,:,:,:,nLevEns_M)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
!$OMP PARALLEL DO PRIVATE (jj)
          do jj = myLatBeg, myLatEnd
            ensAmplitudeAll_MT(:,:,:,jj) = 0.5d0*( ensAmplitudeAll_M(1:nEns,:,:,jj,lev-1) +   &
                                                   ensAmplitudeAll_M(1:nEns,:,:,jj,lev) )
          enddo
!$OMP END PARALLEL DO
          ensAmplitudeAll_MT_ptr(1:,1:,myLonBeg:,myLatBeg:) => ensAmplitudeAll_MT(:,:,:,:)
        endif

      elseif (vnl_varLevelFromVarname(varName) == 'SF') then

        ! surface variable
        ensAmplitudeAll_MT_ptr(1:,1:,myLonBeg:,myLatBeg:) => ensAmplitudeAll_M(1:nEns,:,:,:,nLevEns_M)

      endif
      call tmg_stop(66)

      call tmg_start(77,'ADDMEM_INNER')

      ensMemberAll_r4 => ens_getRepack_r4(ensPerts(waveBandIndex),jk)
!$OMP PARALLEL DO PRIVATE (jj,ji,jstep,jstep_amp,memberIndex)
      do jj = myLatBeg, myLatEnd
        do ji = myLonBeg, myLonEnd
          do jstep = 1, numStep
            if(advectAmplitude) then
              jstep_amp = jstep
            else
              jstep_amp = 1
            endif
            do memberIndex = 1, nEns
              increment_out2(jstep,ji,jj) = increment_out2(jstep,ji,jj) +   &
                ensAmplitudeAll_MT_ptr(memberIndex,jstep_amp,ji,jj) *  &
                dble(ensMemberAll_r4(memberIndex,jstep,ji,jj))
            enddo ! memberIndex
          enddo ! jstep
        enddo ! ji
      enddo ! jj
!$OMP END PARALLEL DO

      call tmg_stop(77)

      ! compute increment level from amplitude/member level
      if (vnl_varLevelFromVarname(varName) == 'SF') then
        topLevOffset = 1
      elseif (vnl_varLevelFromVarname(varName) == 'MM') then
        topLevOffset = topLevIndex_M
      else
        topLevOffset = topLevIndex_T
      endif
      lev2 = lev - 1 + topLevOffset

      increment_out => gsv_getField_r8(statevector_out, varName)
!$OMP PARALLEL DO PRIVATE (jstep)
      do jstep = 1, numStep
        increment_out(:,:,lev2,jstep) = increment_out2(jstep,:,:)
      enddo
!$OMP END PARALLEL DO

    enddo ! jk

    deallocate(ensAmplitudeAll_MT)
    deallocate(increment_out2)

    call tmg_stop(62)

  END SUBROUTINE addEnsMember_repack

!--------------------------------------------------------------------------
! addEnsMemberAd
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMemberAd(statevector_in, statevector_ensamp, &
                            memberIndex, waveBandIndex)
    implicit none

    type(struct_gsv)   :: statevector_ensamp
    type(struct_gsv)   :: statevector_in
    integer,intent(in) :: memberIndex, waveBandIndex

    real(8), pointer :: ensAmplitude_M(:,:,:,:)
    real(8), pointer :: ensAmplitude_MT(:,:,:,:)
    real(8), target  :: ensAmplitude_T(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_T,numStepAmplitude)
    real(8), pointer :: increment_in(:,:,:,:)
    real(4), pointer :: ensMember_r4(:,:,:,:)

    integer     :: jvar, jlev, jlev2, jstep, jstep_amp, jj, ji, numVar, topLevOffset, numLev

    call utl_abort('addEnsMemberAd: this subroutine is not used anymore!')

    call tmg_start(63,'ADDMEMAD')

    ensAmplitude_M => gsv_getField_r8(statevector_ensAmp)

    ensAmplitude_M(:,:,:,:) = 0.0d0
    ensAmplitude_T(:,:,:,:) = 0.0d0

    if (Vcode_anl == 5002 .or. Vcode_anl == 5005) then


      do jvar = 1, vnl_numvarmax
        if (.not. gsv_varExist(statevector_in, vnl_varNameList(jvar))) cycle
        increment_in => gsv_getField_r8(statevector_in, vnl_varNameList(jvar))
!NOT IMPLEMENTED YET        ensMember_r4 => ens_getField_r4(ensPerts(waveBandIndex),memberIndex, &
!                                        vnl_varNameList(jvar))

        if (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'SF') then
          numLev = 1
          topLevOffset = 1
          ensAmplitude_MT(myLonBeg:, myLatBeg:, 1:        , 1:) =>   &
           ensAmplitude_M(myLonBeg:, myLatBeg:, nLevEns_M:, 1:)
        elseif (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'MM') then
          numLev = nlevEns_M
          topLevOffset = topLevIndex_M
          ensAmplitude_MT => ensAmplitude_M
        else
          numLev = nlevEns_T
          topLevOffset = topLevIndex_T
          ensAmplitude_MT => ensAmplitude_T
        endif

        call tmg_start(78,'ADDMEMAD_INNER')
        do jstep = 1, numStep
          if(advectAmplitude) then
            jstep_amp = jstep
          else
            jstep_amp = 1
          endif
!$OMP PARALLEL DO PRIVATE (jlev,jlev2,jj,ji)
          do jlev = 1, numLev                 ! levels for the amplitude and ensemble member
            jlev2 = jlev - 1 + topLevOffset   ! levels for the 1 variable increment field
            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                ensAmplitude_MT(ji,jj,jlev,jstep_amp) = ensAmplitude_MT(ji,jj,jlev,jstep_amp) +   &
                  increment_in(ji,jj,jlev2,jstep) * dble(ensMember_r4(ji,jj,jlev,jstep))
              enddo
            enddo
          enddo
!$OMP END PARALLEL DO
        enddo ! jstep
        call tmg_stop(78)

      enddo ! jvar

    else ! other Vcode

      write(*,*) 'addEnsMember: this Vcode not supported =',Vcode_anl
      call utl_abort('addEnsMember')

    endif

    ! combine thermo and momentum level amplitude sensitivites
    if (Vcode_anl == 5002) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if (jlev == 1) then
          ! use top momentum level amplitudes for top thermo level
          ensAmplitude_M(:,:,jlev,:) = ensAmplitude_M(:,:,jlev,:) + ensAmplitude_T(:,:,jlev,:)
        elseif (jlev == nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_M(:,:,nLevEns_M,:) = ensAmplitude_M(:,:,nLevEns_M,:) + ensAmplitude_T(:,:,jlev,:)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_M(:,:,jlev,:)   = ensAmplitude_M(:,:,jlev,:)   + 0.5d0*ensAmplitude_T(:,:,jlev,:)
        endif
      enddo
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 2, (nLevEns_T-1)
        ensAmplitude_M(:,:,jlev-1,:) = ensAmplitude_M(:,:,jlev-1,:) + 0.5d0*ensAmplitude_T(:,:,jlev,:)
      enddo
!$OMP END PARALLEL DO

    elseif (Vcode_anl == 5005) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if (jlev == nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level (not correct, but
          ! consistent with how it has been done until now)
          ensAmplitude_M(:,:,jlev,:) = ensAmplitude_M(:,:,jlev,:) + ensAmplitude_T(:,:,jlev,:)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_M(:,:,jlev,:)   = ensAmplitude_M(:,:,jlev,:)   + 0.5d0*ensAmplitude_T(:,:,jlev,:)
        endif
      enddo
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, (nLevEns_T-1)
        ensAmplitude_M(:,:,jlev+1,:) = ensAmplitude_M(:,:,jlev+1,:) + 0.5d0*ensAmplitude_T(:,:,jlev,:)
      enddo
!$OMP END PARALLEL DO

    endif

    call tmg_stop(63)

  END SUBROUTINE addEnsMemberAd

!--------------------------------------------------------------------------
! addEnsMemberAd_repack
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMemberAd_repack(statevector_in, ensAmplitudeAll_M, &
                                   waveBandIndex)
    implicit none

    real(8)            :: ensAmplitudeAll_M(nEnsOverDimension,numStepAmplitude,myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)
    type(struct_gsv)   :: statevector_in
    integer,intent(in) :: waveBandIndex

    real(8), allocatable :: ensAmplitudeAll_MT(:,:)
    real(8), pointer :: increment_in(:,:,:,:)
    real(8), allocatable :: increment_in2(:,:,:)
    real(4), pointer :: ensMemberAll_r4(:,:,:,:)
    integer          :: jlev, lev, lev2, jk, jstep, jstep_amp, jj, ji, topLevOffset, numLev, memberIndex
    character(len=4)     :: varName
    !logical :: ensAmpZeroed(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)

    if (Vcode_anl /= 5002) call utl_abort('addEnsMemberAd_repack: Only 5002 supported for now!')

    call tmg_start(63,'ADDMEMAD')

    allocate(ensAmplitudeAll_MT(nEns,numStepAmplitude))
    allocate(increment_in2(numStep,myLonBeg:myLonEnd,myLatBeg:myLatEnd))

    ! set output ensemble Amplitude to zero
    call tmg_start(69,'ADDMEMAD_ZERO')
!$OMP PARALLEL DO PRIVATE (jlev)
    do jlev = 1, nLevEns_M
      ensAmplitudeAll_M(:,:,:,:,jlev) = 0.0d0
    enddo
!$OMP END PARALLEL DO
    call tmg_stop(69)

    do jk = 1, ens_getNumK(ensPerts(waveBandIndex))

      lev = ens_getLevFromK(ensPerts(1),jk)
      varName = ens_getVarNameFromK(ensPerts(1),jk)

      ! compute increment level from amplitude/member level
      if (vnl_varLevelFromVarname(varName) == 'SF') then
        topLevOffset = 1
      elseif (vnl_varLevelFromVarname(varName) == 'MM') then
        topLevOffset = topLevIndex_M
      else
        topLevOffset = topLevIndex_T
      endif
      lev2 = lev - 1 + topLevOffset

      call tmg_start(65,'ADDMEMAD_SHUFFLE')
      increment_in => gsv_getField_r8(statevector_in, varName)
!$OMP PARALLEL DO PRIVATE (jstep)
      do jstep = 1, numStep
        increment_in2(jstep,:,:) = increment_in(:,:,lev2,jstep)
      enddo
!$OMP END PARALLEL DO
      call tmg_stop(65)

      !ensAmpZeroed(:,:,:) = .false.
      ensMemberAll_r4 => ens_getRepack_r4(ensPerts(waveBandIndex),jk)
!$OMP PARALLEL DO PRIVATE (jj,ji,jstep,jstep_amp,memberIndex,ensAmplitudeAll_MT)
      do jj = myLatBeg, myLatEnd
        do ji = myLonBeg, myLonEnd

          if(omp_get_thread_num() == 0) call tmg_start(78,'ADDMEMAD_INNER')
          ensAmplitudeAll_MT(:,:) = 0.0d0
          do jstep = 1, numStep
            if(advectAmplitude) then
              jstep_amp = jstep
            else
              jstep_amp = 1
            endif
            do memberIndex = 1, nEns
              ensAmplitudeAll_MT(memberIndex,jstep_amp) = ensAmplitudeAll_MT(memberIndex,jstep_amp) +  &
                increment_in2(jstep,ji,jj) * dble(ensMemberAll_r4(memberIndex,jstep,ji,jj))
            enddo ! memberIndex
          enddo ! jstep
          if(omp_get_thread_num() == 0) call tmg_stop(78)

          ! transform thermo/momentum level amplitude sensitivites appropriately

          if(omp_get_thread_num() == 0) call tmg_start(68,'ADDMEMAD_PREPAMP')
          if (vnl_varLevelFromVarname(varName) == 'MM') then

            ensAmplitudeAll_M(1:nEns,:,ji,jj,lev) = ensAmplitudeAll_M(1:nEns,:,ji,jj,lev) + ensAmplitudeAll_MT(:,:)

          elseif (vnl_varLevelFromVarname(varName) == 'TH') then

            if (lev == 1) then
              ! use top momentum level amplitudes for top thermo level
              ensAmplitudeAll_M(1:nEns,:,ji,jj,lev) = ensAmplitudeAll_M(1:nEns,:,ji,jj,lev) + ensAmplitudeAll_MT(:,:)
            elseif (lev == nLevEns_T) then
              ! use surface momentum level amplitudes for surface thermo level
              ensAmplitudeAll_M(1:nEns,:,ji,jj,nLevEns_M) = ensAmplitudeAll_M(1:nEns,:,ji,jj,nLevEns_M) + ensAmplitudeAll_MT(:,:)
            else
              ! for other levels, interpolate momentum weights to get thermo amplitudes
              ensAmplitudeAll_M(1:nEns,:,ji,jj,lev)   = ensAmplitudeAll_M(1:nEns,:,ji,jj,lev)   + 0.5d0*ensAmplitudeAll_MT(:,:)
              ensAmplitudeAll_M(1:nEns,:,ji,jj,lev-1) = ensAmplitudeAll_M(1:nEns,:,ji,jj,lev-1) + 0.5d0*ensAmplitudeAll_MT(:,:)
            endif

          elseif (vnl_varLevelFromVarname(varName) == 'SF') then

            ! surface variable
            ensAmplitudeAll_M(1:nEns,:,ji,jj,nLevEns_M) = ensAmplitudeAll_M(1:nEns,:,ji,jj,nLevEns_M) + ensAmplitudeAll_MT(:,:)

          endif
          if(omp_get_thread_num() == 0) call tmg_stop(68)

        enddo ! ji
      enddo ! jj
!$OMP END PARALLEL DO


    enddo ! jk

    deallocate(ensAmplitudeAll_MT)
    deallocate(increment_in2)

    call tmg_stop(63)

  END SUBROUTINE addEnsMemberAd_repack

!--------------------------------------------------------------------------
! localizationSqrt
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrt(controlVector_in, waveBandIndex, zsp_all)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev1,jlev2,jla,p,memberIndex
    real(8) ,allocatable :: zsp(:,:,:,:)

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ens%global) then
       call GlobalHLoc( zsp_all,                        & ! OUT
                        controlVector_in, waveBandIndex ) ! IN
    else
       call LamHLoc( zsp_all,                        & ! OUT
                     controlVector_in, waveBandIndex ) ! IN
    endif

    !
    !- 2.  Vertical localization
    !
    allocate(zsp(nla_mpilocal,nphase,nLevEns_M,nEns)) 

!$OMP PARALLEL DO PRIVATE (memberIndex,jlev1,jlev2,p,jla)
    do memberIndex = 1, nEns
      zsp(:,:,:,memberIndex) = 0.0d0
      do jlev1 = 1, nLevEns_M
        do jlev2 = 1, nLevEns_M
          do p = 1, nphase
            do jla = 1, nla_mpilocal
              zsp(jla,p,jlev1,memberIndex) = zsp(jla,p,jlev1,memberIndex) +  &
                                             ensLocal(waveBandIndex)%Vert(jlev1,jlev2)*zsp_all(jla,p,jlev2,memberIndex)
            enddo
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    zsp_all(:,:,:,:) = zsp(:,:,:,:)
    deallocate(zsp)

  END SUBROUTINE localizationSqrt

!--------------------------------------------------------------------------
! GlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLoc(zsp_all, controlVector_in, waveBandIndex)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev, jm, jn, ila_mpilocal, ila_mpiglobal, jdim, memberIndex 

    jdim = 0

    do memberIndex = 1, nEns

      do jlev = 1, nLevEns_M
        do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if (jm .le. jn) then

              ila_mpiglobal = gst_getnind(jm,gstID) + jn - jm
              ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
              if (jm == 0) then
                ! controlVector only contain real part for jm=0
                jdim = jdim + 1
                zsp_all(ila_mpilocal,1,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*rsq2
                zsp_all(ila_mpilocal,2,jlev,memberIndex) = 0.0d0
              else
                ! controlVector contains real and imag parts for jm>0
                jdim = jdim + 1
                zsp_all(ila_mpilocal,1,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)
                jdim = jdim + 1
                zsp_all(ila_mpilocal,2,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)
              endif

            endif
          enddo
        enddo
      enddo

      if (jdim.gt.cvDim_mpilocal) then
        write(*,*) 'ben globalHLoc: jdim > cvDim_mpilocal! ',jdim,memberIndex,cvDim_mpilocal
        call utl_abort('aborted in ben globalHLoc')
      endif

    enddo

  END SUBROUTINE GlobalHLoc

!--------------------------------------------------------------------------
! LamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE LamHLoc(zsp_all, controlVector_in, waveBandIndex)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev,jla, jdim, memberIndex, p 

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = 1, nEns

       do jlev = 1, nLevEns_M
         do jla = 1, nla_mpilocal
            do p = 1, nphase
              jdim = jdim + 1
              zsp_all(jla,p,jlev,memberIndex) = controlVector_in(jdim)           * &
                                                ensLocal(waveBandIndex)%Horiz(lst_ben%k(jla),jlev) * &
                                                lst_ben%NormFactor(jla,p)
            enddo
         enddo
       enddo
       if (jdim > cvDim_mpilocal ) then
          write(*,*) 'BEN: LamHLoc: jdim > cvDim! ',jdim,memberIndex,cvDim_mpilocal
          call utl_abort('aborted in LamHLoc')
       endif

    enddo

  END SUBROUTINE LamHLoc

!--------------------------------------------------------------------------
! localizationSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrtAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out) :: controlVector_out(cvDim_mpilocal)
    real(8), intent(in)  :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    integer, intent(in)  :: waveBandIndex

    integer :: jlev1,jlev2,jla,memberIndex,p
    real(8),allocatable::zsp(:,:,:,:)

    !
    !- 2.  Vertical Localization
    !
    allocate(zsp(nla_mpilocal,nphase,nLevEns_M,nEns) ) 

!$OMP PARALLEL DO PRIVATE (memberIndex,jlev1,jlev2,p,jla)
    do memberIndex = 1, nEns
      zsp(:,:,:,memberIndex) = 0.0d0
      do jlev1 = 1, nLevEns_M
        do jlev2 = 1, nLevEns_M
          do p = 1, nphase
            do jla = 1, nla_mpilocal
              zsp(jla,p,jlev2,memberIndex) = zsp(jla,p,jlev2,memberIndex) +  & 
                                             ensLocal(waveBandIndex)%Vert(jlev2,jlev1)*zsp_all(jla,p,jlev1,memberIndex)
            enddo
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ens%global) then
      call GlobalHLocAd( zsp, waveBandIndex, & ! IN
                         controlVector_out )   ! OUT
    else
      call LamHLocAd( zsp, waveBandIndex, & ! IN
                      controlVector_out )   ! OUT
    endif
    deallocate(zsp)

  END SUBROUTINE localizationSqrtAd

!--------------------------------------------------------------------------
! GlobalHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLocAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_mpilocal)
    integer, intent(in)    :: waveBandIndex
    real(8), intent(in)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev, jm, jn, ila_mpilocal, ila_mpiglobal, jdim, memberIndex 

    jdim = 0

    do memberIndex = 1, nEns

       do jlev = 1, nLevEns_M
          do jm = mymBeg, mymEnd, mymSkip
            do jn = mynBeg, mynEnd, mynSkip
              if (jm .le. jn) then

                ila_mpiglobal = gst_getnind(jm,gstID) + jn - jm
                ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
                if (jm == 0) then
                  ! controlVector only contain real part for jm=0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,1,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*rsq2
                else
                  ! controlVector contains real and imag parts for jm>0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,1,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*2.0d0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,2,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*2.0d0
                endif

             endif
           enddo
         enddo
       enddo

       if (jdim.gt.cvDim_mpilocal) then
          write(*,*) 'ben globalHLocAd: jdim > cvDim_mpilocal! ',jdim,memberIndex,cvDim_mpilocal
          call utl_abort('aborted in ben globalHLocAd')
       endif
    
    enddo

  END SUBROUTINE GlobalHLocAd

!--------------------------------------------------------------------------
! LamHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE LamHLocAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_mpilocal)
    integer, intent(in)    :: waveBandIndex
    real(8), intent(in)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jla, jlev, jdim, memberIndex, p

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = 1, nEns

       do jlev = 1, nLevEns_M
         do jla = 1, nla_mpilocal
           do p = 1, nphase
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) +           &
                                       ( zsp_all(jla,p,jlev,memberIndex)  * &
                                         ensLocal(waveBandIndex)%Horiz(lst_ben%k(jla),jlev) * &
                                         lst_ben%NormFactorAd(jla,p)    )
           enddo
         enddo
       enddo
       if (jdim > cvDim_mpilocal ) then
          write(*,*) 'BEN: LamHLocAD: jdim > cvDim! ',jdim, memberIndex, cvDim_mpilocal
          call utl_abort('aborted in LamHLocAd')
       endif

    enddo

  END SUBROUTINE LamHLocAd

  !--------------------------------------------------------------------------
  ! EnsembleDiagnostic
  !--------------------------------------------------------------------------
  SUBROUTINE EnsembleDiagnostic(mode)
    implicit none

    character(len=*), intent(in) :: mode

    type(struct_gsv) :: statevector, statevector_temp

    integer :: nWaveBandToDiagnose, waveBandIndex, memberIndex

    real(8) :: dnens2

    character(len=12):: etiket, modeEtiket
    character(len=2) :: wbnum

    if ( trim(mode) == 'FullPerturbations') then
       nWaveBandToDiagnose = 1
    else if ( trim(mode) == 'WaveBandPerturbations' ) then
       nWaveBandToDiagnose = nWaveBand
    else
       write(*,*)
       write(*,*) 'mode = ', trim(mode)
       call utl_abort('EnsembleDiagnostic: unknown mode')
    end if

    if ( mpi_myid == 0 ) write(*,*)
    if ( mpi_myid == 0 ) write(*,*) 'EnsembleDiagnostic in mode: ', mode

    !
    !- Write each wave band for a selected member
    !
    if (trim(LocalizationType) == 'ScaleDependent') then
       if ( mpi_myid == 0 ) write(*,*) '   writing perturbations for member 001'
       memberIndex = 1
       dnens2 = sqrt(1.0d0*dble(nEns-1))
       do waveBandIndex = 1, nWaveBandToDiagnose
          if ( mpi_myid == 0 ) write(*,*) '     waveBandIndex = ', waveBandIndex
          call gsv_allocate(statevector, tim_nstepobsinc, hco_ens, vco_anl, &
                            datestamp=tim_getDatestamp(), mpi_local=.true.)
          call ben_getPerturbation( statevector,    & ! OUT
                                    memberIndex,    & ! IN
                                    'ConstantValue', waveBandIndex ) ! IN
          if ( trim(mode) == 'FullPerturbations') then
             etiket = 'PERT001_FULL'
          else
             write(wbnum,'(I2.2)') waveBandIndex
             etiket = 'PERT001_WB' // trim(wbnum)
          end if
          call gsv_writeToFileMPI(statevector,'./ens_pert001.fst',etiket, & ! IN
                                  dnens2,HUcontainsLQ=HUcontainsLQ_gsv )    ! IN
          call gsv_deallocate(statevector)
       end do
    end if

    !
    !- Compute the standard deviations for each wave band
    !
    if ( mpi_myid == 0 ) write(*,*) '   computing Std.Dev.'
    call gsv_allocate(statevector_temp, tim_nstepobsinc, hco_ens, vco_anl, mpi_local=.true.)

    do waveBandIndex = 1, nWaveBandToDiagnose
       if ( mpi_myid == 0 ) write(*,*) '     waveBandIndex = ', waveBandIndex
       call gsv_allocate(statevector, tim_nstepobsinc, hco_ens, vco_anl, &
                         datestamp=tim_getDatestamp(), mpi_local=.true.)
       call gsv_zero(statevector)
       do memberIndex = 1, nEns
          !- Get normalized perturbations
          call ben_getPerturbation( statevector_temp, & ! OUT
                                    memberIndex,      & ! IN
                                    'ConstantValue', waveBandIndex ) ! IN
          !- Square
          call gsv_power(statevector_temp, & ! INOUT
                         2.d0)               ! IN
          !- Sum square values, result in statevector
          call gsv_add(statevector_temp, & ! IN
                       statevector)        ! INOUT
       end do

       !- Convert to StdDev
       call gsv_power(statevector, & ! INOUT
                      0.5d0)         ! IN

       !- Write to file
       if ( trim(mode) == 'FullPerturbations') then
          etiket = 'STDDEV_FULL'
       else
          write(wbnum,'(I2.2)') waveBandIndex
          etiket = 'STDDEV_WB' // trim(wbnum)
       end if
       call gsv_writeToFileMPI(statevector,'./ens_stddev.fst',etiket, & ! IN
                               HUcontainsLQ=HUcontainsLQ_gsv)           ! IN
       call gsv_deallocate(statevector)
    end do

    call gsv_deallocate(statevector_temp)

  END SUBROUTINE EnsembleDiagnostic

END MODULE BMatrixEnsemble_mod
