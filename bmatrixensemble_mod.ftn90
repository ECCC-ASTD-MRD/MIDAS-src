!--------------------------------------------------------------------------
! MODULE BmatrixEnsemble_mod (Background-error Covariance Matrix estimated
!                             using ensemble members and spatial localization
!                             prefix="ben")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    ben_setup (public)
!    ben_BSqrt (public)
!    ben_BSqrtAd (public)
!    setupLocalization
!    setupEnsemble
!    cain
!    cainAd
!    localizationSqrt
!    localizationSqrtAd
!    addEnsMember
!    addEnsMemberAd
!
! Dependencies:
!    glbspec_mod
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble_mod 

  implicit none
  save
  private

  public             :: ben_Setup,ben_BSqrt,ben_BSqrtAd

  real*8,allocatable  :: ensLocalCor(:,:)
  real*8,allocatable  :: ensPerturbations(:,:,:,:,:)
  integer,allocatable :: nip1_l(:),verticalLevel(:)
  integer             :: nibeg_l,niend_l,njbeg_l,njend_l,njsur_l,nisur_l,nj_l,ni_l
  integer             :: nflev_l,nkgdim_l
  integer             :: ntrunc_l,nla_l
  integer             :: nens_l,cvDim_l,cvDimPerMember_l
  integer             :: ntime_l
  integer             :: gstID

CONTAINS

  SUBROUTINE BEN_setup(ZTLEN_IN,NTRUNC_IN,NI_IN,NJ_IN,NFLEV_IN,NIP1_IN,CVDIM_OUT)
    use glbspec_mod
    implicit none

    real*8         :: ztlen_in
    integer        :: ntrunc_in,ni_in,nj_in,nflev_in,nip1_in(:)
    integer        :: cvDim_out
    integer        :: jlev

    nflev_l=nflev_in
    nkgdim_l=4*nflev_l+2  ! assume 4 3d and 2 2d variables
    allocate(verticalLevel(nkgdim_l))
    do jlev=1,nflev_l
      verticalLevel(jlev)=jlev           ! UU
      verticalLevel(1*nflev_l+jlev)=jlev ! VV
      verticalLevel(2*nflev_l+jlev)=jlev ! TT
      verticalLevel(3*nflev_l+jlev)=jlev ! HU
    enddo
    verticalLevel(1+4*nflev_l)=1  ! P0
    verticalLevel(2+4*nflev_l)=1  ! TG

    ntrunc_l=ntrunc_in
    nla_l=(ntrunc_l+1)*(ntrunc_l+2)/2
    
    nisur_l=2
    njsur_l=2
    ni_l=ni_in
    nj_l=nj_in
    nibeg_l=0
    niend_l=ni_l+nisur_l
    njbeg_l=1-njsur_l
    njend_l=nj_l+njsur_l
    write(*,*) 'BEN: nibeg_l,niend_l,njbeg_l,njend_l=',nibeg_l,niend_l,njbeg_l,njend_l

    allocate(nip1_l(nflev_l))
    nip1_l(1:nflev_l)=nip1_in(1:nflev_l)

    gstID = gst_setup(6,ni_l,nj_l,ntrunc_l)
    write(*,*) 'BEN:returned value of gstID=',gstID

    call setupLocalization(ztlen_in)

    call setupEnsemble

    cvDimPerMember_l=((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)*nflev_l
    cvDim_l=nens_l*cvDimPerMember_l
    cvDim_out=cvDim_l

  END SUBROUTINE BEN_setup


  SUBROUTINE setupEnsemble
    use glbspec_mod
    implicit none
 
    real*8 :: gd2d(ni_l,nj_l)
    real*8 :: dnens,dnens3,rmsknt,rmbtpa,r1sa,conima
    integer :: ji,jj,jt,jk,jens
    integer :: kulin
    integer :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg

    ! standard file variables
    integer ini,inj,ink,ip1,ip2,ip3,ierr,idateo,ikey
    character*1 cltypvar,clgrtyp
    character*2 clnomvar
    character*8 cletiket
    character*256 cflensin,cflens(192)
    integer :: vfstlir,fstfrm,fclos,fnom,fstouv

    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nflev_l
    ngposittt=1+2*nflev_l
    ngpositq =1+3*nflev_l
    ngpositps=1+4*nflev_l
    ngposittg=2+4*nflev_l

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    ! parameters set from the ensemble member files
    nens_l=8
    ntime_l=1
    cflens(1)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_001'
    cflens(2)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_002'
    cflens(3)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_003'
    cflens(4)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_004'
    cflens(5)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_005'
    cflens(6)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_006'
    cflens(7)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_007'
    cflens(8)='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/2009021818_006_008'

    allocate(ensPerturbations(ni_l,nkgdim_l,nj_l,ntime_l,nens_l))

    !ensPerturbations(:,:,:,:,:)=1.0d0
    !ensPerturbations=ensPerturbations/sqrt(dble(nens_l))

    dnens=1.0d0/dble(nens_l)
    dnens3=1.0d0/sqrt(2.0d0*dble(nens_l-1))

    ! read in raw ensemble (UU,VV,TT,P0,LQ - covariances)
    ip2 = 6  ! 6 for 6h forecasts (3d-var), 3 for 3h forecasts (4d-var)
    ip3=-1
    idateo = -1
    cltypvar = ' '
    cletiket = ' '

    do jens=1,nens_l
      cflensin=cflens(jens)
      write(*,*) 'Reading ENS from:',cflensin

      kulin=0
      ierr = fnom(kulin,cflensin,'RND',0)
      write(*,*) 'ierr=',ierr,kulin
      ierr = fstouv(kulin,'RND')
      write(*,*) 'nens=',nens_l
      write(*,*) 'TEST: ngposit,...=',ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg
      write(*,*) 'reading member:',jens
      call flush(6)

      do jt=1,ntime_l  ! read all timesteps

        clnomvar = 'P0' 
        ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,-1,ip2,ip3,cltypvar,clnomvar)
        if(ikey.lt.0) then
          write(*,*) 'SUENS: Problem with P0 ENS'
          call flush(6)
          call exit(-1)
        endif
        do jj=1,nj_l
          do ji=1,ni_l
            ensPerturbations(ji,ngpositps,jj,jt,jens)= gd2d(ji,nj_l+1-jj)*rmbtpa
          enddo
        enddo

        do jk=1,nflev_l
          clnomvar = 'TT'
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            write(*,*) 'SUENS: Problem with TT ENS'
            call flush(6)
            call exit(-1)
          endif
          call flush(6)
          do jj=1,nj_l
            do ji=1,ni_l
              ensPerturbations(ji,jk-1+ngposittt,jj,jt,jens)= gd2d(ji,nj_l+1-jj)
            enddo
          enddo
        enddo

        do jk=1,nflev_l
          clnomvar = 'HU' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            write(*,*) 'SUENS: Problem with HU ENS'
            call flush(6)
            call exit(-1)
          endif
          do jj=1,nj_l
            do ji=1,ni_l
              ensPerturbations(ji,jk-1+ngpositq,jj,jt,jens)= gd2d(ji,nj_l+1-jj)
            enddo
          enddo
        enddo

        do jk=1,nflev_l
          clnomvar = 'UU' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            write(*,*) 'SUENS: Problem with UU ENS'
            call flush(6)
            call exit(-1)
          endif
          do jj=1,nj_l
            conima=r1sa*gst_getRSQM2(jj,gstID)
            do ji=1,ni_l
              ensPerturbations(ji,jk-1+ngposituu,jj,jt,jens)= gd2d(ji,nj_l+1-jj)*rmsknt*conima
            enddo
          enddo
        enddo

        do jk=1,nflev_l
          clnomvar = 'VV' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo,cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            write(*,*) 'SUENS: Problem with VV ENS'
            call flush(6)
            call exit(-1)
          endif
          do jj=1,nj_l
            conima=r1sa*gst_getRSQM2(jj,gstID)
            do ji=1,ni_l
              ensPerturbations(ji,jk-1+ngpositvv,jj,jt,jens)= gd2d(ji,nj_l+1-jj)*rmsknt*conima
            enddo
          enddo
        enddo

        clnomvar = 'TG' 
        ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,-1,ip2,ip3,cltypvar,clnomvar)
        if(ikey.lt.0)  then
          write(*,*) idateo,cletiket,ip2,ip3,cltypvar,clnomvar
          write(*,*) 'SUENS: Problem with TG ENS'
          call flush(6)
          call exit(-1)
        else
          do jj=1,nj_l
            do ji=1,ni_l
              ensPerturbations(ji,ngposittg,jj,jt,jens)= gd2d(ji,nj_l+1-jj)
            enddo
          enddo
        endif

      enddo

      ierr =  fstfrm(kulin)
      ierr =  fclos (kulin)
    enddo
    write(*,*) 'finished reading ensemble members...'
    call flush(6)

    ! remove mean and divide by sqrt(2*(NENS_l-1)) - extra 2 is needed?
    do jt=1,ntime_l
      do jk=1,nkgdim_l
        gd2d(:,:)=0.0d0
        do jens=1,nens_l
          do jj=1,nj_l
            do ji=1,ni_l
              gd2d(ji,jj)=gd2d(ji,jj)+ensPerturbations(ji,jk,jj,jt,jens)
            enddo
          enddo
        enddo
        do jj=1,nj_l
          do ji=1,ni_l
            gd2d(ji,jj)=gd2d(ji,jj)*dnens
          enddo
        enddo
        do jens=1,nens_l
          do jj=1,nj_l
            do ji=1,ni_l
              ensPerturbations(ji,jk,jj,jt,jens)=(ensPerturbations(ji,jk,jj,jt,jens)-gd2d(ji,jj))*dnens3
            enddo
          enddo
        enddo
      enddo
    enddo
    write(*,*) 'finished adjusting ensemble members...'
    call flush(6)

  END SUBROUTINE setupEnsemble


  SUBROUTINE setupLocalization(ZTLEN)
    use glbspec_mod
    implicit none

    real*8 zlc,zr,zpole,zcorr,ztlen
    integer ilen,jn,jlat,jla,jlon,jk
    real*8         :: zsp(nla_l,2,nflev_l)
    real*8         :: zgd(nibeg_l:niend_l,nflev_l,njbeg_l:njend_l)
    real*8         :: ra = 6371229.D0

    allocate(ensLocalCor(0:ntrunc_l,nflev_l))

    ! Calculate 5th Order Correlation Functions in Physical Space

    ztlen=1000.0*ztlen
    if(ztlen.gt.0.0) then
       zlc=ztlen/2.0
       do jk=1,nflev_l
          do jlat=1,nj_l
             zr = ra * acos(gst_getrmu(jlat,gstID))
             if(zr.le.zlc) then
                zcorr= -0.250*(zr/zlc)**5 + 0.5*(zr/zlc)**4 + 0.625*(zr/zlc)**3 -(5.0/3.0)*(zr/zlc)**2 + 1.0
             elseif(zr.le.(2.0*zlc)) then
                zcorr= (1.0/12.0)*(zr/zlc)**5 -0.5*(zr/zlc)**4 + 0.625*(zr/zlc)**3 +(5.0/3.0)*(zr/zlc)**2 -   &
                     5.0*(zr/zlc) +4.0 -(2.0/3.0)*(zlc/zr) 
             else
                zcorr= 0.0
             endif
             write(300,*) 'LOCALIZATION FUNCTION1=',jk,jlat,zr/1000.0,zlc/1000.0,zcorr
             do jlon=1,ni_l
                zgd(jlon,jk,jlat)=zcorr
             enddo
          enddo
       enddo

       ! Transform to spectral space

       call gst_setID(gstID)
       call gst_reespe(zsp,zgd,nflev_l,nflev_l)
       call gst_setToDefaultID

       ! Copy over to EnsLocalCor and truncate to NTRUNC

       do jk=1,nflev_l
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=zsp(jn+1,1,jk)
          enddo
       enddo
       do jk=1,nflev_l
          do jn=ntrunc_l+1,nla_l
             zsp(jn,1,jk)=0.0
             zsp(jn,2,jk)=0.0
          enddo
       enddo

       call gst_setID(gstID)
       call gst_speree(zsp,zgd,nflev_l,nflev_l)
       call gst_setToDefaultID

       ! Make sure it's one at the pole

       do jk = 1,nflev_l
          do  jn = 0, ntrunc_l
             ensLocalCor(jn,jk)=abs(ensLocalCor(jn,jk))
          end do
       enddo
       do jk = 1,nflev_l
          zpole = 0.
          do  jn = 0, ntrunc_l
             zpole = zpole + ensLocalCor(jn,jk)*sqrt((2.*jn+1.)/2.)
          end do
          if(zpole.le.0.) then
             write(*,*)'POLE VALUE NEGATIVE IN SUMASK jk=',jk
          endif
          do jn = 0, ntrunc_l
             ensLocalCor(jn,jk) = ensLocalCor(jn,jk)/zpole
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo
       zsp(:,:,:)=0.0d0
       do jk=1,nflev_l
          do jn=0,ntrunc_l
             zsp(jn+1,1,jk)=ensLocalCor(jn,jk)
          enddo
       enddo
       call gst_setID(gstID)
       call gst_speree(zsp,zgd,nflev_l,nflev_l)
       call gst_setToDefaultID

       ! Convert back to correlations and take sqrt

       do jk=1,nflev_l
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=sqrt(0.5*ensLocalCor(jn,jk)*((2.0/(2.0*jn+1.0))**0.5))
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocalCor to 1.0

       do jk=1,nflev_l
          ensLocalCor(0,jk)=1.0 
       enddo
    endif

    write(*,*)'done setting up localization function'

    return
  END SUBROUTINE setupLocalization


  SUBROUTINE BEN_BSqrt(controlVector_in,increment_out)
    implicit none

    integer   :: memberIndex
    real*8    :: controlVector_in(cvDim_l) 
    real*8    :: increment_out(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l)

    real*8    :: ensControlVector(nla_l,2,nflev_l)
    real*8    :: ensAmplitude(ni_l,nflev_l,nj_l)

    do memberIndex=1,nens_l
      call cain(controlVector_in,ensControlVector,memberIndex)
      call localizationSqrt(ensControlVector,ensAmplitude)
      call addEnsMember(ensAmplitude,increment_out,memberIndex)
    enddo

    return
  END SUBROUTINE BEN_BSqrt


  SUBROUTINE BEN_BSqrtAd(increment_in,controlVector_out)
    implicit none

    real*8    :: controlVector_out(cvDim_l) 
    real*8    :: increment_in(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l)

    integer   :: memberIndex
    real*8    :: ensControlVector(nla_l,2,nflev_l) 
    real*8    :: ensAmplitude(ni_l,nflev_l,nj_l)

    do memberIndex=1,nens_l
      call addEnsMemberAd(increment_in,ensAmplitude,memberIndex)
      call localizationSqrtAd(ensAmplitude,ensControlVector)
      call cainAd(ensControlVector,controlVector_out,memberIndex)
    enddo

    return
  END SUBROUTINE BEN_BSqrtAd


  SUBROUTINE addEnsMember(ensAmplitude_in,increment_out,memberIndex)
    implicit none

    integer,intent(in)     :: memberIndex
    real*8      :: ensAmplitude_in(ni_l,nflev_l,nj_l)
    real*8      :: increment_out(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l)

    integer     :: jk,jlev,jt,jj,ji

!$OMP PARALLEL
!$OMP DO PRIVATE (JK,JLEV,JT,JJ,JI)
    do jk=1,nkgdim_l
      jlev=verticalLevel(jk)
      do jt=1,ntime_l
        do jj=1,nj_l
          do ji=1,ni_l
            increment_out(ji,jk,jj)=increment_out(ji,jk,jj) +   &
              ensAmplitude_in(ji,jlev,jj)*ensPerturbations(ji,jk,jj,jt,memberIndex)
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE addEnsMember


  SUBROUTINE addEnsMemberAd(increment_in,ensAmplitude_out,memberIndex)
    implicit none

    integer,intent(in)     :: memberIndex
    real*8      :: ensAmplitude_out(ni_l,nflev_l,nj_l)
    real*8      :: increment_in(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l)

    integer     :: jk,jlev,jt,jj,ji

!$OMP PARALLEL
!$OMP DO PRIVATE (JK,JLEV,JT,JJ,JI)
    do jk=1,nkgdim_l
      jlev=verticalLevel(jk)
      do jt=1,ntime_l
        do jj=1,nj_l
          do ji=1,ni_l
            ensAmplitude_out(ji,jlev,jj)=ensAmplitude_out(ji,jlev,jj) +   &
              increment_in(ji,jk,jj)*ensPerturbations(ji,jk,jj,jt,memberIndex)
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE addEnsMemberAd


  SUBROUTINE localizationSqrt(ensControlVector_in,ensAmplitude_out)
    use glbspec_mod
    implicit none

    real*8           :: ensControlVector_in(nla_l,2,nflev_l)
    real*8           :: ensAmplitude_out(ni_l,nflev_l,nj_l)
    real*8           :: zgd(nibeg_l:niend_l,nflev_l,njbeg_l:njend_l)
    real*8           :: zsp(nla_l,2,nflev_l)
    integer          :: jlev,jn,jm,ila,jla,jj,ji
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)
    zgd(nibeg_l:niend_l,1:nflev_l,njbeg_l:njend_l)=0.0d0

!$OMP PARALLEL 
!$OMP DO PRIVATE (JLEV,JN,JM,ILA,JLA)
    do jlev=1,nflev_l
       do jn=0,ntrunc_l
          do jm=0,jn
             ila = gst_getnind(jm,gstID)+jn-jm
             zsp(ila,1,jlev)=ensControlVector_in(ila,1,jlev)*ensLocalCor(jn,jlev)
             zsp(ila,2,jlev)=ensControlVector_in(ila,2,jlev)*ensLocalCor(jn,jlev)
          enddo
       enddo
       do jla = 1,ntrunc_l+1
          zsp(jla,1,jlev) = ensControlVector_in(jla,1,jlev)*rsq2
          zsp(jla,2,jlev) = 0.0
       enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    call gst_setID(gstID)
    call gst_speree(zsp,zgd,nflev_l,nflev_l)
    call gst_setToDefaultID

!$OMP PARALLEL 
!$OMP DO PRIVATE (JJ,JLEV,JI)
    do jj = 1, nj_l
      do jlev=1,nflev_l
        do ji = 1, ni_l
          ensAmplitude_out(ji,jlev,jj)=zgd(ji,jlev,jj)
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE localizationSqrt


  SUBROUTINE localizationSqrtAd(ensAmplitude_in,ensControlVector_out)
    use glbspec_mod
    implicit none

    real*8           :: ensControlVector_out(nla_l,2,nflev_l)
    real*8           :: ensAmplitude_in(ni_l,nflev_l,nj_l)
    real*8           :: zgd(nibeg_l:niend_l,nflev_l,njbeg_l:njend_l)
    integer          :: jlev
    integer          :: jn,jm,ila,jla
    integer          :: ji,jj
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)
    zgd(nibeg_l:niend_l,1:nflev_l,njbeg_l:njend_l)=0.0d0

    ! this is from bilinad
!$OMP PARALLEL 
!$OMP DO PRIVATE (JJ,JLEV,JI)
    do jj = 1, nj_l
       do jlev=1,nflev_l
          do ji = 1, ni_l
!             zgd(ji,jlev,jj)=ensAmplitude_in(ji,jlev,jj)*ni_l/gst_getrwt(jj,gstID)
             zgd(ji,jlev,jj)=ensAmplitude_in(ji,jlev,jj)
          enddo
       enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    call gst_setID(gstID)
    call gst_reespe(ensControlVector_out,zgd,nflev_l,nflev_l)
    call gst_setToDefaultID

!$OMP PARALLEL 
!$OMP DO PRIVATE (JLEV,JN,JM,ILA,JLA)
    do jlev=1,nflev_l
       do jn=0,ntrunc_l
          do jm=0,jn
             ila = gst_getnind(jm,gstID)+jn-jm
             ensControlVector_out(ila,1,jlev)=ensControlVector_out(ila,1,jlev)*ensLocalCor(jn,jlev)
             ensControlVector_out(ila,2,jlev)=ensControlVector_out(ila,2,jlev)*ensLocalCor(jn,jlev)
          enddo
       enddo
       do jla = 1,ntrunc_l+1
          ensControlVector_out(jla,1,jlev) = ensControlVector_out(jla,1,jlev)*rsq2
          ensControlVector_out(jla,2,jlev) = 0.0
       enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE localizationSqrtAd


  SUBROUTINE cain(controlVector_in,ensControlVector_out,memberIndex)
    implicit none

    integer,intent(in)   :: memberIndex
    real*8    :: controlVector_in(cvDim_l)
    real*8    :: ensControlVector_out(nla_l,2,nflev_l)

    integer   :: jdim,jlev,jla,jvar,jens

    jdim = (memberIndex-1)*cvDimPerMember_l
    do jlev = 1, nflev_l
      do jla = 1, ntrunc_l+1
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        ensControlVector_out(jla,2,jlev) = 0.0
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        jdim = jdim + 1
        ensControlVector_out(jla,2,jlev) = controlVector_in(jdim)
      enddo
    enddo

    if(jdim.gt.cvDim_l) then
      write(*,*) 'BEN: CAIN: jdim > cvDim! ',jdim,memberIndex,cvDimPerMember_l,cvDim_l
      call flush(6)
      call exit(-1)
    endif

    return
  END SUBROUTINE cain


  SUBROUTINE cainAd(ensControlVector_in,controlVector_out,memberIndex)
    implicit none

    integer,intent(in)    :: memberIndex
    real*8     :: controlVector_out(cvDim_l)
    real*8     :: ensControlVector_in(nla_l,2,nflev_l)

    integer kdim,jdim,jlev,jla,jvar,ji,jj

    jdim = (memberIndex-1)*cvDimPerMember_l
    do jlev = 1, nflev_l
      do jla = 1, ntrunc_l+1
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)*2.0d0
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,2,jlev)*2.0d0
      enddo
    enddo

    if(jdim.gt.cvDim_l) then
      write(*,*) 'BEN: CAINAD: jdim > cvDim! ',jdim,memberIndex,cvDimPerMember_l,cvDim_l
      call flush(6)
      call exit(-1)
    endif

    return
  END SUBROUTINE cainAd


END MODULE BMatrixEnsemble_mod

