!--------------------------------------------------------------------------
! MODULE BmatrixEnsemble (Background-error Covariance Matrix estimated
!                         using ensemble members and spatial localization
!                         prefix="ben")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    ben_setup (public)
!    ben_BSqrt (public)
!    ben_BSqrtAd (public)
!    setupLocalization
!    setupEnsemble
!    cain
!    cainAd
!    localizationSqrt
!    localizationSqrtAd
!    addEnsMember
!    addEnsMemberAd
!
! Dependencies:
!    globalSpectralTransform
!    matsqrt
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble
  use mpi
  use gridStateVector_mod
  implicit none
  save
  private

  public             :: ben_Setup,ben_BSqrt,ben_BSqrtAd

  logical             :: initialized = .false.
  integer,parameter   :: maxNumLevels=200
  real*8              :: scaleFactor(maxNumLevels)
  real*8,allocatable  :: ensLocalCor(:,:)
  real*8,allocatable  :: ensLocalVert(:,:)
  real*4,allocatable  :: ensPerturbations(:,:,:,:,:)
  integer,allocatable :: nip1_l(:),verticalLevel(:),verticalLevelEns(:)
  integer,allocatable :: jn_vec(:),kIndexInc(:)
  integer             :: nj_l,ni_l,latPerPE,maxLatPerPE,maxLatEnd
  integer             :: nLevInc,nkgdimInc,nLevEns,nkgdimEns,topLevIndex
  integer             :: ntrunc_l,nla_l
  integer             :: nens,cvDim_l,cvDimPerMember_l
  integer             :: ntime_l
  integer             :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg
  integer             :: gstID
  character(len=256)  :: enspathname,ensfilebasename

CONTAINS

  SUBROUTINE BEN_setup(ZTLEN_IN,verticalScale_in,pressureProfile_in,NI_IN,NJ_IN,NLEVINC_IN,NTIME_IN,NIP1_IN,stamp_in,CVDIM_OUT)
    use globalSpectralTransform
    implicit none

    real*8         :: ztlen_in,verticalScale_in,pressureProfile_in(:)
    real*8,allocatable :: pressureProfileEns(:)
    integer        :: ntrunc,ni_in,nj_in,nLevInc_in,ntime_in,nip1_in(:),stamp_in
    integer        :: cvDim_out
    integer        :: jlev,jn,jm,ila,njlath_l,mpiMode
    integer        :: fnom,fclos,ierr,nulnam

    !namelist
    NAMELIST /NAMBEN/nens,scaleFactor,ntrunc,enspathname,ensfilebasename,nLevEns

    ! parameters from namelist (date in filename should come directly from sequencer?)
    scaleFactor(:)=0.0d0
    nens=10
    ntrunc=31
    nLevEns=nLevInc_in
    enspathname='/users/dor/arma/bue/gpfs/3dvar_modular/ensemble/'
    ensfilebasename=''

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    write(*,*) 'ben_setup: reading namelist, ierr=',ierr
    read(nulnam,nml=namben)
    write(*,nml=namben)
    ierr=fclos(nulnam)

    do jlev=1,nLevEns
      if(scaleFactor(jlev).gt.0.0d0) then 
        scaleFactor(jlev)=sqrt(scaleFactor(jlev))
      else
        scaleFactor(jlev)=0.0d0
      endif
    enddo

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bmatrixEnsemble: scaleFactor=0, skipping rest of setup'
      cvdim_out=0
      initialized = .true.
      return
    endif

    if(nLevEns.gt.nLevInc_in) then
      write(*,*) 'bmatrixEnsemble: ensemble has more levels than increment - not allowed!'
      call flush(6)
      call qqexit(1)
    endif

    if(nLevEns.lt.nLevInc_in) then
      write(*,*) 'bmatrixEnsemble: ensemble has less levels than increment'
      write(*,*) '                 some levels near top will have zero increment'
    endif

    nLevInc=nLevInc_in
    nkgdimInc=4*nLevInc+2  ! assume 4 3d and 2 2d variables
    nkgdimEns=4*nLevEns+2  ! assume 4 3d and 2 2d variables
    topLevIndex=nLevInc-nLevEns+1

    allocate(verticalLevel(nkgdimInc),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=1',ierr
      call flush(6)
    endif
    do jlev=1,nLevInc
      verticalLevel(          jlev)=jlev ! UU
      verticalLevel(1*nLevInc+jlev)=jlev ! VV
      verticalLevel(2*nLevInc+jlev)=jlev ! TT
      verticalLevel(3*nLevInc+jlev)=jlev ! HU
    enddo
    verticalLevel(4*nLevInc+1)=nLevInc   ! P0
    verticalLevel(4*nLevInc+2)=nLevInc   ! TG

    allocate(verticalLevelEns(nkgdimEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=2',ierr
      call flush(6)
    endif
    do jlev=1,nLevEns
      verticalLevelEns(           jlev)=jlev ! UU
      verticalLevelEns(1*nLevEns+jlev)=jlev ! VV
      verticalLevelEns(2*nLevEns+jlev)=jlev ! TT
      verticalLevelEns(3*nLevEns+jlev)=jlev ! HU
    enddo
    verticalLevelEns(4*nLevEns+1)=nLevEns   ! P0
    verticalLevelEns(4*nLevEns+2)=nLevEns   ! TG

    allocate(kIndexInc(nkgdimEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=3',ierr
      call flush(6)
    endif
    do jlev=1,nLevEns
      kIndexInc(          jlev)=topLevIndex-1+           jlev ! UU
      kIndexInc(1*nLevEns+jlev)=topLevIndex-1+ 1*nLevInc+jlev ! VV
      kIndexInc(2*nLevEns+jlev)=topLevIndex-1+ 2*nLevInc+jlev ! TT
      kIndexInc(3*nLevEns+jlev)=topLevIndex-1+ 3*nLevInc+jlev ! HU
    enddo
    kIndexInc(4*nLevEns+1)= 4*nLevInc+1 ! P0
    kIndexInc(4*nLevEns+2)= 4*nLevInc+2 ! TG

    ntrunc_l=ntrunc
    nla_l=(ntrunc_l+1)*(ntrunc_l+2)/2
    
    ni_l=ni_in
    nj_l=nj_in

    if(ntime_in.eq.1.or.ntime_in.eq.5.or.ntime_in.eq.7) then
      ntime_l=ntime_in
    else
      write(*,*) 'Invalid value for NTIME (choose 1 or 5 or 7)!'
      call flush(6)
      call qqexit(1)
    endif

    if(mpi_myLatBeg.eq.0) then
      write(*,*) 'setting up local variables for process:',mpi_myid
      latPerPE=ceiling(dble(nj_l)/dble(mpi_nprocs))
      mpi_myLatBeg=1+mpi_myid*latPerPE
      mpi_myLatEnd=(1+mpi_myid)*latPerPE
      maxLatPerPE=latPerPE
      maxLatEnd=mpi_myLatEnd
      if(mpi_myLatEnd>nj_l) then
        write(*,*) 'WARNING: latitudes not divisible by MPI numprocs!',mpi_myLatEnd,nj_l
        mpi_myLatEnd=nj_l
        call flush(6)
        !call qqexit(1)
        mpi_myLatEnd=nj_l
        latPerPE=mpi_myLatEnd-mpi_myLatBeg+1
      endif
      write(*,*) 'latPerPE=',latPerPE
      write(*,*) 'mpi_myLatBeg+End=',mpi_myLatBeg,mpi_myLatEnd

      njlath_l = (nj_l + 1)/2
      if(mpi_myLatBeg<=njlath_l .and. mpi_myLatEnd<=njlath_l) then
        mpi_myLatHalfBeg=mpi_myLatBeg
        mpi_myLatHalfEnd=mpi_myLatEnd
      elseif(mpi_myLatBeg>=njlath_l .and. mpi_myLatEnd>=njlath_l) then
        mpi_myLatHalfBeg=1+nj_l-mpi_myLatEnd
        mpi_myLatHalfEnd=1+nj_l-mpi_myLatBeg
      else
        mpi_myLatHalfBeg=min(mpi_myLatBeg,1+nj_l-mpi_myLatEnd)
        mpi_myLatHalfEnd=njlath_l
      endif  
      write(*,*) 'mpi_myLatHalfBeg+End=',mpi_myLatHalfBeg,mpi_myLatHalfEnd
    endif

    allocate(nip1_l(nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=4',ierr
      call flush(6)
    endif
    nip1_l(1:nLevEns)=nip1_in(topLevIndex:nLevInc)

    mpiMode=1
    gstID = gst_setup(6,ni_l,nj_l,ntrunc_l,mpiMode)
    write(*,*) 'BEN:returned value of gstID=',gstID

    allocate(jn_vec(nla_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=5',ierr
      call flush(6)
    endif
    do jn=0,ntrunc_l
      do jm=0,jn
        ila = gst_getnind(jm,gstID)+jn-jm
        jn_vec(ila)=jn
      enddo
    enddo

    allocate(pressureProfileEns(nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=6',ierr
      call flush(6)
    endif
    pressureProfileEns(1:nLevEns)=pressureProfile_in(topLevIndex:nLevInc)
    call setupLocalization(ztlen_in,verticalScale_in,pressureProfileEns)
    deallocate(pressureProfileEns)

    call setupEnsemble(stamp_in)

    cvDimPerMember_l=((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)*nLevEns
    cvDim_l=nens*cvDimPerMember_l
    cvDim_out=cvDim_l

    initialized = .true.

  END SUBROUTINE BEN_setup


  SUBROUTINE setupEnsemble(stamp_in)
    use globalSpectralTransform
    implicit none
 
    integer :: stamp_in
    real*8 :: gd2d(ni_l,nj_l)
    real*4, allocatable :: ensPerturbation1(:,:,:,:) 
    real*8 :: dnens,dnens2,rmsknt,rmbtpa,r1sa,conima
    real*8 :: rhumin = 2.5d-6
    integer :: ji,jj,jt,jk,jens,jpe,jlatband
    integer :: iens,batchnum,nsize,status,pe_src,pe_dest
    integer :: kulin,ndate,ntime
    integer :: readFilePE(192),allLatBeg(192),allLatEnd(192)
    integer :: stamp_last,newdate
    real*8  :: delhh

    ! standard file variables
    integer ini,inj,ink,ip1,ip2(9),ip3,ierr,idateo,ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket
    character(len=256) :: cflensin
    character(len=3)   :: censnumber
    character(len=8)   :: datestr_last
    character(len=2)   :: hourstr_last
    integer :: vfstlir,fstfrm,fclos,fnom,fstouv


    call tmg_start(48,'setupens')

    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nLevEns
    ngposittt=1+2*nLevEns
    ngpositq =1+3*nLevEns
    ngpositps=1+4*nLevEns
    ngposittg=2+4*nLevEns

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    allocate(ensPerturbations(ni_l,nkgdimEns,mpi_myLatBeg:mpi_myLatEnd,ntime_l,nens),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7',ierr
      call flush(6)
    endif
    allocate(ensPerturbation1(ni_l,nkgdimEns,nj_l,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=8',ierr
      call flush(6)
    endif

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)
    if(ntime_l.eq.5) then
      ip2(1) = 3  
      ip2(2) = 4  
      ip2(3) = 6  
      ip2(4) = 7  
      ip2(5) = 9  
    elseif(ntime_l.eq.7) then
      ip2(1) = 3  
      ip2(2) = 4  
      ip2(3) = 5  
      ip2(4) = 6  
      ip2(5) = 7  
      ip2(6) = 8  
      ip2(7) = 9  
    else
      ip2(1) = 6
    endif
    ip3=-1
    idateo = -1
    cltypvar = ' '
    cletiket = ' '

    CALL rpn_comm_allgather(mpi_myLatBeg,1,"mpi_integer",       &
                            allLatBeg,1,"mpi_integer","GRID",ierr)
    CALL rpn_comm_allgather(mpi_myLatEnd,1,"mpi_integer",       &
                            allLatEnd,1,"mpi_integer","GRID",ierr)

    do jens=1,nens
      readFilePE(jens)=mod(jens-1,mpi_nprocs)
    enddo

    delhh = -6.0
    call incdatr(stamp_last,stamp_in,delhh)
    ierr = newdate(stamp_last,ndate,ntime,-3)
    write(datestr_last,'(i8.8)') ndate
    write(hourstr_last,'(i2.2)') ntime/1000000
    write(*,*) 'DATE,TIME=',ndate,'  ,',ntime

    do jens=1,nens
      if(mpi_myid.eq.readFilePE(jens)) then

        write(censnumber,'(i3.3)') jens
        cflensin= trim(enspathname) // '/' // trim(ensfilebasename) // &
                  trim(datestr_last) // trim(hourstr_last) // '_006_' // censnumber
        write(*,*) 'Reading ',ntime_l,' time slices for ensemble member:',trim(cflensin)
        call flush(6)

        kulin=0
        ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
        ierr = fstouv(kulin,'RND+OLD')
        write(*,*) 'reading member:',jens
        call flush(6)

        do jt=1,ntime_l  ! read all timesteps

          clnomvar = 'P0' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,-1,ip2(jt),ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) 'SUENS: Problem with P0 ENS'
            call flush(6)
            call qqexit(1)
          endif
          do jj=1,nj_l
            do ji=1,ni_l
              ensPerturbation1(ji,ngpositps,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmbtpa)
            enddo
          enddo

          do jk=1,nLevEns
            clnomvar = 'TT'
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar
              write(*,*) 'SUENS: Problem with TT ENS'
              call flush(6)
              call qqexit(1)
            endif
            call flush(6)
            do jj=1,nj_l
              do ji=1,ni_l
                ensPerturbation1(ji,jk-1+ngposittt,jj,jt)= sngl(gd2d(ji,nj_l+1-jj))
              enddo
            enddo
          enddo

          do jk=1,nLevEns
            clnomvar = 'HU' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar
              write(*,*) 'SUENS: Problem with HU ENS'
              call flush(6)
              call qqexit(1)
            endif
            do jj=1,nj_l
              do ji=1,ni_l
                ensPerturbation1(ji,jk-1+ngpositq,jj,jt)= sngl(log(max(gd2d(ji,nj_l+1-jj),rhumin)))
              enddo
            enddo
          enddo

          do jk=1,nLevEns
            clnomvar = 'UU' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar
              write(*,*) 'SUENS: Problem with UU ENS'
              call flush(6)
              call qqexit(1)
            endif
            do jj=1,nj_l
              conima=r1sa*gst_getRSQM2(jj,gstID)
              do ji=1,ni_l
                ensPerturbation1(ji,jk-1+ngposituu,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmsknt*conima)
              enddo
            enddo
          enddo

          do jk=1,nLevEns
            clnomvar = 'VV' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo,cletiket,nip1_l(jk),ip2(jt),ip3,cltypvar,clnomvar
              write(*,*) 'SUENS: Problem with VV ENS'
              call flush(6)
              call qqexit(1)
            endif
            do jj=1,nj_l
              conima=r1sa*gst_getRSQM2(jj,gstID)
              do ji=1,ni_l
                ensPerturbation1(ji,jk-1+ngpositvv,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmsknt*conima)
              enddo
            enddo
          enddo

          clnomvar = 'TG' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo,cletiket,-1,ip2(jt),ip3,cltypvar,clnomvar)
          if(ikey.lt.0)  then
            write(*,*) idateo,cletiket,ip2(jt),ip3,cltypvar,clnomvar
            write(*,*) 'SUENS: Problem with TG ENS'
            call flush(6)
            call qqexit(1)
          else
            do jj=1,nj_l
              do ji=1,ni_l
                ensPerturbation1(ji,ngposittg,jj,jt)= sngl(gd2d(ji,nj_l+1-jj))
              enddo
            enddo
          endif

        enddo

        ierr =  fstfrm(kulin)
        ierr =  fclos (kulin)

        write(*,*) 'done reading member ',jens
        call flush(6)
      endif

      if(readFilePE(jens).eq.(mpi_nprocs-1) .or. jens.eq.nens) then
        batchnum=ceiling(dble(jens)/dble(mpi_nprocs))

        ! for each read member, send each latitude band to the appropriate processor
        do iens=1+(batchnum-1)*mpi_nprocs,jens
          do jlatband=1,mpi_nprocs
            pe_src=readFilePE(iens)
            pe_dest=jlatband-1

            if(pe_src.eq.pe_dest) then

              ! do copy if latband already on appropriate processor
              if(mpi_myid.eq.pe_src) then
                ensPerturbations(:,:,mpi_myLatBeg:mpi_myLatEnd,:,iens)=  &
                ensPerturbation1(:,:,mpi_myLatBeg:mpi_myLatEnd,:)
              endif

            else

              ! send latitude band to appropriate processor
              if(mpi_myid.eq.pe_src) then
                nsize=ni_l*nkgdimEns*(allLatEnd(jlatband)-allLatBeg(jlatband)+1)*ntime_l
                call rpn_comm_send(ensPerturbation1(:,:,allLatBeg(jlatband):allLatEnd(jlatband),:),   &
                                   nsize,"mpi_real4",pe_dest,pe_src*100+pe_dest,"GRID", ierr )
              endif

              ! receive the appropriate latitude band for this processor
              if(mpi_myid.eq.pe_dest) then
                nsize=ni_l*nkgdimEns*(allLatEnd(jlatband)-allLatBeg(jlatband)+1)*ntime_l
                call rpn_comm_recv(ensPerturbations(:,:,mpi_myLatBeg:mpi_myLatEnd,:,iens),  &
                                   nsize,"mpi_real4",pe_src,pe_src*100+pe_dest,"GRID",status,ierr)
              endif
    
            endif

          enddo
        enddo
      endif

    enddo

    deallocate(ensPerturbation1)

    write(*,*) 'finished reading ensemble members...'
    call flush(6)

    ! remove mean and divide by sqrt(2*(NENS-1)) - extra 2 is needed?
    dnens=1.0d0/dble(nens)
    do jt=1,ntime_l
!$OMP PARALLEL
!$OMP DO PRIVATE (JK,GD2D,JENS,JJ,JI)
      do jk=1,nkgdimEns
        dnens2=scaleFactor(verticalLevelEns(jk))/sqrt(1.0d0*dble(nens-1))
        gd2d(:,:)=0.0d0
        do jens=1,nens
          do jj=mpi_myLatBeg,mpi_myLatEnd
            do ji=1,ni_l
              gd2d(ji,jj)=gd2d(ji,jj)+dble(ensPerturbations(ji,jk,jj,jt,jens))
            enddo
          enddo
        enddo
        do jj=mpi_myLatBeg,mpi_myLatEnd
          do ji=1,ni_l
            gd2d(ji,jj)=gd2d(ji,jj)*dnens
          enddo
        enddo
        do jens=1,nens
          do jj=mpi_myLatBeg,mpi_myLatEnd
            do ji=1,ni_l
              ensPerturbations(ji,jk,jj,jt,jens)=     &
                sngl((dble(ensPerturbations(ji,jk,jj,jt,jens))-gd2d(ji,jj))*dnens2)
            enddo
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL
    enddo
    write(*,*) 'finished adjusting ensemble members...'
    call flush(6)
 
    call tmg_stop(48)

    ! ensPerturbations(:,:,:,:,:)=0.0 !for testing purposes

  END SUBROUTINE setupEnsemble


  SUBROUTINE setupLocalization(ZTLEN,verticalScale,pressureProfile)
    use globalSpectralTransform
    implicit none

    real*8 zlc,zr,zpole,zcorr,ztlen,verticalScale,pressureProfile(:)
    integer ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr
    real*8         :: zsp(nla_l,2,nLevEns)
    real*8         :: zgd(ni_l,nLevEns,nj_l)
    real*8         :: ra = 6371229.D0

    allocate(ensLocalCor(0:ntrunc_l,nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=9',ierr
      call flush(6)
    endif
    allocate(ensLocalVert(nLevEns,nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=10',ierr
      call flush(6)
    endif

    ! Calculate 5th Order Correlation Functions in Physical Space

    ztlen=1000.0*ztlen
    if(ztlen.gt.0.0) then
       zlc=ztlen/2.0
       do jk=1,nLevEns
          do jlat=1,nj_l
             zr = ra * acos(gst_getrmu(jlat,gstID))
             if(zr.le.zlc) then
                zcorr= -0.250*(zr/zlc)**5 + 0.5*(zr/zlc)**4               &
                       + 0.625*(zr/zlc)**3 -(5.0/3.0)*(zr/zlc)**2 + 1.0
             elseif(zr.le.(2.0*zlc)) then
                zcorr= (1.0/12.0)*(zr/zlc)**5 -0.5*(zr/zlc)**4    &
                      + 0.625*(zr/zlc)**3 +(5.0/3.0)*(zr/zlc)**2  &
                      - 5.0*(zr/zlc) +4.0 -(2.0/3.0)*(zlc/zr) 
             else
                zcorr= 0.0
             endif
             !write(300,*) 'LOCALIZATION FUNCTION1=',jk,jlat,zr/1000.0,zlc/1000.0,zcorr
             do jlon=1,ni_l
                zgd(jlon,jk,jlat)=zcorr
             enddo
          enddo
       enddo

       ! Transform to spectral space

       call gst_setID(gstID)
       call gst_reespe(zsp,zgd,nLevEns,nLevEns)
       call gst_setToDefaultID
       nsize=nla_l*2*nLevEns
       call RPN_COMM_allreduce(zsp,zsp,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)

       ! Copy over to EnsLocalCor and truncate to NTRUNC

       do jk=1,nLevEns
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=zsp(jn+1,1,jk)
          enddo
       enddo
       do jk=1,nLevEns
          do jn=ntrunc_l+1,nla_l
             zsp(jn,1,jk)=0.0
             zsp(jn,2,jk)=0.0
          enddo
       enddo

       call gst_setID(gstID)
       call gst_speree(zsp,zgd,nLevEns,nLevEns)
       call gst_setToDefaultID
       nsize=ni_l*nLevEns*nj_l
       call RPN_COMM_allreduce(zgd,zgd,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)

       ! Make sure it's one at the pole

       do jk = 1,nLevEns
          do  jn = 0, ntrunc_l
             ensLocalCor(jn,jk)=abs(ensLocalCor(jn,jk))
          end do
       enddo
       do jk = 1,nLevEns
          zpole = 0.
          do  jn = 0, ntrunc_l
             zpole = zpole + ensLocalCor(jn,jk)*sqrt((2.*jn+1.)/2.)
          end do
          if(zpole.le.0.) then
             write(*,*)'POLE VALUE NEGATIVE IN SUMASK jk=',jk
          endif
          do jn = 0, ntrunc_l
             ensLocalCor(jn,jk) = ensLocalCor(jn,jk)/zpole
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo

       ! Convert back to correlations and take sqrt

       do jk=1,nLevEns
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=sqrt(0.5*ensLocalCor(jn,jk)*((2.0/(2.0*jn+1.0))**0.5))
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocalCor to 1.0

       do jk=1,nLevEns
          ensLocalCor(0,jk)=1.0 
       enddo
    endif


    ! Compute vertical localization correlation matrix

    ! calculate 5'th order function
    ZLC=verticalScale/2.0
    do jk1=1,nLevEns
      do jk2=1,nLevEns
        ZR = abs(log(pressureProfile(jk2)) - log(pressureProfile(jk1)))
        if(ZR.le.ZLC) then
          zcorr= -0.250*(ZR/ZLC)**5 + 0.5*(ZR/ZLC)**4 + 0.625*(ZR/ZLC)**3   &
                 -(5.0/3.0)*(ZR/ZLC)**2 + 1.0
        elseif(ZR.le.(2.0*ZLC)) then
          zcorr= (1.0/12.0)*(ZR/ZLC)**5   -0.5*(ZR/ZLC)**4     &
                   + 0.625*(ZR/ZLC)**3 +(5.0/3.0)*(ZR/ZLC)**2  &
                   - 5.0*(ZR/ZLC) +4.0 -(2.0/3.0)*(ZLC/ZR) 
        else
          zcorr= 0.0
        endif
        if(zcorr.lt.0.0) zcorr=0.0
        !write(95,*) 'VERT MASK=',jk1,jk2,zcorr
        ensLocalVert(jk1,jk2)=zcorr
      enddo
    enddo

    ! compute sqrt of the matrix if vertical localization requested
    call matsqrt(ensLocalVert(1,1),nLevEns,1.0d0)

    write(*,*)'done setting up localization function'

    return
  END SUBROUTINE setupLocalization


  SUBROUTINE BEN_BSqrt(controlVector_in,statevector)
    implicit none

    real*8    :: controlVector_in(cvDim_l) 
    type(struct_gsv) :: statevector
    real*8,allocatable  :: incrementLocal2(:,:,:,:)
    real*8,allocatable  :: incrementLocal(:,:,:,:)
    real*8,allocatable  :: incrementMax(:,:,:,:)
    real*8    :: ensControlVector(nla_l,2,nLevEns)
    real*8    :: ensAmplitude(ni_l,nLevEns,nj_l)
    real*8, pointer :: field(:,:,:,:)
    integer   :: memberIndex
    integer   :: ierr,nsize,jj,jk,ji,jt,jkInc,jvar,ilev1,ilev2,topLevOffset

    if(.not. initialized) then
      write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrt'
      return
    endif

    write(*,*) 'ben_bsqrt: starting'
    write(*,*) ntime_l,ni_l,nj_l,nkgdimInc,nkgdimEns,mpi_myLatBeg,maxLatEnd,maxLatPerPE,mpi_nprocs,nla_l,nLevInc,nLevEns
    call flush(6)

    allocate(incrementLocal2(ni_l,nkgdimEns,ntime_l,mpi_myLatBeg:maxLatEnd),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=11',ierr
      call flush(6)
    endif
    allocate(incrementLocal(ni_l,nkgdimEns,mpi_myLatBeg:maxLatEnd,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=12',ierr
      call flush(6)
    endif
    allocate(incrementMax(ni_l,nkgdimEns,ntime_l,maxLatPerPE*mpi_nprocs),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=13',ierr
      call flush(6)
    endif

    call tmg_start(38,'comm_gd2')
!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JK,JI)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jk=1,nkgdimEns
        do ji=1,ni_l
          incrementLocal(ji,jk,jj,:)=0.0d0
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL
    call tmg_stop(38)

    do memberIndex=1,nens
      call cain(controlVector_in,ensControlVector,memberIndex)
      call localizationSqrt(ensControlVector,ensAmplitude)
      call addEnsMember(ensAmplitude,incrementLocal,memberIndex)
    enddo

    call tmg_start(38,'comm_gd2')
!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JT,JK,JI)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jt=1,ntime_l
        do jk=1,nkgdimEns
          do ji=1,ni_l
            incrementLocal2(ji,jk,jt,jj)=incrementLocal(ji,jk,jj,jt)
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL
    call tmg_stop(38)

    call tmg_start(39,'comm_gd')
    nsize=ni_l*nkgdimEns*maxLatPerPE*ntime_l
    CALL rpn_comm_allgather(incrementLocal2,nsize,   &
                            "mpi_double_precision",       &
                            incrementMax,nsize,      &
                            "mpi_double_precision","GRID",ierr)
    call tmg_stop(39)

    call tmg_start(38,'comm_gd2')
!$OMP PARALLEL
!$OMP DO PRIVATE (JT,JJ,JK,JI,JVAR,ILEV1,ILEV2,jkInc,field,topLevOffset)
    do jj=1,nj_l
      do jvar=1,vnl_numvarmax 
        if(gsv_varExist(varnamelist(jvar))) then
          field => gsv_getField(statevector,varnamelist(jvar))
          if(varnamelist(jvar).eq.'UU  ') then
            ilev1=ngposituu
          elseif(varnamelist(jvar).eq.'VV  ') then
            ilev1=ngpositvv
          elseif(varnamelist(jvar).eq.'TT  ') then
            ilev1=ngposittt
          elseif(varnamelist(jvar).eq.'HU  ') then
            ilev1=ngpositq
          elseif(varnamelist(jvar).eq.'P0  ') then
            ilev1=ngpositps
          elseif(varnamelist(jvar).eq.'TG  ') then
            ilev1=ngposittg
          else
            write(*,*) 'ben_bsqrt: No covariances available for variable:',varnamelist(jvar)
            call flush(6)
            call qqexit(1)
          endif
          if(vnl_vartypeFromVarname(varNameList(jvar)).eq.'SF') then
            ilev2=ilev1
            topLevOffset=1
          else
            ilev2=ilev1 - 1 + nlevEns
            topLevOffset= topLevIndex
          endif
          do jt=1,ntime_l
            do jk=ilev1,ilev2
              jkInc=jk-ilev1 + topLevOffset
              do ji=1,ni_l
                field(ji,jkInc,jj,jt)=field(ji,jkInc,jj,jt)+incrementMax(ji,jk,jt,jj)
              enddo
            enddo
          enddo
        endif
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL
    call tmg_stop(38)

    deallocate(incrementLocal2)
    deallocate(incrementLocal)
    deallocate(incrementMax)

    write(*,*) 'ben_bsqrt: done'
    call flush(6)

    return
  END SUBROUTINE BEN_BSqrt


  SUBROUTINE BEN_BSqrtAd(statevector,controlVector_out)
    implicit none

    real*8    :: controlVector_out(cvDim_l) 
    type(struct_gsv) :: statevector

    real*8, pointer :: field(:,:,:,:)
    real*8,allocatable :: incrementLocal(:,:,:,:)
    real*8    :: ensControlVector(nla_l,2,nLevEns) 
    real*8    :: ensAmplitude(ni_l,nLevEns,nj_l)
    integer   :: memberIndex,jj,jk,ji,jt,jkinc,nsize,ierr,jvar,ilev1,ilev2,topLevOffset

    write(*,*) 'ben_bsqrtad: starting'
    call flush(6)

    if(.not. initialized) then
      write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrtAd'
      return
    endif

    allocate(incrementLocal(ni_l,nkgdimEns,mpi_myLatBeg:maxLatEnd,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=14',ierr
      call flush(6)
    endif

!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JT,JK,JI,JVAR,ILEV1,ILEV2,jkInc,field,topLevOffset)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jvar=1,vnl_numvarmax 
        if(gsv_varExist(varnamelist(jvar))) then
          field => gsv_getField(statevector,varnamelist(jvar))
          if(varnamelist(jvar).eq.'UU  ') then
            ilev1=ngposituu
          elseif(varnamelist(jvar).eq.'VV  ') then
            ilev1=ngpositvv
          elseif(varnamelist(jvar).eq.'TT  ') then
            ilev1=ngposittt
          elseif(varnamelist(jvar).eq.'HU  ') then
            ilev1=ngpositq
          elseif(varnamelist(jvar).eq.'P0  ') then
            ilev1=ngpositps
          elseif(varnamelist(jvar).eq.'TG  ') then
            ilev1=ngposittg
          else
            write(*,*) 'ben_bsqrtad: No covariances available for variable:',varnamelist(jvar)
            call flush(6)
            call qqexit(1)
          endif
          if(vnl_vartypeFromVarname(varNameList(jvar)).eq.'SF') then
            ilev2=ilev1
            topLevOffset=1
          else
            ilev2=ilev1 - 1 + nlevEns
            topLevOffset= topLevIndex
          endif
          do jt=1,ntime_l
            do jk=ilev1,ilev2
              jkInc=jk-ilev1 + topLevOffset
              do ji=1,ni_l
                incrementLocal(ji,jk,jj,jt)=field(ji,jkInc,jj,jt)
              enddo
            enddo
          enddo
        endif
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    do memberIndex=1,nens
      call addEnsMemberAd(incrementLocal,ensAmplitude,memberIndex)
      call localizationSqrtAd(ensAmplitude,ensControlVector)
      call cainAd(ensControlVector,controlVector_out,memberIndex)
    enddo

    call tmg_start(37,'comm_cv')
    nsize=cvDim_l
    call RPN_COMM_allreduce(controlVector_out,controlVector_out,nsize,    &
                            "mpi_double_precision","mpi_sum","GRID",ierr)
    call tmg_stop(37)

    deallocate(incrementLocal)

    write(*,*) 'ben_bsqrtad: done'
    call flush(6)

    return
  END SUBROUTINE BEN_BSqrtAd


  SUBROUTINE addEnsMember(ensAmplitude_in,incrementLocal_out,memberIndex)
    implicit none

    integer,intent(in)     :: memberIndex
    real*8      :: ensAmplitude_in(ni_l,nLevEns,nj_l)
    real*8      :: incrementLocal_out(ni_l,nkgdimEns,mpi_myLatBeg:maxLatEnd,ntime_l)

    integer     :: jk,jlev,jt,jj,ji

    call tmg_start(40,'addmem')

!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JT,JK,JLEV,JI)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jt=1,ntime_l
        do jk=1,nkgdimEns
          jlev=verticalLevelEns(jk)
          do ji=1,ni_l
            incrementLocal_out(ji,jk,jj,jt)=incrementLocal_out(ji,jk,jj,jt) +   &
              ensAmplitude_in(ji,jlev,jj)*dble(ensPerturbations(ji,jk,jj,jt,memberIndex))
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    call tmg_stop(40)

  END SUBROUTINE addEnsMember


  SUBROUTINE addEnsMemberAd(incrementLocal_in,ensAmplitude_out,memberIndex)
    implicit none

    integer,intent(in)     :: memberIndex
    real*8      :: ensAmplitude_out(ni_l,nLevEns,nj_l)
    real*8      :: incrementLocal_in(ni_l,nkgdimEns,mpi_myLatBeg:maxLatEnd,ntime_l)

    integer     :: jk,jlev,jt,jj,ji

!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JLEV,JI)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jlev=1,nLevEns
        do ji=1,ni_l
          ensAmplitude_out(ji,jlev,jj)=0.0d0
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

!$OMP PARALLEL
!$OMP DO PRIVATE (JK,JLEV,JT,JJ,JI)
    do jj=mpi_myLatBeg,mpi_myLatEnd
      do jt=1,ntime_l
        do jk=1,nkgdimEns
          jlev=verticalLevelEns(jk)
          do ji=1,ni_l
            ensAmplitude_out(ji,jlev,jj)=ensAmplitude_out(ji,jlev,jj) +   &
              incrementLocal_in(ji,jk,jj,jt)*dble(ensPerturbations(ji,jk,jj,jt,memberIndex))
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE addEnsMemberAd


  SUBROUTINE localizationSqrt(ensControlVector_in,ensAmplitude_out)
    use globalSpectralTransform
    implicit none

    real*8           :: ensControlVector_in(nla_l,2,nLevEns)
    real*8           :: ensAmplitude_out(ni_l,nLevEns,nj_l)

    real*8           :: zsp(nla_l,2,nLevEns)
    real*8           :: zsp2(nLevEns,2,nla_l)
    real*8           :: zsp3(nLevEns,2,nla_l)
    integer          :: jlev,jn,jm,ila,jla,jj,ji
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)

    call tmg_start(41,'loc1')
!$OMP PARALLEL 
!$OMP DO PRIVATE (JLEV,JN,JM,JLA)
    do jlev=1,nLevEns
       do jla=1,nla_l
          zsp(jla,1,jlev)=ensControlVector_in(jla,1,jlev)*ensLocalCor(jn_vec(jla),jlev)
          zsp(jla,2,jlev)=ensControlVector_in(jla,2,jlev)*ensLocalCor(jn_vec(jla),jlev)
       enddo
       do jla = 1,ntrunc_l+1
          zsp(jla,1,jlev) = zsp(jla,1,jlev)*rsq2
          zsp(jla,2,jlev) = 0.0
       enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL
    call tmg_stop(41)

    ! Vertical localization
    call tmg_start(42,'loc2')
!$OMP PARALLEL 
!$OMP DO PRIVATE (JLA,JLEV)
    do jla=1,nla_l
      do jlev=1,nLevEns
        zsp2(jlev,1,jla)=zsp(jla,1,jlev)
        zsp2(jlev,2,jla)=zsp(jla,2,jlev)
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    call dgemul(ensLocalVert(1,1),nLevEns,'N',zsp2(1,1,1),nLevEns,'N',zsp3(1,1,1),nLevEns,nLevEns,nLevEns,2*nla_l)

!$OMP PARALLEL 
!$OMP DO PRIVATE (JLA,JLEV)
    do jla=1,nla_l
      do jlev=1,nLevEns
        zsp(jla,1,jlev)=zsp3(jlev,1,jla)
        zsp(jla,2,jlev)=zsp3(jlev,2,jla)
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL
    call tmg_stop(42)

    ! now transform to grid-point space
    call tmg_start(43,'loc3')
    call gst_setID(gstID)
    call gst_speree(zsp,ensAmplitude_out,nLevEns,nLevEns)
    call gst_setToDefaultID
    call tmg_stop(43)

  END SUBROUTINE localizationSqrt


  SUBROUTINE localizationSqrtAd(ensAmplitude_in,ensControlVector_out)
    use globalSpectralTransform
    implicit none

    real*8           :: ensControlVector_out(nla_l,2,nLevEns)
    real*8           :: ensAmplitude_in(ni_l,nLevEns,nj_l)

    real*8           :: zsp(nla_l,2,nLevEns)
    real*8           :: zsp2(nLevEns,2,nla_l)
    real*8           :: zsp3(nLevEns,2,nla_l)
    integer          :: jn,jm,jla,jlev,ji,jj
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)

    call gst_setID(gstID)
    call gst_reespe(zsp,ensAmplitude_in,nLevEns,nLevEns)
    call gst_setToDefaultID

    ! Vertical localization
!$OMP PARALLEL 
!$OMP DO PRIVATE (JLA,JLEV)
    do jla=1,nla_l
      do jlev=1,nLevEns
        zsp2(jlev,1,jla)=zsp(jla,1,jlev)
        zsp2(jlev,2,jla)=zsp(jla,2,jlev)
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    call dgemul(ensLocalVert(1,1),nLevEns,'N',zsp2(1,1,1),nLevEns,'N',zsp3(1,1,1),nLevEns,nLevEns,nLevEns,2*nla_l)

!$OMP PARALLEL 
!$OMP DO PRIVATE (JLA,JLEV)
    do jla=1,nla_l
      do jlev=1,nLevEns
        zsp(jla,1,jlev)=zsp3(jlev,1,jla)
        zsp(jla,2,jlev)=zsp3(jlev,2,jla)
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

!$OMP PARALLEL 
!$OMP DO PRIVATE (JLEV,JN,JM,JLA)
    do jlev=1,nLevEns
       do jla=1,nla_l
          ensControlVector_out(jla,1,jlev)=zsp(jla,1,jlev)*ensLocalCor(jn_vec(jla),jlev)
          ensControlVector_out(jla,2,jlev)=zsp(jla,2,jlev)*ensLocalCor(jn_vec(jla),jlev)
       enddo
       do jla = 1,ntrunc_l+1
          ensControlVector_out(jla,1,jlev) = ensControlVector_out(jla,1,jlev)*rsq2
          ensControlVector_out(jla,2,jlev) = 0.0
       enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE localizationSqrtAd


  SUBROUTINE cain(controlVector_in,ensControlVector_out,memberIndex)
    implicit none

    integer,intent(in)   :: memberIndex
    real*8    :: controlVector_in(cvDim_l)
    real*8    :: ensControlVector_out(nla_l,2,nLevEns)

    integer   :: jdim,jlev,jla,jvar,jens

    call tmg_start(45,'cain')

    jdim = (memberIndex-1)*cvDimPerMember_l
    do jlev = 1, nLevEns
      do jla = 1, ntrunc_l+1
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        ensControlVector_out(jla,2,jlev) = 0.0
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        jdim = jdim + 1
        ensControlVector_out(jla,2,jlev) = controlVector_in(jdim)
      enddo
    enddo

    if(jdim.gt.cvDim_l) then
      write(*,*) 'BEN: CAIN: jdim > cvDim! ',jdim,memberIndex,cvDimPerMember_l,cvDim_l
      call flush(6)
      call qqexit(1)
    endif

    call tmg_stop(45)

    return
  END SUBROUTINE cain


  SUBROUTINE cainAd(ensControlVector_in,controlVector_out,memberIndex)
    implicit none

    integer,intent(in)    :: memberIndex
    real*8     :: controlVector_out(cvDim_l)
    real*8     :: ensControlVector_in(nla_l,2,nLevEns)

    integer kdim,jdim,jlev,jla,jvar,ji,jj

    jdim = (memberIndex-1)*cvDimPerMember_l
    do jlev = 1, nLevEns
      do jla = 1, ntrunc_l+1
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)*2.0d0
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,2,jlev)*2.0d0
      enddo
    enddo

    if(jdim.gt.cvDim_l) then
      write(*,*) 'BEN: CAINAD: jdim > cvDim! ',jdim,memberIndex,cvDimPerMember_l,cvDim_l
      call flush(6)
      call qqexit(1)
    endif

    return
  END SUBROUTINE cainAd


END MODULE BMatrixEnsemble

