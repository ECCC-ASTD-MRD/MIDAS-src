!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
! MODULE BmatrixEnsemble (Background-error Covariance Matrix estimated
!                         using ensemble members and spatial localization
!                         prefix="ben")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    ben_setup (public)
!    ben_BSqrt (public)
!    ben_BSqrtAd (public)
!    setupLocalization
!    setupEnsemble
!    localizationSqrt
!    localizationSqrtAd
!    addEnsMember
!    addEnsMemberAd
!
! Dependencies:
!    globalSpectralTransform
!    matsqrt
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble
  use mpivar_mod
  use gridStateVector_mod
  use globalSpectralTransform
  use lamSpectralTransform_mod
  use horizontalCoord_mod
  use verticalCoord_mod
  use timeCoord_mod
  use localizationFunction_mod
  use mathPhysConstants_mod
  use earthConstants_mod
  implicit none
  save
  private

  ! public procedures
  public :: ben_Setup,ben_BSqrt,ben_BSqrtAd,ben_reduceToMPILocal,ben_expandToMPIGlobal,ben_Finalize
  public :: ben_getScaleFactor, ben_getnEns, ben_getPerturbation

  logical             :: initialized = .false.

  integer,parameter   :: maxNumLevels=200
  real(8)             :: scaleFactor(maxNumLevels)
  real(8)             :: scaleFactorLQ(maxNumLevels)
  real(8),allocatable :: scaleFactor_M(:), scaleFactor_T(:)

  integer             :: ntrunc
  integer,allocatable :: nip1_M(:),nip1_T(:)
  integer             :: nj,ni,lonPerPE,myLonBeg,myLonEnd,latPerPE,myLatBeg,myLatEnd
  integer             :: nLevInc_M,nLevInc_T,nkgdimInc,nLevEns_M,nLevEns_T,nkgdimEns,topLevIndex_M,topLevIndex_T
  integer             :: mynBeg,mynEnd,mynSkip,mynCount
  integer             :: mymBeg,mymEnd,mymSkip,mymCount
  integer             :: nla_mpiglobal,nla_mpilocal,maxMyNla,nphase
  integer             :: nEns,cvDim_mpilocal,cvDim_mpiglobal
  integer             :: numTime
  integer             :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg
  integer             :: gstID
  integer             :: ensembleFileExtLength
  integer,allocatable :: dateStampList(:)
  character(len=256)  :: enspathname,ensfilebasename
  character(len=8)   :: datestr_last
  character(len=2)   :: hourstr_last
  integer,external    :: get_max_rss

  ! Localizations
  character(len=256)  :: LocalizationType
  integer, parameter  :: maxNumLocalLength = 20
  integer             :: waveBandPeaks(maxNumLocalLength)
  integer             :: nWaveBand
  
  type :: struct_ensLoc
     real(8),allocatable :: Horiz(:,:)
     real(8),allocatable :: Vert(:,:)
  end type struct_ensLoc
  type(struct_ensLoc), pointer :: ensLocal(:)

  ! Ensemble perturbations
  type :: struct_ensPert
    type(struct_gsv) :: statevector_r4
  end type struct_ensPert
  type(struct_ensPert), pointer :: ensPerts(:,:)

  type(struct_gsv)   :: statevector_ensMean

  real(8), parameter :: rsq2 = sqrt(2.0d0)

  ! Vertical grid
  type(struct_vco),pointer :: vco_anl, vco_ens
  integer                  :: Vcode_anl

  ! Horizontal grid
  type(struct_hco), pointer :: hco_ben    ! Analysis horizontal grid parameters

  ! LAM spectral transform
  type(struct_lst)          :: lst_ben    ! Spectral transform Parameters

  ! Global spectral transform
  integer, pointer    :: ilaList_mpiglobal(:)
  integer, pointer    :: ilaList_mpilocal(:)

CONTAINS

!--------------------------------------------------------------------------
! BEN_setup
!--------------------------------------------------------------------------
  SUBROUTINE BEN_setup(hco_in,vco_in,NUMTIME_IN,stamp_in,CVDIM_OUT,&
                       mode)
    implicit none
  
    type(struct_hco), pointer, intent(in) :: hco_in
    type(struct_vco), pointer, intent(in) :: vco_in

    character(len=*), intent(in), optional :: mode

    character(len=15) :: ben_mode

    real(8)             :: hLocalize(maxNumLocalLength)
    real(8)             :: vLocalize(maxNumLocalLength)

    real(8) :: zps, delhh

    real(8),allocatable :: pressureProfileEns_M(:)
    real(8),pointer :: pressureProfileInc_M(:)

    integer        :: numTime_in,stamp_in
    integer        :: cvDim_out
    integer        :: jlev,jn,jm,jvar,ila,return_code,status
    integer        :: fnom,fclos,ierr,nulnam
    integer        :: waveBandIndex
    integer        :: stamp_last,newdate,ndate,ntime
    character(len=256) :: cflensin
    character(len=4)   :: censnumber

    logical        :: TweakTG,diagnostic,lExists

    !namelist
    NAMELIST /NAMBEN/nEns,scaleFactor,scaleFactorLQ,ntrunc,enspathname,ensfilebasename, &
                     hLocalize,vLocalize,tweakTG,LocalizationType, &
                     waveBandPeaks,diagnostic

    call tmg_start(12,'BEN_SETUP')

    !
    !- 1.  Read namelist-dependent options
    !

    ! parameters from namelist
    scaleFactor(:)   = 0.0d0
    scaleFactorLQ(:) = 1.0d0
    nEns             = 10
    ntrunc           = 30
    enspathname      = '***NOT_DEFINED***'
    ensfilebasename  = ''
    LocalizationType = 'LevelDependent'
    waveBandPeaks(:) =   -1.0d0
    diagnostic       = .false.
    hLocalize(:)     =   -1.0d0
    hLocalize(1)     = 2800.0d0
    vLocalize(:)     =   -1.0d0
    vLocalize(1)     =    2.0d0
    tweakTG          = .false.

    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namben,iostat=ierr)
    if(ierr.ne.0) call abort3d('ben_setup: Error reading namelist')
    if(mpi_myid.eq.0) write(*,nml=namben)
    ierr = fclos(nulnam)

    !
    !- 2.  Settings
    !
    
    hco_ben => hco_in
    ni = hco_ben%ni
    nj = hco_ben%nj

    !- 2.1 Mode
    if ( present(mode) ) then
       if ( trim(mode) == 'Analysis' .or. trim(mode) == 'BackgroundCheck') then
         ben_mode = trim(mode)
         if(mpi_myid.eq.0) write(*,*)
         if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: Mode activated = ', trim(ben_mode)
       else
          write(*,*)
          write(*,*) 'mode = ', trim(mode)
          call abort3d('bmatrixEnsemble: unknown mode')
       end if
    else
       ben_mode = 'Analysis'
       if(mpi_myid.eq.0) write(*,*)
       if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: Analysis mode activated (by default)'
    end if

    !- 2.2 Global or LAM?
    if (hco_ben%global) then
      if(mpi_myid.eq.0) write(*,*)
      if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: GLOBAL mode activated'
    else
      if(mpi_myid.eq.0) write(*,*)
      if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: LAM mode activated'
    endif

    !- 2.3 Number of time bins
    if(numTime_in.eq.1.or.numTime_in.eq.3.or.numTime_in.eq.5.or.numTime_in.eq.7) then
      numTime = numTime_in
    else
      call abort3d('Invalid value for NUMTIME (choose 1 or 3 or 5 or 7)!')
    endif

    !- 2.4 Initialize dates for ensemble files
    delhh = -6.0d0
    call incdatr(stamp_last,stamp_in,delhh)
    ierr = newdate(stamp_last,ndate,ntime,-3)
    write(datestr_last,'(i8.8)') ndate
    write(hourstr_last,'(i2.2)') ntime/1000000
    if(mpi_myid.eq.0) write(*,*) 'DATE,TIME=',ndate,'  ,',ntime
    allocate(dateStampList(numTime))
    call tim_getstamplist(dateStampList,numTime,stamp_in)

    !- 2.5 Determine file name extension length for ensemble files (3 or 4)
    write(censnumber,'(i4.4)') 1
    cflensin = trim(enspathname) // '/' // trim(ensfilebasename) // &
               trim(datestr_last) // trim(hourstr_last) // '_006_' // trim(censnumber)
    inquire(file=cflensin,exist=lExists)
    if(lExists) then
      ensembleFileExtLength = 4
    else
      write(censnumber,'(i3.3)') 1
      cflensin = trim(enspathname) // '/' // trim(ensfilebasename) // &
                 trim(datestr_last) // trim(hourstr_last) // '_006_' // trim(censnumber)
      inquire(file=cflensin,exist=lExists)
      if(lExists) then
        ensembleFileExtLength = 4
      else 
        call abort3d('ben_setup: could not determine file extension length')
      endif
    endif

    !- 2.6 Vertical levels

    vco_anl => vco_in
    status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)
    call vco_SetupFromFile(vco_ens,cflensin,' ')
    nLevEns_M = vco_ens%nLev_M
    nLevEns_T = vco_ens%nLev_T
    nLevInc_M = vco_anl%nLev_M
    nLevInc_T = vco_anl%nLev_T
    nkgdimInc = 2*nLevInc_M+2*nLevInc_T+2  ! assume 4 3d and 2 2d variables
    nkgdimEns = 2*nLevEns_M+2*nLevEns_T+2  ! assume 4 3d and 2 2d variables
    topLevIndex_M = nLevInc_M-nLevEns_M+1
    topLevIndex_T = nLevInc_T-nLevEns_T+1
    allocate(nip1_M(nLevEns_M),stat=ierr)
    nip1_M(1:nLevEns_M) = vco_anl%ip1_M(topLevIndex_M:nLevInc_M)
    allocate(nip1_T(nLevEns_T),stat=ierr)
    nip1_T(1:nLevEns_T) = vco_anl%ip1_T(topLevIndex_T:nLevInc_T)

    if(Vcode_anl .eq. 5002) then
      if(nLevEns_T.ne.(nLevEns_M+1)) then
        write(*,*) 'bmatrixEnsemble: nLevEns_T, nLevEns_M = ',nLevEns_T,nLevEns_M
        call abort3d('bmatrixEnsemble: Vcode=5002, nLevEns_T must equal nLevEns_M+1!')
      endif
    elseif(Vcode_anl .eq. 5004) then
      if(nLevEns_T.ne.nLevEns_M) then
        write(*,*) 'bmatrixEnsemble: nLevEns_T, nLevEns_M = ',nLevEns_T,nLevEns_M
        call abort3d('bmatrixEnsemble: Vcode=5004, nLevEns_T must equal nLevEns_M!')
      endif
    else
      write(*,*) 'Vcode_anl = ',Vcode_anl
      call abort3d('bmatrixEnsemble: unknown vertical coordinate type!')
    endif

    if(nLevEns_M.gt.nLevInc_M) then
      call abort3d('bmatrixEnsemble: ensemble has more levels than increment - not allowed!')
    endif

    if(nLevEns_M.lt.nLevInc_M) then
      if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: ensemble has less levels than increment'
      if(mpi_myid.eq.0) write(*,*) '                 some levels near top will have zero increment'
    endif

    !- 2.7 Bmatrix Weight
    if ( sum(scaleFactor(1:nLevEns_T)) == 0.0d0 ) then
      if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: scaleFactor=0, skipping rest of setup'
      cvdim_out = 0
      initialized = .true.
      return
    endif

    allocate(scaleFactor_M(nLevEns_M))
    allocate(scaleFactor_T(nLevEns_T))
    do jlev = 1, nLevEns_T
      if(scaleFactor(jlev).gt.0.0d0) then 
        scaleFactor(jlev) = sqrt(scaleFactor(jlev))
      else
        scaleFactor(jlev) = 0.0d0
      endif
    enddo
    scaleFactor_T(1:nLevEns_T) = scaleFactor(1:nLevEns_T)
    if(Vcode_anl .eq. 5002) then
      scaleFactor_M(1:nLevEns_M) = scaleFactor(2:(nLevEns_M+1))
    else
      scaleFactor_M(1:nLevEns_M) = scaleFactor(1:nLevEns_M)
    endif

    do jlev = 1, nLevEns_T
      if(scaleFactorLQ(jlev).gt.0.0d0) then 
        scaleFactorLQ(jlev) = sqrt(scaleFactorLQ(jlev))
      else
        scaleFactorLQ(jlev) = 0.0d0
      endif
    enddo

    !- 2.8 Spectral Transform
    if ( trim(ben_mode) == 'Analysis' ) then

      if (hco_ben%global) then

        ! Global Mode
        nphase = 2
        nla_mpiglobal = (ntrunc+1)*(ntrunc+2)/2

        gstID = gst_setup(ni,nj,ntrunc,nLevEns_M)
        if(mpi_myid.eq.0) write(*,*) 'BEN : returned value of gstID = ',gstID

      else

        ! LAM mode
        call lst_Setup( lst_ben,                          & ! OUT
                        ni, nj, hco_ben%dlon, ntrunc,   & ! IN
                        'LatLonMN', nLevEns_M )             ! IN

        if(mpi_myid.eq.0) write(*,*) 'BEN : returned value of lstID = ', lst_ben%id
        nphase       = lst_ben%nphase
        nla_mpilocal = lst_ben%nla

      end if

    end if ! ben_mode

    !- 2.9 Distribute control vector over mpi processes according to member index and m
    if ( trim(ben_mode) == 'Analysis' ) then
      call mpivar_setup_m(ntrunc,mymBeg,mymEnd,mymSkip,mymCount)
      call mpivar_setup_n(ntrunc,mynBeg,mynEnd,mynSkip,mynCount)

      if (hco_ben%global) then
        ! compute arrays to facilitate conversions between ila_mpilocal and ila_mpiglobal
        call gst_ilaList_mpiglobal(ilaList_mpiglobal,nla_mpilocal,maxMyNla,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
        call gst_ilaList_mpilocal(ilaList_mpilocal,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
        write(*,*) 'ben_setup: nla_mpiglobal, nla_mpilocal, maxMyNla = ', nla_mpiglobal, nla_mpilocal, maxMyNla
      end if
    end if

    !- 2.10 Domain Partionning
    call mpivar_setup_latbands(nj,latPerPE,myLatBeg,myLatEnd)
    call mpivar_setup_lonbands(ni,lonPerPE,myLonBeg,myLonEnd)

    !- 2.11 Localization
    if ( trim(ben_mode) == 'Analysis' ) then
      call loc_setup('FifthOrder') ! IN
      if (trim(LocalizationType) == 'LevelDependent') then
         if(mpi_myid.eq.0) write(*,*)
         if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: Level-Dependent (Standard) localization will be used'
         nWaveBand = 1
      else if (trim(LocalizationType) == 'ScaleDependent') then
         if(mpi_myid.eq.0) write(*,*)
         if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: Scale-Dependent localization will be used'
         nWaveBand = count(waveBandPeaks .ge. 0)
         if ( nWaveBand <= 1 ) then
            call abort3d('ben_setup: nWaveBand <= 1')
         end if
         ! You must provide nWaveBand wavenumbers in decreasing order
         ! e.g. For a 3 wave bands decomposition...
         !      wavenumber #1 = where the response function for wave band 1 (hgh res) reaches 1 
         !                      and stays at 1 for higher wavenumbers
         !      wavenumber #2 = where the response function for wave band 2 reaches 1
         !      wavenumber #3 = where the response function for wave band 3 (low res) reaches 1 
         !                      and stays at 1 for lower wavenumbers
         ! See FilterResponseFunction for further info...

         ! Make sure that the wavenumbers are in the correct (decreasing) order
         do waveBandIndex = 1, nWaveBand-1
            if ( waveBandPeaks(waveBandIndex)-waveBandPeaks(waveBandIndex+1) <= 0 ) then
               call abort3d('ben_setup: waveBandPeaks are not in decreasing wavenumber order') 
            end if
         end do

         ! Make sure that we have valid localization length scales for each wave bands
         do  waveBandIndex = 1, nWaveBand
            if ( hLocalize(waveBandIndex) <= 0.0d0 ) then
               call abort3d('ben_setup: Invalid HORIZONTAL localization length scale')
            end if
            if ( vLocalize(waveBandIndex) <= 0.0d0 ) then
               call abort3d('ben_setup: Invalid VERTICAL localization length scale')
            end if
         end do

         ! Make sure the truncation is compatible with the waveBandPeaks
         if ( ntrunc < waveBandPeaks(1) ) then
            call abort3d('ben_setup: The truncation is not compatible with the your scale-dependent localization')
         end if

      else
         call abort3d('ben_setup: Invalid mode for LocalizationType')
      endif

      zps = 101000.D0
      status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_M, levels=pressureProfileInc_M, &
                           sfc_field=zps, in_log=.false.)
      if(status /= VGD_OK)then
        call abort3d('ben_setup: ERROR from vgd_levels')
      end if

      allocate(pressureProfileEns_M(nLevEns_M),stat=ierr)
      pressureProfileEns_M(1:nLevEns_M) = pressureProfileInc_M(topLevIndex_M:nLevInc_M)

      call setupLocalization(hLocalize, vLocalize, pressureProfileEns_M) ! IN

      deallocate(pressureProfileEns_M)
      deallocate(pressureProfileInc_M)
    end if

    !
    !- 3.  Read/Process the Ensemble
    !
    
    ! Read the ensemble data
    call setupEnsemble()

    ! Special treatment for TG (skin temperature) ensemble perturbations
    if (tweakTG) call AdjustTGOverOpenWater() 

    ! Compute and write Std. Dev.
    if (diagnostic) call EnsembleDiagnostic('FullPerturbations')

    if ( trim(ben_mode) == 'Analysis' ) then

      ! Partitioned the ensemble perturbations into wave bands
      if (trim(LocalizationType) == 'ScaleDependent') then
        call EnsembleScaleDecomposition()
        if (diagnostic) call EnsembleDiagnostic('WaveBandPerturbations')
      endif

      if (hco_ben%global) then
        cvDim_mpiglobal = (ntrunc+1)*(ntrunc+1)*nLevEns_M*nEns
        cvDim_mpilocal  = 0

        do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if(jm.le.jn) then
              if(jm.eq.0) then
                ! controlVector only contains real part for jm=0
                cvDim_mpilocal = cvDim_mpilocal + 1*nLevEns_M*nEns
              else
                ! controlVector contains real and imag parts for jm>0
                cvDim_mpilocal = cvDim_mpilocal + 2*nLevEns_M*nEns
              endif
            endif
          enddo
        enddo
      else
        cvDim_mpiglobal = lst_ben%nlaGlobal * nphase * nLevEns_M * nEns
        cvDim_mpilocal  = nla_mpilocal        * nphase * nLevens_M * nEns
        print*,'cvDim_mpiglobal ', cvDim_mpiglobal, lst_ben%nlaGlobal, nphase, nLevEns_M, nEns
        print*,'cvDim_mpilocal  ', cvDim_mpilocal, nla_mpilocal, nphase, nLevEns_M, nEns
      endif
      cvDim_out = cvDim_mpilocal
    else
      cvDim_out = 9999 ! Dummy value > 0 to indicate to the background check (s/r compute_HBHT_ensemble) 
                       ! that Bens is used
    end if

    !
    !- 4.  Ending
    !
    initialized = .true.

    call tmg_stop(12)

  END SUBROUTINE BEN_setup

!--------------------------------------------------------------------------
! BEN_finalize
!--------------------------------------------------------------------------
  SUBROUTINE BEN_finalize()
    implicit none
    integer :: memberIndex, waveBandIndex

    write(*,*) 'ben_finalize: deallocating B_ensemble arrays'
    do waveBandIndex = 1, nWaveBand
       do memberIndex = 1, nEns
          call gsv_deallocate(ensPerts(waveBandIndex,memberIndex)%statevector_r4)
       end do
    end do
    deallocate(ensPerts)
    
    do waveBandIndex = 1, nWaveBand
       deallocate(ensLocal(waveBandIndex)%Horiz)
       deallocate(ensLocal(waveBandIndex)%Vert)
    end do
    deallocate(ensLocal)
    call gsv_deallocate(statevector_ensMean)

  END SUBROUTINE BEN_finalize

!--------------------------------------------------------------------------
! ben_getScaleFactor
!--------------------------------------------------------------------------
  subroutine ben_getScaleFactor(scaleFactor_out)
    implicit none
    real(8) :: scaleFactor_out(:)
    integer :: jlev

    do jlev = 1, nLevInc_T
      scaleFactor_out(jlev) = scaleFactor(jlev)
    enddo

  end subroutine ben_getScaleFactor

!--------------------------------------------------------------------------
! ben_getnEns
!--------------------------------------------------------------------------
  integer function ben_getnEns()
    !func getnEns - returns the number ensemble member
    implicit none
    ben_getnEns = nEns
  end function ben_getnEns

!--------------------------------------------------------------------------
! setupEnsemble
!--------------------------------------------------------------------------
  SUBROUTINE setupEnsemble()
    implicit none
 
    real(4), allocatable :: gd3d_r4(:,:,:)
    type(struct_gsv) :: statevector_ensPert1_r4
    real(4), allocatable :: gd_send_r4(:,:,:,:)
    real(4), allocatable :: gd_recv_r4(:,:,:,:)
    real(4), pointer     :: ptr3d_r4(:,:,:), ptr4d_r4(:,:,:,:)
    real(8), pointer     :: ptr4d_r8(:,:,:,:)
    real(8) :: dnens,multfactor,multfactor2
    integer :: ji,jj,jt,jk,jvar,memberIndex,waveBandIndex,jpe,jlonband,jlatband
    integer :: memberIndex2,batchnum,nsize,status,pe_src,pe_dest
    integer :: yourid,youridx,youridy
    integer :: kulin
    integer :: readFilePE(1000)
    integer :: memberIndexOffset, totalEnsembleSize
    logical :: lExists
    character(len=32) :: envVariable
    integer :: length_envVariable

    ! standard file variables
    integer :: ini,inj,ink,ip1,ip2(9),ip3,ierr,ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket
    character(len=256) :: cflensin
    character(len=4)   :: censnumber
    integer :: fstlir,fstfrm,fclos,fnom,fstouv,fstinf

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    ! this should come from state vector object
    ngposituu = 1
    ngpositvv = 1+1*nLevEns_M
    ngposittt = 1+2*nLevEns_M
    ngpositq  = 1+2*nLevEns_M+1*nLevEns_T
    ngpositps = 1+2*nLevEns_M+2*nLevEns_T
    ngposittg = 2+2*nLevEns_M+2*nLevEns_T

    allocate(gd_send_r4(lonPerPE,latPerPE,nkgdimEns,mpi_nprocs))
    allocate(gd_recv_r4(lonPerPE,latPerPE,nkgdimEns,mpi_nprocs))

    allocate(ensPerts(nWaveBand,nEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7.1',ierr
      call abort3d('aborting in ben setupEnsemble')
    endif
    do waveBandIndex = 1, nWaveBand
      do memberIndex = 1, nEns
        call gsv_setVco(ensPerts(waveBandIndex,memberIndex)%statevector_r4,vco_ens)
        call gsv_setHco(ensPerts(waveBandIndex,memberIndex)%statevector_r4,hco_ben)
        call gsv_allocate(ensPerts(waveBandIndex,memberIndex)%statevector_r4,numTime,  &
                          datestamp=tim_getDatestamp(),mpi_local=.true.,dataKind_in=4)
      enddo
    enddo

    call gsv_setVco(statevector_ensPert1_r4,vco_ens)
    call gsv_setHco(statevector_ensPert1_r4,hco_ben)
    call gsv_allocate(statevector_ensPert1_r4,1,  &
                      datestamp=tim_getDatestamp(),mpi_local=.false.,dataKind_in=4)

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)

    do memberIndex = 1, nEns
      readFilePE(memberIndex) = mod(memberIndex-1,mpi_nprocs)
    enddo

    ip2 = -1
    ip3 = -1
    cltypvar = ' '
    cletiket = ' '

    ! Retrieve environment variables related to doing an ensemble of perturbed analyses
    status = 0
    call get_environment_variable('envar_memberIndexOffset',envVariable,length_envVariable,status,.true.)
    if (status.gt.1) then
      write(*,*) 'ben_setupEnsemble: Problem when getting the environment variable envar_memberIndexOffset'
      memberIndexOffset = 0
    elseif (status.eq.1) then
      memberIndexOffset = 0
    else
      write(*,*) 'ben_setupEnsemble: The environment variable envar_memberIndexOffset has been detected: ',envVariable
      read(envVariable,'(i8)') memberIndexOffset
      write(*,*) 'memberIndexOffset = ',memberIndexOffset
    endif

    status = 0
    call get_environment_variable('envar_totalEnsembleSize',envVariable,length_envVariable,status,.true.)
    if (status.gt.1) then
      write(*,*) 'ben_setupEnsemble: Problem when getting the environment variable envar_totalEnsembleSize'
      totalEnsembleSize = nEns
    elseif (status.eq.1) then
      totalEnsembleSize = nEns
    else
      write(*,*) 'ben_setupEnsemble: The environment variable envar_totalEnsembleSize has been detected: ',envVariable
      read(envVariable,'(i8)') totalEnsembleSize
      write(*,*) 'totalEnsembleSize = ',totalEnsembleSize
    endif

    if(mpi_myid.eq.0) write(*,*) 'dateStampList=',dateStampList(1:numTime)

    do jt = 1, numTime  ! read all timesteps
      do memberIndex = 1, nEns

        if(mpi_myid.eq.readFilePE(memberIndex)) then

          ! open the file
          if(ensembleFileExtLength == 4) then
            write(censnumber,'(i4.4)') 1+mod(memberIndex+memberIndexOffset-1, totalEnsembleSize)
          elseif(ensembleFileExtLength == 3) then
            write(censnumber,'(i3.3)') 1+mod(memberIndex+memberIndexOffset-1, totalEnsembleSize)
          else
            write(*,*) 'ben setupEnsemble: ensembleFileExtLength = ', ensembleFileExtLength
            call abort3d('ben setupEnsemble: unknown value')
          endif
          cflensin = trim(enspathname) // '/' // trim(ensfilebasename) // &
                     trim(datestr_last) // trim(hourstr_last) // '_006_' // trim(censnumber)
          inquire(file=cflensin,exist=lExists)
          if(lExists) then
            kulin = 0
            ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
          else
            write(*,*) 'filename=',trim(cflensin)
            call abort3d('ben setupEnsemble: Could not open ensemble file')
          endif
          ierr = fstouv(kulin,'RND+OLD')

          ! get grid parameters by looking at P0
          if(.not.allocated(gd3d_r4)) then
            ikey = fstinf(kulin,ini,inj,ink,dateStampList(1),cletiket,-1,ip2,ip3,cltypvar,'P0')
            write(*,*) 'ben_setupensemble: allocating temporary 2D buffer with ini,inj=',ini,inj
            allocate(gd3d_r4(ini,inj,max(nLevEns_T,nLevEns_M)))
          endif

          write(*,*) 'Reading time slice ',jt,' for ensemble member:',trim(cflensin)
          write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

          ! read 1 member per mpi task, only 1 timestep

          do jvar = 1, vnl_numvarmax
            if( .not. gsv_varExist(statevector_ensPert1_r4, vnl_varNameList(jvar)) ) cycle 

            ptr3d_r4 => gsv_getField3D_r4(statevector_ensPert1_r4, vnl_varNameList(jvar))

            if(trim(vnl_varNameList(jvar)) == 'P0') then
              multfactor = MPC_PA_PER_MBAR_R8
            elseif(trim(vnl_varNameList(jvar)) == 'UU' .or. trim(vnl_varNameList(jvar)) == 'VV') then 
              multfactor = MPC_M_PER_S_PER_KNOT_R8
            else
              multfactor = 1.0D0
            endif

            do jk = 1, gsv_getNumLev(statevector_ensPert1_r4, vnl_varLevelFromVarname(vnl_varNameList(jvar)))
              if( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'MM' ) then
                ip1 = nip1_M(jk)
              elseif( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'TH' ) then
                ip1 = nip1_T(jk)
              else
                ip1 = -1
              endif                
              ikey = fstlir(gd3d_r4(:,:,jk),kulin,ini,inj,ink,dateStampList(jt),cletiket,ip1,ip2,ip3,cltypvar,vnl_varNameList(jvar))
              if(ikey.lt.0) then
                write(*,*) dateStampList(jt),cletiket,nip1_T(jk),ip2,ip3,cltypvar,vnl_varNameList(jvar)
                call abort3d('ben setupEnsemble: Problem reading member')
              endif
            enddo ! jk

            if(trim(vnl_varNameList(jvar)) == 'HU') then
!$OMP PARALLEL DO PRIVATE(jk,jj,ji)
              do jk = 1, gsv_getNumLev(statevector_ensPert1_r4, vnl_varLevelFromVarname(vnl_varNameList(jvar)))
                do jj = 1, nj
                  do ji = 1, ni
                    ptr3d_r4(ji,jj,jk) = sngl(log(max(real(gd3d_r4(ji,jj,jk),8),MPC_MINIMUM_HU_R8)))
                  enddo
                enddo
              enddo
!$OMP END PARALLEL DO
            else
!$OMP PARALLEL DO PRIVATE(jk,jj,ji)
              do jk = 1, gsv_getNumLev(statevector_ensPert1_r4, vnl_varLevelFromVarname(vnl_varNameList(jvar)))
                do jj = 1, nj
                  do ji = 1, ni
                    ptr3d_r4(ji,jj,jk) = sngl(gd3d_r4(ji,jj,jk)*multfactor)
                  enddo
                enddo
              enddo ! jk
!$OMP END PARALLEL DO
            endif ! if(HU)

          enddo ! jvar

          ierr =  fstfrm(kulin)
          ierr =  fclos (kulin)

        endif

        ! do mpi communication
        if(readFilePE(memberIndex).eq.(mpi_nprocs-1) .or. memberIndex.eq.nEns) then
          call tmg_start(13,'PRE_SUENS_COMM')
          batchnum = ceiling(dble(memberIndex)/dble(mpi_nprocs))

          ptr3d_r4 => gsv_getField3D_r4(statevector_ensPert1_r4)
!$OMP PARALLEL DO PRIVATE(youridy,youridx,yourid)
          do youridy = 0, (mpi_npey-1)
            do youridx = 0, (mpi_npex-1)
              yourid = youridx + youridy*mpi_npex
              gd_send_r4(:,:,:,yourid+1) =  &
                ptr3d_r4(ensPerts(1,1)%statevector_r4%allLonBeg(youridx+1):ensPerts(1,1)%statevector_r4%allLonEnd(youridx+1),  &
                         ensPerts(1,1)%statevector_r4%allLatBeg(youridy+1):ensPerts(1,1)%statevector_r4%allLatEnd(youridy+1),:)
            enddo
          enddo
!$OMP END PARALLEL DO

          nsize = lonPerPE*latPerPE*nkgdimEns
          if(mpi_nprocs.gt.1) then
            call rpn_comm_alltoall(gd_send_r4,nsize,"mpi_real4",  &
                                   gd_recv_r4,nsize,"mpi_real4","GRID",ierr)
          else
            gd_recv_r4(:,:,:,1) = gd_send_r4(:,:,:,1)
          endif

!$OMP PARALLEL DO PRIVATE(memberIndex2,yourid,ptr4d_r4)
          do memberIndex2 = 1+(batchnum-1)*mpi_nprocs, memberIndex
            yourid = readFilePE(memberIndex2)
            ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex2)%statevector_r4)
            ptr4d_r4(:,:,:,jt) = gd_recv_r4(:,:,:,yourid+1)
            !ensPerts(1,memberIndex2)%statevector_r4%gd_r4(:,:,:,jt) = gd_recv_r4(:,:,:,yourid+1)
          enddo
!$OMP END PARALLEL DO

          call tmg_stop(13)

        endif ! do communication

      enddo ! memberIndex

    enddo ! jt

    call gsv_deallocate(statevector_ensPert1_r4)
    deallocate(gd3d_r4)
    deallocate(gd_send_r4)
    deallocate(gd_recv_r4)

    write(*,*) 'finished reading and communicating ensemble members...'

    ! remove mean, normalize and apply scale factors
    call gsv_setVco(statevector_ensMean,vco_ens)
    call gsv_setHco(statevector_ensMean,hco_ben)
    call gsv_allocate(statevector_ensMean,numTime,  &
                      datestamp=tim_getDatestamp(),mpi_local=.true.)
    call gsv_zero(statevector_ensMean)

    multfactor = 1.0d0/dble(nEns)
!$OMP PARALLEL DO PRIVATE (jt,jk,jvar,memberIndex,multfactor2,ptr4d_r4,ptr4d_r8)
    do jt = 1, numTime

      ! compute mean
      ptr4d_r8 => gsv_getField_r8(statevector_ensMean)
      do memberIndex = 1, nEns
        ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4)
        ptr4d_r8(:,:,:,jt) = ptr4d_r8(:,:,:,jt) + dble(ptr4d_r4(:,:,:,jt))
      enddo
      ptr4d_r8(:,:,:,jt) = ptr4d_r8(:,:,:,jt)*multFactor
 
      ! remove mean, normalize and apply scale factors
      do jvar = 1, vnl_numvarmax
        if( .not. gsv_varExist(statevector_ensPert1_r4, vnl_varNameList(jvar)) ) cycle 

        ptr4d_r8 => gsv_getField_r8(statevector_ensMean, vnl_varNameList(jvar))
        do memberIndex = 1, nEns
          ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4, vnl_varNameList(jvar))

          do jk = 1, gsv_getNumLev(statevector_ensMean, vnl_varLevelFromVarname(vnl_varNameList(jvar)))
            if( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'MM' ) then
              multFactor2 = scaleFactor_M(jk)
            elseif( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'TH' ) then
              multFactor2 = scaleFactor_T(jk)
            else ! SF
              multFactor2 = scaleFactor_T(nLevEns_T)
            endif

            multFactor2 = multFactor2/sqrt(1.0d0*dble(nEns-1))

            if(trim(vnl_varNameList(jvar)) .eq. 'HU') then
              multFactor2 = multFactor2*scaleFactorLQ(jk)
            endif

            ptr4d_r4(:,:,jk,jt) =  &
              sngl( (dble(ptr4d_r4(:,:,jk,jt))-ptr4d_r8(:,:,jk,jt))*multFactor2 )
          enddo ! jk
        enddo ! memberIndex
      enddo ! jvar

    enddo ! jt
!$OMP END PARALLEL DO

    ! for testing of localization advection set perturbations to 1 everywhere
    !do memberIndex = 1, nEns
    !  ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4)
    !  ptr4d_r4(:,:,:,:) = 1.0/sqrt(real(nEns))
    !enddo

    write(*,*) 'finished adjusting ensemble members...'
 
  END SUBROUTINE setupEnsemble

!--------------------------------------------------------------------------
! ben_getPerturbation
!--------------------------------------------------------------------------
  SUBROUTINE ben_getPerturbation(statevector, memberIndexWanted,  &
                                 upwardExtrapolationMethod, waveBandIndexWanted, &
                                 undoNormalization)
    implicit none

    type(struct_gsv) :: statevector
    integer,          intent(in) :: memberIndexWanted
    character(len=*), intent(in) :: upwardExtrapolationMethod
    integer, optional, intent(in):: waveBandIndexWanted
    logical, optional :: undoNormalization

    real(8), pointer :: ptr4d_r8(:,:,:,:)
    real(4), pointer :: ptr4d_r4(:,:,:,:)

    real(8) :: dnens2, scaleFactor_MT
    logical :: undoNormalization2
    integer :: waveBandIndex
    integer :: ji,jj,jvar,jt,jk,jkInc,topLevOffset

    if ( trim(upwardExtrapolationMethod) /= "ConstantValue" ) then
       call abort3d('ben_getPerturbation : Invalid value for upwardExtrapolationMethod')
    end if

    if ( present(waveBandIndexWanted) ) then
       waveBandIndex = waveBandIndexWanted
    else
       waveBandIndex = 1
    end if

    ! set default value for optional argument undoNormalization
    if ( present(undoNormalization) ) then
      undoNormalization2 = undoNormalization
    else
      undoNormalization2 = .false.
    endif

    do jvar = 1, vnl_numvarmax 
      if (.not. gsv_varExist(statevector, vnl_varNameList(jvar))) cycle

      ptr4d_r8 => gsv_getField_r8(statevector, vnl_varNameList(jvar))
      ptr4d_r4 => gsv_getField_r4(ensPerts(waveBandIndex,memberIndexWanted)%statevector_r4,  &
                                  vnl_varNameList(jvar))

!$OMP PARALLEL DO PRIVATE(jt,jk,topLevOffset,scaleFactor_MT,jkInc,dnens2,jj,ji)
      do jt = 1, numTime

        ! Select the corresponding ensemble perturbations
        do jk = 1, gsv_getNumLev(ensPerts(waveBandIndex,memberIndexWanted)%statevector_r4,  &
                                 vnl_varLevelFromVarname(vnl_varNameList(jvar)))

          if( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'MM' ) then
            topLevOffset = topLevIndex_M - 1
            scaleFactor_MT = scaleFactor_M(jk)
          elseif( vnl_varLevelFromVarname(vnl_varNameList(jvar)) .eq. 'TH' ) then
            topLevOffset = topLevIndex_T - 1
            scaleFactor_MT = scaleFactor_T(jk)
          else ! SF
            topLevOffset = 0
            scaleFactor_MT = scaleFactor_T(nLevEns_T)
          endif

          jkInc = jk + topLevOffset

          ! undo the normalization (optional)
          if(undoNormalization2) then
            if(scaleFactor_MT.gt.0.0d0) then
              dnens2 = sqrt(1.0d0*dble(nEns-1))/scaleFactor_MT
            else
              if(jt.eq.1) then 
                write(*,*) 'scalefactor not positive, cannot undo normalization!'
                write(*,*) vnl_varNameList(jvar),scaleFactor_MT,jk
              endif
              dnens2 = 0.0d0
            endif
            if(vnl_varNameList(jvar).eq.'HU  ') then
              if(scaleFactorLQ(jk).gt.0.0d0) then
                dnens2 = dnens2/scaleFactorLQ(jk)
              else
                if(jt.eq.1) then
                  write(*,*) 'LQ scalefactor not positive, cannot undo normalization!'
                  write(*,*) vnl_varNameList(jvar),scaleFactorLQ(jk),jk
                endif
              endif
            endif
          else
            dnens2 = 1.0d0
          endif

          do jj = myLatBeg, myLatEnd
            do ji = myLonBeg, myLonEnd
              ptr4d_r8(ji,jj,jkInc,jt) = dnens2*dble(ptr4d_r4(ji,jj,jk,jt))
            enddo
          enddo
        enddo ! jk

        if ( topLevOffset > 0 ) then
          ! Fill the gap between the ensemble lid and the analysis lid

          ! undo the normalization (optional)
          if(undoNormalization2) then
            if(scaleFactor(1) > 0.0d0) then
              dnens2 = sqrt(1.0d0*dble(nEns-1))/scaleFactor(1)
            else
              if(jt == 1) then
                write(*,*) 'scalefactor(top) not positive, cannot undo normalization!'
                write(*,*) vnl_varNameList(jvar),scaleFactor(1)
              endif
              dnens2 = 0.0d0
            endif
            if(vnl_varNameList(jvar).eq.'HU  ') then
              if(scaleFactorLQ(1) > 0.0d0) then
                dnens2 = dnens2/scaleFactorLQ(1)
              else
                if(jt == 1) then
                  write(*,*) 'LQ scalefactor(top) not positive, cannot undo normalization!'
                  write(*,*) vnl_varNameList(jvar),scaleFactorLQ(1)
                endif
              endif
            endif
          else
            dnens2 = 1.0d0
          endif

          do jkInc = 1, topLevOffset
            ! using a constant value
            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                ptr4d_r8(ji,jj,jkInc,jt) = dnens2 *  &
                  dble(ptr4d_r4(ji,jj,1,jt))
              end do
            end do
          end do

        end if ! topLevOffset > 0

      end do ! jt
!$OMP END PARALLEL DO

    enddo ! jvar

  END SUBROUTINE ben_getPerturbation

!--------------------------------------------------------------------------
! AdjustTGOverOpenWater
!--------------------------------------------------------------------------
  SUBROUTINE AdjustTGOverOpenWater()
    use timeCoord_mod
    implicit none

    real(4), allocatable :: TrialLandSeaMask(:,:), TrialSeaIceMask(:,:)
    real(4), allocatable :: AnalLandSeaMask(:,:), AnalSeaIceMask(:,:)

    real(4), allocatable :: tgstdbg_tmp(:,:)
    real(4), pointer     :: ptr4d_r4(:,:,:,:)

    integer :: jlat, jlon, jt, memberIndex

    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4
    integer :: ierr,ipas,ntrials
    integer :: idateo
    integer :: fstprm,fstinf,iultg,fnom,fclos,fstouv,fstfrm
    integer :: TrlmNumberWanted
    integer :: fstlir, fstecr, key, fstinl, nultrl, ni_trial, nj_trial
    integer :: deet, npas, nbits, datyp
    integer :: swa, lng, dltf, ubc
    integer :: extra1, extra2, extra3
    
    integer :: ezdefset, ezqkdef, ezsint, ezsetopt, TrialGridID

    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket

    character(len=2) :: flnum
    character(len=128) :: trialfile

    logical :: trialExists

    integer :: levTG, levTT2m

    if ( mpi_myid == 0 ) write(*,*)
    if ( mpi_myid == 0 ) write(*,*) 'Adjusting TG ensemble perturbations over Open Water'

    !- Read MG and GL in the middle of the assimilation time window
    if ( tim_nStepObs == 1 ) then
       TrlmNumberWanted = 1
    else
       TrlmNumberWanted = nint( (tim_nStepObs + 1.d0) / 2.d0)
    end if
    
    write(flnum,'(I2.2)') TrlmNumberWanted
    trialfile='./trlm_'//trim(flnum)
    inquire(file=trim(trialfile),exist=trialExists)

    if ( .not. trialExists ) then
       if ( mpi_myid == 0 ) write(*,*)
       if ( mpi_myid == 0 ) write(*,*) 'Trial file not found = ', trialfile
       if ( mpi_myid == 0 ) write(*,*) 'Look for an ensemble of trial files '
       
       trialfile='./trlm_'//trim(flnum)//'_0001'
       inquire(file=trim(trialfile),exist=trialExists)
       if ( .not. trialExists ) then
          if ( mpi_myid == 0 ) write(*,*) 'Ensemble trial file not found = ', trialfile
          call abort3d('BMatrixEnsemble : DID NOT FIND A TRIAL FIELD FILE')
       end if
    end if

    nultrl = 0
    ierr = fnom(nultrl,trim(trialfile),'RND+OLD+R/O',0)
    ierr = fstouv(nultrl,'RND+OLD')

    !- Determine grid size and EZSCINT ID
    idateo    = -1
    cletiket = ' '
    ip1      = -1
    ip2      = -1
    ip3      = -1
    cltypvar = ' '
    clnomvar = 'MG'

    key = fstinf( nultrl,                                             & ! IN
                  ni_trial, nj_trial, ink,                            & ! OUT
                  idateo, cletiket, ip1, ip2, ip3, cltypvar, clnomvar ) ! IN

    if (key < 0) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to find trial field = ',clnomvar
       call abort3d('BMatrixEnsemble')
    end if

    ierr = fstprm( key,                                                 & ! IN
                   idateo, deet, npas, ni_trial, nj_trial, ink, nbits,  & ! OUT
                   datyp, ip1, ip2, ip3, cltypvar, clnomvar, cletiket,  & ! OUT
                   clgrtyp, ig1, ig2, ig3,                              & ! OUT
                   ig4, swa, lng, dltf, ubc, extra1, extra2, extra3 )     ! OUT

    allocate(TrialLandSeaMask(ni_trial, nj_trial))
    allocate(TrialSeaIceMask(ni_trial, nj_trial))

    idateo   = -1
    cletiket = ' '
    ip1      = -1
    ip2      = -1
    ip3      = -1
    cltypvar = ' '
    clnomvar = 'MG'
    ierr = fstlir(TrialLandSeaMask, nultrl, ini, inj, ink,  &
                  idateo ,cletiket, ip1, ip2, ip3, cltypvar, clnomvar)
    if ( ierr < 0 ) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to read trial field = ',clnomvar
       call abort3d('BMatrixEnsemble : fstlir failed')
    end if

    if (ini /= ni_trial .or. inj /= nj_trial) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Invalid dimensions for ...'
       write(*,*) 'nomvar      =', trim(clnomvar)
       write(*,*) 'etiket      =', trim(cletiket)
       write(*,*) 'ip1         =', ip1
       write(*,*) 'Found ni,nj =', ini, inj 
       write(*,*) 'Should be   =', ni_trial, nj_trial
       call abort3d('bMatrixEnsemble')
    end if

    clnomvar = 'GL'
    ierr = fstlir(TrialSeaIceMask, nultrl, ini, inj, ink,  &
                    idateo ,cletiket, ip1, ip2, ip3, cltypvar, clnomvar)
    if ( ierr < 0 ) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Unable to read trial field = ',clnomvar
       call abort3d('BMatrixEnsemble : fstlir failed')
    end if

    if (ini /= ni_trial .or. inj /= nj_trial) then
       write(*,*)
       write(*,*) 'bMatrixEnsemble: Invalid dimensions for ...'
       write(*,*) 'nomvar      =', trim(clnomvar)
       write(*,*) 'etiket      =', trim(cletiket)
       write(*,*) 'ip1         =', ip1
       write(*,*) 'Found ni,nj =', ini, inj 
       write(*,*) 'Should be   =', ni_trial, nj_trial
       call abort3d('bMatrixEnsemble')
    end if

    TrialGridID  = ezqkdef( ni_trial, nj_trial, clgrtyp, ig1, ig2, ig3, ig4, nultrl )   ! IN
 
    ierr = fstfrm(nultrl)  
    ierr = fclos(nultrl)

    !- Interpolate to the Analysis Grid
    allocate(AnalLandSeaMask(hco_ben%ni, hco_ben%nj))
    allocate(AnalSeaIceMask(hco_ben%ni, hco_ben%nj))

    ierr = ezdefset( hco_ben%EZscintID, TrialGridID ) ! IN,  IN
    ierr = ezsetopt('INTERP_DEGREE', 'NEAREST') ! Nearest-neighbor interpolation

    ierr = ezsint  (AnalLandSeaMask, TrialLandSeaMask) ! OUT, IN
    ierr = ezsint  (AnalSeaIceMask , TrialSeaIceMask ) ! OUT, IN

    deallocate(TrialLandSeaMask)
    deallocate(TrialSeaIceMask)

    !- Modify the TG ensemble perturbations
    levTG   = ngposittg
    levTT2m = ngposittt+nLevEns_T-1

    do memberIndex = 1, nens
       ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4)

       do jt = 1, numTime
          do jlat = myLatBeg, myLatEnd
             do jlon = myLonBeg, myLonEnd

                if ( AnalLandSeaMask(jlon,jlat) <= 0.1 .and. AnalSeaIceMask(jlon,jlat) <= 0.2 ) then
                   ! We have an open water point. Replace TG perturbations by 2m T perturbations.
                   ! This is done because the EnKF does not perturbed the SST => TG ens pert = 0 over open water.
                   ptr4d_r4(jlon,jlat,levTG,jt) = ptr4d_r4(jlon,jlat,levTT2m,jt)
                end if
             end do
          end do

       end do
    end do

    !- Write the modified TG

    !allocate(tgstdbg_tmp(hco_ben%ni,hco_ben%nj))
    !tgstdbg_tmp(:,:) = 0.0
    !ptr4d_r4 => gsv_getField_r4(ensPerts(1,1)%statevector_r4)
    !do jlat = myLatBeg, myLatEnd
    !   do jlon = myLonBeg, myLonEnd
    !      tgstdbg_tmp(jlon,jlat) = ptr4d_r4(jlon,jlat,levTG,1)
    !   end do
    !end do
    !call rpn_comm_allreduce(tgstdbg_tmp,tgstdbg_tmp,hco_ben%ni*hco_ben%nj,"mpi_real","mpi_sum","GRID",ierr)
    !
    !if ( mpi_myid == 0 ) then
    !
    !    iultg = 0
    !    ierr = fnom(iultg,'tg_enspert_tweaked.fst','RND',0)
    !    ierr = fstouv(iultg,'RND')
    !
    !    ini = hco_ben%ni
    !    inj = hco_ben%nj
    !    ink = 1
    !    ip1 = 0
    !    ip2 = 0
    !    ip3 = 0
    !    idateo = 0
    !    cltypvar = 'E'
    !    clnomvar = 'TG'
    !    cletiket = 'MOD_ENS_PERT'
    !    clgrtyp = 'G'
    !    ig1 = 0
    !    ig2 = 0
    !    ig3 = 0
    !    ig4 = 0
    !    idatyp = 1
    !
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, cltypvar,         &
    !                   clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    ! end if
    !
    ! tgstdbg_tmp(:,:) = 0.0
    ! ptr4d_r4 => gsv_getField_r4(ensPerts(1,1)%statevector_r4)
    ! do jlat = myLatBeg, myLatEnd
    !    do jlon = myLonBeg, myLonEnd
    !       tgstdbg_tmp(jlon,jlat) = ptr4d_r4(jlon,jlat,levTT2m,1)
    !    end do
    ! end do
    ! call rpn_comm_allreduce(tgstdbg_tmp,tgstdbg_tmp,hco_ben%ni*hco_ben%nj,"mpi_real","mpi_sum","GRID",ierr)
    !
    ! if ( mpi_myid == 0 ) then
    !    cltypvar = 'E'
    !    clnomvar = 'TT'
    !    cletiket = 'RAW_ENS_PERT'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, 12000, ip2, ip3, cltypvar,         &
    !                   clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    do jlat = 1, hco_ben%nj
    !      do jlon = 1,hco_ben%ni
    !         tgstdbg_tmp(jlon,jlat) = AnalLandSeaMask(jlon,jlat)
    !      end do
    !    end do
    !    cltypvar = 'P'
    !    clnomvar = 'MG'
    !    cletiket = 'TRIAL2ANAL'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, cltypvar,         &
    !                   clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    do jlat = 1, hco_ben%nj
    !      do jlon = 1,hco_ben%ni
    !         tgstdbg_tmp(jlon,jlat) = AnalSeaIceMask(jlon,jlat)
    !      end do
    !    end do       
    !    cltypvar = 'P'
    !    clnomvar = 'GL'
    !    cletiket = 'TRIAL2ANAL'
    !    ierr = fstecr(tgstdbg_tmp, tgstdbg_tmp, -32, iultg, idateo,         &
    !                   0, 0, ini, inj, ink, ip1, ip2, ip3, cltypvar,         &
    !                   clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp, &
    !                   .true.)
    !
    !    ierr = fstfrm(iultg)
    !    ierr = fclos(iultg)
    ! end if
    !
    ! deallocate(tgstdbg_tmp)

    deallocate(AnalLandSeaMask)
    deallocate(AnalSeaIceMask)

  END SUBROUTINE AdjustTGOverOpenWater

!--------------------------------------------------------------------------
! CheckEnsDim
!--------------------------------------------------------------------------
  SUBROUTINE CheckEnsDim(niEns,njEns,nkEns,nomvar)
    implicit none

    integer,      intent(in) :: niEns,njEns,nkEns
    character(*), intent(in) :: nomvar

    if ( niEns /= lonPerPE  .or. &
         njEns /= latPerPE  .or. &
         nkEns /= 1 ) then

       write(*,*) 'Variable :', trim(nomvar)
       write(*,*) 'i-dim = ', niEns, lonPerPE
       write(*,*) 'j-dim = ', njEns, latPerPE
       write(*,*) 'k-dim = ', nkEns, 1
       call abort3d('Ensemble dimensions are incompatible with the topology and/or the analysis grid')
    endif

  END SUBROUTINE CheckEnsDim

!--------------------------------------------------------------------------
! EnsembleScaleDecomposition
!--------------------------------------------------------------------------
  SUBROUTINE EnsembleScaleDecomposition()
    use filterResponseFunction_mod
    implicit none

    integer :: waveBandIndex, memberindex, jt, jk, jj, ji
    integer :: ila_filter, p, nla_filter, nphase_filter

    real(8), allocatable :: ResponseFunction(:,:)

    real(8), allocatable :: bandSum(:,:)
    real(8) :: totwvnb_r8

    real(8), allocatable :: ensPertSP(:,:,:)
    real(8), allocatable :: ensPertSPfiltered(:,:,:)
    real(8), allocatable :: ensPertGD(:,:,:)
    real(4), pointer     :: ptr4d_r4(:,:,:,:)

    integer, allocatable :: jn_vec(:)

    integer :: gstID2, jm, jn

    type(struct_lst)    :: lst_ben_filter ! Spectral transform Parameters for filtering

    character(len=19)   :: kind

    !
    ! --- Ensemble Perturbation Data at the Start  ---
    ! ensPerts(1          ,:) contains the full perturbations
    ! ensPerts(2:nWaveBand,:) already allocated but empty
    !
    ! --- Ensemble Perturbation Data at the End    ---
    ! ensPerts(nWaveBand,:) contains the largest scales
    ! ...
    ! ensPerts(1        ,:) contains the smallest scales
    !

    if ( mpi_myid == 0 ) then
       write(*,*)
       write(*,*) 'Scale decomposition of the ensemble perturbations'
       write(*,*) '   number of WaveBands = ', nWaveBand
       write(*,*) '   WaveBand Peaks (total wavenumber)...'
       do waveBandIndex = 1, nWaveBand
          write(*,*) waveBandIndex, waveBandPeaks(waveBandIndex)
       end do
    end if

    !
    !- Setup a spectral transform for filtering (nk = nkgdimEns)
    !
    if (hco_ben%global) then
       ! Global mode
       gstID2 = gst_setup(ni,nj,ntrunc,nkgdimEns)
       if(mpi_myid.eq.0) write(*,*) 'BEN : returned value of gstID2 = ',gstID2
       nla_filter = nla_mpilocal ! should be recomputed here based on gstID2 info
       nphase_filter = 2
       allocate(jn_vec(nla_filter))
       ila_filter = 0
       do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if(jm.le.jn) then
               ila_filter = ila_filter + 1
               jn_vec(ila_filter) = jn
            end if
          enddo
       enddo
    else
       ! LAM mode
        call lst_Setup( lst_ben_filter,               & ! OUT
                        ni, nj, hco_ben%dlon, ntrunc, & ! IN
                        'LatLonMN', nkgdimEns )         ! IN
        nla_filter = lst_ben_filter%nla
        nphase_filter = lst_ben_filter%nphase
    end if

    !
    !- 1.  Scale decomposition for every wave band except for wave band #1
    !
    allocate(ResponseFunction(nla_filter,2:nWaveBand))
    allocate(ensPertSP(nla_filter,nphase_filter,nkgdimEns))
    allocate(ensPertSPfiltered(nla_filter,nphase_filter,nkgdimEns))
    allocate(ensPertGD(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nkgdimEns))

    ensPertSP(:,:,:) = 0.0d0
    ensPertSPfiltered(:,:,:) = 0.0d0

    !- 1.1 Pre-compute the response function for each wave band except for wave band #1
    do waveBandIndex = nWaveBand, 2, -1 ! Start with the largest scales
       do ila_filter = 1, nla_filter
          if (hco_ben%global) then
             totwvnb_r8 = real(jn_vec(ila_filter),8)
          else
             totwvnb_r8 = lst_ben_filter%k_r8(ila_filter)
          endif
          ResponseFunction(ila_filter,waveBandIndex) = FilterResponseFunction(totwvnb_r8,waveBandIndex, waveBandPeaks, nWaveBand)
       end do
    end do
    if (hco_ben%global) deallocate(jn_vec)

    do jt = 1, numTime ! Loop on ensemble time bin
       do memberIndex = 1, nEns ! Loop on ensemble member
          ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4)

          !- 1.2 GridPoint space -> Spectral Space
!$OMP PARALLEL DO PRIVATE (jk,jj,ji)
          do jk = 1, nkgdimEns
             do jj = myLatBeg, myLatEnd
                do ji = myLonBeg, myLonEnd
                   ensPertGD(ji,jj,jk) = dble(ptr4d_r4(ji,jj,jk,jt))
                end do
             end do
          end do
!$OMP END PARALLEL DO
          if (hco_ben%global) then
             ! Global Mode
             call gst_setID(gstID2) ! IN
             call gst_reespe(ensPertSP, & ! OUT
                             ensPertGD)   ! IN
          else
             ! LAM mode
             kind = 'GridPointToSpectral'
             call lst_VarTransform( lst_ben_filter%id, & ! IN
                                    ensPertSP,           & ! OUT
                                    ensPertGD,           & ! IN 
                                    kind, nkgdimEns )      ! IN
          end if

          !- 1.3 Filtering and transformation back to grid point space 
          do waveBandIndex = nWaveBand, 2, -1 ! Start with the largest scales
             ! Filtering
!$OMP PARALLEL DO PRIVATE (jk,p,ila_filter)
             do jk = 1, nkgdimEns
                do p = 1, nphase_filter
                   do ila_filter = 1, nla_filter
                      ensPertSPfiltered(ila_filter,p,jk) = &
                           ensPertSP(ila_filter,p,jk) * ResponseFunction(ila_filter,waveBandIndex)
                   end do
                end do
             end do
!$OMP END PARALLEL DO

             ! Spectral Space -> GridPoint space
             if (hco_ben%global) then
                ! Global Mode
                call gst_setID(gstID2) ! IN
                call gst_speree(ensPertSPfiltered, & ! IN
                                ensPertGD)           ! OUT
             else
                ! LAM mode
                kind = 'SpectralToGridPoint'
                call lst_VarTransform( lst_ben_filter%id, & ! IN
                                       ensPertSPfiltered, & ! IN
                                       ensPertGD,         & ! OUT
                                       kind, nkgdimEns )    ! IN
             end if
             ptr4d_r4 => gsv_getField_r4(ensPerts(waveBandIndex,memberIndex)%statevector_r4)
!$OMP PARALLEL DO PRIVATE (jk,jj,ji)
             do jk = 1, nkgdimEns
                do jj = myLatBeg, myLatEnd
                   do ji = myLonBeg, myLonEnd
                      ptr4d_r4(ji,jj,jk,jt) = sngl(ensPertGD(ji,jj,jk))
                   end do
                end do
             end do
!$OMP END PARALLEL DO

          end do ! waveBandIndex
       end do ! ensemble member
    end do ! time bins

    deallocate(ensPertGD)
    deallocate(ResponseFunction)
    deallocate(ensPertSP)
    deallocate(ensPertSPfiltered)

    !
    !- 2.  Isolate the smallest scales in waveBandIndex = 1 by difference in grid point space
    !
    allocate(bandSum(myLonBeg:myLonEnd,myLatBeg:myLatEnd))
    do jt = 1, numTime
!$OMP PARALLEL DO PRIVATE (memberindex,jk,jj,ji,waveBandIndex,bandsum,ptr4d_r4)
       do memberIndex = 1, nEns
          do jk = 1, nkgdimEns
             bandSum(:,:) = 0.d0
             do waveBandIndex = 2, nWaveBand
                ptr4d_r4 => gsv_getField_r4(ensPerts(waveBandIndex,memberIndex)%statevector_r4)
                do jj = myLatBeg, myLatEnd
                   do ji = myLonBeg, myLonEnd
                     bandSum(ji,jj) = bandSum(ji,jj) + dble(ptr4d_r4(ji,jj,jk,jt))
                   end do
                end do
             end do
             ptr4d_r4 => gsv_getField_r4(ensPerts(1,memberIndex)%statevector_r4)
             do jj = myLatBeg, myLatEnd
                do ji = myLonBeg, myLonEnd
                   ptr4d_r4(ji,jj,jk,jt) = sngl(dble(ptr4d_r4(ji,jj,jk,jt)) - bandSum(ji,jj))
                end do
             end do
          end do
       end do
!$OMP END PARALLEL DO
    end do
    deallocate(bandSum)

  END SUBROUTINE EnsembleScaleDecomposition

!--------------------------------------------------------------------------
! setupLocalization
!--------------------------------------------------------------------------
  SUBROUTINE setupLocalization(hLocalize,vLocalize,pressureProfile)
    implicit none

    real(8), intent(in) :: hLocalize(:),vLocalize(:),pressureProfile(:)

    real(8)  :: zlc,zr,zpole,zcorr

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr
    integer :: waveBandIndex

    real(8)  :: local_length(nLevEns_M)

    !
    !- 1. Allocation for the structure
    !
    allocate(ensLocal(nWaveBand))

    !
    !- 2. Setup Localization for each WaveBand
    !
    do waveBandIndex = 1, nWaveBand

       !- 2.1 Allocation
       allocate(ensLocal(waveBandIndex)%Horiz(0:ntrunc,nLevEns_M),stat=ierr)
       if (ierr.ne.0 ) then
          write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=9',ierr
          call abort3d('aborting in ben: setupLocalization')
       endif

       allocate(ensLocal(waveBandIndex)%Vert(nLevEns_M,nLevEns_M),stat=ierr)
       if (ierr.ne.0 ) then
          write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=10',ierr
          call abort3d('aborting in ben: setupLocalization')
       endif

       !- 2.2.  Compute HORIZONTAL localization correlation matrix

       !  2.1.2 Determine localization length scale for each vertical level
       if ( ( trim(LocalizationType) == 'LevelDependent' .and. hLocalize(2) < 0.0d0 ) .or. &
              trim(LocalizationType) == 'ScaleDependent' ) then
          ! vertically constant horizontal localization
          local_length(:) = hLocalize(waveBandIndex)
       else
          ! vertically varying horizontal localization (linear in log P)
          do jk = 1, nLevEns_M
             local_length(jk) = ( hLocalize(1)*( log(pressureProfile(jk       ))-log(pressureProfile(1 )) ) +    &
                                  hLocalize(2)*( log(pressureProfile(nLevEns_M))-log(pressureProfile(jk)) ) ) /  &
                                               ( log(pressureProfile(nLevEns_M))-log(pressureProfile(1)) )
             if(mpi_myid.eq.0) write(*,*) 'bmatrixEnsemble: localization length scale (',jk,') = ',local_length(jk)
          enddo
       endif

       !- 2.1.3 Compute matrix
       if (hco_ben%global) then
          call setupGlobalHLoc(local_length, waveBandIndex) ! IN
       else
          call setupLamHLoc(local_length, waveBandIndex) ! IN
       endif

       !- 1.3.  Compute VERTICAL localization correlation matrix
    
       !  1.3.1 Calculate 5'th order function
       ZLC = vLocalize(waveBandIndex)
       do jk1 = 1, nLevEns_M
          do jk2 = 1, nLevEns_M
             ZR = abs(log(pressureProfile(jk2)) - log(pressureProfile(jk1)))
             zcorr = loc_response(zr,zlc)
             !if(zcorr.lt.0.0d0) zcorr = 0.0d0
             ensLocal(waveBandIndex)%Vert(jk1,jk2) = zcorr
          enddo
       enddo

       !- 1.3.2 Compute sqrt of the matrix if vertical localization requested
       call matsqrt(ensLocal(waveBandIndex)%Vert(1,1),nLevEns_M,1.0d0,.false.)

    end do

    !
    !- 3.  Ending
    !
    if (mpi_myid.eq.0) write(*,*) 'done setting up localization function'

  END SUBROUTINE setupLocalization

!--------------------------------------------------------------------------
! setupGlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupGlobalHLoc(local_length, waveBandIndex)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns_M)
    integer, intent(in)  :: waveBandIndex

    real(8) ::   zlc,zr,zpole,zcorr

    ! NOTE: arrays passed to spectral transform are dimensioned as follows
    !       gd: lat/lon tiles and sp: member index
    real(8) :: zsp_mpilocal(nla_mpilocal,nphase,nLevEns_M)
    real(8) :: zsp_mpiglobal(nla_mpiglobal,nphase,nLevEns_M)
    real(8) :: zsp_mympiglobal(nla_mpiglobal,nphase,nLevEns_M)
    real(8) :: zgd_gst(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_M)

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr
    integer :: ila_mpiglobal,jla_mpilocal

    if(local_length(1).gt.0.0d0) then

      zgd_gst(:,:,:) = 0.0d0
      do jk = 1, nLevEns_M
        ! Calculate 5th Order Correlation Functions in Physical Space
        zlc = 1000.0d0*local_length(jk)
        do jlat = myLatBeg, myLatEnd
          zr = ra * acos(gst_getrmu(jlat,gstID))
          zcorr = loc_response(zr,zlc)
          do jlon = myLonBeg, myLonEnd
            zgd_gst(jlon,jlat,jk) = zcorr
          enddo
        enddo
      enddo

      ! Transform to spectral space
      zsp_mpilocal(:,:,:) = 0.0d0
      call gst_setID(gstID)
      call gst_reespe(zsp_mpilocal,zgd_gst)

      ! Make mpiglobal in spectral space
      zsp_mympiglobal(:,:,:) = 0.0d0
      do jla_mpilocal = 1, nla_mpilocal
        ila_mpiglobal = ilaList_mpiglobal(jla_mpilocal)
        zsp_mympiglobal(ila_mpiglobal,:,:) = zsp_mpilocal(jla_mpilocal,:,:)
      enddo
      nsize = nla_mpiglobal*nphase*nLevEns_M
      zsp_mpiglobal(:,:,:) = 0.0d0
      call rpn_comm_allreduce(zsp_mympiglobal,zsp_mpiglobal,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)
      
      ! Copy over to EnsLocal(WaveBandIndex)%Horiz and truncate to NTRUNC
      do jk = 1, nLevEns_M
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = zsp_mpiglobal(jn+1,1,jk)
        enddo
      enddo

      ! Make sure it's one at the pole
      do jk = 1, nLevEns_M
        do  jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = abs(ensLocal(waveBandIndex)%Horiz(jn,jk))
        enddo
      enddo
      do jk = 1, nLevEns_M
        zpole = 0.d0
        do  jn = 0, ntrunc
          zpole = zpole + ensLocal(waveBandIndex)%Horiz(jn,jk)*sqrt((2.d0*jn+1.d0)/2.d0)
        enddo
        if(zpole.le.0.d0) then
          write(*,*)'POLE VALUE NEGATIVE IN setupGlobalHLoc jk=',jk
          call abort3d('setupGlobalHLoc')
        endif
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = ensLocal(waveBandIndex)%Horiz(jn,jk)/zpole
        enddo
      enddo

      ! Convert back to correlations and take sqrt
      do jk = 1, nLevEns_M
        do jn = 0, ntrunc
          ensLocal(waveBandIndex)%Horiz(jn,jk) = sqrt( 0.5d0*ensLocal(waveBandIndex)%Horiz(jn,jk) * &
                                                       ((2.0d0/(2.0d0*jn+1.0d0))**0.5d0) )
        enddo
      enddo

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocal(waveBandIndex)%Horiz to 1.0 for wavenumber 0
       do jk = 1, nLevEns_M
          ensLocal(waveBandIndex)%Horiz(:,jk) = 0.0d0
          ensLocal(waveBandIndex)%Horiz(0,jk) = 1.0d0
       enddo
    endif

  END SUBROUTINE setupGlobalHLoc

!--------------------------------------------------------------------------
! setupLamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupLamHLoc(local_length, waveBandIndex)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns_M)
    integer, intent(in)  :: waveBandIndex

    real(8), allocatable :: sp(:,:,:)
    real(8), allocatable :: gd(:,:,:)
    real(8), allocatable :: SumWeight(:)

    real(8) :: sum

    type(struct_lst)     :: lst_hloc    ! Spectral transform Parameters

    integer :: k, p, e, ila, totwvnb

    character(len=19)   :: kind

    if ( local_length(1) > 0.d0 ) then
      !
      !- 1. Enforce HORIZONTAL LOCALIZATION
      !

      !- 1.1 Setup a non-MPI spectral transform
      call lst_Setup( lst_hloc,                       & ! OUT
                      ni, nj, hco_ben%dlon, ntrunc, & ! IN
                      'NoMpi')                          ! IN

      !- 1.2 Create a correlation function in physical space
      allocate (gd(ni,nj,nLevEns_M))

      call loc_CreateBiPerFunction( gd,                           & ! OUT
                                    local_length, hco_ben%dlon, & ! IN
                                    ni, nj, nLevEns_M )             ! IN

      !- 1.3 Transform to spectral space
      allocate (sp(lst_hloc%nla, nphase, nLevEns_M))

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns_M )     ! IN
 
      !- 1.4 Compute band mean
      allocate(SumWeight(0:ntrunc))
      SumWeight  (:)  = 0.d0

      ensLocal(waveBandIndex)%Horiz(:,:) = 0.d0
      do totwvnb = 0, ntrunc
         do e = 1, lst_hloc%nePerK(totwvnb)
            ila = lst_hloc%ilaFromEK(e,totwvnb)
            do p = 1, lst_hloc%nphase
               SumWeight(totwvnb) = SumWeight(totwvnb) + lst_hloc%Weight(ila)
               do k = 1, nLevEns_M
                  ensLocal(waveBandIndex)%Horiz(totwvnb,k) = ensLocal(waveBandIndex)%Horiz(totwvnb,k) + &
                                                             lst_hloc%Weight(ila) * abs(sp(ila,p,k))
                enddo
             enddo
         enddo
      enddo

      do totwvnb = 0, ntrunc
         if (SumWeight(totwvnb) /= 0.d0) then
            ensLocal(waveBandIndex)%Horiz(totwvnb,:) = ensLocal(waveBandIndex)%Horiz(totwvnb,:) / SumWeight(totwvnb)
         else
            ensLocal(waveBandIndex)%Horiz(totwvnb,:) = 0.d0
         endif
      enddo

      deallocate(SumWeight)

      !- 1.5 Normalization to one of correlation function from spectral densities: Part 1
!$OMP PARALLEL DO PRIVATE (totwvnb,k,sum)
      do k = 1, nLevEns_M
         sum = 0.0d0
         do totwvnb = 0, ntrunc
            sum = sum + real(totwvnb,8) * ensLocal(waveBandIndex)%Horiz(totwvnb,k)
         enddo
         do totwvnb = 0, ntrunc
            if ( sum /= 0.0d0 ) then
               ensLocal(waveBandIndex)%Horiz(totwvnb,k) = ensLocal(waveBandIndex)%Horiz(totwvnb,k) / sum
            else
               ensLocal(waveBandIndex)%Horiz(totwvnb,k) = 0.d0
            endif
         enddo
      enddo
!$OMP END PARALLEL DO

      !- 1.6 Normalization to one of correlation function from spectral densities: Part 2

      !- 1.6.1 Spectral transform of a delta function (at the center of the domain)
      gd(:,:,:) = 0.d0
      gd(ni/2,nj/2,:) = 1.d0

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns_M )     ! IN

      !- 1.6.2 Apply the correlation function
!$OMP PARALLEL DO PRIVATE (totwvnb,e,ila,p,k)
      do totwvnb = 0, ntrunc
         do e = 1, lst_hloc%nePerK(totwvnb)
            ila = lst_hloc%ilaFromEK(e,totwvnb)
            do p = 1, nphase
               do k = 1, nLevEns_M
                  sp(ila,p,k) = sp(ila,p,k) * ensLocal(waveBandIndex)%Horiz(totwvnb,k) * &
                                lst_hloc%NormFactor(ila,p) * lst_hloc%NormFactorAd(ila,p)
               enddo
            enddo
         enddo
      enddo
!$OMP END PARALLEL DO

      !- 1.6.3 Move back to physical space
      kind = 'SpectralToGridPoint'
      call lst_VarTransform( lst_hloc%id,      & ! IN
                             sp,                 & ! IN
                             gd,                 & ! OUT
                             kind, nLevEns_M )     ! IN

      !- 1.6.4 Normalize to 1
      do k = 1, nLevEns_M
         if ( gd(ni/2,nj/2,k) <= 0.d0 ) then
            write(*,*) 'setupLamHLoc: Problem in normalization ',gd(ni/2,nj/2,k)
            call abort3d('aborting in setupLamHLoc')
         endif
         if ( mpi_myid == 0 ) then
           write(*,*) 'setupLamHLoc: Normalization factor = ', k, gd(ni/2,nj/2,k), 1.d0 / gd(ni/2,nj/2,k)
         endif
         ensLocal(waveBandIndex)%Horiz(:,k) = ensLocal(waveBandIndex)%Horiz(:,k) / gd(ni/2,nj/2,k)
      enddo

      !- 1.7 Take sqrt
      ensLocal(waveBandIndex)%Horiz(:,:) = sqrt(ensLocal(waveBandIndex)%Horiz(:,:))

      deallocate(sp)
      deallocate(gd)

    else
      !
      !- 2. NO HORIZONTAL LOCALIZATION: set ensLocal%Horiz to 1.0 for wavenumber 0
      !
      ensLocal(waveBandIndex)%Horiz(:,:) = 0.0d0
      ensLocal(waveBandIndex)%Horiz(0,:) = 1.0d0
    endif

  END SUBROUTINE setupLamHLoc

!--------------------------------------------------------------------------
! BEN_reduceToMPILocal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(8), intent(out) :: cv_mpilocal(cvDim_mpilocal)
    real(8), intent(in)  :: cv_mpiglobal(cvDim_mpiglobal)
    integer, intent(out) :: cvDim_mpilocal_out

    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpilocal, ila_mpiglobal
    integer :: jm, jn, memberIndex, jlev, ierr, p

    cvDim_mpilocal_out = cvDim_mpilocal

    ! assign part of mpiglobal vector from current mpi process

    if (hco_ben%global) then

      ! Global
      jdim_mpilocal = 0
      do memberIndex = 1, nEns

        do jlev = 1, nLevEns_M
          do jm = mymBeg, mymEnd, mymSkip
            do jn = mynBeg, mynEnd, mynSkip
              if(jm.le.jn) then

                ! figure out index into global control vector
                ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                if(jm.eq.0) then
                  ! for jm=0 only real part
                  jdim_mpiglobal = ila_mpiglobal
                else
                  ! for jm>0 both real and imaginary part
                  jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                endif
                ! add offset for level
                jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                ! add offset for member index
                jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M

                if(jm.eq.0) then
                  ! controlVector only contain real part for jm=0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
                else
                  ! controlVector contains real and imag parts for jm>0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal+1)
                endif

              endif
            enddo
          enddo
        enddo

      enddo

    else
       
      ! LAM

      do memberIndex = 1, nEns
         do jlev = 1, nLevEns_M
            do ila_mpilocal = 1, lst_ben%nla
               do p = 1, lst_ben%nphase

                  jdim_mpilocal = ( (jlev-1) * nEns * lst_ben%nla * lst_ben%nphase ) + &
                                  ( (memberIndex-1) * lst_ben%nla * lst_ben%nphase ) + &
                                               ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                  ila_mpiglobal = lst_ben%ilaGlobal(ila_mpilocal)
                  jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                   ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                     ( (ila_mpiglobal-1) * lst_ben%nphase ) + p
  
                  if ( jdim_mpilocal  > cvDim_mpilocal ) then 
                     write(*,*) 'BEN_reduceToMPILocal: jdim_mpilocal > cvDim_mpilocal ',memberIndex,jlev,ila_mpilocal,p
                     call abort3d('BEN_reduceToMPILocal')
                  end if
                  if ( jdim_mpiglobal > cvDim_mpiglobal) then
                     write(*,*) 'BEN_reduceToMPILocal: jdim_mpiglobal > cvDim_mpiglobal ',memberIndex,jlev,ila_mpilocal,p,ila_mpiglobal
                     call abort3d('BEN_reduceToMPILocal')
                  end if
                  
                  cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)

               end do
            end do
         end do
      end do

    end if

  END SUBROUTINE BEN_reduceToMPILocal

!--------------------------------------------------------------------------
! BEN_expandToMPIGlobal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none

    real(8), intent(in)  :: cv_mpilocal(cvDim_mpilocal)
    real(8), intent(out) :: cv_mpiglobal(cvDim_mpiglobal)
    integer, intent(out) :: cvDim_mpiglobal_out

    real(8), allocatable :: cv_maxmpilocal(:)
    real(8), pointer     :: cv_allmaxmpilocal(:,:) => null()
    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)
    integer :: jdim_mpilocal, jdim_mpiglobal, ila_mpiglobal, ila_mpilocal, cvDim_maxmpilocal
    integer :: jm, jn, jproc, memberIndex, jlev, ierr, p
    real(8), allocatable :: my_cv_mpiglobal(:)

    cvDim_mpiglobal_out = cvDim_mpiglobal

    ! gather all local control vectors onto mpi task 0

    if (hco_ben%global) then

       ! Global
       call rpn_comm_allreduce(cvDim_mpilocal,cvDim_maxmpilocal,1,"mpi_integer","mpi_max","GRID",ierr)

       allocate(cv_maxmpilocal(cvDim_maxmpilocal))

       cv_maxmpilocal(:) = 0.0d0
       cv_maxmpilocal(1:cvDim_mpilocal) = cv_mpilocal(1:cvDim_mpilocal)

       nullify(cv_allmaxmpilocal)
       if(mpi_myid.eq.0) then
          allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))
       else
          allocate(cv_allmaxmpilocal(1,1))
       end if
       call rpn_comm_gather(cv_maxmpilocal,    cvDim_maxmpilocal, "mpi_double_precision",  &
                            cv_allmaxmpilocal, cvDim_maxmpilocal, "mpi_double_precision", 0, "GRID", ierr )

       deallocate(cv_maxmpilocal)

       allocate(allnBeg(mpi_nprocs))
       call rpn_comm_allgather(mynBeg,1,"mpi_integer",       &
                               allnBeg,1,"mpi_integer","GRID",ierr)
       allocate(allnEnd(mpi_nprocs))
       call rpn_comm_allgather(mynEnd,1,"mpi_integer",       &
                               allnEnd,1,"mpi_integer","GRID",ierr)
       allocate(allnSkip(mpi_nprocs))
       call rpn_comm_allgather(mynSkip,1,"mpi_integer",       &
                               allnSkip,1,"mpi_integer","GRID",ierr)

       allocate(allmBeg(mpi_nprocs))
       call rpn_comm_allgather(mymBeg,1,"mpi_integer",       &
                               allmBeg,1,"mpi_integer","GRID",ierr)
       allocate(allmEnd(mpi_nprocs))
       call rpn_comm_allgather(mymEnd,1,"mpi_integer",       &
                               allmEnd,1,"mpi_integer","GRID",ierr)
       allocate(allmSkip(mpi_nprocs))
       call rpn_comm_allgather(mymSkip,1,"mpi_integer",       &
                               allmSkip,1,"mpi_integer","GRID",ierr)

       ! reorganize gathered mpilocal control vectors into the mpiglobal control vector
       if(mpi_myid.eq.0) then
         cv_mpiglobal(:) = 0.0d0

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,memberIndex,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
         do jproc = 0, (mpi_nprocs-1)
           jdim_mpilocal = 0
           do memberIndex = 1, nEns

             do jlev = 1, nLevEns_M
               do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
                 do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)
                   if(jm.le.jn) then

                     ! figure out index into global control vector
                     ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
                     if(jm.eq.0) then
                       ! for jm=0 only real part
                       jdim_mpiglobal = ila_mpiglobal
                     else
                       ! for jm>0 both real and imaginary part
                       jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                     endif
                     ! add offset for level
                     jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)
                     ! add offset for member index
                     jdim_mpiglobal = jdim_mpiglobal + (memberIndex-1) * (ntrunc+1)*(ntrunc+1)*nLevEns_M

                     ! index into local control vector
                     if(jm.eq.0) then
                       ! only real component for jm=0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     else
                       ! both real and imaginary components for jm>0
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                       jdim_mpilocal = jdim_mpilocal + 1
                       cv_mpiglobal(jdim_mpiglobal+1) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                     endif

                     if(jdim_mpiglobal.gt.cvDim_mpiglobal)   &
                       write(*,*) 'ERROR: jdim,cvDim,mpiglobal=',jdim_mpiglobal,cvDim_mpiglobal,jlev,jn,jm

                   endif
                 enddo
               enddo
             enddo
           enddo
         enddo ! jproc
!$OMP END PARALLEL DO

      endif ! myid .eq. 0 

      deallocate(allnBeg)
      deallocate(allnEnd)
      deallocate(allnSkip)
      deallocate(allmBeg)
      deallocate(allmEnd)
      deallocate(allmSkip)
      deallocate(cv_allmaxmpilocal)

    else

      ! LAM
      allocate(my_cv_mpiglobal(cvDim_mpiglobal)) 
      my_cv_mpiglobal(:) = 0.0d0

      do memberIndex = 1, nEns
         do jlev = 1, nLevEns_M
            do ila_mpilocal = 1, lst_ben%nla
               do p = 1, lst_ben%nphase

                  jdim_mpilocal = ( (jlev-1) * nEns * lst_ben%nla * lst_ben%nphase ) + &
                                  ( (memberIndex-1) * lst_ben%nla * lst_ben%nphase ) + &
                                               ( (ila_mpilocal-1) * lst_ben%nphase ) + p

                  ila_mpiglobal = lst_ben%ilaGlobal(ila_mpilocal)
                  jdim_mpiglobal = ( (jlev-1) * nEns * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                   ( (memberIndex-1) * lst_ben%nlaGlobal * lst_ben%nphase ) + &
                                                     ( (ila_mpiglobal-1) * lst_ben%nphase ) + p
  
                  if ( jdim_mpilocal  > cvDim_mpilocal ) then 
                     write(*,*) 'BEN_expandToMPIGlobal: jdim_mpilocal > cvDim_mpilocal ',memberIndex,jlev,ila_mpilocal,p
                     call abort3d('BEN_expandToMPIGlobal')
                  end if
                  if ( jdim_mpiglobal > cvDim_mpiglobal) then
                     write(*,*) 'BEN_expandToMPIGlobal: jdim_mpiglobal > cvDim_mpiglobal ',memberIndex,jlev,ila_mpilocal,p,ila_mpiglobal
                     call abort3d('BEN_expandToMPIGlobal')
                  end if
            
                  my_cv_mpiglobal(jdim_mpiglobal) = cv_mpilocal(jdim_mpilocal)

               end do
            end do
         end do
      end do

      call rpn_comm_allreduce(my_cv_mpiglobal,cv_mpiglobal,cvDim_mpiglobal,"mpi_double_precision","mpi_sum","GRID",ierr)
      deallocate(my_cv_mpiglobal) 
    end if

  end SUBROUTINE BEN_expandToMPIGlobal

!--------------------------------------------------------------------------
! BEN_BSqrt
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrt(controlVector_in,statevector)
    implicit none

    real(8)    :: controlVector_in(cvDim_mpilocal) 
    type(struct_gsv) :: statevector

    type(struct_gsv) :: statevector_ensAmp
    real(8), pointer :: ensAmplitude(:,:,:)
    real(8)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    real(8)    :: zsp1(nla_mpilocal,nphase,nLevEns_M)
    real(8), pointer :: field(:,:,:,:)

    integer   :: jlev, numTimeAmplitude
    integer   :: ierr,nsize,jj,jk,ji,jt,jkInc,jvar,topLevOffset
    integer   :: memberIndex, waveBandIndex

    character(len=19)   :: kind

    if(.not. initialized) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if(sum(scaleFactor).eq.0.0d0) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrt'
      return
    endif

    if(maxval(controlVector_in).eq.0.0d0 .and. minval(controlVector_in).eq.0.0d0) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixEnsemble: controlVector=0, skipping bSqrt'
      return
    endif

    if(mpi_myid.eq.0) write(*,*) 'ben_bsqrt: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    call gsv_setVco(statevector_ensAmp,vco_ens)
    call gsv_setHco(statevector_ensAmp,hco_ben)
    numTimeAmplitude=1
    call gsv_allocate(statevector_ensAmp,numTimeAmplitude,datestamp=tim_getDatestamp(),mpi_local=.true.,horizSubSample=1,varName='ALFA')
    ensAmplitude => gsv_getField3D_r8(statevector_ensAmp)

    call gsv_zero(statevector)

    !
    !- Compute the analysis increment from Bens
    !
    do waveBandIndex = 1, nWaveBand !  Loop on WaveBand (for ScaleDependent Localization)

!$OMP PARALLEL DO PRIVATE (memberIndex)
      do memberIndex = 1, nEns
        zsp_all(:,:,:,memberIndex) = 0.0d0
      enddo
!$OMP END PARALLEL DO

      call localizationSqrt(controlVector_in, waveBandIndex, & ! IN
                            zsp_all )                          ! OUT

      do memberIndex = 1, nEns ! loop over all members

        ! now transform amplitude to grid-point space
        call tmg_start(67,'BEN_BARR')
        call rpn_comm_barrier("GRID",ierr)
        call tmg_stop(67)

        call tmg_start(64,'BEN_SPECTRAL')

        zsp1(:,:,:) = zsp_all(:,:,:,memberIndex)

        if (hco_ben%global) then

          call gst_setID(gstID)
          call gst_speree(zsp1,ensAmplitude)

        else

          kind = 'SpectralToGridPoint'
          call lst_VarTransform( lst_ben%id,     & ! IN
                                 zsp1,           & ! IN
                                 ensAmplitude,   & ! OUT (i,j,k) !!!
                                 kind, nLevEns_M ) ! IN

        endif

        call tmg_stop(64)

        call addEnsMember( statevector_ensamp, statevector,  & ! INOUT 
                           memberIndex, waveBandIndex )        ! IN

      enddo ! Loop on vertical levels & ensemble members

    enddo ! Loop on WaveBand

    call gsv_deallocate(statevector_ensAmp)

    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'ben_bsqrt: done'

  END SUBROUTINE BEN_BSqrt

!--------------------------------------------------------------------------
! BEN_BSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrtAd(statevector,controlVector_out)
    implicit none

    real(8)    :: controlVector_out(cvDim_mpilocal) 
    type(struct_gsv) :: statevector

    type(struct_gsv) :: statevector_ensAmp
    real(8)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    real(8)    :: zsp1(nla_mpilocal,nphase,nLevEns_M)
    real(8), pointer :: field(:,:,:,:)
    real(8), pointer :: ensAmplitude(:,:,:)

    integer   :: jlev,jj,jk,ji,jt,jkinc,nsize,ierr,jvar,topLevOffset
    integer   :: memberIndex, waveBandIndex, numTimeAmplitude

    character(len=19)   :: kind

    if(.not. initialized) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixEnsemble not initialized'
      return
    endif

    if(sum(scaleFactor).eq.0.0d0) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrtAd'
      return
    endif

    if(mpi_myid.eq.0) write(*,*) 'ben_bsqrtad: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    call gsv_setVco(statevector_ensAmp,vco_ens)
    call gsv_setHco(statevector_ensAmp,hco_ben)
    numTimeAmplitude=1
    call gsv_allocate(statevector_ensAmp,numTimeAmplitude,datestamp=tim_getDatestamp(),mpi_local=.true.,horizSubSample=1,varName='ALFA')
    ensAmplitude => gsv_getField3D_r8(statevector_ensAmp)

    !
    !- Compute the analysis increment from Bens
    !
    do waveBandIndex = 1, nWaveBand !  Loop on WaveBand (for ScaleDependent Localization)

      do memberIndex = 1, nEns ! loop over all members

        call addEnsMemberAd(statevector, statevector_ensamp,  & ! INOUT
                            memberIndex, waveBandIndex)         ! IN

        zsp1(:,:,:) = 0.0d0 ! needed, not everything is set
        call tmg_start(67,'BEN_BARR')
        call rpn_comm_barrier("GRID",ierr)
        call tmg_stop(67)

        call tmg_start(64,'BEN_SPECTRAL')

        if (hco_ben%global) then

          call gst_setID(gstID)
          call gst_reespe(zsp1,ensAmplitude)

        else

          kind = 'GridPointToSpectral'
          call lst_VarTransform( lst_ben%id,     & ! IN
                                 zsp1,           & ! OUT
                                 ensAmplitude,   & ! IN (i,j,k) !!!
                                 kind, nLevEns_M ) ! IN

        endif

        zsp_all(:,:,:,memberIndex) = zsp1(:,:,:)
        call tmg_stop(64)

      enddo

      call localizationSqrtAd(zsp_all, waveBandIndex, & ! IN
                              controlVector_out )       ! OUT

    enddo ! Loop on WaveBand

    call gsv_deallocate(statevector_ensAmp)

    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'ben_bsqrtad: done'

  END SUBROUTINE BEN_BSqrtAd

!--------------------------------------------------------------------------
! addEnsMember
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMember(statevector_ensamp, statevector_out, &
                          memberIndex, waveBandIndex)
    implicit none

    type(struct_gsv)    :: statevector_ensamp
    type(struct_gsv)    :: statevector_out
    integer, intent(in) :: memberIndex, waveBandIndex

    real(8), pointer    :: ensAmplitude_M(:,:,:)
    real(8), pointer    :: ensAmplitude_MT(:,:,:)
    real(8), target     :: ensAmplitude_T(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_T)
    real(8), pointer    :: increment_out(:,:,:,:)
    real(4), pointer    :: ensMember_r4(:,:,:,:)

    integer     :: jvar, jlev, jlev2, jt, jj, ji, numVar, topLevOffset, numLev

    call tmg_start(62,'ADDMEM')

    ensAmplitude_M => gsv_getField3D_r8(statevector_ensamp)

    ! compute thermo level amplitudes from momentum level amplitudes
    if(Vcode_anl .eq. 5002) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if(jlev.eq.1) then
          ! use top momentum level amplitudes for top thermo level
          ensAmplitude_T(:,:,jlev) = ensAmplitude_M(:,:,jlev)
        elseif(jlev.eq.nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_T(:,:,jlev) = ensAmplitude_M(:,:,nLevEns_M)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_T(:,:,jlev) = 0.5d0*( ensAmplitude_M(:,:,jlev-1) +   &
                                             ensAmplitude_M(:,:,jlev) )
        endif
      enddo
!$OMP END PARALLEL DO

    elseif(Vcode_anl .eq. 5004) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if(jlev.eq.nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_T(:,:,jlev) = ensAmplitude_M(:,:,jlev)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_T(:,:,jlev) = 0.5d0*( ensAmplitude_M(:,:,jlev) +   &
                                             ensAmplitude_M(:,:,jlev+1) )
        endif
      enddo
!$OMP END PARALLEL DO

    endif

    if(Vcode_anl .eq. 5002 .or. Vcode_anl .eq. 5004) then

      do jt = 1, numTime

        do jvar = 1, vnl_numvarmax 
          if(.not. gsv_varExist(statevector_out, vnl_varNameList(jvar))) cycle
          increment_out => gsv_getField_r8(statevector_out, vnl_varNameList(jvar))
          ensMember_r4 => gsv_getField_r4(ensPerts(waveBandIndex,memberIndex)%statevector_r4, &
                                          vnl_varNameList(jvar))
          if(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'SF') then
            numLev = 1
            topLevOffset = 1
            ensAmplitude_MT(myLonBeg:, myLatBeg:, 1:        ) =>   &
             ensAmplitude_M(myLonBeg:, myLatBeg:, nLevEns_M:)
          elseif(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'MM') then
            numLev = nlevEns_M
            topLevOffset = topLevIndex_M
            ensAmplitude_MT => ensAmplitude_M
          else
            numLev = nlevEns_T
            topLevOffset = topLevIndex_T
            ensAmplitude_MT => ensAmplitude_T
          endif

!$OMP PARALLEL DO PRIVATE (jlev,jlev2,jj,ji)
          do jlev = 1, numLev                 ! levels for the amplitude and ensemble member
            jlev2 = jlev - 1 + topLevOffset   ! levels for the 1 variable increment field

            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                increment_out(ji,jj,jlev2,jt) = increment_out(ji,jj,jlev2,jt) +   &
                  ensAmplitude_MT(ji,jj,jlev) * dble(ensMember_r4(ji,jj,jlev,jt))
              enddo
            enddo
          enddo
!$OMP END PARALLEL DO
        enddo ! jvar

      enddo ! jt

    else ! other Vcode

      write(*,*) 'addEnsMember: this Vcode not supported =',Vcode_anl
      call abort3d('addEnsMember')

    endif

    call tmg_stop(62)

  END SUBROUTINE addEnsMember


!--------------------------------------------------------------------------
! addEnsMemberAd
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMemberAd(statevector_in, statevector_ensamp, &
                            memberIndex, waveBandIndex)
    implicit none

    type(struct_gsv)   :: statevector_ensamp
    type(struct_gsv)   :: statevector_in
    integer,intent(in) :: memberIndex, waveBandIndex

    real(8), pointer :: ensAmplitude_M(:,:,:)
    real(8), pointer :: ensAmplitude_MT(:,:,:)
    real(8), target  :: ensAmplitude_T(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nLevEns_T)
    real(8), pointer :: increment_in(:,:,:,:)
    real(4), pointer :: ensMember_r4(:,:,:,:)

    integer     :: jvar, jlev, jlev2, jt, jj, ji, numVar, topLevOffset, numLev

    call tmg_start(62,'ADDMEM')

    ensAmplitude_M => gsv_getField3D_r8(statevector_ensamp)

    ensAmplitude_M(:,:,:) = 0.0d0
    ensAmplitude_T(:,:,:) = 0.0d0

    if(Vcode_anl .eq. 5002 .or. Vcode_anl .eq. 5004) then

      do jt = 1, numTime

        do jvar = 1, vnl_numvarmax
          if(.not. gsv_varExist(statevector_in, vnl_varNameList(jvar))) cycle
          increment_in => gsv_getField_r8(statevector_in, vnl_varNameList(jvar))
          ensMember_r4 => gsv_getField_r4(ensPerts(waveBandIndex,memberIndex)%statevector_r4, &
                                          vnl_varNameList(jvar))

          if(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'SF') then
            numLev = 1
            topLevOffset = 1
            ensAmplitude_MT(myLonBeg:, myLatBeg:, 1:        ) =>   &
             ensAmplitude_M(myLonBeg:, myLatBeg:, nLevEns_M:)
          elseif(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'MM') then
            numLev = nlevEns_M
            topLevOffset = topLevIndex_M
            ensAmplitude_MT => ensAmplitude_M
          else
            numLev = nlevEns_T
            topLevOffset = topLevIndex_T
            ensAmplitude_MT => ensAmplitude_T
          endif

!$OMP PARALLEL DO PRIVATE (jlev,jlev2,jj,ji)
          do jlev = 1, numLev                 ! levels for the amplitude and ensemble member
            jlev2 = jlev - 1 + topLevOffset   ! levels for the 1 variable increment field

            do jj = myLatBeg, myLatEnd
              do ji = myLonBeg, myLonEnd
                ensAmplitude_MT(ji,jj,jlev) = ensAmplitude_MT(ji,jj,jlev) +   &
                  increment_in(ji,jj,jlev2,jt) * dble(ensMember_r4(ji,jj,jlev,jt))
              enddo
            enddo
          enddo
!$OMP END PARALLEL DO
        enddo ! jvar

      enddo ! jt

    else ! other Vcode

      write(*,*) 'addEnsMember: this Vcode not supported =',Vcode_anl
      call abort3d('addEnsMember')

    endif

    ! combine thermo and momentum level amplitude sensitivites
    if(Vcode_anl .eq. 5002) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if(jlev.eq.1) then
          ! use top momentum level amplitudes for top thermo level
          ensAmplitude_M(:,:,jlev) = ensAmplitude_M(:,:,jlev) + ensAmplitude_T(:,:,jlev)
        elseif(jlev.eq.nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_M(:,:,nLevEns_M) = ensAmplitude_M(:,:,nLevEns_M) + ensAmplitude_T(:,:,jlev)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_M(:,:,jlev)   = ensAmplitude_M(:,:,jlev)   + 0.5d0*ensAmplitude_T(:,:,jlev)
        endif
      enddo
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 2, (nLevEns_T-1)
        ensAmplitude_M(:,:,jlev-1) = ensAmplitude_M(:,:,jlev-1) + 0.5d0*ensAmplitude_T(:,:,jlev)
      enddo
!$OMP END PARALLEL DO

    elseif(Vcode_anl .eq. 5004) then

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, nLevEns_T
        if(jlev.eq.nLevEns_T) then
          ! use surface momentum level amplitudes for surface thermo level
          ensAmplitude_M(:,:,jlev) = ensAmplitude_M(:,:,jlev) + ensAmplitude_T(:,:,jlev)
        else
          ! for other levels, interpolate momentum weights to get thermo amplitudes
          ensAmplitude_M(:,:,jlev)   = ensAmplitude_M(:,:,jlev)   + 0.5d0*ensAmplitude_T(:,:,jlev)
        endif
      enddo
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (jlev)
      do jlev = 1, (nLevEns_T-1)
        ensAmplitude_M(:,:,jlev+1) = ensAmplitude_M(:,:,jlev+1) + 0.5d0*ensAmplitude_T(:,:,jlev)
      enddo
!$OMP END PARALLEL DO

    endif

    call tmg_stop(62)

  END SUBROUTINE addEnsMemberAd

!--------------------------------------------------------------------------
! localizationSqrt
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrt(controlVector_in, waveBandIndex, zsp_all)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev1,jlev2,jla,p,memberIndex
    real(8) ,allocatable :: zsp(:,:,:,:)

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ben%global) then
       call GlobalHLoc( zsp_all,                        & ! OUT
                        controlVector_in, waveBandIndex ) ! IN
    else
       call LamHLoc( zsp_all,                        & ! OUT
                     controlVector_in, waveBandIndex ) ! IN
    endif

    !
    !- 2.  Vertical localization
    !
    allocate(zsp(nla_mpilocal,nphase,nLevEns_M,nEns)) 
    call tmg_start(63,'BEN_VLOC')

!$OMP PARALLEL DO PRIVATE (memberIndex,jlev1,jlev2,p,jla)
    do memberIndex = 1, nEns
      zsp(:,:,:,memberIndex) = 0.0d0
      do jlev1 = 1, nLevEns_M
        do jlev2 = 1, nLevEns_M
          do p = 1, nphase
            do jla = 1, nla_mpilocal
              zsp(jla,p,jlev1,memberIndex) = zsp(jla,p,jlev1,memberIndex) +  &
                                             ensLocal(waveBandIndex)%Vert(jlev1,jlev2)*zsp_all(jla,p,jlev2,memberIndex)
            enddo
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_stop(63)
    zsp_all(:,:,:,:) = zsp(:,:,:,:)
    deallocate(zsp)

  END SUBROUTINE localizationSqrt

!--------------------------------------------------------------------------
! GlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLoc(zsp_all, controlVector_in, waveBandIndex)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev, jm, jn, ila_mpilocal, ila_mpiglobal, jdim, memberIndex 

    call tmg_start(65,'BEN_HLOC')

    jdim = 0

    do memberIndex = 1, nEns

      do jlev = 1, nLevEns_M
        do jm = mymBeg, mymEnd, mymSkip
          do jn = mynBeg, mynEnd, mynSkip
            if(jm .le. jn) then

              ila_mpiglobal = gst_getnind(jm,gstID) + jn - jm
              ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
              if(jm.eq.0) then
                ! controlVector only contain real part for jm=0
                jdim = jdim + 1
                zsp_all(ila_mpilocal,1,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*rsq2
                zsp_all(ila_mpilocal,2,jlev,memberIndex) = 0.0d0
              else
                ! controlVector contains real and imag parts for jm>0
                jdim = jdim + 1
                zsp_all(ila_mpilocal,1,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)
                jdim = jdim + 1
                zsp_all(ila_mpilocal,2,jlev,memberIndex) = controlVector_in(jdim)*ensLocal(waveBandIndex)%Horiz(jn,jlev)
              endif

            endif
          enddo
        enddo
      enddo

      if(jdim.gt.cvDim_mpilocal) then
        write(*,*) 'ben globalHLoc: jdim > cvDim_mpilocal! ',jdim,memberIndex,cvDim_mpilocal
        call abort3d('aborted in ben globalHLoc')
      endif

    enddo

    call tmg_stop(65)

  END SUBROUTINE GlobalHLoc

!--------------------------------------------------------------------------
! LamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE LamHLoc(zsp_all, controlVector_in, waveBandIndex)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_mpilocal)
    integer, intent(in)  :: waveBandIndex
    real(8), intent(out) :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev,jla, jdim, memberIndex, p 

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = 1, nEns

       call tmg_start(65,'BEN_HLOC')
       do jlev = 1, nLevEns_M
         do jla = 1, nla_mpilocal
            do p = 1, nphase
              jdim = jdim + 1
              zsp_all(jla,p,jlev,memberIndex) = controlVector_in(jdim)           * &
                                                ensLocal(waveBandIndex)%Horiz(lst_ben%k(jla),jlev) * &
                                                lst_ben%NormFactor(jla,p)
            enddo
         enddo
       enddo
       if (jdim > cvDim_mpilocal ) then
          write(*,*) 'BEN: LamHLoc: jdim > cvDim! ',jdim,memberIndex,cvDim_mpilocal
          call abort3d('aborted in LamHLoc')
       endif
       call tmg_stop(65)

    enddo

  END SUBROUTINE LamHLoc

!--------------------------------------------------------------------------
! localizationSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrtAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out) :: controlVector_out(cvDim_mpilocal)
    real(8), intent(in)  :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)
    integer, intent(in)  :: waveBandIndex

    integer :: jlev1,jlev2,jla,memberIndex,p
    real(8),allocatable::zsp(:,:,:,:)

    !
    !- 2.  Vertical Localization
    !
    allocate(zsp(nla_mpilocal,nphase,nLevEns_M,nEns) ) 

    call tmg_start(63,'BEN_VLOC')

!$OMP PARALLEL DO PRIVATE (memberIndex,jlev1,jlev2,p,jla)
    do memberIndex = 1, nEns
      zsp(:,:,:,memberIndex) = 0.0d0
      do jlev1 = 1, nLevEns_M
        do jlev2 = 1, nLevEns_M
          do p = 1, nphase
            do jla = 1, nla_mpilocal
              zsp(jla,p,jlev2,memberIndex) = zsp(jla,p,jlev2,memberIndex) +  & 
                                             ensLocal(waveBandIndex)%Vert(jlev2,jlev1)*zsp_all(jla,p,jlev1,memberIndex)
            enddo
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_stop(63)

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ben%global) then
      call GlobalHLocAd( zsp, waveBandIndex, & ! IN
                         controlVector_out )   ! OUT
    else
      call LamHLocAd( zsp, waveBandIndex, & ! IN
                      controlVector_out )   ! OUT
    endif
    deallocate(zsp)

  END SUBROUTINE localizationSqrtAd

!--------------------------------------------------------------------------
! GlobalHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLocAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_mpilocal)
    integer, intent(in)    :: waveBandIndex
    real(8), intent(in)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jlev, jm, jn, ila_mpilocal, ila_mpiglobal, jdim, memberIndex 

    call tmg_start(65,'BEN_HLOC')

    jdim = 0

    do memberIndex = 1, nEns

       do jlev = 1, nLevEns_M
          do jm = mymBeg, mymEnd, mymSkip
            do jn = mynBeg, mynEnd, mynSkip
              if(jm .le. jn) then

                ila_mpiglobal = gst_getnind(jm,gstID) + jn - jm
                ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
                if(jm.eq.0) then
                  ! controlVector only contain real part for jm=0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,1,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*rsq2
                else
                  ! controlVector contains real and imag parts for jm>0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,1,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*2.0d0
                  jdim = jdim + 1
                  controlVector_out(jdim) = controlVector_out(jdim) +  &
                                            zsp_all(ila_mpilocal,2,jlev,memberIndex)*ensLocal(waveBandIndex)%Horiz(jn,jlev)*2.0d0
                endif

             endif
           enddo
         enddo
       enddo

       if(jdim.gt.cvDim_mpilocal) then
          write(*,*) 'ben globalHLocAd: jdim > cvDim_mpilocal! ',jdim,memberIndex,cvDim_mpilocal
          call abort3d('aborted in ben globalHLocAd')
       endif
    
    enddo

    call tmg_stop(65)

  END SUBROUTINE GlobalHLocAd

!--------------------------------------------------------------------------
! LamHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE LamHLocAd(zsp_all, waveBandIndex, controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_mpilocal)
    integer, intent(in)    :: waveBandIndex
    real(8), intent(in)    :: zsp_all(nla_mpilocal,nphase,nLevEns_M,nEns)

    integer :: jla, jlev, jdim, memberIndex, p

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = 1, nEns

       call tmg_start(65,'BEN_HLOC')
       do jlev = 1, nLevEns_M
         do jla = 1, nla_mpilocal
           do p = 1, nphase
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) +           &
                                       ( zsp_all(jla,p,jlev,memberIndex)  * &
                                         ensLocal(waveBandIndex)%Horiz(lst_ben%k(jla),jlev) * &
                                         lst_ben%NormFactorAd(jla,p)    )
           enddo
         enddo
       enddo
       if (jdim > cvDim_mpilocal ) then
          write(*,*) 'BEN: LamHLocAD: jdim > cvDim! ',jdim, memberIndex, cvDim_mpilocal
          call abort3d('aborted in LamHLocAd')
       endif
       call tmg_stop(65)

    enddo

  END SUBROUTINE LamHLocAd

  !--------------------------------------------------------------------------
  ! EnsembleDiagnostic
  !--------------------------------------------------------------------------
  SUBROUTINE EnsembleDiagnostic(mode)
    use timeCoord_mod
    implicit none

    character(len=*), intent(in) :: mode

    type(struct_gsv) :: statevector, statevector_temp

    integer :: nWaveBandToDiagnose, waveBandIndex, memberIndex

    real(8) :: dnens2

    character(len=12):: etiket, modeEtiket
    character(len=2) :: wbnum

    if ( trim(mode) == 'FullPerturbations') then
       nWaveBandToDiagnose = 1
    else if ( trim(mode) == 'WaveBandPerturbations' ) then
       nWaveBandToDiagnose = nWaveBand
    else
       write(*,*)
       write(*,*) 'mode = ', trim(mode)
       call abort3d('EnsembleDiagnostic: unknown mode')
    end if

    if ( mpi_myid == 0 ) write(*,*)
    if ( mpi_myid == 0 ) write(*,*) 'EnsembleDiagnostic in mode: ', mode

    !- Setup a gridstatevector working array
    call gsv_setVco(statevector,vco_anl)
    call gsv_setHco(statevector,hco_ben)

    !
    !- Write each wave band for a selected member
    !
    if (trim(LocalizationType) == 'ScaleDependent') then
       if ( mpi_myid == 0 ) write(*,*) '   writing perturbations for member 001'
       memberIndex = 1
       dnens2 = sqrt(1.0d0*dble(nEns-1))
       do waveBandIndex = 1, nWaveBandToDiagnose
          if ( mpi_myid == 0 ) write(*,*) '     waveBandIndex = ', waveBandIndex
          call gsv_allocate(statevector,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)
          call ben_getPerturbation( statevector,    & ! OUT
                                    memberIndex,    & ! IN
                                    'ConstantValue', waveBandIndex ) ! IN
          if ( trim(mode) == 'FullPerturbations') then
             etiket = 'PERT001_FULL'
          else
             write(wbnum,'(I2.2)') waveBandIndex
             etiket = 'PERT001_WB' // trim(wbnum)
          end if
          call gsv_writeToFileMPI(statevector,'./ens_pert001.fst',etiket, & ! IN
                               dnens2 ) ! IN
          call gsv_deallocate(statevector)
       end do
    end if

    !
    !- Compute the standard deviations for each wave band
    !
    if ( mpi_myid == 0 ) write(*,*) '   computing Std.Dev.'
    call gsv_setVco(statevector_temp,vco_anl)
    call gsv_setHco(statevector_temp,hco_ben)
    call gsv_allocate(statevector_temp,tim_nstepobsinc,mpi_local=.true.)

    do waveBandIndex = 1, nWaveBandToDiagnose
       if ( mpi_myid == 0 ) write(*,*) '     waveBandIndex = ', waveBandIndex
       call gsv_allocate(statevector,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)
       call gsv_zero(statevector)
       do memberIndex = 1, nEns
          !- Get normalized perturbations
          call ben_getPerturbation( statevector_temp, & ! OUT
                                    memberIndex,      & ! IN
                                    'ConstantValue', waveBandIndex ) ! IN
          !- Square
          call gsv_power(statevector_temp, & ! INOUT
                         2.d0)               ! IN
          !- Sum square values, result in statevector
          call gsv_add(statevector_temp, & ! IN
                       statevector)        ! INOUT
       end do

       !- Convert to StdDev
       call gsv_power(statevector, & ! INOUT
                      0.5d0)         ! IN

       !- Write to file
       if ( trim(mode) == 'FullPerturbations') then
          etiket = 'STDDEV_FULL'
       else
          write(wbnum,'(I2.2)') waveBandIndex
          etiket = 'STDDEV_WB' // trim(wbnum)
       end if
       call gsv_writeToFileMPI(statevector,'./ens_stddev.fst',etiket) ! IN
       call gsv_deallocate(statevector)
    end do

    call gsv_deallocate(statevector_temp)

  END SUBROUTINE EnsembleDiagnostic

END MODULE BMatrixEnsemble
