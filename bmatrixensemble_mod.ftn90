!--------------------------------------------------------------------------
! MODULE BmatrixEnsemble_mod (Background-error Covariance Matrix estimated
!                             using ensemble members and spatial localization
!                             prefix="ben")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    ben_setup (public)
!    ben_BSqrt (public)
!    ben_BSqrtAd (public)
!    setupLocalization
!    setupEnsemble
!    cain
!    cainAd
!    localizationSqrt
!    localizationSqrtAd
!    addEnsMember
!    addEnsMemberAd
!
! Dependencies:
!    glbspec_mod
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble_mod 

  implicit none
  save
  private

  public             :: ben_Setup,ben_BSqrt,ben_BSqrtAd

  real*8,allocatable :: ensLocalCor(:,:)
  real*8,allocatable :: ensPerturbations(:,:,:,:,:)
  integer            :: nibeg_l,niend_l,njbeg_l,njend_l,njsur_l,nisur_l,nj_l,ni_l
  integer            :: nflev_l,nkgdim_l
  integer            :: ntrunc_l,nla_l
  integer            :: nens_l,cvDim_l
  integer            :: ntime_l

CONTAINS

  SUBROUTINE BEN_setup(ZTLEN_IN,NTRUNC_IN,NI_IN,NJ_IN,NFLEV_IN,CVDIM_OUT)
    implicit none

    real*8         :: ztlen_in
    integer        :: ntrunc_in,ni_in,nj_in,nflev_in
    integer        :: cvDim_out

    nflev_l=nflev_in
    nkgdim_l=4*nflev_l+2  ! assume 4 3d and 2 2d variables

    ntrunc_l=ntrunc_in
    nla_l=(ntrunc_l+1)*(ntrunc_l+2)/2
    
    nisur_l=2
    njsur_l=2
    ni_l=ni_in
    nj_l=nj_in
    nibeg_l=0
    niend_l=ni_l+nisur_l
    njbeg_l=1-njsur_l
    njend_l=nj_l+njsur_l

    call setupLocalization(ztlen_in)

    call setupEnsemble

    cvDim_l=nens_l*((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)*nflev_l
    cvDim_out=cvDim_l

  END SUBROUTINE BEN_setup


  SUBROUTINE setupEnsemble
    implicit none

    ! parameters set from the ensemble member files
    nens_l=10
    ntime_l=5

    allocate(ensPerturbations(ni_l,nkgdim_l,nj_l,ntime_l,nens_l))

    ensPerturbations(:,:,:,:,:)=1.0d0
    ensPerturbations=ensPerturbations/sqrt(dble(nens_l))

  END SUBROUTINE setupEnsemble


  SUBROUTINE setupLocalization(ZTLEN)
    use glbspec_mod
    implicit none

    real*8 zlc,zr,zpole,zcorr,ztlen
    integer ilen,jn,jlat,jla,jlon,jk
    real*8,pointer :: zsp(:,:,:)
    real*8,pointer :: zgd(:,:,:)
    real*8         :: ra = 6371229.D0

    allocate(ensLocalCor(0:ntrunc_l,nflev_l))
    allocate(zgd(nibeg_l:niend_l,nflev_l,njbeg_l:njend_l))
    allocate(zsp(nla_l,2,nflev_l))

    ! Calculate 5th Order Correlation Functions in Physical Space

    ztlen=1000.0*ztlen
    if(ztlen.gt.0.0) then
       zlc=ztlen/2.0
       do jk=1,nflev_l
          do jlat=1,nj_l
             zr = ra * acos(gst_getrmu(jlat))
             if(zr.le.zlc) then
                zcorr= -0.250*(zr/zlc)**5 + 0.5*(zr/zlc)**4 + 0.625*(zr/zlc)**3 -(5.0/3.0)*(zr/zlc)**2 + 1.0
             elseif(zr.le.(2.0*zlc)) then
                zcorr= (1.0/12.0)*(zr/zlc)**5 -0.5*(zr/zlc)**4 + 0.625*(zr/zlc)**3 +(5.0/3.0)*(zr/zlc)**2 -   &
                     5.0*(zr/zlc) +4.0 -(2.0/3.0)*(zlc/zr) 
             else
                zcorr= 0.0
             endif
             write(300,*) 'LOCALIZATION FUNCTION1=',jk,jlat,zr/1000.0,zlc/1000.0,zcorr
             do jlon=1,ni_l
                zgd(jlon,jk,jlat)=zcorr
             enddo
          enddo
       enddo

       ! Transform to spectral space

       call gst_reespe(zsp,zgd,nflev_l,nflev_l)

       ! Copy over to EnsLocalCor and truncate to NTRUNC

       do jk=1,nflev_l
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=zsp(jn+1,1,jk)
          enddo
       enddo
       do jk=1,nflev_l
          do jn=ntrunc_l+1,nla_l
             zsp(jn,1,jk)=0.0
             zsp(jn,2,jk)=0.0
          enddo
       enddo

       call gst_speree(zsp,zgd,nflev_l,nflev_l)

       ! Make sure it's one at the pole

       do jk = 1,nflev_l
          do  jn = 0, ntrunc_l
             ensLocalCor(jn,jk)=abs(ensLocalCor(jn,jk))
          end do
       enddo
       do jk = 1,nflev_l
          zpole = 0.
          do  jn = 0, ntrunc_l
             zpole = zpole + ensLocalCor(jn,jk)*sqrt((2.*jn+1.)/2.)
          end do
          if(zpole.le.0.) then
             write(*,*)'POLE VALUE NEGATIVE IN SUMASK jk=',jk
          endif
          do jn = 0, ntrunc_l
             ensLocalCor(jn,jk) = ensLocalCor(jn,jk)/zpole
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo
       zsp(:,:,:)=0.0d0
       do jk=1,nflev_l
          do jn=0,ntrunc_l
             zsp(jn+1,1,jk)=ensLocalCor(jn,jk)
          enddo
       enddo
       call gst_speree(zsp,zgd,nflev_l,nflev_l)

       ! Convert back to correlations and take sqrt

       do jk=1,nflev_l
          do jn=0,ntrunc_l
             ensLocalCor(jn,jk)=sqrt(0.5*ensLocalCor(jn,jk)*((2.0/(2.0*jn+1.0))**0.5))
             !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
          enddo
       enddo

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocalCor to 1.0

       do jk=1,nflev_l
          ensLocalCor(0,jk)=1.0 
       enddo
    endif

    deallocate(zgd)
    deallocate(zsp)

    write(*,*)'done setting up localization function'

    return
  END SUBROUTINE setupLocalization


  SUBROUTINE BEN_BSqrt(controlVector_in,increment_out)
    implicit none

    real*8    :: controlVector_in(cvDim_l) 
    real*8    :: increment_out(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l,ntime_l)

    integer   :: memberIndex
    real*8    :: ensControlVector(nla_l,2,nflev_l)
    real*8    :: ensAmplitude(ni_l,nflev_l,nj_l)

    do memberIndex=1,nens_l
      call cain(controlVector_in,ensControlVector,memberIndex)
      call localizationSqrt(ensControlVector,ensAmplitude)
      call addEnsMember(ensAmplitude,increment_out,memberIndex)
    enddo

    return
  END SUBROUTINE BEN_BSqrt


  SUBROUTINE BEN_BSqrtAd(increment_in,controlVector_out)
    implicit none

    real*8    :: controlVector_out(cvDim_l) 
    real*8    :: increment_in(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l)

    integer   :: memberIndex
    real*8    :: ensControlVector(nla_l,2,nflev_l) 
    real*8    :: ensAmplitude(ni_l,nflev_l,nj_l)

    do memberIndex=1,nens_l
      call addEnsMemberAd(increment_in,ensAmplitude,memberIndex)
      call localizationSqrtAd(ensAmplitude,ensControlVector)
      call cainAd(ensControlVector,controlVector_out,memberIndex)
    enddo

    return
  END SUBROUTINE BEN_BSqrtAd


  SUBROUTINE addEnsMember(ensAmplitude_in,increment_out,memberIndex)
    implicit none

    integer     :: memberIndex
    real*8      :: ensAmplitude_in(ni_l,nflev_l,nj_l)
    real*8      :: increment_out(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l,ntime_l)

    integer     :: jk,jlev,jt,jj,ji

    !$OMP PARALLEL
    !$OMP DO PRIVATE (JK,JLEV,JT,JJ,JI)
    do jk=1,nkgdim_l
      jlev=mod(jk-1,nflev_l)+1
      do jt=1,ntime_l
        do jj=1,nj_l
          do ji=1,ni_l
            increment_out(ji,jk,jj,jt)=increment_out(ji,jk,jj,jt) +   &
              ensAmplitude_in(ji,jlev,jj)*ensPerturbations(ji,jk,jj,jt,memberIndex)
          enddo
        enddo
      enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

  END SUBROUTINE addEnsMember


  SUBROUTINE addEnsMemberAd(increment_in,ensAmplitude_out,memberIndex)
    implicit none

    integer     :: memberIndex
    real*8      :: ensAmplitude_out(ni_l,nflev_l,nj_l)
    real*8      :: increment_in(nibeg_l:niend_l,nkgdim_l,njbeg_l:njend_l,ntime_l)

    integer     :: jk,jlev,jt,jj,ji

    !$OMP PARALLEL
    !$OMP DO PRIVATE (JK,JLEV,JT,JJ,JI)
    do jk=1,nkgdim_l
      jlev=mod(jk-1,nflev_l)+1
      do jt=1,ntime_l
        do jj=1,nj_l
          do ji=1,ni_l
            ensAmplitude_out(ji,jlev,jj)=ensAmplitude_out(ji,jlev,jj) +   &
              increment_in(ji,jk,jj,jt)*ensPerturbations(ji,jk,jj,jt,memberIndex)
          enddo
        enddo
      enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

  END SUBROUTINE addEnsMemberAd


  SUBROUTINE localizationSqrt(ensControlVector_in,ensAmplitude_out)
    use glbspec_mod
    implicit none

    real*8           :: ensControlVector_in(nla_l,2,nflev_l)
    real*8           :: ensAmplitude_out(ni_l,nflev_l,nj_l)
    real*8           :: zsp(nla_l,2,nflev_l)
    integer          :: jlev,jn,jm,ila,jla
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)

    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JLEV,JN,JM,ILA,JLA)
    do jlev=1,nflev_l
       do jn=0,ntrunc_l
          do jm=0,jn
             ila = gst_getnind(jm)+jn-jm
             zsp(ila,1,jlev)=ensControlVector_in(ila,1,jlev)*ensLocalCor(jn,jlev)
             zsp(ila,2,jlev)=ensControlVector_in(ila,2,jlev)*ensLocalCor(jn,jlev)
          enddo
       enddo
       do jla = 1,ntrunc_l+1
          zsp(jla,1,jlev) = ensControlVector_in(jla,1,jlev)*rsq2
          zsp(jla,2,jlev) = 0.0
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

    call gst_speree(zsp,ensAmplitude_out,nflev_l,nflev_l)

  END SUBROUTINE localizationSqrt


  SUBROUTINE localizationSqrtAd(ensAmplitude_in,ensControlVector_out)
    use glbspec_mod
    implicit none

    real*8           :: ensControlVector_out(nla_l,2,nflev_l)
    real*8           :: ensAmplitude_in(ni_l,nflev_l,nj_l)
    real*8           :: zgd(ni_l,nflev_l,nj_l)
    integer          :: jlev
    integer          :: jn,jm,ila,jla
    integer          :: ji,jj
    real*8           :: rsq2

    rsq2=sqrt(2.0d0)

    ! this is from bilinad
    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JJ,JLEV,JI)
    do jj = 1, nj_l
       do jlev=1,nflev_l
          do ji = 1, ni_l
             zgd(ji,jlev,jj)=ensAmplitude_in(ji,jlev,jj)*ni_l/gst_getrwt(jj)
          enddo
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

    call gst_reespe(ensControlVector_out,zgd,nflev_l,nflev_l)

    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JLEV,JN,JM,ILA,JLA)
    do jlev=1,nflev_l
       do jn=0,ntrunc_l
          do jm=0,jn
             ila = gst_getnind(jm)+jn-jm
             ensControlVector_out(ila,1,jlev)=ensControlVector_out(ila,1,jlev)*ensLocalCor(jn,jlev)
             ensControlVector_out(ila,2,jlev)=ensControlVector_out(ila,2,jlev)*ensLocalCor(jn,jlev)
          enddo
       enddo
       do jla = 1,ntrunc_l+1
          ensControlVector_out(jla,1,jlev) = ensControlVector_out(jla,1,jlev)*rsq2
          ensControlVector_out(jla,2,jlev) = 0.0
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

  END SUBROUTINE localizationSqrtAd


  SUBROUTINE cain(controlVector_in,ensControlVector_out,memberIndex)
    implicit none

    integer   :: memberIndex
    real*8    :: controlVector_in(cvDim_l)
    real*8    :: ensControlVector_out(nla_l,2,nflev_l)

    integer   :: jdim,jlev,jla,jvar,jens

    jdim = (memberIndex-1)*((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)
    do jlev = 1, nflev_l
      do jla = 1, ntrunc_l + 1
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        ensControlVector_out(jla,2,jlev) = 0.0
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        ensControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        jdim = jdim + 1
        ensControlVector_out(jla,2,jlev) = controlVector_in(jdim)
      enddo
    enddo

    return
  END SUBROUTINE cain


  SUBROUTINE cainAd(ensControlVector_in,controlVector_out,memberIndex)
    implicit none

    integer    :: memberIndex
    real*8     :: controlVector_out(cvDim_l)
    real*8     :: ensControlVector_in(nla_l,2,nflev_l)

    integer kdim,jdim,jlev,jla,jvar,ji,jj

    jdim = (memberIndex-1)*((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)
    do jlev = 1, nflev_l
      do jla = 1, ntrunc_l + 1
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,1,jlev)*2.0d0
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + ensControlVector_in(jla,2,jlev)*2.0d0
      enddo
    enddo

    return
  END SUBROUTINE cainAd


END MODULE BMatrixEnsemble_mod

