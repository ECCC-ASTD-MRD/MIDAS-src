!--------------------------------------------------------------------------
! MODULE BmatrixEnsemble (Background-error Covariance Matrix estimated
!                         using ensemble members and spatial localization
!                         prefix="ben")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    ben_setup (public)
!    ben_BSqrt (public)
!    ben_BSqrtAd (public)
!    setupLocalization
!    setupEnsemble
!    localizationSqrt
!    localizationSqrtAd
!    addEnsMember
!    addEnsMemberAd
!
! Dependencies:
!    globalSpectralTransform
!    matsqrt
!--------------------------------------------------------------------------
MODULE BmatrixEnsemble
  use mpi
  use gridStateVector_mod
  use globalSpectralTransform
  use lamSpectralTransform_mod
  use horizontalCoord_mod
  implicit none
  save
  private

  public             :: ben_Setup,ben_BSqrt,ben_BSqrtAd,ben_reduceToMPILocal,ben_expandToMPIGlobal,ben_Finalize

  logical             :: initialized = .false.
  integer,parameter   :: maxNumLevels=200
  real(8)              :: scaleFactor(maxNumLevels)
  real(8)              :: scaleFactorLQ(maxNumLevels)
  real(8),allocatable  :: ensLocalCor(:,:)
  real(8),allocatable  :: ensLocalVert(:,:)
  integer,allocatable :: nip1_l(:),verticalLevel(:,:),verticalLevelEns(:)
  integer,allocatable :: jn_vec(:)
  integer             :: nj_l,ni_l,latPerPE,myLatBeg,myLatEnd
  integer             :: nLevInc,nkgdimInc,nLevEns,nkgdimEns,topLevIndex
  integer             :: myMemBeg,myMemEnd,myMemCount
  integer             :: ntrunc_l,nla_l,nphase
  integer             :: nEns,cvDim_l,cvDim_mpiglobal
  integer             :: ntime_l
  integer             :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg
  integer             :: gstID
  character(len=256)  :: enspathname,ensfilebasename
  integer             :: get_max_rss

  type :: struct_ens
    real(4), allocatable :: member(:,:,:,:)
  end type struct_ens
  type(struct_ens), pointer :: ensPerturbations(:)

  real(8), parameter :: rsq2=sqrt(2.0d0)

  type(struct_hco), pointer :: hco_ben    ! Analysis horizontal grid parameters
  type(struct_lst)          :: lst_ben    ! Spectral transform Parameters

CONTAINS

!--------------------------------------------------------------------------
! BEN_setup
!--------------------------------------------------------------------------
  SUBROUTINE BEN_setup(pressureProfile_in,hco_anl_in,NLEVINC_IN,NTIME_IN,NIP1_IN, &
                       stamp_in,CVDIM_OUT)
    implicit none

    type(struct_hco), pointer, intent(in)    :: hco_anl_in

    real(8)         :: hLocalize(2),vLocalize,pressureProfile_in(:)
    real(8),allocatable :: pressureProfileEns(:)

    integer        :: ntrunc,nLevInc_in,ntime_in,nip1_in(:),stamp_in
    integer        :: cvDim_out
    integer        :: jlev,jn,jm,jproc,ila,mpiMode,return_code
    integer        :: fnom,fclos,ierr,nulnam

    !namelist
    NAMELIST /NAMBEN/nEns,scaleFactor,scaleFactorLQ,ntrunc,enspathname,ensfilebasename,nLevEns,hLocalize,vLocalize

    !
    !- 1.  Read namelist-dependent options
    !

    ! parameters from namelist (date in filename should come directly from sequencer?)
    scaleFactor(:)  = 0.0d0
    scaleFactorLQ(:)= 1.0d0
    nEns            = 10
    ntrunc          = 31
    nLevEns         = nLevInc_in
    enspathname     = '***NOT_DEFINED***'
    ensfilebasename = ''
    hLocalize(1)    = 2800.0d0
    hLocalize(2)    = -1.0d0
    vLocalize       = 2.0d0

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namben,iostat=ierr)
    if(ierr.ne.0) call abort3d('ben_setup: Error reading namelist')
    write(*,nml=namben)
    ierr=fclos(nulnam)

    !
    !- 2.  Settings
    !

    hco_ben => hco_anl_in

    !- 2.1 Globa or LAM?
    if (hco_ben % global) then
      write(*,*)
      write(*,*) 'bmatrixEnsemble: GLOBAL mode activated'
    else
      write(*,*)
      write(*,*) 'bmatrixEnsemble: LAM mode activated'
    end if

    !- 2.1 Bmatrix Weight
    do jlev=1,nLevEns
      if(scaleFactor(jlev).gt.0.0d0) then 
        scaleFactor(jlev)=sqrt(scaleFactor(jlev))
      else
        scaleFactor(jlev)=0.0d0
      end if
    end do
    do jlev=1,nLevEns
      if(scaleFactorLQ(jlev).gt.0.0d0) then 
        scaleFactorLQ(jlev)=sqrt(scaleFactorLQ(jlev))
      else
        scaleFactorLQ(jlev)=0.0d0
      end if
    end do

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bmatrixEnsemble: scaleFactor=0, skipping rest of setup'
      cvdim_out=0
      initialized = .true.
      return
    end if

    !- 2.2. Levels
    if(nLevEns.gt.nLevInc_in) then
      call abort3d('bmatrixEnsemble: ensemble has more levels than increment - not allowed!')
    end if

    if(nLevEns.lt.nLevInc_in) then
      write(*,*) 'bmatrixEnsemble: ensemble has less levels than increment'
      write(*,*) '                 some levels near top will have zero increment'
    end if

    nLevInc=nLevInc_in
    nkgdimInc=4*nLevInc+2  ! assume 4 3d and 2 2d variables
    nkgdimEns=4*nLevEns+2  ! assume 4 3d and 2 2d variables
    topLevIndex=nLevInc-nLevEns+1

    allocate(verticalLevel(nLevEns,6),stat=ierr)
    verticalLevel(:,:)=0
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=1',ierr
      call abort3d('aborting in ben_setup')
    end if
    do jlev=1,nLevEns
      verticalLevel(jlev,1) =           jlev ! UU
      verticalLevel(jlev,2) = 1*nLevEns+jlev ! VV
      verticalLevel(jlev,3) = 2*nLevEns+jlev ! TT
      verticalLevel(jlev,4) = 3*nLevEns+jlev ! HU
    end do
    verticalLevel(nLevEns,5) = 4*nLevEns+1 ! P0
    verticalLevel(nLevEns,6) = 4*nLevEns+2 ! TG

    allocate(verticalLevelEns(nkgdimEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=2',ierr
      call abort3d('aborting in ben_setup')
    end if
    do jlev=1,nLevEns
      verticalLevelEns(           jlev)=jlev ! UU
      verticalLevelEns(1*nLevEns+jlev)=jlev ! VV
      verticalLevelEns(2*nLevEns+jlev)=jlev ! TT
      verticalLevelEns(3*nLevEns+jlev)=jlev ! HU
    end do
    verticalLevelEns(4*nLevEns+1)=nLevEns   ! P0
    verticalLevelEns(4*nLevEns+2)=nLevEns   ! TG

    allocate(nip1_l(nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=4',ierr
      call abort3d('aborting in ben_setup')
    end if
    nip1_l(1:nLevEns)=nip1_in(topLevIndex:nLevInc)

    !- 2.3 Distribute members in control vector over mpi processes
    call mpi_setup_levels(nEns,myMemBeg,myMemEnd,myMemCount)
    write(*,*) 'ben_setup: myMemBeg,End,Count=',myMemBeg,myMemEnd,myMemCount

    if(myMemCount.le.0) then
      write(*,*) 'ERROR: Number of MPI processes must be >= number of ensemble members'
      call abort3d('ben_setup')
    end if

    !- 2.4 Domain Partionning
    ni_l = hco_ben % ni
    nj_l = hco_ben % nj
    call mpi_setup_latbands(nj_l,latPerPE,myLatBeg,myLatEnd)

    !- 2.5 Time bin number
    if(ntime_in.eq.1.or.ntime_in.eq.5.or.ntime_in.eq.7) then
      ntime_l=ntime_in
    else
      call abort3d('Invalid value for NTIME (choose 1 or 5 or 7)!')
    end if

    !- 2.6 Spectral Transform
    ntrunc_l=ntrunc

    if (hco_ben % global) then

      ! Global Mode
      nphase=2
      nla_l=(ntrunc_l+1)*(ntrunc_l+2)/2

      mpiMode=3
      gstID = gst_setup(6,ni_l,nj_l,ntrunc_l,mpiMode,nEns)
      write(*,*) 'BEN : returned value of gstID = ',gstID

      allocate(jn_vec(nla_l),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=5',ierr
        call abort3d('aborting in ben_setup')
      end if
      do jn=0,ntrunc_l
        do jm=0,jn
          ila = gst_getnind(jm,gstID)+jn-jm
          jn_vec(ila)=jn
        end do
      end do

    else

       ! LAM mode
       call lst_Setup( lst_ben,                              & ! OUT
                       ni_l, nj_l, hco_ben % dlon, ntrunc_l, & ! IN
                       'LatLev', nEns )                        ! IN

       write(*,*) 'BEN : returned value of lstID = ', lst_ben % id
       nphase = lst_ben % nphase
       nla_l  = lst_ben % nla

    end if

    !- 2.7 Localization
    allocate(pressureProfileEns(nLevEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=6',ierr
      call abort3d('aborting in ben_setup')
    end if
    pressureProfileEns(1:nLevEns)=pressureProfile_in(topLevIndex:nLevInc)
    call setupLocalization(hLocalize,vLocalize,pressureProfileEns)
    deallocate(pressureProfileEns)

    !
    !- 3.  Read/Process the Ensemble
    !
    call setupEnsemble_latbands(stamp_in,return_code)
    if ( return_code .lt. 0 ) then
      ! could not open local ensemble files, try global files
      call setupEnsemble(stamp_in)
    end if

    if (hco_ben % global) then
      cvDim_mpiglobal = ((ntrunc_l+1)*(ntrunc_l+1))*nLevEns*nEns
      cvDim_l         = ((ntrunc_l+1)*(ntrunc_l+1))*nLevEns*myMemCount
    else
      cvDim_mpiglobal = lst_ben % nlaGlobal * nphase * nLevEns * nEns
      cvDim_l         = nla_l               * nphase * nLevEns * myMemCount
    end if
    cvDim_out=cvDim_l

    !
    !- 4.  Ending
    !
    initialized = .true.

  END SUBROUTINE BEN_setup

!--------------------------------------------------------------------------
! BEN_finalize
!--------------------------------------------------------------------------
  SUBROUTINE BEN_finalize()
    implicit none
    integer :: memberIndex

    write(*,*) 'ben_finalize: deallocating B_ensemble arrays'
    do memberIndex = 1,nEns
      deallocate(ensPerturbations(memberIndex)%member)
    end do
    deallocate(ensPerturbations)
    deallocate(ensLocalCor)
    deallocate(ensLocalVert)

  END SUBROUTINE BEN_finalize

!--------------------------------------------------------------------------
! setupEnsemble
!--------------------------------------------------------------------------
  SUBROUTINE setupEnsemble(stamp_in)
    implicit none
 
    integer :: stamp_in
    real(8) :: gd2d(ni_l,nj_l)
    real(4), allocatable :: ensPerturbation1(:,:,:,:) 
    real(8) :: dnens,dnens2,rmsknt,rmbtpa,r1sa
    real(8) :: rhumin = 2.5d-6
    integer :: ji,jj,jt,jk,memberIndex,jpe,jlatband
    integer :: memberIndex2,batchnum,nsize,status,pe_src,pe_dest
    integer :: kulin,ndate,ntime
    integer :: readFilePE(256),allLatBeg(256),allLatEnd(256)
    integer :: stamp_last,newdate
    real(8)  :: delhh
    logical :: lExists

    ! standard file variables
    integer ini,inj,ink,ip1,ip2(9),ip3,ierr,idateo(7),ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket
    character(len=256) :: cflensin
    character(len=4)   :: censnumber
    character(len=8)   :: datestr_last
    character(len=2)   :: hourstr_last
    integer :: vfstlir,fstfrm,fclos,fnom,fstouv,rpn_comm_datyp


    call tmg_start(12,'PRE_SUENS')

    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nLevEns
    ngposittt=1+2*nLevEns
    ngpositq =1+3*nLevEns
    ngpositps=1+4*nLevEns
    ngposittg=2+4*nLevEns

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    allocate(ensPerturbations(nEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7.1',ierr
      call abort3d('aborting in ben setupEnsemble')
    end if
    do memberIndex = 1,nEns
      allocate(ensPerturbations(memberIndex)%member(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7.2',ierr,memberIndex
        call abort3d('aborting in ben setupEnsemble')
      end if
    end do
    allocate(ensPerturbation1(ni_l,nkgdimEns,nj_l,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=8',ierr
      call abort3d('aborting in ben setupEnsemble')
    end if

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)

    CALL rpn_comm_allgather(myLatBeg,1,"mpi_integer",       &
                            allLatBeg,1,"mpi_integer","GRID",ierr)
    CALL rpn_comm_allgather(myLatEnd,1,"mpi_integer",       &
                            allLatEnd,1,"mpi_integer","GRID",ierr)

    do memberIndex=1,nEns
      readFilePE(memberIndex)=mod(memberIndex-1,mpi_nprocs)
    end do

    delhh = -6.0
    call incdatr(stamp_last,stamp_in,delhh)
    ierr = newdate(stamp_last,ndate,ntime,-3)
    write(datestr_last,'(i8.8)') ndate
    write(hourstr_last,'(i2.2)') ntime/1000000
    write(*,*) 'DATE,TIME=',ndate,'  ,',ntime

    if(ntime_l.eq.1) then
      call incdatr(idateo(1),stamp_in, 0.0d0)
    elseif(ntime_l.eq.5) then
      call incdatr(idateo(1),stamp_in,-3.0d0)
      call incdatr(idateo(2),stamp_in,-1.5d0)
      call incdatr(idateo(3),stamp_in, 0.0d0)
      call incdatr(idateo(4),stamp_in, 1.5d0)
      call incdatr(idateo(5),stamp_in, 3.0d0)
    elseif(ntime_l.eq.7) then
      call incdatr(idateo(1),stamp_in,-3.0d0)
      call incdatr(idateo(2),stamp_in,-2.0d0)
      call incdatr(idateo(3),stamp_in,-1.0d0)
      call incdatr(idateo(4),stamp_in, 0.0d0)
      call incdatr(idateo(5),stamp_in, 1.0d0)
      call incdatr(idateo(6),stamp_in, 2.0d0)
      call incdatr(idateo(7),stamp_in, 3.0d0)
    else
      write(*,*) 'bmatrixEnsemble: Problem with number of timesteps for ensemble=',ntime_l
      call abort3d('aborting in ben setupEnsemble')
    end if
    ip2=-1
    ip3=-1
    cltypvar = ' '
    cletiket = ' '

    write(*,*) 'idateo=',idateo(1:ntime_l)

    do memberIndex=1,nEns
      if(mpi_myid.eq.readFilePE(memberIndex)) then

        ! first try to open file with 4 digit member number
        write(censnumber,'(i4.4)') memberIndex
        cflensin= trim(enspathname) // '/' // trim(ensfilebasename) // &
                  trim(datestr_last) // trim(hourstr_last) // '_006_' // trim(censnumber)
        inquire(file=cflensin,exist=lExists)
        if(lExists) then
          kulin=0
          ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
        else
          ! now try to open file with (older) 3 digit member number
          write(censnumber,'(i3.3)') memberIndex
          cflensin= trim(enspathname) // '/' // trim(ensfilebasename) // &
                    trim(datestr_last) // trim(hourstr_last) // '_006_' // trim(censnumber)
          inquire(file=cflensin,exist=lExists)
          if(lExists) then
            kulin=0
            ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
          else
            write(*,*) 'filename=',trim(cflensin)
            call abort3d('ben setupEnsemble: Could not open ensemble file')
          end if
        end if
        ierr = fstouv(kulin,'RND+OLD')

        write(*,*) 'Reading ',ntime_l,' time slices for ensemble member:',trim(cflensin)
        write(*,*) 'reading member:',memberIndex

        do jt=1,ntime_l  ! read all timesteps

          clnomvar = 'P0' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,-1,ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            call abort3d('SUENS: Problem with P0 ENS')
          end if
          do jj=1,nj_l
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbation1(ji,ngpositps,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmbtpa)
              else
                 ensPerturbation1(ji,ngpositps,jj,jt)= sngl(gd2d(ji,jj)*rmbtpa)
              end if
            end do
          end do

          do jk=1,nLevEns
            clnomvar = 'TT'
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
              call abort3d('SUENS: Problem with TT ENS')
            end if
            do jj=1,nj_l
              do ji=1,ni_l
                if (hco_ben % global) then
                   ensPerturbation1(ji,jk-1+ngposittt,jj,jt)= sngl(gd2d(ji,nj_l+1-jj))
                else
                   ensPerturbation1(ji,jk-1+ngposittt,jj,jt)= sngl(gd2d(ji,jj))
                end if
              end do
            end do
          end do

          do jk=1,nLevEns
            clnomvar = 'HU' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
              call abort3d('SUENS: Problem with HU ENS')
            end if
            do jj=1,nj_l
              do ji=1,ni_l
                if (hco_ben % global) then
                   ensPerturbation1(ji,jk-1+ngpositq,jj,jt)= sngl(log(max(gd2d(ji,nj_l+1-jj),rhumin)))
                else
                   ensPerturbation1(ji,jk-1+ngpositq,jj,jt)= sngl(log(max(gd2d(ji,jj),rhumin)))
                end if
              end do
            end do
          end do

          do jk=1,nLevEns
            clnomvar = 'UU' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
              call abort3d('SUENS: Problem with UU ENS')
            end if
            do jj=1,nj_l
              do ji=1,ni_l
                if (hco_ben % global) then
                   ensPerturbation1(ji,jk-1+ngposituu,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmsknt)
                else
                   ensPerturbation1(ji,jk-1+ngposituu,jj,jt)= sngl(gd2d(ji,jj)*rmsknt)
                end if
              end do
            end do
          end do

          do jk=1,nLevEns
            clnomvar = 'VV' 
            ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
              call abort3d('SUENS: Problem with VV ENS')
            end if
            do jj=1,nj_l
              do ji=1,ni_l
                if (hco_ben % global) then
                   ensPerturbation1(ji,jk-1+ngpositvv,jj,jt)= sngl(gd2d(ji,nj_l+1-jj)*rmsknt)
                else
                   ensPerturbation1(ji,jk-1+ngpositvv,jj,jt)= sngl(gd2d(ji,jj)*rmsknt)
                end if
              end do
            end do
          end do

          clnomvar = 'TG' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,-1,ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0)  then
            write(*,*) idateo(jt),cletiket,ip2,ip3,cltypvar,clnomvar
            call abort3d('SUENS: Problem with TG ENS')
          else
            do jj=1,nj_l
              do ji=1,ni_l
                if (hco_ben % global) then
                   ensPerturbation1(ji,ngposittg,jj,jt)= sngl(gd2d(ji,nj_l+1-jj))
                else
                   ensPerturbation1(ji,ngposittg,jj,jt)= sngl(gd2d(ji,jj))
                end if
              end do
            end do
          end if

        end do

        ierr =  fstfrm(kulin)
        ierr =  fclos (kulin)

        write(*,*) 'done reading member ',memberIndex
      end if

      if(readFilePE(memberIndex).eq.(mpi_nprocs-1) .or. memberIndex.eq.nEns) then
        call tmg_start(13,'PRE_SUENS_COMM')
        batchnum=ceiling(dble(memberIndex)/dble(mpi_nprocs))

        ! for each read member, send each latitude band to the appropriate processor
        do memberIndex2=1+(batchnum-1)*mpi_nprocs,memberIndex
          do jlatband=1,mpi_nprocs
            pe_src=readFilePE(memberIndex2)
            pe_dest=jlatband-1

            if(pe_src.eq.pe_dest) then

              ! do copy if latband already on appropriate processor
              if(mpi_myid.eq.pe_src) then
                ensPerturbations(memberIndex2)%member(:,:,myLatBeg:myLatEnd,:)=  &
                ensPerturbation1(:,:,myLatBeg:myLatEnd,:)
              end if

            else

              ! send latitude band to appropriate processor
              if(mpi_myid.eq.pe_src) then
                nsize=ni_l*nkgdimEns*(allLatEnd(jlatband)-allLatBeg(jlatband)+1)*ntime_l
                call rpn_comm_send(ensPerturbation1(:,:,allLatBeg(jlatband):allLatEnd(jlatband),:),   &
                              nsize,"mpi_real4",pe_dest,pe_src*500+pe_dest,"GRID",ierr)
              end if

              ! receive the appropriate latitude band for this processor
              if(mpi_myid.eq.pe_dest) then
                nsize=ni_l*nkgdimEns*(allLatEnd(jlatband)-allLatBeg(jlatband)+1)*ntime_l
                call rpn_comm_recv(ensPerturbations(memberIndex2)%member(:,:,myLatBeg:myLatEnd,:),  &
                              nsize,"mpi_real4",pe_src,pe_src*500+pe_dest,"GRID",status,ierr)
              end if
    
            end if

          end do
        end do
        call tmg_stop(13)
      end if

    end do

    deallocate(ensPerturbation1)

    write(*,*) 'finished reading ensemble members...'

    ! remove mean and divide by sqrt(2*(NENS-1)) - extra 2 is needed?
    dnens=1.0d0/dble(nEns)
    do jt=1,ntime_l
!$OMP PARALLEL
!$OMP DO PRIVATE (JK,dnens2,GD2D,MEMBERINDEX,JJ,JI)
      do jk=1,nkgdimEns
        dnens2=scaleFactor(verticalLevelEns(jk))/sqrt(1.0d0*dble(nEns-1))
        if(jk.ge.(1+3*nLevEns) .and. jk.le.4*nLevEns) then
          dnens2=dnens2*scaleFactorLQ(verticalLevelEns(jk))
        end if
        gd2d(:,:)=0.0d0
        do memberIndex=1,nEns
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              gd2d(ji,jj)=gd2d(ji,jj)+dble(ensPerturbations(memberIndex)%member(ji,jk,jj,jt))
            end do
          end do
        end do
        do jj=myLatBeg,myLatEnd
          do ji=1,ni_l
            gd2d(ji,jj)=gd2d(ji,jj)*dnens
          end do
        end do
        do memberIndex=1,nEns
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              ensPerturbations(memberIndex)%member(ji,jk,jj,jt)=     &
                sngl((dble(ensPerturbations(memberIndex)%member(ji,jk,jj,jt))-gd2d(ji,jj))*dnens2)
            end do
          end do
        end do
      end do
!$OMP END DO
!$OMP END PARALLEL
    end do

    write(*,*) 'finished adjusting ensemble members...'
 
    call tmg_stop(12)

  END SUBROUTINE setupEnsemble

!--------------------------------------------------------------------------
! setupEnsemble_latbands
!--------------------------------------------------------------------------
  SUBROUTINE setupEnsemble_latbands(stamp_in,return_code)
    implicit none
 
    integer :: stamp_in,return_code
    real(8) :: gd2d(ni_l,myLatBeg:myLatEnd)
    real(8) :: dnens,dnens2,rmsknt,rmbtpa,r1sa
    real(8) :: rhumin = 2.5d-6
    integer :: ji,jj,jt,jk,memberIndex,memberIndex2,jpe,jlatband
    integer :: batchnum,nsize,status,pe_src,pe_dest
    integer :: kulin,ndate,ntime
    integer :: stamp_last,newdate
    real(8)  :: delhh
    logical :: lExists

    ! standard file variables
    integer ini,inj,ink,ip1,ip2(9),ip3,ierr,idateo(7),ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket
    character(len=256) :: cflensin
    character(len=4)   :: censnumber,latBandNumber,lonBandNumber
    character(len=8)   :: datestr_last
    character(len=2)   :: hourstr_last
    integer :: vfstlir,fstfrm,fclos,fnom,fstouv,rpn_comm_datyp


    call tmg_start(12,'PRE_SUENS')

    ! set OK value for return_code
    return_code = 0

    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nLevEns
    ngposittt=1+2*nLevEns
    ngpositq =1+3*nLevEns
    ngpositps=1+4*nLevEns
    ngposittg=2+4*nLevEns

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    allocate(ensPerturbations(nEns),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7.1',ierr
      call abort3d('aborting in ben setupEnsemble_latbands')
    end if
    do memberIndex = 1,nEns
      allocate(ensPerturbations(memberIndex)%member(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=7.2',ierr,memberIndex
        call abort3d('aborting in ben setupEnsemble_latbands')
      end if
    end do

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)

    delhh = -6.0
    call incdatr(stamp_last,stamp_in,delhh)
    ierr = newdate(stamp_last,ndate,ntime,-3)
    write(datestr_last,'(i8.8)') ndate
    write(hourstr_last,'(i2.2)') ntime/1000000
    write(*,*) 'DATE,TIME=',ndate,'  ,',ntime

    if(ntime_l.eq.1) then
      call incdatr(idateo(1),stamp_in, 0.0d0)
    elseif(ntime_l.eq.5) then
      call incdatr(idateo(1),stamp_in,-3.0d0)
      call incdatr(idateo(2),stamp_in,-1.5d0)
      call incdatr(idateo(3),stamp_in, 0.0d0)
      call incdatr(idateo(4),stamp_in, 1.5d0)
      call incdatr(idateo(5),stamp_in, 3.0d0)
    elseif(ntime_l.eq.7) then
      call incdatr(idateo(1),stamp_in,-3.0d0)
      call incdatr(idateo(2),stamp_in,-2.0d0)
      call incdatr(idateo(3),stamp_in,-1.0d0)
      call incdatr(idateo(4),stamp_in, 0.0d0)
      call incdatr(idateo(5),stamp_in, 1.0d0)
      call incdatr(idateo(6),stamp_in, 2.0d0)
      call incdatr(idateo(7),stamp_in, 3.0d0)
    else
      write(*,*) 'bmatrixEnsemble: Problem with number of timesteps for ensemble=',ntime_l
      call abort3d('aborting in ben setupEnsemble_latbands')
    end if
    ip2=-1
    ip3=-1
    cltypvar = ' '
    cletiket = ' '

    write(*,*) 'idateo=',idateo(1:ntime_l)

    ! latitude band is reverse order as proc id due to north-south flip
    write(latBandNumber,'(i4.4)') mpi_nprocs-mpi_myid
    lonBandNumber='0001'

    do memberIndex=1,nEns

      ! first try to open file with 4 digit member number
      write(censnumber,'(i4.4)') memberIndex

      !! try filename 'subdomain_0001_0024/2011020100_006_0013'
      cflensin= trim(enspathname) // '/subdomain_' // lonBandNumber // '_' // trim(latBandNumber) // '/' // &
                trim(ensfilebasename) // trim(datestr_last) // trim(hourstr_last) // &
                '_006_' // trim(censnumber)
      inquire(file=cflensin,exist=lExists)
      if(lExists) then
        kulin=0
        ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
      else

        write(censnumber,'(i3.3)') memberIndex
        !! try filename 'subdomain_0001_0024/2011020100_006_013'
        cflensin= trim(enspathname) // '/subdomain_' // lonBandNumber // '_' // trim(latBandNumber) // '/' // &
              trim(ensfilebasename) // trim(datestr_last) // trim(hourstr_last) // &
              '_006_' // trim(censnumber)
        inquire(file=cflensin,exist=lExists)
        if(lExists) then
          kulin=0
          ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
        else

          write(censnumber,'(i4.4)') memberIndex
          !! try filename 'latband_0024/2011020100_006_0013'
          cflensin= trim(enspathname) // '/latband_' // trim(latBandNumber) // '/' // &
               trim(ensfilebasename) // trim(datestr_last) // trim(hourstr_last) // &
               '_006_' // trim(censnumber)
          inquire(file=cflensin,exist=lExists)
          if(lExists) then
            kulin=0
            ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
          else
            write(censnumber,'(i3.3)') memberIndex
            !! try filename 'latband_0024/2011020100_006_013'
            cflensin= trim(enspathname) // '/latband_' // trim(latBandNumber) // '/' // &
                 trim(ensfilebasename) // trim(datestr_last) // trim(hourstr_last) // &
                 '_006_' // trim(censnumber)
            inquire(file=cflensin,exist=lExists)
            if(lExists) then
              kulin=0
              ierr = fnom(kulin,cflensin,'RND+OLD+R/O',0)
            else
              write(*,*) 'filename=',trim(cflensin)
              write(*,*) '============================================================================='
              write(*,*) 'ben setupEnsemble_latbands: Could not open ensemble file, trying global files'
              write(*,*) '============================================================================='
              return_code = -1
              do memberIndex2 = 1,nEns
                deallocate(ensPerturbations(memberIndex2)%member)
              end do
              deallocate(ensPerturbations)
              return
            end if
          end if
        end if
      end if
      write(*,*) 'ben setupEnsemble_latbands: opening file ', cflensin
      ierr = fstouv(kulin,'RND+OLD')

      write(*,*) 'Reading ',ntime_l,' time slices for ensemble member:',trim(cflensin)
      write(*,*) 'reading member:',memberIndex

      do jt=1,ntime_l  ! read all timesteps

        clnomvar = 'P0' 
        ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,-1,ip2,ip3,cltypvar,clnomvar)
        if(ikey.lt.0) then
          call abort3d('SUENS: Problem with P0 ENS')
        end if
        call CheckEnsDim(ini,inj,ink,clnomvar) ! IN
        do jj=myLatBeg,myLatEnd
          do ji=1,ni_l
            if (hco_ben % global) then
               ensPerturbations(memberIndex)%member(ji,ngpositps,jj,jt)= sngl(gd2d(ji,myLatEnd+myLatBeg-jj)*rmbtpa)
            else
               ensPerturbations(memberIndex)%member(ji,ngpositps,jj,jt)= sngl(gd2d(ji,jj)*rmbtpa)
            end if
          end do
        end do

        do jk=1,nLevEns
          clnomvar = 'TT'
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            call abort3d('SUENS: Problem with TT ENS')
          end if
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngposittt,jj,jt)= sngl(gd2d(ji,myLatEnd+myLatBeg-jj))
              else
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngposittt,jj,jt)= sngl(gd2d(ji,jj))
              end if
            end do
          end do
        end do

        do jk=1,nLevEns
          clnomvar = 'HU' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            call abort3d('SUENS: Problem with HU ENS')
          end if
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngpositq,jj,jt)= sngl(log(max(gd2d(ji,myLatEnd+myLatBeg-jj),rhumin)))
              else
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngpositq,jj,jt)= sngl(log(max(gd2d(ji,jj),rhumin)))
              end if
            end do
          end do
        end do

        do jk=1,nLevEns
          clnomvar = 'UU' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            call abort3d('SUENS: Problem with UU ENS')
          end if
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngposituu,jj,jt)= sngl(gd2d(ji,myLatEnd+myLatBeg-jj)*rmsknt)
              else
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngposituu,jj,jt)= sngl(gd2d(ji,jj)*rmsknt)
              end if
            end do
          end do
        end do

        do jk=1,nLevEns
          clnomvar = 'VV' 
          ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(*,*) idateo(jt),cletiket,nip1_l(jk),ip2,ip3,cltypvar,clnomvar
            call abort3d('SUENS: Problem with VV ENS')
          end if
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngpositvv,jj,jt)= sngl(gd2d(ji,myLatEnd+myLatBeg-jj)*rmsknt)
              else
                 ensPerturbations(memberIndex)%member(ji,jk-1+ngpositvv,jj,jt)= sngl(gd2d(ji,jj)*rmsknt)
              end if
            end do
          end do
        end do

        clnomvar = 'TG' 
        ikey = vfstlir(gd2d,kulin,ini,inj,ink,idateo(jt),cletiket,-1,ip2,ip3,cltypvar,clnomvar)
        if(ikey.lt.0)  then
          write(*,*) idateo(jt),cletiket,ip2,ip3,cltypvar,clnomvar
          call abort3d('SUENS: Problem with TG ENS')
        else
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              if (hco_ben % global) then
                 ensPerturbations(memberIndex)%member(ji,ngposittg,jj,jt)= sngl(gd2d(ji,myLatEnd+myLatBeg-jj))
              else
                 ensPerturbations(memberIndex)%member(ji,ngposittg,jj,jt)= sngl(gd2d(ji,jj))
              end if
            end do
          end do
        end if

      end do

      ierr =  fstfrm(kulin)
      ierr =  fclos (kulin)

      write(*,*) 'done reading member ',memberIndex

    end do

    write(*,*) 'finished reading ensemble members...'

    ! remove mean and divide by sqrt(2*(NENS-1)) - extra 2 is needed?
    dnens=1.0d0/dble(nEns)
    do jt=1,ntime_l
!$OMP PARALLEL
!$OMP DO PRIVATE (JK,dnens2,GD2D,MEMBERINDEX,JJ,JI)
      do jk=1,nkgdimEns
        dnens2=scaleFactor(verticalLevelEns(jk))/sqrt(1.0d0*dble(nEns-1))
        if(jk.ge.(1+3*nLevEns) .and. jk.le.4*nLevEns) then
          dnens2=dnens2*scaleFactorLQ(verticalLevelEns(jk))
        end if
        gd2d(:,:)=0.0d0
        do memberIndex=1,nEns
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              gd2d(ji,jj)=gd2d(ji,jj)+dble(ensPerturbations(memberIndex)%member(ji,jk,jj,jt))
            end do
          end do
        end do
        do jj=myLatBeg,myLatEnd
          do ji=1,ni_l
            gd2d(ji,jj)=gd2d(ji,jj)*dnens
          end do
        end do
        do memberIndex=1,nEns
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              ensPerturbations(memberIndex)%member(ji,jk,jj,jt)=     &
                sngl((dble(ensPerturbations(memberIndex)%member(ji,jk,jj,jt))-gd2d(ji,jj))*dnens2)
            end do
          end do
        end do
      end do
!$OMP END DO
!$OMP END PARALLEL
    end do

    write(*,*) 'finished adjusting ensemble members...'
    call tmg_stop(12)

  END SUBROUTINE setupEnsemble_latbands

!--------------------------------------------------------------------------
! CheckEnsDim
!--------------------------------------------------------------------------
  SUBROUTINE CheckEnsDim(niEns,njEns,nkEns,nomvar)
    implicit none

    integer,      intent(in) :: niEns,njEns,nkEns
    character(*), intent(in) :: nomvar

    if ( niEns /= ni_l      .or. &
         njEns /= latPerPE  .or. &
         nkEns /= 1 ) then

       write(*,*) 'Variable :', trim(nomvar)
       write(*,*) 'i-dim = ', niEns, ni_l
       write(*,*) 'j-dim = ', njEns, latPerPE
       write(*,*) 'k-dim = ', nkEns, 1
       call abort3d('Ensemble dimensions are incompatible with the topology and/or the analysis grid')
    end if

  END SUBROUTINE CheckEnsDim

!--------------------------------------------------------------------------
! setupLocalization
!--------------------------------------------------------------------------
  SUBROUTINE setupLocalization(hLocalize,vLocalize,pressureProfile)
    implicit none

    real(8)  :: zlc,zr,zpole,zcorr,hLocalize(:),vLocalize,pressureProfile(:)

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr

    real(8)  :: local_length(nLevEns)

    !
    !- 1. Allocation
    !
    allocate(ensLocalCor(0:ntrunc_l,nLevEns),stat=ierr)
    if (ierr.ne.0 ) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=9',ierr
      call abort3d('aborting in ben: setupLocalization')
    end if

    allocate(ensLocalVert(nLevEns,nLevEns),stat=ierr)
    if (ierr.ne.0 ) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=10',ierr
      call abort3d('aborting in ben: setupLocalization')
    end if

    !
    !- 2.  Compute HORIZONTAL localization correlation matrix
    !

    !- 2.1 Determine localization length scale for each vertical level
    if(hLocalize(2).lt.0.0d0) then
      ! vertically constant horizontal localization
      local_length(:)=hLocalize(1)
    else
      ! vertically varying horizontal localization (linear in log P)
      do jk=1,nLevEns
        local_length(jk)= ( hLocalize(1)*( log(pressureProfile(jk     ))-log(pressureProfile(1 )) ) +    &
                            hLocalize(2)*( log(pressureProfile(nLevEns))-log(pressureProfile(jk)) ) ) /  &
                          ( log(pressureProfile(nLevEns))-log(pressureProfile(1)) )
        write(*,*) 'bmatrixEnsemble: localization length scale (',jk,') = ',local_length(jk)
      end do      
    end if 

    !- 2.2. Compute matrix
    if (hco_ben % global) then
       call setupGlobalHLoc(local_length) ! IN
    else
       call setupLamHLoc(local_length) ! IN
    end if

    !
    !- 3.  Compute VERTICAL localization correlation matrix
    !
    
    !- 3.1 Calculate 5'th order function
    ZLC=vLocalize/2.0
    do jk1=1,nLevEns
      do jk2=1,nLevEns
        ZR = abs(log(pressureProfile(jk2)) - log(pressureProfile(jk1)))
        if(ZR.le.ZLC) then
          zcorr= -0.250*(ZR/ZLC)**5 + 0.5*(ZR/ZLC)**4 + 0.625*(ZR/ZLC)**3   &
                 -(5.0/3.0)*(ZR/ZLC)**2 + 1.0
        elseif(ZR.le.(2.0*ZLC)) then
          zcorr= (1.0/12.0)*(ZR/ZLC)**5   -0.5*(ZR/ZLC)**4     &
                   + 0.625*(ZR/ZLC)**3 +(5.0/3.0)*(ZR/ZLC)**2  &
                   - 5.0*(ZR/ZLC) +4.0 -(2.0/3.0)*(ZLC/ZR) 
        else
          zcorr= 0.0
        end if
        if(zcorr.lt.0.0) zcorr=0.0
        !write(95,*) 'VERT MASK=',jk1,jk2,zcorr
        ensLocalVert(jk1,jk2)=zcorr
      end do
    end do

    !- 3.2 Compute sqrt of the matrix if vertical localization requested
    call matsqrt(ensLocalVert(1,1),nLevEns,1.0d0)

    !
    !- 4.  Ending
    !
    write(*,*)'done setting up localization function'

    return
  END SUBROUTINE setupLocalization

!--------------------------------------------------------------------------
! FifthOrderCorrelFunction
!--------------------------------------------------------------------------
  function FifthOrderCorrelFunction(distance,halflength) result(correlation)
    implicit none

    real(8) :: distance, halflength
    real(8) :: correlation

    if ( distance <= halflength ) then
       correlation =      -0.250*(distance/halflength)**5  &
                     +       0.5*(distance/halflength)**4  &
                     +     0.625*(distance/halflength)**3  &
                     - (5.0/3.0)*(distance/halflength)**2  &
                     + 1.0
    else if ( distance <= (2.0*halflength) ) then
       correlation =  (1.0/12.0)*(distance/halflength)**5  &
                     -       0.5*(distance/halflength)**4  &
                     +     0.625*(distance/halflength)**3  &
                     + (5.0/3.0)*(distance/halflength)**2  &
                     -       5.0*(distance/halflength)     &
                     + 4.0                                 &
                     - (2.0/3.0)*(halflength/distance) 
    else
       correlation = 0.d0
    end if

  end function FifthOrderCorrelFunction

!--------------------------------------------------------------------------
! setupGlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupGlobalHLoc(local_length)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns)

    real(8) ::   zlc,zr,zpole,zcorr

    real(8)  :: zsp(nla_l,nphase,nLevEns)
    real(8)  :: zgd(ni_l,nLevEns,myLatBeg:myLatEnd)
    real(8)  :: zsp2(nla_l,nphase,nEns)
    real(8)  :: zgd2(ni_l,nEns,myLatBeg:myLatEnd)
    real(8)  :: ra = 6371229.D0

    integer :: ilen,jn,jlat,jla,jlon,jk,jk1,jk2,nsize,ierr

    if(local_length(1).gt.0.0) then

      do jk=1,nLevEns

        ! Calculate 5th Order Correlation Functions in Physical Space
        zlc=1000.0d0*local_length(jk)/2.0d0
        do jlat=myLatBeg,myLatEnd
          zr = ra * acos(gst_getrmu(jlat,gstID))
          zcorr = FifthOrderCorrelFunction(zr,zlc)
          !write(300,*) 'LOCALIZATION FUNCTION1=',jk,jlat,zr/1000.0,zlc/1000.0,zcorr
          do jlon=1,ni_l
            zgd(jlon,jk,jlat)=zcorr
          end do
        end do

        ! Transform to spectral space (extra manipulation because of mpi spectral transform)
        zsp2(:,:,:)=0.0d0
        zgd2(:,1,:)=zgd(:,jk,:)
        call gst_setID(gstID)
        call gst_reespe(zsp2,zgd2,nEns,nEns)
        call gst_setToDefaultID
        zsp(:,:,jk)=zsp2(:,:,1)

      end do

      nsize=nla_l*nphase*nLevEns
      call RPN_COMM_allreduce(zsp,zsp,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)

      ! Copy over to EnsLocalCor and truncate to NTRUNC
      do jk=1,nLevEns
        do jn=0,ntrunc_l
          ensLocalCor(jn,jk)=zsp(jn+1,1,jk)
        end do
      end do

      ! Make sure it's one at the pole
      do jk = 1,nLevEns
        do  jn = 0, ntrunc_l
          ensLocalCor(jn,jk)=abs(ensLocalCor(jn,jk))
        end do
      end do
      do jk = 1,nLevEns
        zpole = 0.
        do  jn = 0, ntrunc_l
          zpole = zpole + ensLocalCor(jn,jk)*sqrt((2.*jn+1.)/2.)
        end do
        if(zpole.le.0.) then
          write(*,*)'POLE VALUE NEGATIVE IN SUMASK jk=',jk
        end if
        do jn = 0, ntrunc_l
          ensLocalCor(jn,jk) = ensLocalCor(jn,jk)/zpole
          !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
        end do
      end do

      ! Convert back to correlations and take sqrt
      do jk=1,nLevEns
        do jn=0,ntrunc_l
          ensLocalCor(jn,jk)=sqrt(0.5*ensLocalCor(jn,jk)*((2.0/(2.0*jn+1.0))**0.5))
          !write(*,*) 'SUMASK: ENSLOCALCOR',jk,jn,ensLocalCor(jn,jk)
        end do
      end do

    else

       ! NO HORIZONTAL LOCALIZATION, set ensLocalCor to 1.0 for wavenumber 0
       do jk=1,nLevEns
          ensLocalCor(:,jk)=0.0d0
          ensLocalCor(0,jk)=1.0d0
       end do
    end if

    return
  END SUBROUTINE setupGlobalHLoc

!--------------------------------------------------------------------------
! setupLamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE setupLamHLoc(local_length)
    implicit none

    real(8), intent(in)  :: local_length(nLevEns)

    real(8), allocatable :: sp(:,:,:)
    real(8), allocatable :: gd(:,:,:)
    real(8), allocatable :: SumWeight(:)

    real(8) :: sum

    type(struct_lst)          :: lst_hloc    ! Spectral transform Parameters

    integer :: k, p, e, ila, totwvnb

    character(len=19)   :: kind

    if ( local_length(1) > 0.d0 ) then
      !
      !- 1. Enforce HORIZONTAL LOCALIZATION
      !

      !- 1.1 Setup a non-MPI spectral transform
      call lst_Setup( lst_hloc,                             & ! OUT
                      ni_l, nj_l, hco_ben % dlon, ntrunc_l, & ! IN
                      'NoMpi', nLevEns )                      ! IN

      !- 1.2 Create a correlation function in physical space
      allocate ( gd(ni_l,nj_l,nLevEns))

      call CreateBiPerCorrelFunction( gd,                   & ! OUT
                                      local_length, nLevEns ) ! IN

      !- 1.3 Transform to spectral space
      allocate ( sp(lst_hloc % nla, nphase, nLevEns))

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc % id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns )       ! IN
 
      !- 1.4 Compute band mean
      allocate(SumWeight(0:ntrunc_l))
      SumWeight(:) = 0.d0

      do totwvnb = 0, ntrunc_l
         do e = 1, lst_hloc % nePerK(totwvnb)
            ila = lst_hloc % ilaFromEK(e,totwvnb)
            do p = 1, lst_hloc % nphase
               SumWeight(totwvnb) = SumWeight(totwvnb) + lst_hloc % Weight(ila)
               do k = 1, nLevEns
                  ensLocalCor(totwvnb,k) = ensLocalCor(totwvnb,k) + lst_hloc % Weight(ila) * abs(sp(ila,p,k))
               end do
            end do
         end do
      end do
      
      do totwvnb = 0, ntrunc_l
         if (SumWeight(totwvnb) /= 0.d0) then
            ensLocalCor(totwvnb,:) = ensLocalCor(totwvnb,:) / SumWeight(totwvnb)
         else
            ensLocalCor(totwvnb,:) = 0.d0
         end if
      end do

      deallocate(SumWeight)
    
      !- 1.5 Normalization to one of correlation function from spectral densities: Part 1
!$OMP PARALLEL
!$OMP DO PRIVATE (totwvnb,k,sum)
      do k = 1, nLevEns
         sum = 0.0d0
         do totwvnb = 0, ntrunc_l
            sum = sum + real(totwvnb,8) * ensLocalCor(totwvnb,k)
         end do
         do totwvnb = 0, ntrunc_l
            if ( sum /= 0.0d0 ) then
               ensLocalCor(totwvnb,k) = ensLocalCor(totwvnb,k) / sum
            else
               ensLocalCor(totwvnb,k) = 0.d0
            end if
         end do
      end do
!$OMP END DO
!$OMP END PARALLEL

      !- 1.6 Normalization to one of correlation function from spectral densities: Part 2

      !- 1.6.1 Spectral transform of a delta function (at the center of the domain)
      gd(:,:,:) = 0.d0
      gd(ni_l/2,nj_l/2,:) = 1.d0

      kind = 'GridPointToSpectral'
      call lst_VarTransform( lst_hloc % id,      & ! IN
                             sp,                 & ! OUT
                             gd,                 & ! IN
                             kind, nLevEns )       ! IN

      !- 1.6.2 Apply the correlation function
!$OMP PARALLEL
!$OMP DO PRIVATE (totwvnb,e,ila,p,k)
      do totwvnb = 0, ntrunc_l
         do e = 1, lst_hloc % nePerK(totwvnb)
            ila = lst_hloc % ilaFromEK(e,totwvnb)
            do p = 1, nphase
               do k = 1, nLevEns
                  sp(ila,p,k) = sp(ila,p,k) * ensLocalCor(totwvnb,k) * &
                                lst_hloc % NormFactor(ila,p) * lst_hloc % NormFactorAd(ila,p)
               end do
            end do
         end do
      end do
!$OMP END DO
!$OMP END PARALLEL

      !- 1.6.3 Move back to physical space
      kind = 'SpectralToGridPoint'
      call lst_VarTransform( lst_hloc % id,      & ! IN
                             sp,                 & ! IN
                             gd,                 & ! OUT
                             kind, nLevEns )       ! IN

      !- 1.6.4 Normalize to 1
      do k = 1, nLevEns
         if ( mpi_myid == 0 ) then
           write(*,*) 'setupLamHLoc: Normalization factor = ', k, 1.d0 / gd(ni_l/2,nj_l/2,k)
         end if
         ensLocalCor(:,k) = ensLocalCor(:,k) / gd(ni_l/2,nj_l/2,k)
      end do

      !- 1.7 Take sqrt
      ensLocalCor(:,:) = sqrt(ensLocalCor(:,:))

      deallocate(sp)
      deallocate(gd)

    else
      !
      !- 2. NO HORIZONTAL LOCALIZATION: set ensLocalCor to 1.0 for wavenumber 0
      !
      ensLocalCor(:,:) = 0.0d0
      ensLocalCor(0,:) = 1.0d0
    end if

    return
  END SUBROUTINE setupLamHLoc

!--------------------------------------------------------------------------
! CreateBiPerCorrelFunction
!--------------------------------------------------------------------------
  SUBROUTINE  CreateBiPerCorrelFunction(gridpoint,CorrelLength,nk)
    use EarthConstants_mod, only: RA
    implicit none

    integer, intent(in)  :: nk

    real(8), intent(in)  :: CorrelLength(nk)

    real(8), intent(out) :: gridpoint(ni_l,nj_l,nk)

    integer          :: i, j, k, iref, jref
    real(8)          :: distance, distance_ref

    gridpoint(:,:,:) = 0.d0

    distance_ref = hco_ben % dlon * RA

    !
    !- Create a bi-periodic correlation function by centering the function in each 4 corners
    !

    !- Lower-Left Corner
    iref = 1
    jref = 1
    do j = 1, nj_l
       do i = 1,ni_l
          distance = distance_ref * sqrt( real((i-iref)**2 + (j-jref)**2,8) )
          do k = 1, nk
             gridpoint(i,j,k) = gridpoint(i,j,k) + FifthOrderCorrelFunction(distance,1000.d0*CorrelLength(k)/2.d0) 
          end do
       end do
    end do

    !- Upper-Left Corner
    iref = 1
    jref = nj_l
    do j = 1, nj_l
       do i = 1,ni_l
          distance = distance_ref * sqrt( real((i-iref)**2 + (j-jref)**2,8) )
          do k = 1, nk
             gridpoint(i,j,k) = gridpoint(i,j,k) + FifthOrderCorrelFunction(distance,1000.d0*CorrelLength(k)/2.d0) 
          end do
       end do
    end do

    !- Lower-Right Corner
    iref = ni_l
    jref = 1
    do j = 1, nj_l
       do i = 1,ni_l
          distance = distance_ref * sqrt( real((i-iref)**2 + (j-jref)**2,8) )
          do k = 1, nk
             gridpoint(i,j,k) = gridpoint(i,j,k) + FifthOrderCorrelFunction(distance,1000.d0*CorrelLength(k)/2.d0) 
          end do
       end do
    end do

    !- Upper-Right Corner
    iref = ni_l
    jref = nj_l
    do j = 1, nj_l
       do i = 1,ni_l
          distance = distance_ref * sqrt( real((i-iref)**2 + (j-jref)**2,8) )
          do k = 1, nk
             gridpoint(i,j,k) = gridpoint(i,j,k) + FifthOrderCorrelFunction(distance,1000.d0*CorrelLength(k)/2.d0) 
          end do
       end do
    end do

  END SUBROUTINE CreateBiPerCorrelFunction

!--------------------------------------------------------------------------
! BEN_reduceToMPILocal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(8)  :: cv_mpilocal(:)
    real(8)  :: cv_mpiglobal(:)
    integer :: cvDim_mpilocal_out

    integer :: jdim_mpilocal,jdim_mpiglobal,memberIndex,jlev,jla

    cvDim_mpilocal_out = cvDim_l

    jdim_mpilocal=0
    jdim_mpiglobal=0

    ! assign part of mpiglobal vector from current mpi process
    do memberIndex=1,nEns

      do jlev = 1,nlevEns
        do jla = 1, ((ntrunc_l+1)*(ntrunc_l+1))

          jdim_mpiglobal = jdim_mpiglobal + 1

          if(memberIndex.ge.myMemBeg.and.memberIndex.le.myMemEnd) then
            jdim_mpilocal = jdim_mpilocal + 1
            cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
          end if

        end do
      end do

    end do

  END SUBROUTINE BEN_reduceToMPILocal

!--------------------------------------------------------------------------
! BEN_expandToMPIGlobal
!--------------------------------------------------------------------------
  SUBROUTINE BEN_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none
    real(8)  :: cv_mpilocal(:)
    real(8)  :: cv_mpiglobal(:)
    integer :: cvDim_mpiglobal_out

    integer :: jdim_mpilocal,jdim_mpiglobal,memberIndex,jlev,jla,ierr

    cvDim_mpiglobal_out = cvDim_mpiglobal

    jdim_mpilocal=0
    jdim_mpiglobal=0

    ! initialize receiving global vector to zero
    cv_mpiglobal(:)=0.0d0

    ! assign part of mpiglobal vector from current mpi process
    do memberIndex=1,nEns

      do jlev = 1,nlevEns
        do jla = 1, ((ntrunc_l+1)*(ntrunc_l+1))

          jdim_mpiglobal = jdim_mpiglobal + 1

          if(memberIndex.ge.myMemBeg.and.memberIndex.le.myMemEnd) then
            jdim_mpilocal = jdim_mpilocal + 1
            cv_mpiglobal(jdim_mpiglobal) = cv_mpilocal(jdim_mpilocal)
          end if

        end do
      end do

    end do

    ! combine the contributions from all mpi processes
    call rpn_comm_allreduce(cv_mpiglobal,cv_mpiglobal,cvDim_mpiglobal,"mpi_double_precision","mpi_sum","GRID",ierr)

  end SUBROUTINE BEN_expandToMPIGlobal

!--------------------------------------------------------------------------
! BEN_BSqrt
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrt(controlVector_in,statevector)
    implicit none

    real(8)    :: controlVector_in(cvDim_l) 
    type(struct_gsv) :: statevector
    real(8),allocatable  :: incrementLocal(:,:,:,:)
    real(8)    :: ensAmplitude(ni_l,nEns,myLatBeg:myLatEnd)
    real(8)    :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)
    real(8)    :: zsp1(nla_l,nphase,nEns)
    real(8), pointer :: field(:,:,:,:)
    integer   :: jlev
    integer   :: ierr,nsize,jj,jk,ji,jt,jkInc,jvar,ilev1,ilev2,topLevOffset
    integer   :: rpn_comm_datyp,ens

    real(8), allocatable :: gd_out(:,:,:)
    character(len=19)   :: kind

    if(.not. initialized) then
      write(*,*) 'bMatrixEnsemble not initialized'
      return
    end if

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrt'
      return
    end if

    write(*,*) 'ben_bsqrt: starting'
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(incrementLocal(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=12',ierr
      call abort3d('aborting in ben_bsqrt')
    end if

!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,JK,JI)
    do jj=myLatBeg,myLatEnd
      do jk=1,nkgdimEns
        do ji=1,ni_l
          incrementLocal(ji,jk,jj,:)=0.0d0
        end do
      end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    call localizationSqrt(controlVector_in,zsp_all)

    do jlev=1,nLevEns

      ! now transform amplitude to grid-point space
      call rpn_comm_barrier("GRID",ierr)
      call tmg_start(64,'BEN_SPECTRAL')

      zsp1(:,:,myMemBeg:myMemEnd)=zsp_all(jlev,:,:,:)

      if (hco_ben % global) then
        call gst_setID(gstID)
        call gst_speree(zsp1,ensAmplitude,nEns,nEns)
        call gst_setToDefaultID
      else
        allocate( gd_out(ni_l,myLatBeg:myLatEnd,nEns) )
        kind = 'SpectralToGridPoint'
        call lst_VarTransform( lst_ben % id,            & ! IN
                               zsp1,                    & ! IN
                               gd_out,                  & ! OUT (i,j,k) !!!
                               kind, nEns )               ! IN
        !- reordering because of gd_out(i,j,k)
!$OMP PARALLEL
!$OMP DO PRIVATE(ens,jj,ji)        
        do ens = 1, nEns
          do jj = myLatBeg,myLatEnd
            do ji = 1, ni_l
              ensAmplitude(ji,ens,jj) = gd_out(ji,jj,ens)
            end do
          end do
        end do
!$OMP END DO
!$OMP END PARALLEL
        deallocate(gd_out)
      end if

      call tmg_stop(64)

      call addEnsMember(ensAmplitude,incrementLocal,jlev)

    end do

!$OMP PARALLEL
!$OMP DO PRIVATE(jj,jvar,field,ilev1,ilev2,topLevOffset,jt,jk,jkInc,ji)
    do jj=myLatBeg,myLatEnd
      do jvar=1,vnl_numvarmax 
        if(gsv_varExist(varnamelist(jvar))) then
          field => gsv_getField(statevector,varnamelist(jvar))
          if(varnamelist(jvar).eq.'UU  ') then
            ilev1=ngposituu
          elseif(varnamelist(jvar).eq.'VV  ') then
            ilev1=ngpositvv
          elseif(varnamelist(jvar).eq.'TT  ') then
            ilev1=ngposittt
          elseif(varnamelist(jvar).eq.'HU  ') then
            ilev1=ngpositq
          elseif(varnamelist(jvar).eq.'P0  ') then
            ilev1=ngpositps
          elseif(varnamelist(jvar).eq.'TG  ') then
            ilev1=ngposittg
          else
            call abort3d('ben_bsqrt: No covariances available for variable:' // varnamelist(jvar))
          end if
          if(vnl_vartypeFromVarname(varNameList(jvar)).eq.'SF') then
            ilev2=ilev1
            topLevOffset=1
          else
            ilev2=ilev1 - 1 + nlevEns
            topLevOffset= topLevIndex
          end if
          do jt=1,ntime_l
            do jk=ilev1,ilev2
              jkInc=jk-ilev1 + topLevOffset
              do ji=1,ni_l
                field(ji,jkInc,jj,jt)=incrementLocal(ji,jk,jj,jt)
              end do
            end do
          end do
        end if
      end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    deallocate(incrementLocal)

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    write(*,*) 'ben_bsqrt: done'

    return
  END SUBROUTINE BEN_BSqrt

!--------------------------------------------------------------------------
! BEN_BSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE BEN_BSqrtAd(statevector,controlVector_out)
    implicit none

    real(8)    :: controlVector_out(cvDim_l) 
    type(struct_gsv) :: statevector

    real(8)    :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)
    real(8)    :: zsp1(nla_l,nphase,nEns)
    real(8), pointer :: field(:,:,:,:)
    real(8),allocatable :: incrementLocal(:,:,:,:)
    real(8)    :: ensAmplitude(ni_l,nEns,myLatBeg:myLatEnd)
    real(8),allocatable    :: gd_in(:,:,:)

    integer   :: jlev,jj,jk,ji,jt,jkinc,nsize,ierr,jvar,ilev1,ilev2,topLevOffset
    integer   :: rpn_comm_datyp,rpn_comm_oper,ens

    character(len=19)   :: kind

    if(.not. initialized) then
      write(*,*) 'bMatrixEnsemble not initialized'
      return
    end if

    if(sum(scaleFactor).eq.0.0d0) then
      write(*,*) 'bMatrixEnsemble: scaleFactor=0, skipping bSqrtAd'
      return
    end if

    write(*,*) 'ben_bsqrtad: starting'
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(incrementLocal(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l),stat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'bmatrixEnsemble: Problem allocating memory! id=14',ierr
      call abort3d('aborting in ben_bsqrtad')
    end if

!$OMP PARALLEL
!$OMP DO PRIVATE(jj,jvar,field,ilev1,ilev2,topLevOffset,jt,jk,jkInc,ji)
    do jj=myLatBeg,myLatEnd
      do jvar=1,vnl_numvarmax 
        if(gsv_varExist(varnamelist(jvar))) then
          field => gsv_getField(statevector,varnamelist(jvar))
          if(varnamelist(jvar).eq.'UU  ') then
            ilev1=ngposituu
          elseif(varnamelist(jvar).eq.'VV  ') then
            ilev1=ngpositvv
          elseif(varnamelist(jvar).eq.'TT  ') then
            ilev1=ngposittt
          elseif(varnamelist(jvar).eq.'HU  ') then
            ilev1=ngpositq
          elseif(varnamelist(jvar).eq.'P0  ') then
            ilev1=ngpositps
          elseif(varnamelist(jvar).eq.'TG  ') then
            ilev1=ngposittg
          else
            call abort3d('ben_bsqrtad: No covariances available for variable:' // varnamelist(jvar))
          end if
          if(vnl_vartypeFromVarname(varNameList(jvar)).eq.'SF') then
            ilev2=ilev1
            topLevOffset=1
          else
            ilev2=ilev1 - 1 + nlevEns
            topLevOffset= topLevIndex
          end if
          do jt=1,ntime_l
            do jk=ilev1,ilev2
              jkInc=jk-ilev1 + topLevOffset
              do ji=1,ni_l
                incrementLocal(ji,jk,jj,jt)=field(ji,jkInc,jj,jt)
              end do
            end do
          end do
        end if
      end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    do jlev=1,nLevEns

      call addEnsMemberAd(incrementLocal,ensAmplitude,jlev)

      zsp1(:,:,:)=0.0d0 ! needed, not all levels set
      call rpn_comm_barrier("GRID",ierr)
      call tmg_start(64,'BEN_SPECTRAL')

      if (hco_ben % global) then
        call gst_setID(gstID)
        call gst_reespe(zsp1,ensAmplitude,nEns,nEns)
        call gst_setToDefaultID
      else
        allocate( gd_in(ni_l,myLatBeg:myLatEnd,nEns) )

        !- reordering because of gd_in(i,j,k)
!$OMP PARALLEL
!$OMP DO PRIVATE(ens,jj,ji)        
        do ens = 1, nEns
          do jj = myLatBeg, myLatEnd
            do ji = 1, ni_l
              gd_in(ji,jj,ens) = ensAmplitude(ji,ens,jj)
            end do
          end do
        end do
!$OMP END DO
!$OMP END PARALLEL

        kind = 'GridPointToSpectral'
        call lst_VarTransform( lst_ben % id,            & ! IN
                               zsp1,                    & ! OUT
                               gd_in,                   & ! IN (i,j,k) !!!
                               kind, nEns )               ! IN
        deallocate(gd_in)
      end if

      zsp_all(jlev,:,:,:)=zsp1(:,:,myMemBeg:myMemEnd)
      call tmg_stop(64)

    end do

    call localizationSqrtAd(zsp_all,controlVector_out)

    deallocate(incrementLocal)

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    write(*,*) 'ben_bsqrtad: done'

    return
  END SUBROUTINE BEN_BSqrtAd

!--------------------------------------------------------------------------
! addEnsMember
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMember(ensAmplitude_in,incrementLocal_out,levelIndex)
    implicit none

    integer,intent(in) :: levelIndex
    real(8)      :: ensAmplitude_in(ni_l,nEns,myLatBeg:myLatEnd)
    real(8)      :: incrementLocal_out(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l)

    integer     :: jvar,jlev,memberIndex,jt,jj,ji,numVar

    call tmg_start(62,'ADDMEM')

    if(levelIndex.eq.nLevEns) then
      ! surface level, 4 3D and 2 sfc fields
      numVar=6
    else
      ! above the surface, only 4 3D fields
      numVar=4
    end if

    do memberIndex=1,nEns
!$OMP PARALLEL
!$OMP DO PRIVATE (JT,JJ,JVAR,JLEV,JI)
      do jt=1,ntime_l
        do jj=myLatBeg,myLatEnd
          do jvar=1,numVar
            jlev=verticalLevel(levelIndex,jvar)
            do ji=1,ni_l
              incrementLocal_out(ji,jlev,jj,jt)=incrementLocal_out(ji,jlev,jj,jt) +   &
                ensAmplitude_in(ji,memberIndex,jj)*dble(ensPerturbations(memberIndex)%member(ji,jlev,jj,jt))
            end do
          end do
        end do
      end do
!$OMP END DO
!$OMP END PARALLEL
    end do

    call tmg_stop(62)

  END SUBROUTINE addEnsMember

!--------------------------------------------------------------------------
! addEnsMemberAd
!--------------------------------------------------------------------------
  SUBROUTINE addEnsMemberAd(incrementLocal_in,ensAmplitude_out,levelIndex)
    implicit none

    integer,intent(in) :: levelIndex
    real(8)      :: ensAmplitude_out(ni_l,nEns,myLatBeg:myLatEnd)
    real(8)      :: incrementLocal_in(ni_l,nkgdimEns,myLatBeg:myLatEnd,ntime_l)

    integer     :: jvar,jlev,memberIndex,jt,jj,ji,numVar

    call tmg_start(62,'ADDMEM')

    if(levelIndex.eq.nLevEns) then
      ! surface level, 4 3D and 2 sfc fields
      numVar=6
    else
      ! above the surface, only 4 3D fields
      numVar=4
    end if

!$OMP PARALLEL
!$OMP DO PRIVATE (JJ,memberIndex,JI)
    do jj=myLatBeg,myLatEnd
      do memberIndex=1,nEns
        do ji=1,ni_l
          ensAmplitude_out(ji,memberIndex,jj)=0.0d0
        end do
      end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    do jt=1,ntime_l
      do jvar=1,numVar
        jlev=verticalLevel(levelIndex,jvar)
!$OMP PARALLEL
!$OMP DO PRIVATE (memberIndex,JJ,JI)
        do memberIndex=1,nEns
          do jj=myLatBeg,myLatEnd
            do ji=1,ni_l
              ensAmplitude_out(ji,memberIndex,jj)=ensAmplitude_out(ji,memberIndex,jj) +   &
                incrementLocal_in(ji,jlev,jj,jt)*dble(ensPerturbations(memberIndex)%member(ji,jlev,jj,jt))
            end do
          end do
        end do
!$OMP END DO
!$OMP END PARALLEL
      end do
    end do

    call tmg_stop(62)

  END SUBROUTINE addEnsMemberAd

!--------------------------------------------------------------------------
! localizationSqrt
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrt(controlVector_in,zsp_all)
    implicit none

    real(8)           :: controlVector_in(cvDim_l)
    real(8)           :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer          :: jlev,jla,memberIndex,p

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ben % global) then
       call GlobalHLoc( zsp_all,         & ! OUT
                        controlVector_in ) ! IN
    else
       call LamHLoc( zsp_all,         & ! OUT
                     controlVector_in ) ! IN
    end if

    !
    !- 2.  Vertical localization
    !
    call tmg_start(63,'BEN_VLOC')

    call dgemul(ensLocalVert(1,1),nLevEns,'N',  &
                zsp_all(1,1,1,myMemBeg),nLevEns,'N',  &
                zsp_all(1,1,1,myMemBeg),nLevEns,  &
                nLevEns,nLevEns,nphase*nla_l*myMemCount)

    call tmg_stop(63)
    
  END SUBROUTINE localizationSqrt

!--------------------------------------------------------------------------
! GlobalHLoc
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLoc(zsp_all,controlVector_in)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_l)
    real(8), intent(out) :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer :: jlev,jla, jdim, memberIndex 

    jdim = 0

    do memberIndex=myMemBeg,myMemEnd

       call tmg_start(65,'BEN_CAIN')
       do jlev = 1,nLevEns
          do jla = 1, ntrunc_l+1
             jdim = jdim + 1
             zsp_all(jlev,jla,1,memberIndex) = controlVector_in(jdim)*ensLocalCor(jn_vec(jla),jlev)*rsq2
             zsp_all(jlev,jla,2,memberIndex) = 0.0
          end do
          do jla = ntrunc_l+2, nla_l
             jdim = jdim + 1
             zsp_all(jlev,jla,1,memberIndex) = controlVector_in(jdim)*ensLocalCor(jn_vec(jla),jlev)
             jdim = jdim + 1
             zsp_all(jlev,jla,2,memberIndex) = controlVector_in(jdim)*ensLocalCor(jn_vec(jla),jlev)
          end do
       end do
       if(jdim.gt.cvDim_l) then
          write(*,*) 'BEN: CAIN: jdim > cvDim! ',jdim,memberIndex,cvDim_l
          call abort3d('aborted in cain')
       end if
       call tmg_stop(65)

    end do

  END SUBROUTINE GlobalHLoc

!--------------------------------------------------------------------------
! LamHLoc
!--------------------------------------------------------------------------
  SUBROUTINE LamHLoc(zsp_all,controlVector_in)
    implicit none

    real(8), intent(in)  :: controlVector_in(cvDim_l)
    real(8), intent(out) :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer :: jlev,jla, jdim, memberIndex, p 

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = myMemBeg, myMemEnd

       call tmg_start(65,'BEN_CAIN')
       do jlev = 1,nLevEns
         do jla = 1, nla_l
            do p = 1, nphase
              jdim = jdim + 1
              zsp_all(jlev,jla,p,memberIndex) = controlVector_in(jdim)           * &
                                                ensLocalCor(lst_ben%k(jla),jlev) * &
                                                lst_ben % NormFactor(jla,p)
            end do
         end do
       end do
       if (jdim > cvDim_l ) then
          write(*,*) 'BEN: LamHLoc: jdim > cvDim! ',jdim,memberIndex,cvDim_l
          call abort3d('aborted in LamHLoc')
       end if
       call tmg_stop(65)

    end do

  END SUBROUTINE LamHLoc

!--------------------------------------------------------------------------
! localizationSqrtAd
!--------------------------------------------------------------------------
  SUBROUTINE localizationSqrtAd(zsp_all,controlVector_out)
    implicit none

    real(8) :: controlVector_out(cvDim_l)
    real(8) :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer          :: jlev,jla,memberIndex,p

    !
    !- 2.  Vertical Localization
    !
    call tmg_start(63,'BEN_VLOC')

    call dgemul(ensLocalVert(1,1),nLevEns,'N',  &
                zsp_all(1,1,1,myMemBeg),nLevEns,'N',  &
                zsp_all(1,1,1,myMemBeg),nLevEns,  &
                nLevEns,nLevEns,nphase*nla_l*myMemCount)

    call tmg_stop(63)

    !
    !- 1.  Horizontal Localization
    !
    if (hco_ben % global) then
      call GlobalHLocAd( zsp_all,           & ! IN
                         controlVector_out )  ! OUT
    else
      call LamHLocAd( zsp_all,           & ! IN
                      controlVector_out )  ! OUT
    end if

  END SUBROUTINE localizationSqrtAd

!--------------------------------------------------------------------------
! GlobalHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE GlobalHLocAd(zsp_all,controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_l)
    real(8), intent(in)    :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer          :: jla,jlev,jdim,memberIndex

    jdim = 0

    do memberIndex=myMemBeg,myMemEnd

       call tmg_start(65,'BEN_CAIN')
       do jlev = 1, nLevEns
          do jla = 1, ntrunc_l+1
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) + zsp_all(jlev,jla,1,memberIndex)*ensLocalCor(jn_vec(jla),jlev)*rsq2
          end do
          do jla = ntrunc_l+2, nla_l
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) + zsp_all(jlev,jla,1,memberIndex)*ensLocalCor(jn_vec(jla),jlev)*2.0d0
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) + zsp_all(jlev,jla,2,memberIndex)*ensLocalCor(jn_vec(jla),jlev)*2.0d0
         end do
       end do
       if(jdim.gt.cvDim_l) then
          write(*,*) 'BEN: CAINAD: jdim > cvDim! ',jdim,memberIndex,cvDim_l
          call abort3d('aborted in cainad')
       end if
       call tmg_stop(65)
    
    end do

  END SUBROUTINE GlobalHLocAd

!--------------------------------------------------------------------------
! LamHLocAd
!--------------------------------------------------------------------------
  SUBROUTINE LamHLocAd(zsp_all,controlVector_out)
    implicit none

    real(8), intent(out)   :: controlVector_out(cvDim_l)
    real(8), intent(in)    :: zsp_all(nLevEns,nla_l,nphase,myMemBeg:myMemEnd)

    integer          :: jla, jlev, jdim, memberIndex, p

    !
    !- Reshape + Horizontal localization + Scaling (parseval)
    !
    jdim = 0

    do memberIndex = myMemBeg, myMemEnd

       call tmg_start(65,'BEN_CAIN')
       do jlev = 1, nLevEns
         do jla = 1, nla_l
           do p = 1, nphase
             jdim = jdim + 1
             controlVector_out(jdim) = controlVector_out(jdim) +           &
                                       ( zsp_all(jlev,jla,p,memberIndex)  * &
                                         ensLocalCor(lst_ben%k(jla),jlev) * &
                                         lst_ben % NormFactorAd(jla,p)    )
           end do
         end do
       end do
       if (jdim > cvDim_l ) then
          write(*,*) 'BEN: LamHLocAD: jdim > cvDim! ',jdim, memberIndex, cvDim_l
          call abort3d('aborted in LamHLocAd')
       end if
       call tmg_stop(65)

    end do

  END SUBROUTINE LamHLocAd

END MODULE BMatrixEnsemble
