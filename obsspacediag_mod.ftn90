!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

module obsSpaceDiag_mod
!
! Author: Mark Buehner, ARMA.
!
! Revisions: M. Sitwell, ARQI (July 2015)
!            - Addition of 'use chem_mod' for constituents output.
!            - Addition of lrandom logical (see osd_setup)
!            Y. Rochon, ARQI (Oct 2015)
!            - Addition of public procedure 'osd_ObsSpaceDiag'
!
!-------------------------------------------------------------------------------------------

  use topLevelControl_mod
  use mpivar_mod
  use bufr
  use codtyp_mod
  use EarthConstants_mod
  use MathPhysConstants_mod
  use horizontalCoord_mod
  use timeCoord_mod
  use controlVector_mod
  use obsSpaceData_mod
  use columnData_mod
  use gridStateVector_mod
  use bMatrix_mod
  use chem_mod
  use bmatrixchem
  use burpfiles_mod
  use varNameList_mod
  implicit none
  save
  private
  
  ! public procedures
  public :: osd_ObsSpaceDiag

  ! namelist variables
  real*8 :: deltaLat,deltaLon,deltaPressure,deltaHeight
  integer :: numFamily
  character(len=2) :: familyList(20)
  integer :: numElement
  integer :: elementList(20) 
  integer :: nrandseed
  logical :: lrandom  

contains

!-------------------------------------------------------------------------------------------
  subroutine osd_ObsSpaceDiag(obsSpaceData,columng)
!
! Author:  Y. Rochon, ARQI (Oct 2015)
!           
! Purpose:  Calls routines to calculate observation-space diagnostics
!
! Revisions: 
!       
!-------------------------------------------------------------------------------------------

    implicit none
    type(struct_obs) :: obsSpaceData
    type(struct_columnData) :: columng

    logical :: nmlExists    
    integer :: ierr
    integer :: dateprnt,timeprnt,newdate
    
!    write(*,*) 'osd_ObsSpaceDiag: Starting'

    call osd_setup(nmlExists)
    ierr = newdate(tim_getDatestamp(),dateprnt,timeprnt,-3)
    dateprnt=dateprnt*100+timeprnt/1000000
    
!   Perform diagnostics based on OmP and OmA
 
!   Diagnostics for chemical constituents 
    
    if (obs_famExist(obsSpaceData,'CH')) call osd_chem_diagnostics(obsSpaceData,columng,dateprnt)

    if ((.not.lrandom) .or. (.not.nmlExists)) return

!   Perform diagnostics from random perturbations
    
    call osd_calcInflation(obsSpaceData,columng,dateprnt)

!    write(*,*) 'osd_obsspace_diag: Completed'

  end subroutine osd_ObsSpaceDiag
  
!-------------------------------------------------------------------------------------------
  subroutine osd_calcInflation(obsSpaceData,columng,dateprnt)
!
! Author:  Mark Buehner
!          
! Purpose:  Calculates observation-space diagnostics from random perturbations
!
! Revisions: M. Sitwell, ARQI (July 2015)
!            - Changed ordering of Bhi and Bens perturbation ordering for consistency with
!              the comments.
!            - Accounts for the association of cvBhi and cvBen in the dermination of random
!              perturbations and related calculation and output of diagnostics.
!            - Changed to sum locally over my_*Std arrays to fix bug when rpn_comm_allreduce
!              is called.
!            - Added call to the routine osd_chem_diagnostics for the CH family for calculation
!              and writing of additional diagsnotics. 
!            Y. Rochon, ARQI (July 2015)
!            - Added the possibility of perturbation-based diagnostics for constituents - cvBChm
!            - Changed scaleFactor* array names
!            - Adjusted MaxLat and MaxLon settings
!            - Added HH to dateprnt
!            - Added use of logicals lpert_static and lpert_ens.
!            Y. Rochon, ARQI (Oct 2015)
!            - Some of the above indicated additions moved to routine osd_obspsace_diag.
!       
!-------------------------------------------------------------------------------------------

    implicit none
    type(struct_obs) :: obsSpaceData
    type(struct_columnData) :: columng

    type(struct_gsv) :: statevector
    type(struct_columnData) :: column
    type(struct_hco), pointer :: hco_anl

    integer :: dateprnt
        
    integer :: familyIndex,elementIndex,bodyIndex,headerIndex,latIndex,lonIndex,verticalIndex
    integer :: maxLat,maxLon,maxVertical
    real*8, allocatable  :: innovStd(:,:,:),bmatHiStd(:,:,:),bmatEnStd(:,:,:)
    integer, allocatable :: counts(:,:,:)

    real*8, allocatable  :: my_innovStd(:,:,:),my_bmatHiStd(:,:,:),my_bmatEnStd(:,:,:)
    integer, allocatable :: my_counts(:,:,:)
    
    integer :: ierr,nulinnov,nulBmatHi,nulBmatEn,nulcount,fnom,fclos,ivco,iseed,jj,jlev,jvar
    real*8 :: zdum,gasdev
    real*8,pointer :: cvBhi(:), cvBen(:), cvBchm(:), field(:,:,:,:)
    logical :: lpert_static, lpert_ens
    integer :: ivar_count
    real*8,allocatable :: HxBhi(:), HxBen(:)
    real*8,allocatable :: scaleFactor(:),scaleFactorChm(:,:)
    character(len=128) :: innovFileName,bmatHiFileName,bmatEnFileName,countFileName
    character(len=6)   :: elementStr
    character(len=10)   :: dateStr
    
    write(*,*) 'osd_calcInflation: Starting'

    if(nrandseed.eq.999) nrandseed=dateprnt ! if seed not set by namelist, use valid date/time
    write(*,*) 'osd_calcInflation: random seed set to ',nrandseed

    maxLat = nint(180.0d0/deltaLat)
    maxLon = nint(360.0d0/deltaLon)
    maxVertical = max(1+nint(110000.0d0/deltaPressure),1+nint(80000.0d0/deltaHeight),200)

    write(*,*) 'osd_calcInflation: Compute random realization of background error'

    ! allocate vectors to store Hx for the static and ensemble-based covariance matrices
    allocate(HxBhi(obs_numbody(obsSpaceData)))
    allocate(HxBen(obs_numbody(obsSpaceData)))

    ! initialize columnData object for increment
    call col_setVco(column,col_getVco(columng))
    call col_allocate(column,col_getNumCol(columng),mpi_local=.true.)
    call col_copyLatLon(columng,column)

    ! initialize gridStateVector object for increment
    call gsv_setVco(statevector,col_getVco(columng))
    hco_anl => hco_get('Analysis')
    call gsv_setHco(statevector,hco_anl)
    call gsv_allocate(statevector,tim_nstepobsinc,mpi_local=.true.)

    ! COMPUTE BMATRIX PERTURBATION FOR THE STATIC COVARIANCES CASE; from Bhi and or BChm 

    if (.not. all(familyList(1:numFamily).eq.'CH')) cvBhi => cvm_getSubVector(cvm_vazx,1)
    if (any(familyList(1:numFamily).eq.'CH').and.obs_famExist(obsSpaceData,'CH')) cvBChm => cvm_getSubVector(cvm_vazx,3)

    HxBhi(:) = 0.0d0
    
    iseed = abs(nrandseed)
    zdum = gasdev(-iseed)

    if (associated(cvBhi).or.associated(cvBChm)) then
       
       ! compute random control vector
       cvm_vazx(:) = 0.0d0

       if (associated(cvBhi)) then
          do jj = 1,size(cvBhi)
             cvBhi(jj)=gasdev(1)
          enddo

          ! initialize vector of scaleFactors
          allocate(scaleFactor(col_getNumLev(columng,'MM')))
          call bhi_getScaleFactor(scaleFactor)
       else
          allocate(scaleFactor(col_getNumLev(columng,'MM')))
          scaleFactor(:)=1.0      
       end if

       if (associated(cvBChm)) then
          do jj = 1,size(cvBChm)
             cvBChm(jj)=gasdev(1)
          enddo

          ! initialize vector of scaleFactors
          allocate(scaleFactorChm(col_getNumLev(columng,'MM'),100))
          call bChm_getScaleFactor(scaleFactorChm)
       else
          allocate(scaleFactorChm(col_getNumLev(columng,'MM'),100))
          scaleFactorChm(:,:)=1.0
       end if
        
       ! multiply vector by B^1/2
       call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

       ! undo the scaleFactor (THIS IS NOT CORRECT FOR 2D VARIABLES!!! (P0 and TG) ) 

       ivar_count=0
       do jvar=1,vnl_numvarmax 
          if(gsv_varExist(vnl_varNameList(jvar))) then
             field => gsv_getField(statevector,vnl_varNameList(jvar))

             if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'MT') then
                do jlev = 1, gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))   
                   if(scaleFactor(jlev).gt.0.0d0) field(:,jlev,:,:)=field(:,jlev,:,:)/scaleFactor(jlev)
                enddo
             else if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then
                ivar_count=ivar_count+1
                do jlev = 1, gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))   
                   if(scaleFactorChm(jlev,ivar_count).gt.0.0d0) field(:,jlev,:,:)=field(:,jlev,:,:) &
                         /scaleFactorChm(jlev,ivar_count)
                end do
             end if
          endif
       enddo
       
       deallocate(scaleFactor)
       deallocate(scaleFactorChm)
       
       ! multiply by H
       call oda_L(statevector,column,columng,obsSpaceData)  ! put in column H_horiz dx
       call oda_H(column,columng,obsSpaceData)  ! Save as OBS_WORK: H_vert H_horiz dx = Hdx
       do bodyIndex=1,obs_numBody(obsSpaceData)
          HxBhi(bodyIndex) = obs_bodyElem_r(obsSpaceData,OBS_WORK,bodyIndex)
       enddo
    end if
   
    ! COMPUTE BMATRIX PERTURBATION FOR THE ENSEMBLE COVARIANCES CASE; from Ben

    cvBen     => cvm_getSubVector(cvm_vazx,2)
   
    HxBen(:) = 0.0d0

    if (associated(cvBen)) then

       ! compute random control vector
       cvm_vazx(:) = 0.0d0

        do jj = 1,size(cvBen)
           cvBhi(jj)=gasdev(1)
        enddo

        ! initialize vector of scaleFactors
        allocate(scaleFactor(col_getNumLev(columng,'MM')))
        call ben_getScaleFactor(scaleFactor)

       ! multiply vector by B^1/2
       call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

       ! undo the scaleFactor
       
       ivar_count=0
       do jvar=1,vnl_numvarmax 
          if(gsv_varExist(vnl_varNameList(jvar))) then
             field => gsv_getField(statevector,vnl_varNameList(jvar))

             if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'MT') then
                do jlev = 1, gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))   
                   if(scaleFactor(jlev).gt.0.0d0) field(:,jlev,:,:)=field(:,jlev,:,:)/scaleFactor(jlev)
                enddo
             else if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then
                ivar_count=ivar_count+1
                do jlev = 1, gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))   
                   if(scaleFactorChm(jlev,ivar_count).gt.0.0d0) field(:,jlev,:,:)=field(:,jlev,:,:) &
                         /scaleFactorChm(jlev,ivar_count)
                end do
             end if
          endif
       enddo
       
       deallocate(scaleFactor)
       
       ! multiply vector by H
       call oda_L(statevector,column,columng,obsSpaceData)  ! put in column H_horiz dx
       call oda_H(column,columng,obsSpaceData)  ! Save as OBS_WORK: H_vert H_horiz dx = Hdx
       do bodyIndex=1,obs_numBody(obsSpaceData)
          HxBen(bodyIndex) = obs_bodyElem_r(obsSpaceData,OBS_WORK,bodyIndex)
       enddo
    end if

    call col_deallocate(column)
    call gsv_deallocate(statevector)
       
    allocate(my_innovStd(maxLat,maxLon,maxVertical))
    allocate(my_bmatHiStd(maxLat,maxLon,maxVertical))
    allocate(my_bmatEnStd(maxLat,maxLon,maxVertical))
    allocate(my_counts(maxLat,maxLon,maxVertical))

    allocate(innovStd(maxLat,maxLon,maxVertical))
    allocate(bmatHiStd(maxLat,maxLon,maxVertical))
    allocate(bmatEnStd(maxLat,maxLon,maxVertical))
    allocate(counts(maxLat,maxLon,maxVertical))

    FAMILY: do familyIndex = 1, numFamily

      ELEMENT: do elementIndex = 1, numElement  

        ! Initialize logicals for calc of perturbation diagnostics.

        lpert_static=.false.
        lpert_ens=.false.
        
        if (familyList(familyIndex).ne.'CH') then
           if (associated(cvBhi)) lpert_static=.true.
        else        
           if (associated(cvBChm)) lpert_static=.true.
        end if
        if (associated(cvBen)) lpert_ens=.true.
      
        ivco = -999
        my_innovStd(:,:,:) = 0.0d0
        my_bmatHiStd(:,:,:) = 0.0d0
        my_bmatEnStd(:,:,:) = 0.0d0
        my_counts(:,:,:) = 0

        call obs_set_current_body_list(obsSpaceData,familyList(familyIndex))
        BODY: do
          bodyIndex = obs_getBodyIndex(obsSpaceData)
          if (bodyIndex < 0) exit BODY

          if(obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).eq.elementList(elementIndex) .and. &
             obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex).eq.1) then

            call osd_getIndices(obsSpaceData,bodyIndex,latIndex,lonIndex,verticalIndex)
            
            if(verticalIndex.eq.-1) then
               ! skip this obs for whatever reason
               cycle BODY
            else if(latIndex.gt.maxLat .or. lonIndex.gt.maxLon .or. verticalIndex.gt.maxVertical) then
               write(*,*) 'osd_calcInflation: index too big: lat,lon,vertical=',latIndex,lonIndex,verticalIndex, &
                          ' lat_max,lon_max,vertical_max=',maxlat,maxlon,maxvertical
               call abort3d('osd_calcInflation')
            endif

            ivco = obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex)
            my_counts(latIndex,lonIndex,verticalIndex) = my_counts(latIndex,lonIndex,verticalIndex) + 1
            my_innovStd(latIndex,lonIndex,verticalIndex) = my_innovStd(latIndex,lonIndex,verticalIndex) +     &
                                                        obs_bodyElem_r(obsSpaceData,OBS_OMP,bodyIndex)* &
                                                        obs_bodyElem_r(obsSpaceData,OBS_OMP,bodyIndex)
            if (lpert_static) my_bmatHiStd(latIndex,lonIndex,verticalIndex)  = my_bmatHiStd(latIndex,lonIndex,verticalIndex) +     &
                                                          HxBhi(bodyIndex)*HxBhi(bodyIndex)
            if (lpert_ens) my_bmatEnStd(latIndex,lonIndex,verticalIndex)  = my_bmatEnStd(latIndex,lonIndex,verticalIndex) +     &
                                                          HxBen(bodyIndex)*HxBen(bodyIndex)

            headerIndex = obs_bodyElem_i(obsSpaceData,OBS_HIND,bodyIndex)

          endif
        enddo BODY

        call rpn_comm_allreduce(ivco,ivco,1,"MPI_INTEGER","MPI_MAX","GRID",ierr)

        call rpn_comm_allreduce(my_counts,counts,maxLat*maxLon*maxVertical,"MPI_INTEGER","MPI_SUM","GRID",ierr)
        call rpn_comm_allreduce(my_innovStd,innovStd,maxLat*maxLon*maxVertical,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
        if (lpert_static) call rpn_comm_allreduce(my_bmatHiStd,bmatHiStd,maxLat*maxLon*maxVertical,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)
        if (lpert_ens) call rpn_comm_allreduce(my_bmatEnStd,bmatEnStd,maxLat*maxLon*maxVertical,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)

        where (counts.gt.0) innovStd = sqrt(innovStd/counts)
        if (lpert_static) then
           where (counts.gt.0) bmatHiStd = sqrt(bmatHiStd/counts)
        end if
        if (lpert_ens) then
           where (counts.gt.0) bmatEnStd = sqrt(bmatEnStd/counts)
        end if 

        if(mpi_myid.eq.0 .and. sum(counts(:,:,:)).gt.0) then

         ! determine file names
          write(dateStr,'(i10.10)') dateprnt
          write(elementStr,'(i6.6)') elementList(elementIndex)
          innovFileName = 'innov' // dateStr // '_'  // trim(familyList(familyIndex)) // '_' // trim(elementStr) // '.dat'
          if (lpert_static) bmatHiFileName =  'bmathi'  // dateStr // '_'  // trim(familyList(familyIndex)) // '_' // trim(elementStr) // '.dat'
          if (lpert_ens) bmatEnFileName =  'bmaten'  // dateStr // '_'  // trim(familyList(familyIndex)) // '_' // trim(elementStr) // '.dat'
          countFileName = 'count' // dateStr // '_'  // trim(familyList(familyIndex)) // '_' // trim(elementStr) // '.dat'

          ! open files
          nulinnov=0
          nulBmatHi =0
          nulBmatEn =0
          nulcount=0
          ierr = fnom(nulinnov,innovFileName,'FMT+R/W',0)
          if (lpert_static) ierr = fnom(nulBmatHi ,bmatHiFileName ,'FMT+R/W',0)
          if (lpert_ens) ierr = fnom(nulBmatEn ,bmatEnFileName ,'FMT+R/W',0)
          ierr = fnom(nulcount,countFileName,'FMT+R/W',0)

          ! write data for this family/element
          write(nulinnov,*) '***maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight='
          write(nulinnov,*) maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight
          
          if (lpert_static) then 
             write(nulBmatHi,*)  '***maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight='
             write(nulBmatHi,*)  maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight
          end if
          if (lpert_ens) then 
             write(nulBmatEn,*)  '***maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight='
             write(nulBmatEn,*)  maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight
          end if
          
          write(nulcount,*) '***maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight='
          write(nulcount,*) maxLon,maxLat,deltaLon,deltaLat,deltaPressure,deltaHeight
          do verticalIndex = 1,maxVertical
            if(sum(counts(:,:,verticalIndex)).gt.0) then
              write(nulinnov,*) '***verticalIndex,vco='
              write(nulinnov,*) verticalIndex,ivco
              
              if (lpert_static) then 
                 write(nulBmatHi,*)  '***verticalIndex,vco='
                 write(nulBmatHi,*)  verticalIndex,ivco
              end if
              if (lpert_ens) then 
                 write(nulBmatEn,*)  '***verticalIndex,vco='
                 write(nulBmatEn,*)  verticalIndex,ivco
              end if
              
              write(nulcount,*) '***verticalIndex,vco='
              write(nulcount,*) verticalIndex,ivco
              do latIndex = 1,maxLat
                write(nulinnov,*) innovStd(latIndex,:,verticalIndex)
                write(nulcount,*) counts(latIndex,:,verticalIndex)
              enddo
 
              if (lpert_static) then 
                 do latIndex = 1,maxLat
                   write(nulBmatHi ,*) bmatHiStd(latIndex,:,verticalIndex)
                 enddo
              end if
              if (lpert_ens) then 
                 do latIndex = 1,maxLat
                    write(nulBmatEn ,*) bmatEnStd(latIndex,:,verticalIndex)
                 enddo
              end if

            endif
          enddo

          ! close files
          ierr = fclos(nulinnov)
          if (lpert_static) ierr = fclos(nulBmatHi)
          if (lpert_ens) ierr = fclos(nulBmatEn)
          ierr = fclos(nulcount)
        endif

      enddo ELEMENT
    enddo FAMILY

    deallocate(my_counts) 
    deallocate(my_innovStd)  
    deallocate(my_bmatHiStd)  
    deallocate(my_bmatEnStd)  

    deallocate(innovStd)
    deallocate(bmatHiStd)
    deallocate(bmatEnStd)
    deallocate(counts)
    
    deallocate(HxBhi)
    deallocate(HxBen)

    write(*,*) 'osd_calcInflation: Finished'
    flush(6) 

  end subroutine osd_calcInflation

!------------------------------------------------------------------------------------
  subroutine osd_getIndices(obsSpaceData,bodyIndex,latIndex,lonIndex,verticalIndex)
!
!   Revisions:
!             Y.J. Rochon, ARQI/AQRD, Aug 2015
!             - Account for vco=4 (total column measurements)
!             - Adjusted latIndex and lonIndex settings
!
!------------------------------------------------------------------------------------
    implicit none
    type(struct_obs) :: obsSpaceData
    integer :: bodyIndex,headerIndex,latIndex,lonIndex,verticalIndex
    real(8), parameter :: epsilon=0.001

    ! codtypes for tovs: 164(AMSUA) 168 180 181 182 183 185 186 192 193

    ! epsilon is added below to handle case where lon/dlon~1 or lat/dlat~1
    headerIndex = obs_bodyElem_i(obsSpaceData,OBS_HIND,bodyIndex)
    latIndex = 1 + floor((90.0d0 + obs_headElem_r(obsSpaceData,OBS_LAT,headerIndex)*MPC_DEGREES_PER_RADIAN_R8)/deltaLat - epsilon)
    if (latIndex.eq.0) latIndex=1
    lonIndex = 1 + floor(obs_headElem_r(obsSpaceData,OBS_LON,headerIndex)*MPC_DEGREES_PER_RADIAN_R8/deltaLon - epsilon)
    if (lonIndex.eq.0) lonIndex=1

    select case(obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex))
      case(1)
        ! height coordinate
        verticalIndex = 1 + nint(obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex)/deltaHeight)
      case(2)
        ! pressure coordinate
        verticalIndex = 1 + nint(obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex)/deltaPressure)
      case(3)
        ! channel number
        verticalIndex = nint(obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex))
        if(obs_headElem_i(obsSpaceData,OBS_ITY,headerIndex).eq.CODTYP_AMSUA) then
          ! amsu-a
          verticalIndex = verticalIndex - 27
        else
          ! ignore other types of TOVS for now
          verticalIndex = -1
        endif
      case(4)
         ! Integrated column value - assign to first level
         verticalIndex = 1
      case default
        ! unknown vertical coordinate
        write(*,*) 'osd_getIndices: Unknown VCO! ',obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex)
        verticalIndex = -1
    end select
 
  end subroutine osd_getIndices

!-------------------------------------------------------------------------------------------
  subroutine osd_setup(nmlExists) 
!
! Revisions: M. Sitwell, ARQI (July 2015)
!            - Added lrandom with initialization to .false.
!
!-------------------------------------------------------------------------------------------
 
    implicit none
    logical :: nmlExists

    integer :: nulnam,ierr,fnom,fclos
    namelist /namosd/nrandseed,deltaLat,deltaLon,deltaPressure,deltaHeight, &
        numFamily,familyList,numElement,elementList,lrandom

    ! set default values for namelist variables
    nrandseed = 999
    lrandom=.true.
    deltaLat = 10.0d0
    deltaLon = 10.0d0
    deltaPressure = 10000.0d0
    deltaHeight = 5000.0d0

    numFamily = 7
    familyList(:) = 'XX'
    familyList(1) = 'UA'
    familyList(2) = 'AI'
    familyList(3) = 'SC'
    familyList(4) = 'RO'
    familyList(5) = 'TO'
    familyList(6) = 'SW'
    familyList(7) = 'SF'

    numElement = 11
    elementList(:) = 0
    elementList(1) = BUFR_NETT
    elementList(2) = BUFR_NEUU
    elementList(3) = BUFR_NEVV
    elementList(4) = BUFR_NEES
    elementList(5) = BUFR_NEUS
    elementList(6) = BUFR_NEVS
    elementList(7) = BUFR_NBT1
    elementList(8) = BUFR_NBT2
    elementList(9) = BUFR_NBT3
    elementList(10)= BUFR_NERF
    elementList(11)= BUFR_NEPS

    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namosd,iostat=ierr)
    if(ierr.ne.0) then
      write(*,*) 'osd_setup: No valid namelist NAMOSD found, skipping some diagnostics'
      nmlExists = .false.
      ierr = fclos(nulnam)
      return
    else
      nmlExists = .true.
    endif
    if(mpi_myid.eq.0) write(*,nml=namosd)
    ierr = fclos(nulnam)

  end subroutine osd_setup

!-------------------------------------------------------------------------------------------
  subroutine osd_chem_diagnostics(obsSpaceData,columng,date)
!
! Author:   M. Sitwell, ARQI/AQRD, June 2015
!
! Revisions:
!            Y. Rochon, ARQI/AQRD, July 2015
!            - Additional generalizations
!          
! Purpose:  Calculates and prints observation-space diagnostics for chemical constituents
!
!-------------------------------------------------------------------------------------------

    use earthconstants_mod
    use chem_interface_mod

    implicit none

    type(struct_obs) :: obsSpaceData
    type(struct_columnData) :: columng
    integer :: date

    integer :: headerIndex,bodyIndex,istnid,vco,nlev_obs,ilev_obs,nlev_mod,ilev_mod

    integer, parameter :: nmax=100
    integer :: varno,varno_elemID(nmax)
    integer :: elemID,i,num_elemID,nset
    character(len=9) :: stnid_elemID(nmax)
    logical :: unilev_elemID(nmax)
    character(len=256) :: label,filename
    real(8) :: lat,lon
    logical :: unilevel,print_summary,add_obs
    real(8), allocatable :: zobslev(:), lev(:), omp(:), oma(:), obs(:), jo(:), pres_mod(:), sigma_obs(:)
    logical, allocatable :: success(:)
    real(8), pointer :: gz_mod(:)

    filename = 'obsspace_diag_CH_' ! Date added to name by transfer script.
    
    ! Get combination lists to group diagnostics by
    call chm_get_comboIdlist(obsSpaceData,stnid_elemID,varno_elemID,unilev_elemID,num_elemID,nset)
    
    if (num_elemID.eq.0) return

    if (mpi_myid.eq.0) then
       write(*,*)
       write(*,*) "osd_chem_diagnostics: Observation-space diagnostics for chemical constituents"
       write(*,*)
    end if

    ! Calculate OmA for non-assimilated data (saved in OBS_OMA in obsSpaceData)
    call chm_calc_OmA_nonassim(columng,obsSpaceData)
    
    ! Loop over all pairs in *_elemID lists
    
    call flush(6)
    do elemID=1,num_elemID
       
       ! Initialize the diagnostic arrays
       call chm_obsspace_diagnostic(deltaLat, deltaLon, initialize=.TRUE., deltaPressure=deltaPressure)
       
       call obs_set_current_header_list(obsSpaceData,'CH')
       HEADER: do
          headerIndex = obs_getHeaderIndex(obsSpaceData)
          if (headerIndex < 0) exit HEADER
  
          ! Body info that we only need for first point in the profile
          bodyIndex = obs_headElem_i(obsSpaceData,OBS_RLN,headerIndex)     
          vco = obs_bodyElem_i(obsSpaceData,OBS_VCO,bodyIndex)

          if (vco.ne.1 .and. vco.ne.2 .and. vco.ne.4) then
             ! Vertical coordinate not handled
             write(*,*) 'osd_chem_diagnostics: Currently unaccounted VCO = ',vco
             cycle HEADER
          end if

          varno = obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex)
          nlev_obs = obs_headElem_i(obsSpaceData,OBS_NLV,headerIndex)
          
          ! Identify max number of profile points in the profile (exclude 8090 elements)
          call obs_set_current_body_list(obsSpaceData,headerIndex)
          do
             bodyIndex = obs_getBodyIndex(obsSpaceData)
             if (bodyIndex < 0) exit
             if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).eq.8090) then
                nlev_obs = nlev_obs-1
             else
                varno=obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex)
             end if
          end do

          ! Determine if this observation should be added to this group (as specified by nset)
          add_obs = stnid_equal(stnid_elemID(elemID),obs_elem_c(obsSpaceData,'STID',headerIndex))
          if (nset.ge.2) add_obs = add_obs .and. varno.eq.varno_elemID(elemID)
          if (nset.ge.3) add_obs = add_obs .and. (nlev_obs.eq.1.and.vco.eq.4).eqv.unilev_elemID(elemID)

          if (add_obs) then
             
             ! Accumulate for this combo
          
             lat = obs_headElem_r(obsSpaceData,OBS_LAT,headerIndex)*MPC_DEGREES_PER_RADIAN_R8
             lon = obs_headElem_r(obsSpaceData,OBS_LON,headerIndex)*MPC_DEGREES_PER_RADIAN_R8
              
             allocate(lev(nlev_obs), omp(nlev_obs), oma(nlev_obs), obs(nlev_obs), jo(nlev_obs), sigma_obs(nlev_obs), success(nlev_obs))

             lev(:) = 0.0d0
             omp(:) = 0.0d0
             oma(:) = 0.0d0
             obs(:) = 0.0d0
             jo(:)  = 0.0d0
             sigma_obs(:)  = 0.0d0
             success(:) = .false.
             ilev_obs = 0
          
             call obs_set_current_body_list(obsSpaceData,headerIndex)
             BODY: do

                bodyIndex = obs_getBodyIndex(obsSpaceData)
                if (bodyIndex < 0) exit BODY
                
                if (obs_bodyElem_i(obsSpaceData,OBS_VNM,bodyIndex).ne.varno) cycle BODY

                if (obs_bodyElem_i(obsSpaceData,OBS_ASS,bodyIndex).eq.1) then

                   ilev_obs = ilev_obs+1
 
                   lev(ilev_obs) = obs_bodyElem_r(obsSpaceData,OBS_PPP,bodyIndex)
                   omp(ilev_obs) = obs_bodyElem_r(obsSpaceData,OBS_OMP,bodyIndex)
                   oma(ilev_obs) = obs_bodyElem_r(obsSpaceData,OBS_OMA,bodyIndex)
                   obs(ilev_obs) = obs_bodyElem_r(obsSpaceData,OBS_VAR,bodyIndex)
                   jo(ilev_obs)  = obs_bodyElem_r(obsSpaceData,OBS_JOBS,bodyIndex)
                   sigma_obs(ilev_obs) = obs_bodyElem_r(obsSpaceData,OBS_OER,bodyIndex)
                   success(ilev_obs) = .true.

                end if

             end do BODY
            
             if (ilev_obs.gt.0) then
            
                ! Convert to pressure if needed and identify unilevel observations
                unilevel = .false.
                select case(vco)
                case(1)
                   ! Height coordinate
               
                   nlev_mod = col_getNumLev(columng,'TH')  ! number of model levels     
                   gz_mod => col_getColumn(columng,headerIndex,'GZ','TH') ! geopotential
                
                   allocate(pres_mod(nlev_mod))
               
                   do ilev_mod=1,nlev_mod
                      pres_mod(ilev_mod) = col_getPressure(columng,ilev_mod,headerIndex,'TH') ! model pressure
                   end do
               
                   ! Convert altidudes to pressure, note that gz_mod/RG converts geopotential to geopotential height
                   lev = chm_convert_z_to_pressure(lev,gz_mod/RG,pres_mod,nlev_obs,nlev_mod,lat/MPC_DEGREES_PER_RADIAN_R8,success)
               
                   deallocate(pres_mod)
                   
                case(4)
                   ! Uni-level observations
                   unilevel = .true.
                end select
                
                ! Add observation to diagnostic arrays
                call chm_obsspace_diagnostic(lat, lon, pressure=lev, omp=omp, oma=oma, obs=obs, jo=jo, sigma_obs=sigma_obs, &
                                             success=success, nlev_obs=nlev_obs, unilevel=unilevel)
                                        
             end if
        
             deallocate(lev,omp,oma,obs,jo,sigma_obs,success)
       
          end if

       end do HEADER
       
       ! Prepare output identification (to be used for mpi_mpid=0)          
       write(label,*) ">>> Statistics for BUFR # ",varno_elemID(elemID),"and STNID ",stnid_elemID(elemID)
       
       ! Sum over different processors, output (when mpi_myid.eq.0), and deallocate diagnostic arrays
       call chm_obsspace_diagnostic(0.0d0, 0.0d0, print_stats=.TRUE., label=label, filename=filename)
    
       call flush(6)
    end do
    
    ! Output diagnostics summary (over all CH observations)
    call chm_obsspace_diagnostic(0.0d0, 0.0d0, print_summary=.TRUE., filename=filename)
    
  end subroutine osd_chem_diagnostics

end module obsSpaceDiag_mod
