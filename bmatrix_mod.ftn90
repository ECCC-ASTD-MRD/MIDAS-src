MODULE BMatrix_mod
    use bMatrixHI
    use bMatrixEnsemble
    use controlVector_mod
    use gridStateVector_mod
    use columnData_mod
    use gaussGrid_mod

contains

  SUBROUTINE bmat_setup(lcolumng,datestamp)
!
!**s/r bmat_setup  - Initializes the analysis Background term for the specific analysis configuration used.
!
      IMPLICIT NONE
#include "comfilt.cdk"
!
      type(struct_columnData) :: lcolumng
      type(struct_vco), pointer :: vco_anl
      integer  cvdimens,cvdimhi,datestamp
      real*8 zps(1)
      real*8, pointer :: pressureProfile(:,:),pressureProfile1(:)
      integer jlev

      vco_anl => col_getVco(lcolumng)
      allocate(pressureProfile(vco_anl%nlev_M,1))
      pressureProfile1 => pressureProfile(:,1)

! Initialize the background-error covariances

      zps(1) = 101000.D0
      call vco_calcpres(vco_anl,pressureProfile,vco_anl%nlev_M,zps,1)
      pressureProfile1(:)=pressureProfile(:,1)
      cvdimhi=0
      cvdimens=0

      write(*,*) 'Setting up the modular HI covariances...'
      call bhi_setup(gaus_NI,gaus_NJ,vco_anl%nlev_M,pressureProfile1,cvdimhi)
      write(*,*) 'Dimension of HI  control vector returned:',cvdimhi
      call flush(6)

      write(*,*) 'Setting up the ensemble covariances...'
      call ben_setup(2800.0d0,2.0d0,pressureProfile1,gaus_ni,gaus_nj,vco_anl%nlev_M,nstepobsinc,vco_anl%ip1_M,datestamp,cvdimens)
      write(*,*) 'Dimension of ENS control vector returned:',cvdimens
      call flush(6)

      call cvm_setup(cvdimhi,cvdimens)
      write(*,*) 'Dimension of TOTAL control vector:',cvm_nvadim
      call flush(6)

      deallocate(pressureProfile)

      return
  END SUBROUTINE bmat_setup


  SUBROUTINE bmat_sqrtB(da_v,na_vdim,statevector)
    implicit none
    !
    !Purpose:
    !Transforms model state from error covariance space to grid point space.
    !
    integer na_vdim
    real*8         :: da_v(na_vdim)
    real*8,pointer :: cvBhi(:),cvBen(:),field(:,:,:,:)
    type(struct_gsv) :: statevector

    call tmg_start(51,'VAR_CH') !

    ! set analysis increment to zero
    call gsv_zero(statevector) 
    field   => gsv_getField(statevector)

    call tmg_start(46,'B_HI')
    ! add 3D contribution to increment from BmatrixHI
    cvBhi=>cvm_getSubVector(da_v,1)
    if(associated(cvBhi)) call bhi_bsqrt(cvBhi,statevector)
    call tmg_stop(46)

    ! copy 3D increment to other timesteps to create 4D increment
    call gsv_3dto4d(statevector)

    call tmg_start(47,'B_ENS')
    ! add 4D contribution to increment from BmatrixEnsemble
    cvBen=>cvm_getSubVector(da_v,2)
    if(associated(cvBen)) call ben_bsqrt(cvBen,field)
    call tmg_stop(47)

    call tmg_stop (51)

  END SUBROUTINE bmat_sqrtB


  SUBROUTINE bmat_sqrtBT(da_v,na_vdim,statevector)
    implicit none
    !
    !Purpose:
    !Transforms model state from grid point space to error covariance space.
    !
    integer na_vdim
    real*8 da_v(na_vdim)
    real*8,pointer :: cvBhi(:),cvBen(:),field(:,:,:,:) 
    type(struct_gsv) :: statevector

    call tmg_start(51,'VAR_CH') 

    ! set gradient to zero
    da_v(:)=0.0d0
    field   => gsv_getField(statevector)

    call tmg_start(65,'B_ENS_T')
    ! add contribution to gradient from BmatrixEnsemble
    cvBen=>cvm_getSubVector(da_v,2)
    if(associated(cvBen)) call ben_bsqrtad(field,cvBen)
    call tmg_stop(65)

    ! adjoint of copy 3D increment to 4D increment
    call gsv_3dto4dAdj(statevector)

    call tmg_start(66,'B_HI_T')
    ! add contribution to gradient from BmatrixHI
    cvBhi=>cvm_getSubVector(da_v,1)
    if(associated(cvBhi)) call bhi_bsqrtad(statevector,cvBhi)
    call tmg_stop(66)

    call tmg_stop(51) 

  END SUBROUTINE bmat_sqrtBT


END MODULE BMatrix_mod
