MODULE BMatrix_mod
    use bMatrixHI
    use bMatrixEnsemble
    use controlVector_mod
    use gridStateVector_mod
    use columnData_mod
    use gaussGrid_mod
    implicit none
    save
    private

    public :: bmat_setup, bmat_finalize, bmat_sqrtB, bmat_sqrtBT
    public :: bmat_reduceToMPILocal, bmat_expandToMPIGlobal

contains

  SUBROUTINE bmat_setup(vco_anl,datestamp)
!
!**s/r bmat_setup  - Initializes the analysis Background term for the specific analysis configuration used.
!
      use vGrid_Descriptors , only:vgrid_descriptor,vgd_levels,VGD_OK
      IMPLICIT NONE
#include "comfilt.cdk"
!
      type(struct_vco), pointer :: vco_anl
      integer  cvdimens,cvdimhi,datestamp
      real*8 zps
      real*8, pointer :: pressureProfile(:)
      integer :: jlev,status,newcomm_group,newcomm_rank
      integer :: rpn_comm_comm,ierr,get_max_rss

! Initialize the background-error covariances

      zps = 101000.D0

      status=vgd_levels(vco_anl%vgrid,ip1_list=vco_anl%ip1_M,levels=pressureProfile,sfc_field=zps,in_log=.false.)

      if(status.ne.VGD_OK)then
         write(*,*) 'ERROR with vgd_levels for desired levels '
         call exit(1)
      endif

      cvdimhi=0
      cvdimens=0

      write(*,*) 'Setting up the modular HI covariances...'
      call bhi_setup(gaus_NI,gaus_NJ,vco_anl%nlev_M,pressureProfile,cvdimhi)
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      write(*,*) 'Dimension of HI  control vector returned:',cvdimhi

      write(*,*) 'Setting up the ensemble covariances...'
      call ben_setup(pressureProfile,gaus_ni,gaus_nj,vco_anl%nlev_M,nstepobsinc,vco_anl%ip1_M,datestamp,cvdimens)
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      write(*,*) 'Dimension of ENS control vector returned:',cvdimens

      call cvm_setup(cvdimhi,cvdimens)
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      write(*,*) 'Dimension of TOTAL control vector:',cvm_nvadim

      deallocate(pressureProfile)

      return
  END SUBROUTINE bmat_setup


  SUBROUTINE bmat_sqrtB(da_v,na_vdim,statevector)
    implicit none
    !
    !Purpose:
    !Transforms model state from error covariance space to grid point space.
    !
    integer na_vdim
    real*8         :: da_v(na_vdim)
    real*8,pointer :: cvBhi(:),cvBen(:),field(:,:,:),field4d(:,:,:,:)
    type(struct_gsv) :: statevector,statevector_temp
    integer :: ierr, nsize

    ! set analysis increment to zero
    call gsv_zero(statevector) 

    ! allocate and set to zero another temporary statevector
    call gsv_setVco(statevector_temp,gsv_getVco(statevector))
    call gsv_allocate(statevector_temp,statevector%ni,statevector%nj,statevector%numStep,mpi_local=.true.)
    call gsv_zero(statevector_temp)

    call tmg_start(50,'B_HI')
    cvBhi=>cvm_getSubVector(da_v,1)
    if(associated(cvBhi)) then
      ! compute 3D contribution to increment from BmatrixHI
      call bhi_bsqrt(cvBhi,statevector)
      ! copy 3D increment to other timesteps to create 4D increment
      call gsv_3dto4d(statevector)
    endif
    call tmg_stop(50)

    call tmg_start(60,'B_ENS')
    cvBen=>cvm_getSubVector(da_v,2)
    ! compute 4D contribution to increment from BmatrixEnsemble
    if(associated(cvBen)) call ben_bsqrt(cvBen,statevector_temp)
    call tmg_stop(60)

    ! add the two contributions together, result in statevector
    call gsv_add(statevector_temp,statevector)

    call gsv_deallocate(statevector_temp)

  END SUBROUTINE bmat_sqrtB


  SUBROUTINE bmat_sqrtBT(da_v,na_vdim,statevector)
    implicit none
    !
    !Purpose:
    !Transforms model state from grid point space to error covariance space.
    !
    integer :: na_vdim
    real*8 :: da_v(na_vdim)
    real*8,pointer :: cvBhi(:),cvBen(:)
    type(struct_gsv) :: statevector
    integer :: ierr,nsize

    ! set gradient to zero
    da_v(:)=0.0d0

    call tmg_start(61,'B_ENS_T')
    cvBen=>cvm_getSubVector(da_v,2)
    ! add contribution to gradient from BmatrixEnsemble
    if(associated(cvBen)) call ben_bsqrtad(statevector,cvBen)
    call tmg_stop(61)

    call tmg_start(51,'B_HI_T')
    cvBhi=>cvm_getSubVector(da_v,1)
    if(associated(cvBhi)) then
      ! adjoint of copy 3D increment to 4D increment
      call gsv_3dto4dAdj(statevector)
      ! add contribution to gradient from BmatrixHI
      if(associated(cvBhi)) call bhi_bsqrtad(statevector,cvBhi)
    endif
    call tmg_stop(51)

  END SUBROUTINE bmat_sqrtBT


  SUBROUTINE bmat_finalize(da_v)
    implicit none
    real*8 :: da_v(:)
    !
    !Purpose:
    !Releases memory used by bmatrices.
    !
    real*8,pointer :: cvBhi(:),cvBen(:)

    cvBhi=>cvm_getSubVector(da_v,1)
    if(associated(cvBhi)) call bhi_finalize()

    cvBen=>cvm_getSubVector(da_v,2)
    if(associated(cvBen)) call ben_finalize() 

  END SUBROUTINE bmat_finalize


  SUBROUTINE BMAT_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real*8  :: cv_mpilocal(:)
    real*8  :: cv_mpiglobal(:)
    integer :: cvDim_mpilocal_out

    integer :: cvDim_Bhi_mpilocal,cvDim_Ben_mpilocal
    real*8,pointer :: cvBhi_mpilocal(:),cvBen_mpilocal(:)
    real*8,pointer :: cvBhi_mpiglobal(:),cvBen_mpiglobal(:)

    cvBhi_mpilocal =>cvm_getSubVector(cv_mpilocal,1)
    cvBhi_mpiglobal=>cvm_getSubVector_mpiglobal(cv_mpiglobal,1)
    if(associated(cvBhi_mpilocal)) then
      call bhi_reduceToMPILocal(cvBhi_mpilocal,cvBhi_mpiglobal,cvDim_Bhi_mpilocal)
    endif

    cvBen_mpilocal =>cvm_getSubVector(cv_mpilocal,2)
    cvBen_mpiglobal=>cvm_getSubVector_mpiglobal(cv_mpiglobal,2)
    if(associated(cvBen_mpilocal)) then
      call ben_reduceToMPILocal(cvBen_mpilocal,cvBen_mpiglobal,cvDim_Ben_mpilocal)
    endif

    cvDim_mpilocal_out = cvDim_Bhi_mpilocal + cvDim_Ben_mpilocal

  END SUBROUTINE BMAT_reduceToMPILocal


  SUBROUTINE BMAT_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none
    real*8  :: cv_mpilocal(:)
    real*8  :: cv_mpiglobal(:)
    integer :: cvDim_mpiglobal_out

    integer :: cvDim_Bhi_mpiglobal,cvDim_Ben_mpiglobal
    real*8,pointer :: cvBhi_mpilocal(:),cvBen_mpilocal(:)
    real*8,pointer :: cvBhi_mpiglobal(:),cvBen_mpiglobal(:)

    cvBhi_mpilocal =>cvm_getSubVector(cv_mpilocal,1)
    cvBhi_mpiglobal=>cvm_getSubVector_mpiglobal(cv_mpiglobal,1)
    if(associated(cvBhi_mpilocal)) then
      call bhi_expandToMPIGlobal(cvBhi_mpilocal,cvBhi_mpiglobal,cvDim_Bhi_mpiglobal)
    endif

    cvBen_mpilocal =>cvm_getSubVector(cv_mpilocal,2)
    cvBen_mpiglobal=>cvm_getSubVector_mpiglobal(cv_mpiglobal,2)
    if(associated(cvBen_mpilocal)) then
      call ben_expandToMPIGlobal(cvBen_mpilocal,cvBen_mpiglobal,cvDim_Ben_mpiglobal)
    endif

    cvDim_mpiglobal_out = cvDim_Bhi_mpiglobal + cvDim_Ben_mpiglobal

  end SUBROUTINE BMAT_expandToMPIGlobal

END MODULE BMatrix_mod
