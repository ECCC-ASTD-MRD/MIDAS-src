      subroutine sutimeinterp(lobsSpaceData,lcolumn)
!*
!***s/r sutimeinterp  
!*
      use obsSpaceData_mod
      use columnData_mod
      IMPLICIT NONE
#include "comlun.cdk"
#include "comfilt.cdk"
      type(struct_obs) :: lobsSpaceData
      type(struct_columnData) :: lcolumn
      integer :: jobs,jstep
      real*8 :: stepObsIndex

      write(nulout,*) ' '
      write(nulout,*) '-------- ENTERING SUTIMEINTERP ---------'
      write(nulout,*) ' '

! Compute the number of step obs over a 6 hours assimilation window
      write(nulout,*) 'SUTIMEINTERP: Number of step obs inc : ',nstepobsinc

      do jobs=1, obs_numheader(lobsSpaceData)
! return the step stamp associated whit date and time of the observation

! building the list of step stamp and counting number of obs in each step
        if(nstepobsinc.eq.1) then
          call col_setTimeInterpWeight(lcolumn,1.0d0,jobs,1)
        else
          call getStepObsIndex(stepObsIndex,obs_get_datestamp(lobsSpaceData),
     &                         obs_elem_i(lobsSpaceData,'DAT ',jobs)
     &         ,obs_elem_i(lobsSpaceData,'ETM ',jobs),nstepobsinc)
          if(floor(stepObsIndex).ge.nstepobsinc) then
            write(*,*) 'stepObsIndex too big=',jobs,stepObsIndex
            call col_setTimeInterpWeight(lcolumn,
     &           1.0d0,jobs,nstepobsinc)
          elseif(floor(stepObsIndex).le.0) then
            write(*,*) 'stepObsIndex too small=',jobs,stepObsIndex
            call col_setTimeInterpWeight(lcolumn,
     &           1.0d0,jobs,1)
          else
            call col_setTimeInterpWeight(lcolumn,
     &         1.0d0-(stepObsIndex-floor(stepObsIndex)),jobs,floor(stepObsIndex))
            call col_setTimeInterpWeight(lcolumn,
     &         stepObsIndex-floor(stepObsIndex),jobs,floor(stepObsIndex)+1)
          endif
        endif

      enddo

      write(nulout,*) ' '
      write(nulout,*) '-------- END OF SUTIMEINTERP ---------'
      write(nulout,*) ' '
c
      return
      end

