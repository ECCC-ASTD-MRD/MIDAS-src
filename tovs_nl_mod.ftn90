!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! MODULE tovs_nl (prefix= no defined prefix)
!!
!! *Purpose*: Derived types, public variables and procedures related to the nonlinear
!!            version of RTTOV
!!
!--------------------------------------------------------------------------
Module tovs_nl_mod
  use mpi_mod
  Use rttov_types, only : &
     rttov_coefs         ,&
     rttov_options       ,&
     rttov_profile       ,&
     rttov_radiance      ,&
     rttov_transmission  ,&
     rttov_chanprof      ,&
     rttov_emissivity

  Use rttov_const, only : &
       platform_name     ,&
       nplatforms        ,&
       inst_name         ,&
       ninst             ,&
       inst_id_goesim    ,&
       inst_id_gmsim     ,&
       inst_id_mtsatim   ,&
       platform_id_jpss  ,&
       platform_id_himawari,&
       errorstatus_success, &
       mair, mh2o, mo3,   &
       surftype_land, surftype_seaice, sensor_id_mw
  use codtyp_mod
  use mpi
  use utilities_mod

  implicit none
  save
  private

  ! public derived type through inheritance (from module rttov_types)
  public :: rttov_radiance, rttov_profile, rttov_chanprof, rttov_coefs, rttov_transmission, rttov_options, rttov_emissivity

  ! public variables (parameters)
  public :: tvs_MaxChannelNumber, tvs_MaxNumberOfChannels, tvs_MaxNumberOfSensors,  tvs_nlevels, tvs_MesosphereLapseRate, tvs_qMixratio2ppmv, tvs_o3Mixratio2ppmv
  ! public variables (non-parameters)
  public :: tvs_nchan, tvs_ichan, tvs_lsensor, tvs_lobsno, tvs_ltovsno, tvs_nobtov
  public :: tvs_l_really_present,tvs_list_sensors,tvs_useUofWIREmiss
  public :: TVS_NSENSORS, TVS_PLATFORMS, TVS_SATELLITES, TVS_INSTRUMENTS, tvs_channelOffset
  public :: TVS_DEBUG, TVS_SATELLITENAME, TVS_INSTRUMENTNAME, TVS_RADIATIVETRANSFERCODE
  public :: platform_name, inst_name
  public :: tvs_coefs, tvs_opts, tvs_profiles
  public :: tvs_radiance

  ! public procedures
  public :: TOVS_NL_SETUPALLO,TOVS_SETUP, tvs_Is_idburp_tovs, tvs_Is_idburp_inst
  public :: tvs_get_inst_id, tvs_get_platform_id, tvs_mapSat, tvs_mapInstrum
  public ::  tvs_Is_Instrum_Geostationary,  tvs_Is_Instrum_HyperSpectral, TVS_GET_CHANPROF, &
       TVS_COUNT_RADIANCES, TVS_GetHIREmissivities, TVS_GetOtherEmissivities
  ! Module parameters
  ! units conversion from  mixing ratio to ppmv
  Real(8), Parameter :: tvs_qMixratio2ppmv  = (1000000.0_8 * mair) / mh2o
  Real(8), Parameter :: tvs_o3Mixratio2ppmv = (1000000.0_8 * mair) / mo3
!  Real(8), Parameter :: tvs_co2Mixratio2ppmv =  (1000000.0_8 * mair) / mco2
!  Real(8), Parameter :: tvs_coMixratio2ppmv =  (1000000.0_8 * mair) / mco
!  Real(8), Parameter :: tvs_n2oMixratio2ppmv = (1000000.0_8 * mair) / mn2o
!  Real(8), Parameter :: tvs_ch4Mixratio2ppmv = (1000000.0_8 * mair) / mch4
  Integer, PARAMETER :: tvs_MaxChannelNumber   = 8461     ! Max. value for channel number
  Integer, PARAMETER :: tvs_MaxNumberOfChannels = 1305     ! Max. no. of channels (for one profile/spectra)
  Integer, PARAMETER :: tvs_MaxNumberOfSensors  = 40       ! Max no sensors to be used
  Integer, PARAMETER :: tvs_nlevels     = 54       ! No. of RTTOV pressure levels including "rttov top" at 0.005 hPa
!**********************************************************
! S. Heilliette this parameter was computed from the mean lapse rate between 50 km and 85 km
! of the US standard atmosphere from data contained in "AFGL Atmospheric Constituent Profiles (0-120km)"
! AFGL 1986, G.P. ANDERSON, J.H. CHETWYND, S.A. CLOUGH, E. P. SHETTLE and F.X. KNEIZYS
  real(8), PARAMETER :: tvs_MesosphereLapseRate=16.2_8
! unit is K/log(P), a positive value corresponds to decrease of temperature with height
!**********************************************************

  ! Module variables
  Integer, allocatable :: tvs_nchan(:)              ! number of channels per instrument
  Integer, allocatable :: tvs_ichan(:,:)            ! list of channels per instrument
  Integer, allocatable :: tvs_lsensor(:)            ! sensor number for each profile
  Integer, allocatable :: tvs_lobsno (:)            ! observation number in cma for each profile
  Integer, allocatable :: tvs_ltovsno (:)           ! index in TOVS structures for each observation in cma
  Logical, allocatable :: tvs_l_really_present(:)   ! logical flag to identify instruments really assimilated
  Integer, allocatable :: tvs_list_sensors(:,:)     ! sensor list
  Integer tvs_nobtov

!   Variables from comtov.cdk
!     TVS_NSENSORS           : number of individual sensors.
!     TVS_PLATFORMS(MXPLATFORM)  : platform ID's (e.g., 1=NOAA; 2=DMSP; ...)
!     TVS_SATELLITES(TVS_MAXNUMBEROFSENSORS)  : satellite ID's (e.g., 1 to 16 for NOAA; ...)
!     TVS_INSTRUMENTS(TVS_MAXNUMBEROFSENSORS) : instrument ID's (e.g., 3=AMSU-A; 4=AMSU-B; 6=SSMI; ...)
!     tvs_channelOffset(TVS_MAXNUMBEROFSENSORS) : BURP to RTTOV channel mapping offset
!     TVS_DEBUG            : logical key controlling statements to be
!     .                    executed while debugging TOVS only
!     TVS_RADIATIVETRANSFERCODE            : TOVS radiation model used:
!                             RTTOV, EUMETSAT NWP SAF radiation model
  INTEGER TVS_NSENSORS
  INTEGER TVS_PLATFORMS(TVS_MAXNUMBEROFSENSORS), TVS_SATELLITES(TVS_MAXNUMBEROFSENSORS)
  INTEGER TVS_INSTRUMENTS(TVS_MAXNUMBEROFSENSORS), tvs_channelOffset(TVS_MAXNUMBEROFSENSORS)
  LOGICAL TVS_DEBUG, tvs_useUofWIREmiss
  CHARACTER*15 TVS_SATELLITENAME(TVS_MAXNUMBEROFSENSORS), TVS_INSTRUMENTNAME(TVS_MAXNUMBEROFSENSORS)
  CHARACTER*8 TVS_RADIATIVETRANSFERCODE

  ! Derived types

  type( rttov_coefs ) ,     allocatable :: tvs_coefs(:)          ! coefficients
  type( rttov_options ),    allocatable :: tvs_opts(:)           ! options
  type( rttov_profile ),    allocatable :: tvs_profiles(:)       ! profiles, all profiles
  type( rttov_radiance ),   allocatable :: tvs_radiance(:)     ! radiances organized by profile
 
contains


SUBROUTINE TOVS_NL_SETUPALLO(lobsSpaceData)
#if defined (DOC)
!
!  s/r TOVS_NL_SETUPALLO : Memory allocation for the non linear radiative transfer model
!                 variables.
!          (original name of routine: sutovalo)
!
!Author  : J. Halle *CMDA/AES Oct 1999
!    -------------------
!     Purpose: to allocate memory for the radiative transfer model variables.
!
! Revision:
!           S. Pellerin *ARMA/SMC May 2000
!            - Fix for F90 conversion
!           C. Chouinard *ARMA/SMC Aug 2000
!            - remove reference to nincrem in memory allocation
!           JM Belanger *CMDA/SMC!  aug 2000
!            - 32 bits conversion
!           J. Halle *CMDA/AES  dec 2000
!            - adapt to TOVS level 1b.
!           J. Halle CMDA/SMC May 2002
!            - adapt to RTTOV-7 code
!           J. Halle CMDA/SMC Feb 2003
!            - add codtyp for AMSUB (=181).
!           J. Halle CMDA/SMC Nov 2004
!            - adapt to RTTOV-8;
!            - convert to Fortran 90.
!           A. Beaulne CMDA/SMC June 2006
!            - modifications for AIRS
!            - allocation of ozone profiles
!           R. Sarrazin  CMDA   April 2008
!            - adapt to CSR
!           S. Heilliette
!            - adapt to IASI
!            - adapt to rttov 10.0 (october 2010)
!           S. Macpherson
!            - adapt to ATMS (codtyp 192)
!           S.  Heilliette
!            - adapt to CrIS (codtyp 193)
#endif
  use hirchannels_mod
  use obsSpaceData_mod

  IMPLICIT NONE
!implicits
#include "rttov_read_coefs.interface"
#include "rttov_user_options_checkinput.interface"
#include "rttov_alloc_prof.interface"

  type(struct_obs) :: lobsSpaceData

  Integer :: alloc_status(6)

  INTEGER ::  ival, IPLATFORM, ISAT, INSTRUM, KRTID

  INTEGER ::  JO, IDATYP, J, JI, JK
  INTEGER ::  ISENS, NC, NL
  INTEGER ::  ICHN, NOSENSOR, INDXCHN
  INTEGER ::  ERRORSTATUS(1),ASW
  integer ::  index_header, index_body

  if (tvs_nsensors == 0) return

!     1. Determine the number of radiances to be assimilated.
!        Construct a list of channels for each sensor.
!        Construct a list of sensor number for each profile
!     .  ---------------------------------------------------

  WRITE(*,*) "Entering TOVS_NL_SETUPALLO" 


  alloc_status = 0
  allocate (tvs_nchan(tvs_nsensors),                       stat= alloc_status(1))
  allocate (tvs_ichan(tvs_MaxNumberOfChannels,tvs_nsensors),                stat= alloc_status(2))
  allocate (tvs_lsensor(obs_numheader(lobsSpaceData)), stat= alloc_status(3))
  allocate (tvs_lobsno (obs_numheader(lobsSpaceData)), stat= alloc_status(4))
  allocate (tvs_ltovsno(obs_numheader(lobsSpaceData)), stat= alloc_status(5))
  allocate (tvs_l_really_present(tvs_nsensors),            stat= alloc_status(6))

  call utl_checkAllocationStatus(alloc_status, " TOVS_NL_SETUPALLO")
  
  tvs_nchan(:)   = 0 
  tvs_ichan(:,:) = 0
  tvs_ltovsno(:) = 0
  tvs_l_really_present(:) = .true.

  TVS_NOBTOV = 0

  ! loop over all header indices of the 'TO' family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)

     IF ( .not.  tvs_Is_idburp_tovs(IDATYP) ) cycle HEADER   ! Proceed to the next header_index

     TVS_NOBTOV = TVS_NOBTOV + 1
     
!    Construct list of channels for each sensor:
!          map burp satellite info to RTTOV platform and satellite.
     IVAL = obs_headElem_i(lobsSpaceData,OBS_SAT,index_header)
     CALL TVS_MAPSAT(IVAL,IPLATFORM,ISAT)
     if (IPLATFORM==-1) then
        Write(*,*) "Unknown OBS_SAT !",IVAL
        CALL utl_abort('TOVS_NL_SETUPALLO')
     endif
!    map burp instrument info to RTTOV instrument.
     IVAL = obs_headElem_i(lobsSpaceData,OBS_INS,index_header)
     CALL TVS_MAPINSTRUM(IVAL,INSTRUM)
     if (INSTRUM==-1) then
        Write(*,*) "Unknown OBS_INS !",IVAL
        CALL utl_abort('TOVS_NL_SETUPALLO')
     endif
!    find sensor number for this obs.
     DO KRTID = 1, TVS_NSENSORS
        IF ( IPLATFORM == TVS_PLATFORMS  (KRTID) .AND. &
             ISAT      == TVS_SATELLITES (KRTID) .AND. &
             INSTRUM   == TVS_INSTRUMENTS(KRTID)      ) THEN
           NOSENSOR = KRTID
           GO TO 110
        ENDIF
     ENDDO
     Write(*,*) "IPLATFORM,ISAT,INSTRUM ",IPLATFORM,ISAT,INSTRUM
     WRITE(*,'(A)') ' TOVS_NL_SETUPALLO: Invalid Sensor'
     do KRTID = 1, TVS_NSENSORS
        print *,krtid,TVS_PLATFORMS  (KRTID),TVS_SATELLITES (KRTID),TVS_INSTRUMENTS(KRTID)
     enddo
     CALL utl_Abort('TOVS_NL_SETUPALLO')

110  tvs_lsensor(tvs_nobtov) = nosensor
     tvs_lobsno (tvs_nobtov) = index_header
     tvs_ltovsno (index_header)    = tvs_nobtov

     ! loop over all body indices (still in the 'TO' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
     call obs_set_current_body_list(lobsSpaceData, index_header)
     BODY: do 
        index_body = obs_getBodyIndex(lobsSpaceData)
        if (index_body < 0) exit BODY

        IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body)==1 ) THEN
           ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,index_body))
           ICHN = MAX(0,MIN(ICHN,TVS_MAXCHANNELNUMBER+1))

           ICHN=ICHN-tvs_channelOffset(NOSENSOR)

           INDXCHN = utl_findArrayIndex(tvs_ichan(:,nosensor),tvs_nchan(nosensor),ichn)
           if ( indxchn == 0 ) then
              tvs_nchan(nosensor) = tvs_nchan(nosensor) + 1
              tvs_ichan(tvs_nchan(nosensor),nosensor) = ichn
           endif
        ENDIF
     ENDDO BODY
  ENDDO HEADER

! Sort list of channels in ascending order.Also force at least one channel, if none are found.

  do ji = 1, tvs_nsensors
    call isort(tvs_ichan(:,ji),tvs_nchan(ji))
    if ( tvs_nchan(ji) == 0 ) then
       tvs_l_really_present ( ji ) =.false.
       tvs_nchan(ji) = 1
       tvs_ichan(1,ji) = 1
    endif
  enddo

  write(*,*) ' TOVS_NL_SETUPALLO: tvs_nobtov = ', tvs_nobtov

!-----------------------------------------------------------------------


!     3. Initialize TOVS radiance transfer model
!     .  ---------------------------------------

  IF     ( TVS_RADIATIVETRANSFERCODE == 'RTTOV' ) THEN

     WRITE(*,'(//,10x,A)') "-rttov_setup: initializing the TOVS radiative transfer model"

     alloc_status(:) = 0
     allocate (tvs_coefs(tvs_nsensors)              ,stat= alloc_status(1))
     allocate (tvs_list_sensors (3,tvs_nsensors)    ,stat= alloc_status(2))
     allocate (tvs_opts (tvs_nsensors)              ,stat= alloc_status(3))

     call utl_checkAllocationStatus(alloc_status(1:3), " TOVS_NL_SETUPALLO before rttov initialization")

     DO JK=1,TVS_NSENSORS
        TVS_LIST_SENSORS(1,JK) = TVS_PLATFORMS  (JK)
        TVS_LIST_SENSORS(2,JK) = TVS_SATELLITES (JK)
        TVS_LIST_SENSORS(3,JK) = TVS_INSTRUMENTS(JK)

        !< General configuration options
        tvs_opts(JK)%config%apply_reg_limits=.true. ! if true application of profiles limits
        tvs_opts(JK)%config%verbose=.false. ! verbose output
        tvs_opts(JK)%config%do_checkinput=.true. ! to check if input profiles are within absolute and regression limits
        !< General RT options
        tvs_opts(JK)%rt_all%switchrad=.true.  ! to use brightness temperature (true) or radiance (false) units in AD routine
        tvs_opts(JK)%rt_all%use_q2m=.false.   ! if true use of surface humidity (false for compatibility with the way rttov 8.7 was compiled)
        tvs_opts(JK)%rt_all%addrefrac=.true. ! to account for atmospheric refraction
        !< VIS/IR RT options
        tvs_opts(JK)%rt_ir%addsolar=.false.  ! to model solar component in the near IR (2000 cm-1 et plus)
        tvs_opts(JK)%rt_ir%addaerosl=.false. ! to account for scattering due to aerosols
        tvs_opts(JK)%rt_ir%addclouds=.false. ! to account for scattering due to clouds
        tvs_opts(JK)%rt_ir%ir_sea_emis_model = 2 ! ISEM (ir_sea_emis_model 1) useful for GEORAD
                                             ! 2 would select IREMIS which is more sophisticated (to try)
        tvs_opts(JK)%rt_ir%pc%ipcreg=-1         ! index of the required PC predictors... to see later
        tvs_opts(JK)%rt_ir%pc%addpc=.false.     ! to carry out principal component calculations 
        tvs_opts(JK)%rt_ir%pc%addradrec=.false. ! to reconstruct radiances from principal components
        !< MW RT options
        tvs_opts(JK)%rt_mw%clw_data=.false.  ! profil d'eau liquide pas disponible
        tvs_opts(JK)%rt_mw%fastem_version=6  ! use fastem version 6 microwave sea surface emissivity model (1-6)
        !< Interpolation options
        tvs_opts(JK)%interpolation%addinterp=.false. ! use of internal profile interpolator (rt calculation on model levels)
        tvs_opts(JK)%interpolation%lgradp=.false.    ! allow tl/ad of user pressure levels

        errorstatus = errorstatus_success

        CALL rttov_read_coefs(errorstatus(1), tvs_coefs(jk), tvs_opts(jk), channels=TVS_ICHAN(1:tvs_nchan(JK),JK), instrument = TVS_LIST_SENSORS(:,JK))
        IF (errorstatus(1) /= errorstatus_success) THEN
           WRITE(*,*) 'rttov_read_coefs: fatal error reading coefficients',errorstatus,JK,TVS_LIST_SENSORS(1:3,JK)
           CALL utl_abort('TOVS_SETUPALLO')
        ENDIF
        tvs_opts(JK)%rt_ir%co2_data = .false. 
        tvs_opts(JK)%rt_ir%n2o_data = .false.
        tvs_opts(JK)%rt_ir%co_data  = .false.
        tvs_opts(JK)%rt_ir%ch4_data = .false.
        tvs_opts(JK)%rt_ir%ozone_data = ( tvs_coefs(jk)%coef%nozone > 0 ) ! profil d'ozone disponible

! Ensure the options and coefficients are consistent
        CALL rttov_user_options_checkinput(errorstatus(1), tvs_opts(jk), tvs_coefs(jk))
        IF (errorstatus(1) /= errorstatus_success) THEN
           WRITE(*,*) 'error in rttov options',errorstatus
           CALL utl_abort('TOVS_SETUPALLO')
        ENDIF
       
     ENDDO
    
     do jk = 1, tvs_nsensors
       if ( tvs_instruments(jk) /= 20 ) then
        tvs_nchan(jk) = tvs_coefs(jk)% coef %fmv_chn
        do j = 1,tvs_nchan(jk)
           tvs_ichan(j,jk) = tvs_coefs(jk)% coef %ff_ori_chn(j)
        enddo
       end if
     enddo

!    .   3.1 Validate RTTOV dimensions
!     .       -------------------------

!   Verify that all coefficient files have the same number of levels, since
!   the rest of the processing assumes this!

     do jk = 1, tvs_nsensors
        if ( tvs_coefs(jk)% coef %nlevels /= tvs_coefs(1)%coef%nlevels ) then
           WRITE(*,'(A)') ' Number of levels not identical in all coef files'
           CALL utl_abort('TOVS_SETUPALLO')
        endif
     enddo

  ENDIF

!-----------------------------------------------------------------------


!     2. Memory allocation for radiative tranfer model variables
!     .  -----------------------------------------------------

!___ profiles

  allocate(tvs_profiles(TVS_NOBTOV)         , stat= alloc_status(1) )
  call utl_checkAllocationStatus(alloc_status(1:1), " TOVS_NL_SETUPALLO tvs_profiles 1")
 

  asw=1 ! to allocate
  do jo = 1, TVS_NOBTOV
     isens = tvs_lsensor(jo)
     nl = tvs_coefs(isens)%coef % nlevels
     ! allocate model profiles atmospheric arrays with RTTOV levels dimension
     call rttov_alloc_prof(errorstatus(1),1,tvs_profiles(jo),nl, &
          tvs_opts(isens),asw,coefs=tvs_coefs(isens),init=.false. )

     call utl_checkAllocationStatus(errorstatus(1:1), " TOVS_NL_SETUPALLO tvs_profiles 2")
     
  end do

!___ radiance by profile

  alloc_status(:) = 0
  allocate( tvs_radiance(TVS_NOBTOV) ,stat= alloc_status(1))

  call utl_checkAllocationStatus(alloc_status(1:1), " TOVS_NL_SETUPALLO radiances 1")
  
  do jo = 1, TVS_NOBTOV
     isens = tvs_lsensor(jo)
     nc = tvs_nchan(isens)
     nl = tvs_coefs(isens) % coef % nlevels
     !! allocate BT equivalent to total direct, tl and ad radiance output
     alloc_status(:) = 0
     allocate( tvs_radiance(jo)  % bt  ( nc ) ,stat= alloc_status(1))
     
     tvs_radiance(jo)  % bt  ( : ) = 0.d0
    
     !! allocate clear/cloudy sky radiance/BT output and overcast radiance at given cloud top
     allocate( tvs_radiance(jo)  % clear  ( nc ) ,stat= alloc_status(2) )
     tvs_radiance(jo)  % clear  ( : ) = 0.d0

    call utl_checkAllocationStatus(alloc_status(1:2), " TOVS_NL_SETUPALLO radiances 2")
     
  end do


  WRITE(*,*) "Leaving TOVS_NL_SETUPALLO"

END SUBROUTINE TOVS_NL_SETUPALLO


SUBROUTINE TOVS_SETUP
  !
  !  s/r TOVS_SETUP : Initialisation of the TOVS processing and radiative
  !     .        transfer model.
  !    -------------------
  !     Purpose: to read namelist NAMTOV, initialize the observation error covariance
  !              and setup RTTOV-8.
  !
  IMPLICIT NONE

  INTEGER  JK, IERR, nulnam
  integer ,external :: fclos, fnom
  NAMELIST /NAMTOV/ TVS_NSENSORS, TVS_SATELLITENAME, TVS_INSTRUMENTNAME
  NAMELIST /NAMTOV/ TVS_DEBUG 
  NAMELIST /NAMTOV/ tvs_useUofWIREmiss, TVS_RADIATIVETRANSFERCODE

 
  !     .  1.1 Default values
  !     .      --------------

  TVS_NSENSORS   = 0
  TVS_SATELLITENAME(:)  = '***UNDEFINED***'
  TVS_INSTRUMENTNAME(:) = '***UNDEFINED***'
  TVS_SATELLITENAME(1)  = 'NOAA16'
  TVS_INSTRUMENTNAME(1) = 'AMSUA'
  TVS_DEBUG   = .FALSE.
  TVS_RADIATIVETRANSFERCODE   = 'RTTOV'
  tvs_useUofWIREmiss=.false.

  !     .   1.2 Read the NAMELIST NAMTOV to modify them
  !     .       ---------------------------------------
 
  nulnam=0
  ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
  read(nulnam,nml=namtov,iostat=ierr)
  if(ierr/=0) call utl_abort('tov_setup: Error reading namelist')
  if(mpi_myid==0) write(*,nml=namtov)
  ierr=fclos(nulnam)

  !     .   1.3 Validate namelist values
  !     .       ------------------------

  if ( tvs_nsensors == 0 ) then
     if(mpi_myid==0) then 
        write(*,*) ' ====================================================='
        write(*,*) ' TOVS_SETUP: Number of sensors is zero, skipping setup'
        write(*,*) ' ====================================================='
     endif
     return
  endif

  IF ( TVS_RADIATIVETRANSFERCODE /= 'RTTOV' ) THEN
     WRITE(*,'(A)') ' Invalid radiation model name'
     CALL utl_abort('TOVS_SETUP')
  ENDIF

  IF ( TVS_NSENSORS > TVS_MAXNUMBEROFSENSORS ) THEN
     WRITE(*,'(A)') ' Number of sensors (TVS_NSENSORS) is greater than maximum allowed (TVS_MAXNUMBEROFSENSORS)'
     CALL utl_abort('TOVS_SETUP')
  ENDIF

  !     .   1.4 Print the content of this NAMELIST
  !     .       ----------------------------------

  if(mpi_myid == 0) then
     WRITE(*,'(A)') 
     WRITE(*,'(3X,A)') '- Parameters used for TOVS processing (read in NAMTOV)'
     WRITE(*,'(3X,A)') '  ----------------------------------------------------'
     WRITE(*,'(6X,A,2X,L1)') 'TOVS debug                           : ', TVS_DEBUG
     WRITE(*,'(6X,A,2X,L1)') 'Use of UW IR land emissivity atlases : ', tvs_useUofWIREmiss
     WRITE(*,'(6X,A,2X,A)')  'Radiative transfer model             : ', TVS_RADIATIVETRANSFERCODE
     WRITE(*,'(6X,A,2X,I3)') 'Number of sensors                    : ', TVS_NSENSORS
     WRITE(*,'(6X,A,2X,10A10)') "Satellite id's                       : ", (TVS_SATELLITENAME(JK), JK=1,TVS_NSENSORS)
     WRITE(*,'(6X,A,2X,10A10)') "Instrument id's                      : ", (TVS_INSTRUMENTNAME(JK), JK=1,TVS_NSENSORS)
     WRITE(*,'(A)') 
     WRITE(*,'(A)') 
     WRITE(*,'(A)') 
     WRITE(*,'(3X,A)') '- Reading and initialization in preparation to the TOVS processing'
     WRITE(*,'(5X,A)') '----------------------------------------------------------------'
  endif

  !     .   1.5 Set up platform, satellite, instrument and channel mapping
  !     .       ----------------------------------------------------------

  CALL SENSORS

END SUBROUTINE TOVS_SETUP

SUBROUTINE SENSORS
!*
!***s/r SENSORS : Initialisation of the RTTOV-10 platform, satellite
!*                and instrument ID's. Also set burp to RTTOV channel
!*                mapping offset.
!*    -------------------
!**    Purpose: to verify and transfom the sensor information contained in the
!*              NAMTOV namelist into the variables required by RTTTOV-7:
!*              platform, satellite and instrument ID's.
!*
!*Variables:
!*     i : TVS_NSENSORS      : number of sensors
!*     i : TVS_SATELLITENAME        : satellite ID (e.g. 'NOAA15')
!*     i : TVS_INSTRUMENTNAME : instrument ID (e.g. 'AMSUA')
!*     o : TVS_PLATFORMS      : RTTOV platform ID numbers (e.g. 1 for  NOAA)
!*     o : SATELLITE     : RTTOV satellite ID numbers (e.g. 15)
!*     o : INSTRUMENT    : RTTOV instrument ID numbers (e.g. 3 for AMSUA)
!*     o : tvs_channelOffset    : BURP to RTTOV channel mapping offset
  IMPLICIT NONE

  INTEGER J, K, IPOS1, IPOS2
  INTEGER NUMEROSAT, IERR, KINDEX, nulnam
  CHARACTER(len=15) :: TEMPOCSATID
  LOGICAL, SAVE :: LFIRST=.true.
  INTEGER, SAVE :: IOFFSET1B(0:ninst-1)
  CHARACTER(len=8) :: LISTINSTRUM(0:ninst-1)
  CHARACTER(len=15) :: tempo_inst
  INTEGER:: LISTOFFSET(0:ninst-1)
  NAMELIST /NAMCHANOFFSET/ LISTOFFSET, LISTINSTRUM
  integer ,external :: fnom, fclos

!
!*    .  1.0 Go through sensors and set RTTOV-10 variables
!     .      --------------------------------------------

  DO J=1, TVS_NSENSORS
     TVS_PLATFORMS  (J) = -1
     TVS_SATELLITES (J) = -1
     TVS_INSTRUMENTS(J) = -1
     tvs_channelOffset(J) = -1
  ENDDO

  IF (LFIRST) then
     ! read the namelist
     NULNAM=0
     IERR=FNOM(NULNAM,'./flnml','FTN+SEQ+R/O',0)
     IF (IERR/=0) then
        write(*,*) "Error while opening namelist file !"
        call utl_abort("sensors")
     ENDIF
     LISTOFFSET(:) = 0
     LISTINSTRUM(:) = "XXXXXXXX"
     READ(NULNAM,NAMCHANOFFSET,iostat=ierr)
     IF (IERR/=0) then
        write(*,*) "Error while reading namelist file !"
        call utl_abort("sensors")
     ENDIF
     do j=0, ninst-1
        if ( LISTINSTRUM(j) /= "XXXXXXXX" ) then
         IOFFSET1B( tvs_get_inst_id( LISTINSTRUM(j) ) )  = LISTOFFSET(j)
        endif
     enddo
     ierr=FCLOS(NULNAM)
     LFIRST = .false.
  ENDIF

!*    .  1.1 Set platforms and satellites
!     .      ----------------------------
!
!** N.B.: Special cases for satellites TERRA and AQUA.
!**       For consistency with the RTTOV-10 nomenclature, rename:
!**       TERRA  to  EOS1
!**       AQUA   to  EOS2
!**       NPP    to  NPP0
  DO J = 1, TVS_NSENSORS
     IF    ( TVS_SATELLITENAME(J) == 'TERRA' ) THEN
        TEMPOCSATID = 'eos1'
     ELSEIF ( TVS_SATELLITENAME(J) == 'AQUA'  ) THEN
        TEMPOCSATID = 'eos2'
     ELSEIF ( TVS_SATELLITENAME(J) == 'NPP'  ) THEN
        TEMPOCSATID = 'jpss0'
     ELSEIF ( TVS_SATELLITENAME(J) == 'JPSS'  ) THEN
        TEMPOCSATID = 'jpss0'
     ELSEIF ( TVS_SATELLITENAME(J)(1:6) == 'HMWARI'  ) THEN
        TEMPOCSATID = 'himawari' // trim(TVS_SATELLITENAME(J) (7:15))
     ELSE
        call up2low(TVS_SATELLITENAME(J),TEMPOCSATID)
     ENDIF
     DO K = 1, nplatforms
        IPOS1 = LEN_TRIM(platform_name(K))
        IPOS2 = INDEX(TEMPOCSATID,platform_name(K)(1:IPOS1))
        IF ( IPOS2 == 1 ) THEN
           TVS_PLATFORMS(J) = K
           KINDEX = K
        ENDIF
     ENDDO
     IF ( TVS_PLATFORMS(J) < 0 ) THEN
        WRITE(*,'(A)') ' Satellite ' // trim(TEMPOCSATID) // ' not supported.'
        CALL utl_abort('SENSORS')
     ELSE
        IPOS1 = LEN_TRIM(platform_name(KINDEX))
        IPOS2 = LEN_TRIM(TEMPOCSATID)
        READ(TEMPOCSATID(IPOS1+1:IPOS2),*,IOSTAT=IERR) NUMEROSAT
        NUMEROSAT = ABS ( NUMEROSAT )
        IF ( IERR /= 0) THEN
           WRITE(*,'(A,1x,i6,1x,i3,1x,i3,1x,A15)') "Problem while reading satellite number", &
                IERR, ipos1, ipos2, TEMPOCSATID
           CALL utl_abort('SENSORS')
        ELSE
           TVS_SATELLITES(J) = NUMEROSAT
        ENDIF
     ENDIF
  ENDDO

!*    .  1.2 Set instruments,
!     .      also set channel offset, which is in fact a channel mapping between
!     .      the channel number in BURP files and the channel number used in
!     .      RTTOV-10.
!     .      --------------------------------------------------------------------

  DO J = 1, TVS_NSENSORS
     if ( TVS_SATELLITENAME(J)(1:4) == "GOES") then !cas particulier
        TVS_INSTRUMENTS(J) = inst_id_goesim
     else if ( TVS_SATELLITENAME(J)(1:5) == "MTSAT") then !autre cas particulier
        TVS_INSTRUMENTS(J) = inst_id_gmsim
     else 
        call up2low(TVS_INSTRUMENTNAME(J),tempo_inst)
        DO K = 0, ninst -1 
           IF ( trim(tempo_inst) == trim(inst_name(K))) THEN
              TVS_INSTRUMENTS(J) = K
           ENDIF
        ENDDO
     endif
     IF ( TVS_INSTRUMENTS(J) .LT. 0 ) THEN
        WRITE(*,'(A)') ' INSTRUMENT '// trim( TVS_INSTRUMENTNAME(J)) // ' not supported.'
        CALL utl_abort('SENSORS')
     ENDIF
     tvs_channelOffset(J) = IOFFSET1B(TVS_INSTRUMENTS(J))
  ENDDO

!*    .   1.3 Print the RTTOV-10 related variables
!     .       -----------------------------------

  if(mpi_myid == 0) then
     WRITE(*,*)
     WRITE(*,'(3X,A)') '- SENSORS. Variables prepared for RTTOV-10:'
     WRITE(*,'(3X,A)') '  ----------------------------------------'
     WRITE(*,*)
     WRITE(*,'(6X,A,I3)')   "Number of sensors       : ", TVS_NSENSORS
     WRITE(*,'(6X,A,10I3)') "Platform numbers        : ",  (TVS_PLATFORMS(J), J=1,TVS_NSENSORS)
     WRITE(*,'(6X,A,10I3)') "Satellite numbers       : ",  (TVS_SATELLITES(J), J=1,TVS_NSENSORS)
     WRITE(*,'(6X,A,10I3)') "Instrument numbers      : ",  (TVS_INSTRUMENTS(J), J=1,TVS_NSENSORS)
     WRITE(*,'(6X,A,10I3)') "Channel mapping offsets : ",  (tvs_channelOffset(J), J=1,TVS_NSENSORS)
  endif

END subroutine sensors

logical function tvs_Is_idburp_tovs(idatyp)
  implicit none
  integer ,intent(in) :: idatyp
!*********************************************
  logical ,save :: lfirst=.true.
  integer,save :: ninst_tovs
  integer :: nulnam, ierr, i 
  integer,external :: fnom, fclos
  integer, save :: list_inst(ninst)
  character (len=22) :: inst_names(ninst)
  namelist /namtovsinst/ inst_names

  if (tvs_nsensors == 0) then
    ! no tovs data will be read, therefore false
    tvs_is_idburp_tovs = .false.
    return
  endif

  if (lfirst) then
     nulnam = 0
     ninst_tovs = 0
     list_inst(:) = -1
     inst_names="XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namtovsinst, iostat=ierr)
     if (ierr/=0) call utl_abort('tvs_Is_idburp_tovs: Error reading namelist')
     if (mpi_myid==0) write(*,nml=namtovsinst)
     ierr = fclos(nulnam)
     do i=1, ninst
        if (inst_names(i) == "XXXXXX" ) then
            ninst_tovs= i - 1
           exit
        else
           list_inst(i) = codtyp_get_codtyp( inst_names(i) )
           if (list_inst(i) < 0) then
              Write(*,*) inst_names(i)
              call utl_abort('tvs_Is_idburp_tovs: unknown instrument in namtovsinst namelist')
           endif
        endif
     enddo
     if ( ninst_tovs == 0 ) call utl_abort('tvs_Is_idburp_tovs: Empty namtovsinst namelist')
     lfirst = .false.
  endif

  tvs_Is_idburp_tovs = .false.

  do i=1, ninst_tovs
     if (idatyp == list_inst(i) ) then
        tvs_Is_idburp_tovs = .true.
        exit
     endif
  enddo

end function tvs_Is_idburp_tovs

logical function tvs_Is_idburp_inst(idburp,cinst)
  implicit none
  integer ,intent(in) :: idburp
  character (len=*) ,intent(in) :: cinst

  tvs_Is_idburp_inst = ( idburp == codtyp_get_codtyp(cinst) )

end function tvs_Is_idburp_inst

integer function tvs_get_platform_id(name)
!******************************************
! S. Heilliette November 2015
! return RTTOV platform id (>0) from
! platform name.
! -1 if not found
!******************************************
  implicit none
  character(len=*),intent(in) :: name
!************************************
  integer :: i, ipos1, ipos2
  character(len=64) :: tempo_name
!*************************************

  tvs_get_platform_id = -1
  ipos1 = LEN_TRIM(name)
  call up2low(name(1:ipos1),tempo_name(1:ipos1))

  if ( INDEX(tempo_name(1:ipos1),"npp") /=0 ) then
     tvs_get_platform_id = platform_id_jpss
  elseif ( INDEX(tempo_name(1:ipos1),"hmwari") /=0 ) then
     tvs_get_platform_id = platform_id_himawari
  else
     do i = 1, nplatforms
        ipos2 = INDEX(tempo_name(1:ipos1),trim(platform_name(i)))
        if ( ipos2 == 1) then
           tvs_get_platform_id = i
           exit
        endif
     enddo
  endif

end function tvs_get_platform_id

integer function tvs_get_inst_id(name)
!******************************************
! S. Heilliette November 2015
! return RTTOV instrument id from
! intrument name. 0 is a valid answer.
! -1 if not found
!******************************************
  implicit none
  character(len=*),intent(in) :: name
!************************************
  integer :: i, ipos1
  character(len=64) :: tempo_name
!***********************************
  tvs_get_inst_id = -1
  ipos1 = LEN_TRIM(name)
  call up2low(name(1:ipos1),tempo_name(1:ipos1))
  if ( trim(tempo_name(1:ipos1)) == "goesim" ) then
     tvs_get_inst_id = inst_id_goesim
  elseif ( trim(tempo_name(1:ipos1)) == "gmsim" ) then
     tvs_get_inst_id = inst_id_gmsim
  else
     do i = 0, ninst-1
        if (trim(inst_name(i)) == tempo_name(1:ipos1) ) then
           tvs_get_inst_id = i
           exit
        endif
     enddo
  endif
end function tvs_get_inst_id

logical function tvs_Is_Instrum_Hyperspectral(instrum)
!******************************************
! S. Heilliette November 2015
! given an RTTOV instrument code
! return if it is an hyperspectral one
! information from namelist NAMHYPER
!******************************************
  implicit none
  integer,intent(in) :: instrum
!******************************************
  integer ,parameter :: maxsize = 100
  integer :: nulnam, ierr, i 
  integer ,save :: list_inst(maxsize), ninst_hir
  logical, save :: lfirst = .true.
  integer ,external :: fclos, fnom
  character (len=6) :: name_inst(maxsize)
  NAMELIST /NAMHYPER/ name_inst

  if (lfirst) then
     nulnam = 0
     ninst_hir = 0
     name_inst(:) = "XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namhyper, iostat=ierr)
     if (ierr/=0) call utl_abort('tvs_Is_Instrum_Hyperspectral: Error reading namelist')
     if (mpi_myid==0) write(*,nml=namhyper)
     ierr = fclos(nulnam)
     list_inst(:) = -1
     do i=1, maxsize
        list_inst(i) = tvs_get_inst_id( name_inst(i) )
        if (name_inst(i) /= "XXXXXX") then
           if (list_inst(i) == -1) then
              Write(*,*) i,name_inst(i)
              call utl_abort('tvs_Is_Instrum_Hyperspectral: Unknown instrument name')
           endif
        else
           ninst_hir = i -1
           exit
        endif
     enddo
     lfirst = .false.
     if (ninst_hir == 0) then
        Write(*,*) "tvs_Is_Instrum_Hyperspectral: Warning : empty namhyper namelist !"
     endif
  endif
  tvs_Is_Instrum_Hyperspectral = .false.
  do i=1, ninst_hir
     if ( instrum == list_inst(i)) then
        tvs_Is_Instrum_Hyperspectral =.true.
        exit
     endif
  enddo

end function tvs_Is_Instrum_Hyperspectral

logical function tvs_Is_Instrum_Geostationary(instrum)
!******************************************
! S. Heilliette November 2015
! given an RTTOV instrument code
! return if it is a Geostationnary Imager
! information from namelist NAMGEO
!******************************************
  implicit none
  integer,intent(in) :: instrum
!******************************************
  integer ,parameter :: maxsize = 100
  integer :: nulnam, ierr, i 
  integer ,save :: list_inst(maxsize), ninst_geo
  logical, save :: lfirst = .true.
  character (len=8) :: name_inst(maxsize)
  integer ,external :: fnom, fclos

  NAMELIST /NAMGEO/ name_inst
  if (lfirst) then
     nulnam = 0
     ninst_geo = 0
     name_inst(:) = "XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namgeo, iostat=ierr)
     if (ierr/=0) call utl_abort('tvs_Is_Instrum_Geostationary: Error reading namelist')
     if (mpi_myid==0) write(*,nml=namgeo)
     ierr = fclos(nulnam)
     list_inst(:) = -1
     do i=1, maxsize
        list_inst(i) = tvs_get_inst_id( name_inst(i) )
        if (name_inst(i) /= "XXXXXX") then
           if (list_inst(i) == -1) then
              Write(*,*) i,name_inst(i)
              call utl_abort('tvs_Is_Instrum_Geostationary: Unknown instrument name')
           endif
        else
           ninst_geo = i -1
           exit
        endif
     enddo
     lfirst = .false.
     if (ninst_geo == 0) then
        Write(*,*) "tvs_Is_Instrum_Geostationary: Warning : empty namgeo namelist !"
     endif
     Write(*,*) "DEBUGX:",list_inst(1:ninst_geo)
  endif
  tvs_Is_Instrum_Geostationary = .false.
  do i=1, ninst_geo
     if ( instrum == list_inst(i)) then
        tvs_Is_Instrum_Geostationary =.true.
        exit
     endif
  enddo

end function tvs_Is_Instrum_Geostationary

SUBROUTINE TVS_MAPINSTRUM(INSTRUMBURP,INSTRUM)
!
!**s/r TVS_MAPINSTRUM : Map burp satellite instrument (element #2019)
!                    to RTTOV-10 instrument.
!
!Author  : J. Halle *CMDA/SMC May 2002
!
!Revision 001: J. Halle *CMDA/SMC Sept. 2005
!              - add MHS.
!         002: R Sarrazin CMDA, April 2008
!              - comment on MTSAT imager instrument number
!         003: R. McTaggart-Cowan *RPN  Mar 2012
!	       - Use assumed-length declarations for string dummy args
!         003: S. Macpherson ARMA, August 2011
!              - add NPP/ATMS codtyp=192
!         004: C. Cote Juillet 2015
!              - Ajout Himawari-8/AHI codtyp=185
!         005: S. Heilliette Novembre 2015
!              - suppression des tables hardcodees
!                lecture depuis une namelist
!
!
!    -------------------
!*    Purpose:  Map burp satellite instrument (element #2019)
!               to RTTOV-7 instrument.
!*              A negative value is returned, if no match in found.
!
!               Table of  RTTOV-7 instrument identifier
!               ---------------------------------------
!               Instrument        Instrument identifier  Sensor type
!               ---------         ---------------------  -----------
!               HIRS               0                     ir
!               MSU                1                     mw
!               SSU                2                     ir
!               AMSUA              3                     mw
!               AMSUB              4                     mw
!               AVHRR              5                     ir
!               SSMI               6                     mw
!               VTPR1              7                     ir
!               VTPR2              8                     ir
!               TMI                9                     mw
!               SSMIS             10                     mw
!               AIRS              11                     ir
!               MODIS             13                     ir
!               ATSR              14                     ir
!               MHS               15                     mw
!               ATMS              19                     mw
!               MVIRI             20                     ir
!               SEVIRI            21                     ir
!               GOESIMAGER        22                     ir
!               GOESSOUNDER       23                     ir
!               GMS/MTSAT IMAGER  24                     ir
!               FY2-VISSR         25                     ir
!               FY1-MVISR         26                     ir
!               AHI               56                     ir
!
!Argumets:
!     i : INSTRUMBURP : burp satellite instrument (element #2019)
!     o : INSTRUM     : RTTOV-7 instrument ID numbers (e.g. 3 for  AMSUA)
!
   IMPLICIT NONE
   INTEGER J,INSTRUMBURP,INSTRUM,numinstburp
   INTEGER,parameter :: MXINSTRUMBURP   = 100
   INTEGER,save ::   LISTBURP(MXINSTRUMBURP)
   CHARACTER(len=8),save :: LISTINSTRUM(MXINSTRUMBURP)
   NAMELIST /NAMINST/ LISTBURP, LISTINSTRUM
   LOGICAL,SAVE :: LFIRST = .true.
   INTEGER :: NULNAM, IER
   integer ,external :: fnom, fclos
!*************
!      TESTING ONLY: burp 2047 is AIRS.
!*************
!
!*            Table of BURP satellite sensor identifier element #002019
!*            ----------------------------------------------------------

!
!
!*    .  1.0 Find instrument
!     .      ---------------------------

   IF (LFIRST) THEN
! set the default values
      LISTBURP(:) = -1
      LISTINSTRUM(:) = "XXXXXXXX"

! read the namelist
      NULNAM=0
      IER=FNOM(NULNAM,'./flnml','FTN+SEQ+R/O',0)
      IF (IER/=0) then
         write(*,*) "Error while opening namelist file !"
         call utl_abort("tvs_mapInstrum")
      ENDIF
      READ(NULNAM,NAMINST,iostat=ier)
      IF (IER/=0) then
         write(*,*) "Error while reading namelist file !"
         call utl_abort("tvs_mapInstrum")
      ENDIF
      ier=FCLOS(NULNAM)

! figure out how many valid elements in the lists
      DO J=1, MXINSTRUMBURP
         if(listburp(j)==-1) then
            numinstburp = j - 1
            exit
         endif
      enddo
      if (numinstburp > MXINSTRUMBURP) then
         call utl_abort('tvs_mapInstrum: exceeded maximum number of platforms')
      endif
      write(*,*) 'tvs_mapInstrum: number of satellites found in namelist = ',numinstburp
      WRITE(*,*) 'tvs_mapInstrum: listburp   = ',listburp(1:numinstburp)
      WRITE(*,*) 'tvs_mapInstrum: listinstrum    = ',listinstrum(1:numinstburp)
      LFIRST=.FALSE.
   ENDIF

   INSTRUM = -1
   DO J=1, MXINSTRUMBURP
      IF ( INSTRUMBURP == LISTBURP(J) ) THEN
         INSTRUM    = tvs_get_inst_id( LISTINSTRUM(J) )
         EXIT
      ENDIF
   ENDDO

END subroutine TVS_MAPINSTRUM

SUBROUTINE TVS_MAPSAT(ISATBURP,IPLATFORM,ISAT)
!
!**s/r TVS_MAPSAT : Map burp satellite identifier (element #1007)
!                to RTTOV-10 platform and satellite.
!
!Author  :       J. Halle *CMDA/SMC May 2002
!
!Revision 001  : J. Halle *CMDA/AES Jul 2005
!                . add NOAA-18.
!
!Revision 002  : J. Halle *CMDA/AES May 2007
!                . add METOP 1,2,3.
!
!Revision 003  : R. Sarrazin CMDA   Apr 2008
!                  add MTSAT1, GOES13 and MSG2, modif to MSG1
!
!Revision 004  : C. Cote  mars 2009
!                . add NOAA-19.
!
!Revision 005  : S. Macpherson *ARMA  Jul 2010
!                . add SSMIS satellites DMSP17-18
!
!Revision 006  : S. Macpherson *ARMA  Feb 2013
!                . add NPP/ATMS codtyp=192
!
!Revision 007  : J. Morneau CMDA    FEb 2014
!                . add GOES15 and MTSAT-2
!                . add GOES14
!                . add MSG3 and MSG4
!Revision 008 :  S. Heilliette    March 2014
!                . Major Modification:
!                . information is now read from namelist
!                . instead of being hardcoded
!
!    -------------------
!    Purpose:  Map burp satellite identifier (element #1007)
!               to RTTOV-7 platform and satellite.
!               Negative values are returned, if no match in found.
!
!               ---------------------------------------------
!               Table of  RTTOV-7 platform identifier
!               ---------------------------------------------
!               Platform          RTTOV-7 platform identifier
!               ---------         ---------------------------
!               NOAA               1
!               DMSP               2
!               METEOSAT           3
!               GOES               4
!               GMS                5
!               FY2                6
!               TRMM               7
!               ERS                8
!               EOS                9
!               METOP             10
!               ENVISAT           11
!               MSG               12
!               FY1               13
!               ADEOS             14
!               MTSAT             15
!               CORIOLIS          16
!               NPP               17
!               ---------------------------------------------
!
!               Example: NOAA15, which has a burp satellite identifier value of 206,
!                        is mapped into the following:
!                                RTTOV-7 platform  =  1,
!                                RTTOV-7 satellite = 15.
!
!
!
!Arguments:
!     i : ISATBURP      : BURP satellite identifier
!     o : IPLATFORM     : RTTOV-7 platform ID numbers (e.g. 1 for  NOAA)
!     o : ISAT          : RTTOV-7 satellite ID numbers (e.g. 15)
!
   IMPLICIT NONE

   INTEGER J,ISATBURP,IPLATFORM,ISAT
   INTEGER IER,NULNAM
   LOGICAL ,SAVE :: LFIRST=.TRUE.
   INTEGER ,EXTERNAL :: FNOM, FCLOS

   integer, parameter :: mxsatburp = 100
   INTEGER,SAVE :: NUMSATBURP

! Table of BURP satellite identifier element #001007
   INTEGER,SAVE :: LISTBURP(mxsatburp)
! Table of RTTOV-7 platform identifier
   CHARACTER(len=8),SAVE :: LISTPLAT(mxsatburp)
! Table of RTTOV-7 satellite identifier
   INTEGER,SAVE :: LISTSAT (mxsatburp)

   NAMELIST /NAMSAT/ LISTBURP, LISTPLAT, LISTSAT

!     Fill tables from namelist at the first call 
!     -------------------------------------------
!
   IF (LFIRST) THEN
! set the default values
      LISTBURP(:) = -1
      LISTSAT(:) = -1
      LISTPLAT(:) = "XXXXXXXX"

! read the namelist
      NULNAM=0
      IER=FNOM(NULNAM,'./flnml','FTN+SEQ+R/O',0)
      IF (IER/=0) then
         write(*,*) "Error while opening namelist file !"
         call utl_abort("tvs_mapSat")
      ENDIF
      READ(NULNAM,NAMSAT,iostat=ier)
      IF (IER/=0) then
         write(*,*) "Error while reading namelist file !"
         call utl_abort("tvs_mapSat")
      ENDIF
      ier=FCLOS(NULNAM)

! figure out how many valid elements in the lists
      DO J=1, MXSATBURP
         if(listburp(j)==-1) then
            numsatburp = j - 1
            exit
         endif
      enddo
      if(numsatburp.ge.mxsatburp) then
         call utl_abort('tvs_mapSat: exceeded maximum number of platforms')
      endif
      write(*,*) 'tvs_mapSat: number of satellites found in namelist = ',numsatburp
      WRITE(*,*) 'tvs_mapSat: listburp   = ',listburp(1:numsatburp)
      WRITE(*,*) 'tvs_mapSat: listsat    = ',listsat(1:numsatburp)
      WRITE(*,*) 'tvs_mapSat: listplat   = ',listplat(1:numsatburp)
      LFIRST=.FALSE.
   ENDIF

!     .  Find platform and satellite
!     .      ---------------------------
!
   IPLATFORM = -1
   ISAT      = -1
   DO J=1, NUMSATBURP
      IF ( ISATBURP == LISTBURP(J) ) THEN
         IPLATFORM = tvs_get_platform_id( LISTPLAT(J) )
         ISAT      = LISTSAT (J)
         EXIT
      ENDIF
   ENDDO

END SUBROUTINE TVS_MAPSAT

SUBROUTINE TVS_GET_CHANPROF(sensor_id, iptobs, nprofiles, ObsSpaceData, chanprof)
   use obsSpaceData_mod
   implicit none
   integer ,intent(in) :: nprofiles, sensor_id, iptobs(:)
   type(struct_obs) :: ObsSpaceData
   type(rttov_chanprof) :: chanprof(:)
!******************************************************************************
   integer :: count, profile_index, header_index, start, end, body_index, ichn, nrank, iobs
!******************************************************************************
! Build the list of channels/profiles indices
   count = 0
         
   do profile_index = 1,  nprofiles
      iobs = iptobs(profile_index)
      header_index = tvs_lobsno(iobs)
      start = obs_headElem_i(ObsSpaceData,OBS_RLN,header_index)
      end = obs_headElem_i(ObsSpaceData,OBS_NLV,header_index) + start - 1
      do body_index = start, end
         if(obs_bodyElem_i(ObsSpaceData,OBS_ASS,body_index)==1) then
            ichn = nint(obs_bodyElem_r(ObsSpaceData,OBS_PPP,body_index))
            ichn = max(0,min(ichn,tvs_MaxChannelNumber+1))
            ICHN = ICHN - tvs_channelOffset(sensor_id)
            do nrank = 1, tvs_nchan(sensor_id)
               if ( ichn == tvs_ichan(nrank,sensor_id) ) exit
            end do
            if (nrank/=tvs_nchan(sensor_id)+1) then
               count =  count + 1
               chanprof(count)%prof = profile_index
               chanprof(count)%chan = nrank
            else
               print *,"strange channel number",ichn
            endif
         end if
      end do
   end do

end SUBROUTINE TVS_GET_CHANPROF

integer function TVS_COUNT_RADIANCES(iptobs, nprofiles, ObsSpaceData)
   use obsSpaceData_mod
   implicit none
   integer ,intent(in) :: nprofiles, iptobs(:)
   type(struct_obs) :: ObsSpaceData
!******************************************************************************
   integer :: profile_index, header_index, start, end, body_index, iobs

   TVS_COUNT_RADIANCES = 0
   do profile_index = 1, nprofiles
      iobs = iptobs(profile_index)
      header_index = tvs_lobsno(iobs)
      start = obs_headElem_i(ObsSpaceData,OBS_RLN,header_index)
      end = obs_headElem_i(ObsSpaceData,OBS_NLV,header_index) + start - 1
      do body_index = start, end
         if(obs_bodyElem_i(ObsSpaceData,OBS_ASS,body_index)==1) TVS_COUNT_RADIANCES  = TVS_COUNT_RADIANCES + 1
      end do
   end do

end function TVS_COUNT_RADIANCES

SUBROUTINE TVS_GetHIREmissivities(sensor_id, iptobs, nprofiles, ObsSpaceData, surfem)
   use obsSpaceData_mod
   implicit none
   integer ,intent(in) :: nprofiles, sensor_id, iptobs(:)
   type(struct_obs) :: ObsSpaceData
   Real(8), intent(out) :: surfem(:)
!***************************************************************************
   integer :: count, profile_index, iobs, start, end, index_body, index_header
!***************************************************************************
   count = 0 
   surfem(:) = 0.98d0
   do profile_index = 1, nprofiles
      iobs = iptobs(profile_index)
      index_header = tvs_lobsno(iobs)
      start = obs_headElem_i(ObsSpaceData,OBS_RLN,index_header)
      end = obs_headElem_i(ObsSpaceData,OBS_NLV,index_header) + start - 1
      do index_body = start, end
         if(obs_bodyElem_i(ObsSpaceData,OBS_ASS,index_body)==1) then
            count = count + 1
            surfem ( count ) = obs_bodyElem_r(ObsSpaceData,OBS_SEM,index_body)
         end if
      end do
   end do

end SUBROUTINE TVS_GetHIREmissivities

SUBROUTINE TVS_GetOtherEmissivities(chanprof, iptobs, nradiances, sensor_type, instrument, surfem, calcemis)
   implicit none
   integer ,intent(in) :: nradiances, iptobs(:),sensor_type, instrument
   Real(8), intent(out) :: surfem(:)
   Logical, intent(out) :: calcemis(:)
   type(rttov_chanprof),intent(in) :: chanprof(:)
!*******************************************************************************************************
   integer :: radiance_index, profile_index, iobs, surface_type
!*******************************************************************************************************
   do radiance_index = 1, nradiances
      profile_index = chanprof(radiance_index)%prof
      iobs = iptobs(profile_index)
      surface_type = tvs_profiles(iobs) % skin % surftype
      if     (sensor_type == sensor_id_mw ) then
         if ( surface_type == surftype_land .or. &
              surface_type == surftype_seaice     ) then
            calcemis(radiance_index) = .false.
            surfem (radiance_index) = 0.75d0
         else
            calcemis(radiance_index) = .true.
            surfem (radiance_index) = 0.d0
         endif
      elseif ( tvs_Is_Instrum_Hyperspectral(instrument) ) then
         calcemis(radiance_index) = .false. 
      elseif ( tvs_Is_Instrum_Geostationary(instrument) ) then
         calcemis(radiance_index) = .true.
         surfem (radiance_index) = 0.d0
      else
         Write(*,*) sensor_type,instrument
         call utl_abort('TVS_GetOtherEmissivities. invalid sensor type')
      endif
   enddo
   
end SUBROUTINE TVS_GetOtherEmissivities

end module tovs_nl_mod
