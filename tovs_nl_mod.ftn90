!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

Module tovs_nl_mod
  use mpi_mod
  Use rttov_types, only : &
     rttov_coefs         ,&
     rttov_options       ,&
     profile_type        ,&
     radiance_type       ,&
     transmission_Type   ,&
     rttov_chanprof
  Use rttov_const, only : &
       platform_name     ,&
       nplatforms        ,&
       inst_name         ,&
       ninst             ,&
       inst_id_goesim    ,&
       inst_id_gmsim     ,&
       platform_id_jpss
  use codtyp_mod
  use mpi
  use utilities_mod

  implicit none
  save
  private

  ! public derived type through inheritance (from module rttov_types)
  public :: radiance_type,profile_type,rttov_chanprof,rttov_coefs,transmission_Type,rttov_options

  ! public variables (parameters)
  public :: jppf, jpchmax, jpchus, jpnsatmax, jplev, mesosphere_lapse_rate
  ! public variables (non-parameters)
  public :: nchan, ichan, lsensor, lobsno, ltovsno, JPMOTOP, JPMOLEV, nobtov
  public :: l_really_present,list_sensors,luse_uwiremis
  public :: NSENSORS, PLATFORM, SATELLITE, INSTRUMENT, CHANOFFSET
  public :: LDBGTOV, LNLVTOV, CSATID, CINSTRUMENTID, CRTMODL
  public :: platform_name, inst_name
  public :: coefs, opts, profilesdata, profiles
  public :: radiance_d

  ! public procedures
  public :: TOVS_NL_SETUPALLO,TOVS_SETUP, tvs_Is_idburp_tovs, tvs_Is_idburp_inst
  public :: tvs_get_inst_id, tvs_get_platform_id
  public ::  tvs_Is_Instrum_Geostationary,  tvs_Is_Instrum_HyperSpectral
  ! Module parameters
  Integer, PARAMETER :: jppf      = 40       ! Max no. profiles per RTTOV call
  Integer, PARAMETER :: jpchmax   = 8461     ! Max. no. of channels
  Integer, PARAMETER :: jpchus    = 1305     ! Max. no. of channels computed/call
  Integer, PARAMETER :: jpnsatmax = 40       ! Max no sensors to be used
  Integer, PARAMETER :: jplev     = 51       ! No. of pressure levels including "rttov top" at 0.005 hPa for rttov-10
!**********************************************************
! S. Heilliette this parameter was computed from the mean lapse rate between 50 km and 85 km
! of the US standard atmosphere from data contained in "AFGL Atmospheric Constituent Profiles (0-120km)"
! AFGL 1986, G.P. ANDERSON, J.H. CHETWYND, S.A. CLOUGH, E. P. SHETTLE and F.X. KNEIZYS
  real*8, PARAMETER :: mesosphere_lapse_rate=16.2_8
! unit is K/log(P), a positive value corresponds to decrease of temperature with height
!**********************************************************

  ! Module variables
  Integer, allocatable :: nchan(:)              ! number of channels per instrument
  Integer, allocatable :: ichan(:,:)            ! list of channels per instrument
  Integer, allocatable :: lsensor(:)            ! sensor number for each profile
  Integer, allocatable :: lobsno (:)            ! observation number in cma for each profile
  Integer, allocatable :: ltovsno (:)           ! index in TOVS structures for each observation in cma
  Logical, allocatable :: l_really_present(:)   ! logical flag to identify instruments really assimilated
  Integer, allocatable :: list_sensors(:,:)     ! sensor list
  Integer JPMOTOP, JPMOLEV, nobtov

  ! Variables from comtov.cdk
!     NSENSORS           : number of individual sensors.
!     PLATFORM(MXPLATFORM)  : platform ID's (e.g., 1=NOAA; 2=DMSP; ...)
!     SATELLITE(JPNSATMAX)  : satellite ID's (e.g., 1 to 16 for NOAA; ...)
!     INSTRUMENT(JPNSATMAX) : instrument ID's (e.g., 3=AMSU-A; 4=AMSU-B; 6=SSMI; ...)
!     CHANOFFSET(JPNSATMAX) : BURP to RTTOV channel mapping offset
!     LDBGTOV            : logical key controlling statements to be
!     .                    executed while debugging TOVS only
!     CRTMODL            : TOVS radiation model used:
!                             RTTOV, EUMETSAT NWP SAF radiation model
!     LNLVTOV            : .T. if processing is to be non-linear
  INTEGER NSENSORS
  INTEGER PLATFORM(JPNSATMAX), SATELLITE(JPNSATMAX)
  INTEGER INSTRUMENT(JPNSATMAX), CHANOFFSET(JPNSATMAX)
  LOGICAL LDBGTOV, LNLVTOV, luse_uwiremis
  CHARACTER*15 CSATID(JPNSATMAX), CINSTRUMENTID(JPNSATMAX)
  CHARACTER*8 CRTMODL

  ! Derived types

  type( rttov_coefs ) ,     allocatable :: coefs(:)          ! coefficients
  type( rttov_options ),    allocatable :: opts(:)           ! options
  type( profile_Type ),     allocatable :: profilesdata(:)   ! profiles buffer used in rttov calls
  type( profile_Type ),     allocatable :: profiles(:)       ! profiles, all profiles
  type(radiance_Type) ,     allocatable :: radiance_d(:)     ! radiances organized by profile
 
contains


SUBROUTINE TOVS_NL_SETUPALLO(lobsSpaceData)
#if defined (DOC)
!
!  s/r TOVS_NL_SETUPALLO : Memory allocation for the non linear radiative transfer model
!                 variables.
!          (original name of routine: sutovalo)
!
!Author  : J. Halle *CMDA/AES Oct 1999
!    -------------------
!     Purpose: to allocate memory for the radiative transfer model variables.
!
! Revision:
!           S. Pellerin *ARMA/SMC May 2000
!            - Fix for F90 conversion
!           C. Chouinard *ARMA/SMC Aug 2000
!            - remove reference to nincrem in memory allocation
!           JM Belanger *CMDA/SMC!  aug 2000
!            - 32 bits conversion
!           J. Halle *CMDA/AES  dec 2000
!            - adapt to TOVS level 1b.
!           J. Halle CMDA/SMC May 2002
!            - adapt to RTTOV-7 code
!           J. Halle CMDA/SMC Feb 2003
!            - add codtyp for AMSUB (=181).
!           J. Halle CMDA/SMC Nov 2004
!            - adapt to RTTOV-8;
!            - convert to Fortran 90.
!           A. Beaulne CMDA/SMC June 2006
!            - modifications for AIRS
!            - allocation of ozone profiles
!           R. Sarrazin  CMDA   April 2008
!            - adapt to CSR
!           S. Heilliette
!            - adapt to IASI
!            - adapt to rttov 10.0 (october 2010)
!           S. Macpherson
!            - adapt to ATMS (codtyp 192)
!           S.  Heilliette
!            - adapt to CrIS (codtyp 193)
#endif
  use hir_chans
  use obsSpaceData_mod

  IMPLICIT NONE
!implicits
#include "rttov_setup.interface"
#include "rttov_alloc_prof.interface"

  type(struct_obs) :: lobsSpaceData
  INTEGER :: VERBOSITY_LEVEL,ERR_UNIT=0

  Integer :: alloc_status(8)
  Integer :: setup_errorstatus ! setup return code

  INTEGER ::  ival, IPLATFORM, ISAT, INSTRUM, KRTID

  INTEGER ::  JO, IDATYP, J, JI, JK
  INTEGER ::  ISENS, NC, NL
  INTEGER ::  ICHN, NOSENSOR, INDXCHN
  INTEGER ::  ERRORSTATUS,ASW
  integer ::  index_header, index_body

!     1. Determine the number of radiances to be assimilated.
!        Construct a list of channels for each sensor.
!        Construct a list of sensor number for each profile
!     .  ---------------------------------------------------
  if (nsensors <= 0) return
  alloc_status(:) = 0
  allocate (nchan(nsensors),                       stat= alloc_status(1))
  allocate (ichan(jpchus,nsensors),                stat= alloc_status(2))
  allocate (lsensor(obs_numheader(lobsSpaceData)), stat= alloc_status(3))
  allocate (lobsno (obs_numheader(lobsSpaceData)), stat= alloc_status(4))
  allocate (ltovsno(obs_numheader(lobsSpaceData)), stat= alloc_status(5))
  allocate (l_really_present(nsensors),            stat= alloc_status(6))
  If( any(alloc_status /= 0) ) then
9201 FORMAT(' TOVS_NL_SETUPALLO: Memory Allocation Error')
     WRITE(*,FMT=9201)
     WRITE(*,*) alloc_status(1:5)
     CALL varAbort('TOVS_NL_SETUPALLO')
  End If

  nchan(:)   = 0 
  ichan(:,:) = 0
  ltovsno(:) = 0
  l_really_present(:) = .true.

  NOBTOV = 0

  ! loop over all header indices of the 'TO' family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

     IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)

     IF ( .not.  tvs_Is_idburp_tovs(IDATYP) ) cycle HEADER   ! Proceed to the next header_index

     NOBTOV = NOBTOV + 1
     
!    Construct list of channels for each sensor:
!          map burp satellite info to RTTOV platform and satellite.
     IVAL = obs_headElem_i(lobsSpaceData,OBS_SAT,index_header)
     CALL MAP_SAT(IVAL,IPLATFORM,ISAT)
     if (IPLATFORM==-1) then
        Write(*,*) "Unknown OBS_SAT !",IVAL
        CALL varAbort('TOVS_NL_SETUPALLO')
     endif
!    map burp instrument info to RTTOV instrument.
     IVAL = obs_headElem_i(lobsSpaceData,OBS_INS,index_header)
     CALL MAP_INSTRUM(IVAL,INSTRUM)
     if (INSTRUM==-1) then
        Write(*,*) "Unknown OBS_INS !",IVAL
        CALL varAbort('TOVS_NL_SETUPALLO')
     endif
!    find sensor number for this obs.
     DO KRTID = 1, NSENSORS
        IF ( IPLATFORM .EQ. PLATFORM  (KRTID) .AND. &
             ISAT      .EQ. SATELLITE (KRTID) .AND. &
             INSTRUM   .EQ. INSTRUMENT(KRTID)      ) THEN
           NOSENSOR = KRTID
           GO TO 110
        ENDIF
     ENDDO
     Write(*,*) "IPLATFORM,ISAT,INSTRUM ",IPLATFORM,ISAT,INSTRUM
     WRITE(*,FMT=9101)
9101 FORMAT(' TOVS_NL_SETUPALLO: Invalid Sensor')
     CALL varAbort('TOVS_NL_SETUPALLO')

110  lsensor(nobtov) = nosensor
     lobsno (nobtov) = index_header
     ltovsno (index_header)    = nobtov

     ! loop over all body indices (still in the 'TO' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
     call obs_set_current_body_list(lobsSpaceData, index_header)
     BODY: do 
        index_body = obs_getBodyIndex(lobsSpaceData)
        if (index_body < 0) exit BODY

        IF ( obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body).EQ.1 ) THEN
           ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,index_body))
           ICHN = MAX(0,MIN(ICHN,JPCHMAX+1))

           ICHN=ICHN-CHANOFFSET(NOSENSOR)

           INDXCHN = utl_findArrayIndex(ichan(:,nosensor),nchan(nosensor),ichn)
           if ( indxchn .eq. 0 ) then
              nchan(nosensor) = nchan(nosensor) + 1
              ichan(nchan(nosensor),nosensor) = ichn
           endif
        ENDIF
     ENDDO BODY
  ENDDO HEADER

! Sort list of channels in ascending order.Also force at least one channel, if none are found.

  do ji = 1, nsensors
    call isort(ichan(:,ji),nchan(ji))
    if ( nchan(ji) .eq. 0 ) then
       l_really_present ( ji ) =.false.
       nchan(ji) = 1
       ichan(1,ji) = 1
    endif
  enddo

  write(*,*) ' TOVS_NL_SETUPALLO: nobtov = ', nobtov

!-----------------------------------------------------------------------


!     3. Initialize TOVS radiance transfer model
!     .  ---------------------------------------

  IF     ( CRTMODL .EQ. 'RTTOV' ) THEN
     WRITE(*,FMT=9300)
  9300    FORMAT(//,10x,"-rttov_setup: initializing the TOVS radiative " &
                   ,"transfer model" )
     alloc_status(:) = 0
     allocate (coefs(nsensors)              ,stat= alloc_status(1))
     allocate (list_sensors (3,nsensors)    ,stat= alloc_status(2))
     allocate (opts (nsensors)              ,stat= alloc_status(3))
     If( any(alloc_status /= 0) ) then
        WRITE(*,FMT=9201)
        WRITE(*,*) alloc_status(1:3)
        CALL varAbort('TOVS_NL_SETUPALLO')
     End If

  ! The levels of verbosity are
  !  0 = no error messages output
  !  1 = FATAL errors only printed. these are errors which
  !      mean that profile should be aborted (e.g. unphysical
  !      profile input)
  !  2 = WARNING errors only printed. Errors which can allow
  !      the computation to continue but the results may be
  !      suspect (e.g. profile outside basis profile limits)
  !  3 = INFORMATION messages which inform the user about
  !      the computation
     VERBOSITY_LEVEL = 3

     DO JK=1,NSENSORS
        LIST_SENSORS(1,JK) = PLATFORM  (JK)
        LIST_SENSORS(2,JK) = SATELLITE (JK)
        LIST_SENSORS(3,JK) = INSTRUMENT(JK)

        opts(JK)%ipcreg=-1         ! index of the required PC predictors... to see later
        opts(JK)%addinterp=.false. !use of internal profile interpolator (rt calculation on model levels)
        opts(JK)%addpc=.false.     ! to carry out principal component calculations 
        opts(JK)%addradrec=.false. ! to reconstruct radiances from principal components
        opts(JK)%addsolar=.false.  ! to model solar component in the near IR (2000 cm-1 et plus)
        opts(JK)%addaerosl=.false. ! to account for scattering due to aerosols
        opts(JK)%addclouds=.false. ! to account for scattering due to clouds
        opts(JK)%switchrad=.true.  ! to use brightness temperature (true) or radiance (false) units in AD routine
        opts(JK)%lgradp=.false.    ! allow tl/ad of user pressure levels
        opts(JK)%use_q2m=.false.   ! if true use of surface humidity (false for compatibility with the way rttov 8.7 was compiled)
        opts(JK)%apply_reg_limits=.false. ! if true application of profiles limits
        opts(JK)%verbose_checkinput_warnings=.false. ! useful for debuging the code should be turned off later
        opts(JK)%ozone_data=.true. ! profil d'ozone disponible
        opts(JK)%clw_data=.false.  ! profil d'eau liquide pas disponible
        opts(JK)%addrefrac=.false. ! to account for atmospheric refraction (useless???)
        opts(JK)%do_checkinput=.true. ! to check if input profiles are within absolute and regression limits
        opts(JK)%fastem_version=4  ! use fastem version 4 file (in the range 1-5 to force a specific version)

        setup_errorstatus = 0
! read coefficients using the list of required channels.
        CALL rttov_setup (&
             & setup_errorstatus,  & ! out 
             & err_unit,           & ! in
             & verbosity_level,        & ! in
             & opts(JK),               & ! in
             & coefs(JK),              & ! out
             & LIST_SENSORS(:,JK),     & ! in
             & ICHAN(1:nchan(JK),JK)         ) !in (opt) 
        if ( setup_errorstatus/=0 ) then
           Write(*,*) "Error during RTTOV setup !",JK,LIST_SENSORS(1:3,JK)
           CALL varAbort('TOVS_SETUPALLO')
        endif

        opts(JK)%co2_data = ( coefs(jk)%coef%nco2 > 0 )
        opts(JK)%n2o_data = ( coefs(jk)%coef%nn2o > 0 )
        opts(JK)%co_data  = ( coefs(jk)%coef%nco  > 0 )
        opts(JK)%ch4_data = ( coefs(jk)%coef%nch4 > 0 )

     ENDDO
    
     do jk = 1, nsensors
       if ( instrument(jk) /= 20 ) then
        nchan(jk) = coefs(jk)% coef %fmv_chn
        do j = 1,nchan(jk)
           ichan(j,jk) = coefs(jk)% coef %ff_ori_chn(j)
        enddo
       end if
     enddo

!    .   3.1 Validate RTTOV dimensions
!     .       -------------------------

!   Verify that all coefficient files have the same number of levels, since
!   the rest of the processing assumes this!

     do jk = 1, nsensors
        if ( coefs(jk)% coef %nlevels .ne. coefs(1)%coef%nlevels ) then
           WRITE(*,FMT=9311)
  9311     FORMAT(' TOVS_SETUPALLO: Number of levels not', &
                  ' identical in all coef files')
           CALL varAbort('TOVS_SETUPALLO')
        endif
     enddo


  ENDIF

!-----------------------------------------------------------------------


!     2. Memory allocation for radiative tranfer model variables
!     .  -----------------------------------------------------

!___ profiles

  allocate(profiles(NOBTOV)         , stat= alloc_status(1) )
  If( alloc_status(1) /= 0 ) then
     WRITE(*,FMT=9201)
     CALL varAbort('TOVS_NL_SETUPALLO')
  End If

  asw=1
  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nl = coefs(isens)%coef % nlevels
     ! allocate model profiles atmospheric arrays with RTTOV levels dimension

     call rttov_alloc_prof(errorstatus,1,profiles(jo),nl, &
          opts(isens),asw,coefs=coefs(isens),init=.false. )
     if (errorstatus/=0) THEN
        Write(*,*) "Error in profiles allocation",errorstatus
        CALL varAbort('TOVS_NL_SETUPALLO')
     endif
       
  end do

!___ radiance by profile

  alloc_status(:) = 0
  allocate( radiance_d(NOBTOV) ,stat= alloc_status(1))
  If( alloc_status(1) /= 0 ) then
     WRITE(*,FMT=9201)
     CALL varAbort('TOVS_NL_SETUPALLO')
  End If
  do jo = 1, NOBTOV
     isens = lsensor(jo)
     nc = nchan(isens)
     nl = coefs(isens) % coef % nlevels
     !! allocate BT equivalent to total direct, tl and ad radiance output
     alloc_status(:) = 0
     allocate( radiance_d(jo)  % bt  ( nc ) ,stat= alloc_status(1))
     
     radiance_d(jo)  % bt  ( : ) = 0.d0
    
     !! allocate clear/cloudy sky radiance/BT output and overcast radiance at given cloud top
     allocate( radiance_d(jo)  % clear  ( nc ) ,stat= alloc_status(2) )
     radiance_d(jo)  % clear  ( : ) = 0.d0
    
     If( any(alloc_status /= 0) ) then
         WRITE(*,FMT=9201)
         Write(*,*) alloc_status(1:2)
         CALL varAbort('TOVS_NL_SETUPALLO')
     End If
  end do

END SUBROUTINE TOVS_NL_SETUPALLO


SUBROUTINE TOVS_SETUP
  !
  !  s/r TOVS_SETUP : Initialisation of the TOVS processing and radiative
  !     .        transfer model.
  !    -------------------
  !     Purpose: to read namelist NAMTOV, initialize the observation error covariance
  !              and setup RTTOV-8.
  !
  IMPLICIT NONE

  INTEGER  JK, IERR, nulnam
  integer ,external :: fclos, fnom
  NAMELIST /NAMTOV/NSENSORS, CSATID, CINSTRUMENTID
  NAMELIST /NAMTOV/LDBGTOV 
  NAMELIST /NAMTOV/LNLVTOV,luse_uwiremis, CRTMODL

 
  !     .  1.1 Default values
  !     .      --------------

  NSENSORS   = 1
  CSATID(:)  = '***UNDEFINED***'
  CINSTRUMENTID(:) = '***UNDEFINED***'
  CSATID(1)  = 'NOAA16'
  CINSTRUMENTID(1) = 'AMSUA'
  LDBGTOV   = .FALSE.
  LNLVTOV   = .FALSE.
  CRTMODL   = 'RTTOV'
  luse_uwiremis=.false.

  !     .   1.2 Read the NAMELIST NAMTOV to modify them
  !     .       ---------------------------------------
 
  nulnam=0
  ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
  read(nulnam,nml=namtov,iostat=ierr)
  if(ierr.ne.0) call varAbort('tov_setup: Error reading namelist')
  if(mpi_myid.eq.0) write(*,nml=namtov)
  ierr=fclos(nulnam)

  !     .   1.3 Validate namelist values
  !     .       ------------------------

  IF ( CRTMODL .NE. 'RTTOV' ) THEN
     WRITE(*,FMT=9131)
  9131    FORMAT(' TOVS_SETUP: Invalid radiation model name')
     CALL varAbort('TOVS_SETUP')
  ENDIF

  IF ( NSENSORS .GT. JPNSATMAX ) THEN
     WRITE(*,FMT=9132)
  9132    FORMAT(' TOVS_SETUP: Number of sensors (NSENSORS)', &
            ' is greater than maximum allowed (JPNSATMAX)')
     CALL varAbort('TOVS_SETUP')
  ENDIF

  if(mpi_myid.eq.0) WRITE(*,FMT=9140) LDBGTOV, LNLVTOV, luse_uwiremis,CRTMODL
  if(mpi_myid.eq.0) WRITE(*,FMT=9143) NSENSORS

  IF ( NSENSORS .LE. 0 ) THEN
     if(mpi_myid.eq.0) WRITE(*,FMT=9133)
  9133 FORMAT(' TOVS_SETUP: Skiping RTTOV initialization')
     return
  ENDIF

  !     .   1.4 Print the content of this NAMELIST
  !     .       ----------------------------------

  if(mpi_myid.eq.0) WRITE(*,FMT=9145) (CSATID(JK), JK=1,NSENSORS)
  if(mpi_myid.eq.0) WRITE(*,FMT=9146) (CINSTRUMENTID(JK), JK=1,NSENSORS)


  9140 FORMAT(/,3X,'- Parameters used for TOVS processing' &
            ,' (read in NAMTOV)'                           &
            ,/,3X,'  ----------------------------------'   &
            ,'------------------'                          &
            ,/,6X,'TOVS debug                           : ',2X,L1       &
            ,/,6X,'Non-linear processing                : ',2X,L1       &
            ,/,6X,'Use of UW IR land emissivity atlases : ',2X,L1       &
            ,/,6X,'Radiative transfer model: ',2X,A)
  9143 FORMAT(/,6X,"Number of sensors       : ",I3)
  9145 FORMAT(  6X,"Satellite id's          : ",10A10)
  9146 FORMAT(  6X,"Instrument id's         : ",10A10)

  if(mpi_myid.eq.0) WRITE(*,FMT=9142)
  9142 FORMAT(//,3X,"- Reading and initialization in preparation to the " &
       ,"TOVS processing",/,5X,64('-'))

  !     .   1.5 Set up platform, satellite, instrument and channel mapping
  !     .       ----------------------------------------------------------

  CALL SENSORS

END SUBROUTINE TOVS_SETUP

SUBROUTINE SENSORS
  !*
  !***s/r SENSORS : Initialisation of the RTTOV-10 platform, satellite
  !*                and instrument ID's. Also set burp to RTTOV channel
  !*                mapping offset.
  !*    -------------------
  !**    Purpose: to verify and transfom the sensor information contained in the
  !*              NAMTOV namelist into the variables required by RTTTOV-7:
  !*              platform, satellite and instrument ID's.
  !*
  !*Variables:
  !*     i : NSENSORS      : number of sensors
  !*     i : CSATID        : satellite ID (e.g. 'NOAA15')
  !*     i : CINSTRUMENTID : instrument ID (e.g. 'AMSUA')
  !*     o : PLATFORM      : RTTOV platform ID numbers (e.g. 1 for  NOAA)
  !*     o : SATELLITE     : RTTOV satellite ID numbers (e.g. 15)
  !*     o : INSTRUMENT    : RTTOV instrument ID numbers (e.g. 3 for AMSUA)
  !*     o : CHANOFFSET    : BURP to RTTOV channel mapping offset
  IMPLICIT NONE

  INTEGER J, K, IPOS1, IPOS2
  INTEGER NUMEROSAT, IERR, KINDEX, nulnam
  CHARACTER(len=15) :: TEMPOCSATID
  LOGICAL, SAVE :: LFIRST=.true.
  INTEGER, SAVE :: IOFFSET1B(0:ninst-1)
  CHARACTER(len=8) :: LISTINSTRUM(0:ninst-1)
  CHARACTER(len=15) :: tempo_inst
  INTEGER:: LISTOFFSET(0:ninst-1)
  NAMELIST /NAMCHANOFFSET/ LISTOFFSET, LISTINSTRUM
  integer ,external :: fnom, fclos

!
!*    .  1.0 Go through sensors and set RTTOV-10 variables
!     .      --------------------------------------------

  DO J=1, NSENSORS
     PLATFORM  (J) = -1
     SATELLITE (J) = -1
     INSTRUMENT(J) = -1
     CHANOFFSET(J) = -1
  ENDDO

  IF (LFIRST) then
     ! read the namelist
     NULNAM=0
     IERR=FNOM(NULNAM,'./flnml','FTN+SEQ+R/O',0)
     IF (IERR/=0) then
        write(*,*) "Error while opening namelist file !"
        call varAbort("sensors")
     ENDIF
     LISTOFFSET(:) = 0
     LISTINSTRUM(:) = "XXXXXXXX"
     READ(NULNAM,NAMCHANOFFSET,iostat=ierr)
     IF (IERR/=0) then
        write(*,*) "Error while reading namelist file !"
        call varAbort("sensors")
     ENDIF
     do j=0, ninst-1
        if ( LISTINSTRUM(j) /= "XXXXXXXX" ) then
         IOFFSET1B( tvs_get_inst_id( LISTINSTRUM(j) ) )  = LISTOFFSET(j)
        endif
     enddo
     ierr=FCLOS(NULNAM)
     LFIRST = .false.
  ENDIF

!*    .  1.1 Set platforms and satellites
!     .      ----------------------------
!
!** N.B.: Special cases for satellites TERRA and AQUA.
!**       For consistency with the RTTOV-10 nomenclature, rename:
!**       TERRA  to  EOS1
!**       AQUA   to  EOS2
!**       NPP    to  NPP0
  DO J = 1, NSENSORS
     IF    ( CSATID(J) .EQ. 'TERRA' ) THEN
        TEMPOCSATID = 'eos1'
     ELSEIF ( CSATID(J) .EQ. 'AQUA'  ) THEN
        TEMPOCSATID = 'eos2'
     ELSEIF ( CSATID(J) .EQ. 'NPP'  ) THEN
        TEMPOCSATID = 'jpss0'
     ELSEIF ( CSATID(J) .EQ. 'JPSS'  ) THEN
        TEMPOCSATID = 'jpss0'
     ELSE
        call up2low(CSATID(J),TEMPOCSATID)
        IPOS1 = INDEX(TEMPOCSATID,"-")
        if (ipos1 > 0 .and. ipos1<len(TEMPOCSATID)) then
           do k=ipos1,len(TEMPOCSATID)-1
              TEMPOCSATID(k:k)=TEMPOCSATID(k+1:k+1)
           enddo
           k = len(TEMPOCSATID)
           TEMPOCSATID(k:k)=" "
        endif
     ENDIF
     DO K = 1, nplatforms
        IPOS1 = LEN_TRIM(platform_name(K))
        IPOS2 = INDEX(TEMPOCSATID,platform_name(K)(1:IPOS1))
        IF ( IPOS2 .EQ. 1 ) THEN
           PLATFORM(J) = K
           KINDEX = K
        ENDIF
     ENDDO
     IF ( PLATFORM(J) .LT. 0 ) THEN
        WRITE(*,FMT=9132) TEMPOCSATID
9132    FORMAT(' SENSORS: Satellite ',A,' not supported.')
        CALL varAbort('SENSORS')
     ELSE
        IPOS1 = LEN_TRIM(platform_name(KINDEX))
        IPOS2 = LEN_TRIM(TEMPOCSATID)
        READ(TEMPOCSATID(IPOS1+1:IPOS2),*,IOSTAT=IERR) NUMEROSAT
        IF ( IERR .NE. 0) THEN
           WRITE(*,FMT=9132) TEMPOCSATID
           CALL varAbort('SENSORS')
        ELSE
           SATELLITE(J) = NUMEROSAT
        ENDIF
     ENDIF
  ENDDO

!*    .  1.2 Set instruments,
!     .      also set channel offset, which is in fact a channel mapping between
!     .      the channel number in BURP files and the channel number used in
!     .      RTTOV-10.
!     .      --------------------------------------------------------------------

  DO J = 1, NSENSORS
     if ( CSATID(J)(1:4) == "GOES") then !cas particulier
        INSTRUMENT(J) = inst_id_goesim
     else if ( CSATID(J)(1:5) == "MTSAT") then !autre cas particulier
        INSTRUMENT(J) = inst_id_gmsim
     else 
        call up2low(CINSTRUMENTID(J),tempo_inst)
        DO K = 0, ninst -1 
           IF ( trim(tempo_inst) == trim(inst_name(K))) THEN
              INSTRUMENT(J) = K
           ENDIF
        ENDDO
     endif
     IF ( INSTRUMENT(J) .LT. 0 ) THEN
        WRITE(*,FMT=9133) CINSTRUMENTID(J)
 9133      FORMAT(' SENSORS: INSTRUMENT ',A,' not supported.')
        CALL varAbort('SENSORS')
     ENDIF
     CHANOFFSET(J) = IOFFSET1B(INSTRUMENT(J))
  ENDDO

!C*    .   1.3 Print the RTTOV-10 related variables
!C     .       -----------------------------------

  if(mpi_myid.eq.0) WRITE(*,FMT=9140)
  if(mpi_myid.eq.0) WRITE(*,FMT=9143) NSENSORS
  if(mpi_myid.eq.0) WRITE(*,FMT=9145) (PLATFORM(J), J=1,NSENSORS)
  if(mpi_myid.eq.0) WRITE(*,FMT=9146) (SATELLITE(J), J=1,NSENSORS)
  if(mpi_myid.eq.0) WRITE(*,FMT=9147) (INSTRUMENT(J), J=1,NSENSORS)
  if(mpi_myid.eq.0) WRITE(*,FMT=9148) (CHANOFFSET(J), J=1,NSENSORS)


 9140 FORMAT(/,3X,'- SENSORS. Variables prepared for RTTOV-10:'  &
            ,/,3X,'  ----------------------------------------')

 9143 FORMAT(/,6X,"Number of sensors       : ",I3)
 9145 FORMAT(  6X,"Platform numbers        : ",10I3)
 9146 FORMAT(  6X,"Satellite numbers       : ",10I3)
 9147 FORMAT(  6X,"Instrument numbers      : ",10I3)
 9148 FORMAT(  6X,"Channel mapping offset  : ",10I3)

END subroutine sensors

logical function tvs_Is_idburp_tovs(idatyp)
  implicit none
  integer ,intent(in) :: idatyp
!*********************************************
  logical ,save :: lfirst=.true.
  integer,save :: ninst_tovs
  integer :: nulnam, ierr, i 
  integer,external :: fnom, fclos
  integer, save :: list_inst(ninst)
  character (len=22) :: inst_names(ninst)
  namelist /namtovsinst/ inst_names
  if (lfirst) then
     nulnam = 0
     ninst_tovs = 0
     list_inst(:) = -1
     inst_names="XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namtovsinst, iostat=ierr)
     if (ierr.ne.0) call varAbort('tvs_Is_idburp_tovs: Error reading namelist')
     if (mpi_myid.eq.0) write(*,nml=namtovsinst)
     ierr = fclos(nulnam)
     do i=1, ninst
        if (inst_names(i) == "XXXXXX" ) then
            ninst_tovs= i - 1
           exit
        else
           list_inst(i) = codtyp_get_codtyp( inst_names(i) )
           if (list_inst(i) < 0) then
              Write(*,*) inst_names(i)
              call varAbort('tvs_Is_idburp_tovs: unknown instrument in namtovsinst namelist')
           endif
        endif
     enddo
     if ( ninst_tovs == 0 ) call varAbort('tvs_Is_idburp_tovs: Empty namtovsinst namelist')
     lfirst = .false.
  endif

  tvs_Is_idburp_tovs = .false.

  do i=1, ninst_tovs
     if (idatyp == list_inst(i) ) then
        tvs_Is_idburp_tovs = .true.
        exit
     endif
  enddo

end function tvs_Is_idburp_tovs

logical function tvs_Is_idburp_inst(idburp,cinst)
  implicit none
  integer ,intent(in) :: idburp
  character (len=*) ,intent(in) :: cinst

  tvs_Is_idburp_inst = ( idburp == codtyp_get_codtyp(cinst) )

end function tvs_Is_idburp_inst

integer function tvs_get_platform_id(name)
!******************************************
! S. Heilliette November 2015
! return RTTOV platform id (>0) from
! platform name.
! -1 if not found
!******************************************
  implicit none
  character(len=*),intent(in) :: name
!************************************
  integer :: i, ipos1, ipos2
  character(len=64) :: tempo_name
!*************************************

  tvs_get_platform_id = -1
  ipos1 = LEN_TRIM(name)
  call up2low(name(1:ipos1),tempo_name(1:ipos1))

  if ( INDEX(tempo_name(1:ipos1),"npp") /=0 ) then
     tvs_get_platform_id = platform_id_jpss
  else
     do i = 1, nplatforms
        ipos2 = INDEX(tempo_name(1:ipos1),trim(platform_name(i)))
        if ( ipos2 == 1) then
           tvs_get_platform_id = i
           exit
        endif
     enddo
  endif

end function tvs_get_platform_id

integer function tvs_get_inst_id(name)
!******************************************
! S. Heilliette November 2015
! return RTTOV instrument id from
! intrument name. 0 is a valid answer.
! -1 if not found
!******************************************
  implicit none
  character(len=*),intent(in) :: name
!************************************
  integer :: i, ipos1
  character(len=64) :: tempo_name
!***********************************
  tvs_get_inst_id = -1
  ipos1 = LEN_TRIM(name)
  call up2low(name(1:ipos1),tempo_name(1:ipos1))
  if ( trim(tempo_name(1:ipos1)) == "goesim" ) then
     tvs_get_inst_id = inst_id_goesim
  elseif ( trim(tempo_name(1:ipos1)) == "gmsim" ) then
     tvs_get_inst_id = inst_id_gmsim
  else
     do i = 0, ninst-1
        if (trim(inst_name(i)) == tempo_name(1:ipos1) ) then
           tvs_get_inst_id = i
           exit
        endif
     enddo
  endif
end function tvs_get_inst_id

logical function tvs_Is_Instrum_Hyperspectral(instrum)
!******************************************
! S. Heilliette November 2015
! given an RTTOV instrument code
! return if it is an hyperspectral one
! information from namelist NAMHYPER
!******************************************
  implicit none
  integer,intent(in) :: instrum
!******************************************
  integer ,parameter :: maxsize = 100
  integer :: nulnam, ierr, i 
  integer ,save :: list_inst(maxsize), ninst_hir
  logical, save :: lfirst = .true.
  integer ,external :: fclos, fnom
  character (len=6) :: name_inst(maxsize)
  NAMELIST /NAMHYPER/ name_inst

  if (lfirst) then
     nulnam = 0
     ninst_hir = 0
     name_inst(:) = "XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namhyper, iostat=ierr)
     if (ierr.ne.0) call varAbort('tvs_Is_Instrum_Hyperspectral: Error reading namelist')
     if (mpi_myid.eq.0) write(*,nml=namhyper)
     ierr = fclos(nulnam)
     list_inst(:) = -1
     do i=1, maxsize
        list_inst(i) = tvs_get_inst_id( name_inst(i) )
        if (name_inst(i) /= "XXXXXX") then
           if (list_inst(i) == -1) then
              Write(*,*) i,name_inst(i)
              call varAbort('tvs_Is_Instrum_Hyperspectral: Unknown instrument name')
           endif
        else
           ninst_hir = i -1
           exit
        endif
     enddo
     lfirst = .false.
     if (ninst_hir == 0) then
        Write(*,*) "tvs_Is_Instrum_Hyperspectral: Warning : empty namhyper namelist !"
     endif
  endif
  tvs_Is_Instrum_Hyperspectral = .false.
  do i=1, ninst_hir
     if ( instrum == list_inst(i)) then
        tvs_Is_Instrum_Hyperspectral =.true.
        exit
     endif
  enddo

end function tvs_Is_Instrum_Hyperspectral

logical function tvs_Is_Instrum_Geostationary(instrum)
!******************************************
! S. Heilliette November 2015
! given an RTTOV instrument code
! return if it is a Geostationnary Imager
! information from namelist NAMGEO
!******************************************
  implicit none
  integer,intent(in) :: instrum
!******************************************
  integer ,parameter :: maxsize = 100
  integer :: nulnam, ierr, i 
  integer ,save :: list_inst(maxsize), ninst_geo
  logical, save :: lfirst = .true.
  character (len=6) :: name_inst(maxsize)
  integer ,external :: fnom, fclos

  NAMELIST /NAMGEO/ name_inst
  if (lfirst) then
     nulnam = 0
     ninst_geo = 0
     name_inst(:) = "XXXXXX"
     ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
     read(nulnam,nml=namgeo, iostat=ierr)
     if (ierr.ne.0) call varAbort('tvs_Is_Instrum_Geostationary: Error reading namelist')
     if (mpi_myid.eq.0) write(*,nml=namgeo)
     ierr = fclos(nulnam)
     list_inst(:) = -1
     do i=1, maxsize
        list_inst(i) = tvs_get_inst_id( name_inst(i) )
        if (name_inst(i) /= "XXXXXX") then
           if (list_inst(i) == -1) then
              Write(*,*) i,name_inst(i)
              call varAbort('tvs_Is_Instrum_Geostationary: Unknown instrument name')
           endif
        else
           ninst_geo = i -1
           exit
        endif
     enddo
     lfirst = .false.
     if (ninst_geo == 0) then
        Write(*,*) "tvs_Is_Instrum_Geostationary: Warning : empty namgeo namelist !"
     endif
  endif
  tvs_Is_Instrum_Geostationary = .false.
  do i=1, ninst_geo
     if ( instrum == list_inst(i)) then
        tvs_Is_Instrum_Geostationary =.true.
        exit
     endif
  enddo

end function tvs_Is_Instrum_Geostationary

End Module tovs_nl_mod

