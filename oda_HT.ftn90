!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_HT(lcolumn,lcolumng,lobsSpaceData)
  use EarthConstants_mod
  use MathPhysConstants_mod
  use obsSpaceData_mod
  use columnData_mod 
  use masks_mod
  use bufr
  implicit none
  !
  !Purpose:
  !Call the several adjoint of observation operators
  !
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
#include "pardim.cdk"
#include "comgpsgb.cdk"

  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_vco), pointer :: vco_anl

  vco_anl => col_getVco(lcolumng)

  call tmg_start(64,'GPSZTD') !
  call oda_HTgp
  call tmg_stop (64)        !

  call tmg_start(63,'ZPROF') !
  call oda_HTzp
  call tmg_stop (63)

  call tmg_start(90,'GPSRO') !
  call oda_HTro
  call tmg_stop (90)      !     !

  call tmg_start(60,'RTTOV') !
  call oda_HTto
  call tmg_stop (60)      !

  call tmg_start(59,'SFC')
  call oda_HTsf
  call tmg_stop (59)      !

  call tmg_start(56,'PPROF') !
  call oda_HTpp
  call tmg_stop (56)

  CONTAINS

      SUBROUTINE oda_HTpp
!*
!***s/r AOBSPPP  - Adjoint of the "vertical" interpolation
!*                  for "UPPER AIR" data files.
!*
!*
!*
!*Author  : P. Koclas *CMC/AES  April 1996
!*
!*     Purpose: based on vint3d to build the adjoint of the
!*              vertical interpolation for UPPER-AIR data files.
!*
      INTEGER IPB,IPT,IDBURP,ITYP
      REAL*8 ZRES,ZOER
      REAL*8 ZWB,ZWT,zcon,zexp,zgamma,ZATV,ZTVG
      REAL*8 ZLEV,ZPT,ZPB,ZDADPS,ZPRESBPB,ZPRESBPT
      INTEGER IOBS,IK
      INTEGER J,JDATA
      LOGICAL LLPRINT
      REAL*8 columngVarT,columngVarB,lqtoes
      real*8, pointer :: all_column(:),tt_column(:),hu_column(:),ps_column(:)
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C
      LLPRINT = .FALSE.
!ccc      LLPRINT = .TRUE.
      zgamma = 0.0065 / GRAV
      zexp = MPC_RGAS_DRY_AIR_R8*zgamma
!C
!C*    1. Fill in COMMVO by using the adjoint of the "vertical"
!c interpolation
!C
!C     Process all data within the domain of the model
!C
        DO JDATA=1,obs_numbody(lobsSpaceData)
          IF (lmaskpp_in(jdata)) THEN
            IOBS = obs_elem_i(lobsSpaceData,'OBS ',JDATA)
            ZOER = obs_elem_r8(lobsSpaceData,'OER ',JDATA)
            ZRES = obs_elem_r8(lobsSpaceData,'OMI ',JDATA)
            ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',JDATA)
            IDBURP = obs_elem_i(lobsSpaceData,'ITY ',IOBS)
            ITYP = obs_elem_i(lobsSpaceData,'VNM ',JDATA)
            IK   = obs_elem_i(lobsSpaceData,'LYR ',JDATA)
            IPT  = IK  + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1
            ZPT  = col_getPressure(LCOLUMNG,IK,IOBS,'NA')
            ZPB  = col_getPressure(LCOLUMNG,IK+1,IOBS,'NA')
            ZWB  = LOG(ZLEV/ZPT)/LOG(ZPB/ZPT)
            ZWT  = 1.0D0 - ZWB
            zpresbpt = vco_anl%db_M(ik)
            zpresbpb = vco_anl%db_M(ik+1)

            ZDADPS   = ( (ZPRESBPT/ZPT)*LOG(ZLEV/ZPB) &
                 -(ZPRESBPB/ZPB)*LOG(ZLEV/ZPT) ) &
                 /LOG(ZPB/ZPT)**2
!C
!C               Set ZDADPS to zero for HUMSAT (idtyp=158)
            IF (IDBURP .EQ. 158) THEN
              ZDADPS = 0.0
            ENDIF

            all_column => col_getColumn(lcolumn,IOBS)
            tt_column  => col_getColumn(lcolumn,IOBS,'TT')
            hu_column  => col_getColumn(lcolumn,IOBS,'HU')
            ps_column  => col_getColumn(lcolumn,IOBS,'P0')
            if(ITYP.eq.BUFR_NEES) then
              call lqtoes_ad(hu_column(IK+1),tt_column(IK+1),ps_column(1),  &
                ZWB*ZRES,col_getElem(lcolumng,IK+1,IOBS,'HU'),col_getPressure(lcolumng,IK+1,IOBS,'NA'),  &
                vco_anl%dhyb_m(IK+1),vco_anl%db_m(IK+1))
              call lqtoes_ad(hu_column(IK  ),tt_column(IK  ),ps_column(1),  &
                ZWT*ZRES,col_getElem(lcolumng,IK  ,IOBS,'HU'),col_getPressure(lcolumng,IK  ,IOBS,'NA'),  &
                vco_anl%dhyb_m(IK  ),vco_anl%db_m(IK  ))
              columngVarB=lqtoes(col_getElem(lcolumng,IK+1,IOBS,'HU'),col_getElem(lcolumng,IK+1,IOBS,'TT'),col_getPressure(lcolumng,IK+1,IOBS,'NA'))
              columngVarT=lqtoes(col_getElem(lcolumng,IK  ,IOBS,'HU'),col_getElem(lcolumng,IK  ,IOBS,'TT'),col_getPressure(lcolumng,IK  ,IOBS,'NA'))
            else
              all_column(IPB) = all_column(IPB) + ZWB*ZRES
              all_column(IPT) = all_column(IPT) + ZWT*ZRES
              columngVarB=col_getElem(lcolumng,IPB,IOBS)
              columngVarT=col_getElem(lcolumng,IPT,IOBS)
            endif
            ps_column(1)    = ps_column(1)    +         &
                 (columngVarB - columngVarT)  &
                 *ZDADPS*ZRES
          elseif (lmaskpp_out(jdata)) THEN
            IOBS = obs_elem_i(lobsSpaceData,'OBS ',JDATA)
            ZOER = obs_elem_r8(lobsSpaceData,'OER ',JDATA)
            ZRES = obs_elem_r8(lobsSpaceData,'OMI ',JDATA)
            ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',JDATA)
            IDBURP = obs_elem_i(lobsSpaceData,'ITY ',IOBS)
            IPT  = col_getNumLev(lcolumn)-1 + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1
!c
!c-------------adjoint of TL of geopotential extrapolation below
!c orography
!c
            zcon = (zlev/col_getElem(lcolumng,1,iobs,'P0'))**zexp
            ZATV = ((1.0 - ZCON)/ZGAMMA)*ZRES
            ZTVG = lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*col_getElem(lcolumng,col_getNumLev(lcolumn),IOBS,'TT')
            ps_column(1)    = ps_column(1)  &
                 + MPC_RGAS_DRY_AIR_R8*ZTVG*zcon*zres &
                 / col_getElem(lcolumng,1,iobs,'P0')
            tt_column(col_getNumLev(lcolumn)) = tt_column(col_getNumLev(lcolumn))  &
                 + lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*ZATV
            hu_column(col_getNumLev(lcolumn)) = hu_column(col_getNumLev(lcolumn))  &
                 + lcolumng%OLTV(2,col_getNumLev(lcolumn),IOBS)*ZATV
          ENDIF
        END DO
      RETURN
      END subroutine oda_HTpp


      SUBROUTINE oda_HTsf
!*
!***s/r AOBSSFC  - Adjoint of the "vertical" interpolation
!*                  for "SURFACE" data files.
!*
!*Author  : P. Koclas *CMC/AES  April 1996
!*    -------------------
!*
!*     Purpose: based on surfc1dz to build the adjoint of the
!*              vertical interpolation for SURFACE data files.
!*
      INTEGER IPB,IPT
      REAL*8 ZRES
      REAL*8 ZWB,ZWT,zcon,zexp,zexpgz,zgamma,ZATV,ZTVG
      REAL*8 ZLEV,ZPT,ZPB,ZDADPS,ZDELPS,ZDELTV,ZGAMAZ,ZHHH
      INTEGER IOBS,IK
      INTEGER J,JDATA,ITYP
      real*8, pointer :: all_column(:),tt_column(:),hu_column(:),ps_column(:)
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C
      zgamma = 0.0065 / GRAV
      zexp   = 1.0/(MPC_RGAS_DRY_AIR_R8*zgamma)
      zexpgz = MPC_RGAS_DRY_AIR_R8*zgamma
!C
!C*    1. Fill in COMMVO by using the adjoint of the "vertical"
!c interpolation
!C     .  ---------------------------------------------------------------
!C
!C     Process all data within the domain of the model
!C
        DO JDATA=1,obs_numbody(lobsSpaceData)
          IF (lmasksf_in(jdata)) THEN
            IOBS = obs_elem_i(lobsSpaceData,'OBS ',JDATA)
            all_column => col_getColumn(lcolumn,IOBS)
            tt_column  => col_getColumn(lcolumn,IOBS,'TT')
            hu_column  => col_getColumn(lcolumn,IOBS,'HU')
            ps_column  => col_getColumn(lcolumn,IOBS,'P0')
            ITYP = obs_elem_i(lobsSpaceData,'VNM ',JDATA)
            IK   = obs_elem_i(lobsSpaceData,'LYR ',JDATA)
            ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',JDATA)
            ZHHH = ZLEV * GRAV
            IPT  = col_getNumLev(lcolumn)-1 + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1
            ZRES = obs_elem_r8(lobsSpaceData,'OMI ',JDATA)
            IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NESS .OR.  &
                ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS ) THEN
              if(ityp.eq.bufr_ness) then
                call lqtoes_ad(hu_column(col_getNumLev(lcolumn)),tt_column(col_getNumLev(lcolumn)),ps_column(1),  &
                  ZRES,col_getElem(lcolumng,col_getNumLev(lcolumn),IOBS,'HU'),col_getPressure(lcolumng,col_getNumLev(lcolumn),IOBS,'NA'),  &
                  vco_anl%dhyb_m(col_getNumLev(lcolumn)),vco_anl%db_m(col_getNumLev(lcolumn)))
              else
                all_column(IPB) = all_column(IPB) + ZRES
              endif
            ELSEIF (ITYP.EQ.BUFR_NEPS .OR. ITYP.EQ.BUFR_NEPN) THEN
              ZTVG  = lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*col_getElem(lcolumng,col_getNumLev(lcolumn),IOBS,'TT')
              ZGAMAZ= ZGAMMA*(ZHHH-col_getHeight(lcolumng,col_getNumLev(lcolumn),IOBS,'NA'))
              ZCON  = ((ZTVG-ZGAMAZ)/ZTVG)
              ZDELTV= (col_getElem(lcolumng,1,IOBS,'P0')*ZEXP*ZCON**(ZEXP-1))  &
                   *(ZGAMAZ/(ZTVG*ZTVG))
              ZDELPS= ZCON**ZEXP
              ZATV  = ZDELTV*ZRES
              ps_column(1)    = ps_column(1) + ZDELPS*ZRES
              tt_column(col_getNumLev(lcolumn)) = tt_column(col_getNumLev(lcolumn))  &
                   + lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*ZATV
              hu_column(col_getNumLev(lcolumn))= hu_column(col_getNumLev(lcolumn))   &
                   + lcolumng%OLTV(2,col_getNumLev(lcolumn),IOBS)*ZATV
            ELSE
              IPT  = IK + col_getOffsetFromVarno(lcolumng,ityp)
              IPB  = IPT+1
              ZPT  = col_getHeight(lcolumng,IK  ,IOBS,'NA')
              ZPB  = col_getHeight(lcolumng,IK+1,IOBS,'NA')
              ZWB  = (ZPT-ZHHH)/(ZPT-ZPB)
              ZWT  = 1. - ZWB
!ccc ATTN ATTN ZDADPS EST A DEFINIR POUR UNE COORDONNEE Z
              ZDADPS= 0.
              all_column(IPB) = all_column(IPB) + ZWB*ZRES
              all_column(IPT) = all_column(IPT) + ZWT*ZRES
              ps_column(1)    = ps_column(1)    +         &
                   (col_getElem(lcolumng,IPB,IOBS) - col_getElem(lcolumng,IPT,IOBS))  &
                   *ZDADPS*ZRES
            ENDIF
            
          elseif(lmasksf_out(jdata)) then
            IOBS = obs_elem_i(lobsSpaceData,'OBS ',JDATA)
            ZRES = obs_elem_r8(lobsSpaceData,'OMI ',JDATA)
            ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',JDATA)
!C
!c  adjoint of TL of geopotential extrapolation below orography
!c
            zcon = (zlev/col_getElem(lcolumng,1,iobs,'P0'))**zexpgz
            ZATV = ((1.0 - ZCON)/ZGAMMA)*ZRES
            ZTVG = lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*col_getElem(lcolumng,col_getNumLev(lcolumn),IOBS,'TT')
            ps_column(1)    = ps_column(1)     &
                 + MPC_RGAS_DRY_AIR_R8*ZTVG*zcon*zres &
                 / col_getElem(lcolumng,1,iobs,'P0')
            tt_column(col_getNumLev(lcolumn)) = tt_column(col_getNumLev(lcolumn))  &
                 + lcolumng%OLTV(1,col_getNumLev(lcolumn),IOBS)*ZATV
            hu_column(col_getNumLev(lcolumn)) = hu_column(col_getNumLev(lcolumn))  &
                 + lcolumng%OLTV(2,col_getNumLev(lcolumn),IOBS)*ZATV                
          endif
        END DO
      RETURN
      END subroutine oda_HTsf


subroutine oda_HTto
!
!**s/r tovs_obs_ad  - Adjoint of computation of residuals to the tovs observations
!
!
!author        : j. halle *cmda/aes  april 19, 2005
!
!revision 001  :
!                S. Pellerin - ARMA, jan. 2009
!                - call  to oda_get_radiance_ad
!
!    -------------------
!     purpose:
!
!     1.   Getting the adjoint of the residuals
!     .    ----------------------------------
!
  call oda_get_radiance_ad(lobsSpaceData)

!     2.   Adjoint of computing radiance
!     .    -----------------------------
!
  call tovs_rttov_ad(lobsSpaceData)


!     3.   Adjoint of preparation of atmospheric profiles
!     .    ----------------------------------------------
!
  call tovs_fill_profiles_ad(lcolumn,lcolumng,lobsSpaceData)

end subroutine oda_HTto


      SUBROUTINE oda_HTro
!*
!***s/r AVGPSRO - Adjoint of the computation of Jo and
!*                the residuals to the GPSRO observations
!*
!*Author  : J. M. Aparicio Jan 2004
!*    -------------------
!**    Purpose:
!*
      use modgps04profile
      use modgps06gravity
      use modgps08refop
      use IndexListDepot_mod, only:  struct_index_list

      REAL*8 DPJO0(ngpscvmx)
      REAL*8 DPJO1(ngpscvmx)

      REAL*8 ZLAT, Lat
      REAL*8 ZLON, Lon
      REAL*8 ZETA(JPNFLEV)
      REAL*8 BTT(JPNFLEV)
      REAL*8 BHU(JPNFLEV)
      REAL*8 BGZ(JPNFLEV)
      REAL*8 BP0
      REAL*8 BPT, BPR, BCF
      REAL*8 BMT
      REAL*8 HNH1

      REAL*8 ZOBS, ZMHX, ZINC, ZOBI
      REAL*8 JAC(ngpscvmx)

      real*8, pointer :: tt_column(:),hu_column(:),ps_column(:)
      INTEGER IDATYP
      INTEGER JL, NGPSLEV
      integer :: index_header, index_body
      type(struct_index_list), pointer :: local_current_list

      LOGICAL  ASSIM, LUSE

      INTEGER NH, NH1
      TYPE(GPSPROFILE)           :: PRF
      REAL(DP)     , ALLOCATABLE :: H   (:)
      TYPE(GPSDIFF), ALLOCATABLE :: RSTV(:)
!C
!C     * 1.  Initializations
!C     *     ---------------
!C

!C
!C     *     Eta vector:
!C
      NGPSLEV=col_getNumLev(lcolumn)
      DO JL = 1, col_getNumLev(lcolumn)
        ZETA(JL) = vco_anl%dhyb_m(JL)
      ENDDO

      !
      ! loop over all header indices of the 'RO' family (Radio Occultation)
      !
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,'RO')
!$omp parallel default(shared) &
!$omp private(dpjo0,idatyp,assim,nh) &
!$omp private(luse,lat,lon,zlat,zlon,jl,btt) &
!$omp private(bhu,bgz,bp0,bpt,bmt,bpr,bcf,prf) &
!$omp private(h,rstv,nh1,hnh1,zmhx,zobi,zobs) &
!$omp private(jac,zinc,dpjo1) &
!$omp private(index_header,index_body, local_current_list) &
!$omp private(tt_column,hu_column,ps_column)
      nullify(local_current_list)

      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER

         DPJO0 = 0._dp
!C
!C     *    Calculate DPJO0 only for refractivity observations (codtyp 169)
!C
         IDATYP = obs_elem_i(lobsSpaceData,'ITY ',INDEX_HEADER)
         DATYP: IF ( IDATYP .EQ. 169 ) THEN
           ASSIM = .FALSE.
!C
!C              Scan for requested assimilations, and count them
!C
           NH = 0
           ! loop over all body indices (still in the 'RO' family)
                                        ! Obtain the body list
                                        ! (& start at the beginning of the list)
           call obs_set_current_body_list(lobsSpaceData, index_header, &
                                          current_list=local_current_list)
           BODY: do 
              index_body = obs_getBodyIndex(local_current_list)
              if (index_body < 0) exit BODY

             LUSE=( obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY).EQ.1 )
             IF ( LUSE ) THEN
               ASSIM = .TRUE.
               NH = NH + 1
             ENDIF
           ENDDO BODY
!C
!C     *           If assimilations are requested, apply the observation
!c operator
!C
           ASSIMILATE: IF (ASSIM) THEN
!C
!C     *           Profile at the observation location:
!C
             Lat  = obs_elem_r8(lobsSpaceData,'LAT ',INDEX_HEADER)
             Lon  = obs_elem_r8(lobsSpaceData,'LON ',INDEX_HEADER)
             ZLAT = obs_elem_r8(lobsSpaceData,'LAT ',INDEX_HEADER) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
             ZLON = obs_elem_r8(lobsSpaceData,'LON ',INDEX_HEADER) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
             DO JL = 1, col_getNumLev(lcolumn)
!C
!C     *              Profile x_b
!C
               BTT(JL) = col_getElem(lcolumng,JL,INDEX_HEADER,'TT') - 273.15
               BHU(JL) = col_getElem(lcolumng,JL,INDEX_HEADER,'HU')
               BGZ(JL) = col_getHeight(lcolumng,JL,INDEX_HEADER,'NA')
             ENDDO
             BP0 = col_getElem(lcolumng,1,INDEX_HEADER,'P0')
             BPT = col_getPressure(LCOLUMNG,1,INDEX_HEADER,'NA')
             BMT = BGZ(col_getNumLev(lcolumn))/RG
             BMT = gpsgeopotential(Lat, BMT)/RG
             BPR = vco_anl%dprf_M
             BCF = vco_anl%drcf1
!C
!C     *           GPS profile structure:
!C
             CALL GPSSTRUCT1H(NGPSLEV,ZLAT,ZLON,ZETA,  &
                  BTT,BHU,BP0,BMT,BPT,BPR,BCF,PRF)
             call gpsgeo(prf)
!C
!C     *           Prepare the vector of all the observations
!C
             ALLOCATE( H    (NH) )
             ALLOCATE( RSTV (NH) )
             NH1 = 0
             ! loop over all body indices (still in the 'RO' family)
                                        ! Start at the beginning of the list
             call obs_set_current_body_list(lobsSpaceData, index_header, &
                                            current_list=local_current_list)
             BODY_2: do 
                index_body = obs_getBodyIndex(local_current_list)
                if (index_body < 0) exit BODY_2

               LUSE=( obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY).EQ.1 )
               IF ( LUSE ) THEN
                 NH1 = NH1 + 1
                 HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',INDEX_BODY)
                 H(NH1)= gpsgeopotential(Lat,HNH1)/9.80616
               ENDIF
             ENDDO BODY_2
!C
!C     *           Apply the observation operator
!C
             CALL GPSREFOPV(H, PRF, RSTV)
!C
!C     *           Perform the (H(xb)DX-Y')/S operation
!C
             NH1 = 0
             ! loop over all body indices (still in the 'RO' family)
                                        ! Start at the beginning of the list
             call obs_set_current_body_list(lobsSpaceData, index_header, &
                                            current_list=local_current_list)
             BODY_3: do 
                index_body = obs_getBodyIndex(local_current_list)
                if (index_body < 0) exit BODY_3

               LUSE=( obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY).EQ.1 )
               IF ( LUSE ) THEN
                 NH1 = NH1 + 1
!C
!C     *                 Observation operator H(x)
!C
                 ZMHX = RSTV(NH1)%VAR
!C
!C     *                 Observation increment Y'=Y-H(x)
!C
                 ZOBI = obs_elem_r8(lobsSpaceData,'VAR ',INDEX_BODY)
!C
!C     *                 Observation value    Y
!C
                 ZOBS = ZMHX + ZOBI
!C
!C     *                 Observation jacobian
!C
                 JAC = RSTV(NH1)%DVAR
!C
!C     *                 Normalized increment
!C
                 ZINC = obs_elem_r8(lobsSpaceData,'OMI ',INDEX_BODY)
!C
!C                       O-F Tested criteria:
!C
                 DPJO1 = ZINC * JAC
!C
!C     *                 Accumulate the gradient of the observation
!C     *                 cost function
!C
                 DPJO0 = DPJO0 + DPJO1

               ENDIF
             ENDDO BODY_3
             DEALLOCATE( RSTV )
             DEALLOCATE( H    )
           ENDIF ASSIMILATE
         ENDIF DATYP
!C
!C     *        Store H* (HX - Z)/SIGMA in COMMVO
!C
         tt_column => col_getColumn(lcolumn,index_header,'TT')
         hu_column => col_getColumn(lcolumn,index_header,'HU')
         ps_column => col_getColumn(lcolumn,index_header,'P0')
         DO JL = 1, col_getNumLev(lcolumn)
           tt_column(JL) = DPJO0(JL)
           hu_column(JL) = DPJO0(JL+col_getNumLev(lcolumn))
         ENDDO
         ps_column(1) = DPJO0(1+2*col_getNumLev(lcolumn))

      ENDDO HEADER
!$omp end parallel

      RETURN
      END subroutine oda_HTro


      SUBROUTINE oda_HTzp
!*
!***s/r AOBSZZZ  - Adjoint of the "vertical" interpolation in z
!*                 for profiler data.
!*
!*Author  : J. St-James *CMDA/SMC  July 2003
!*Revision :
!*    -------------------
!*
!*     Purpose: based on vint3d to build the adjoint of the
!*              vertical interpolation for profiler data.
!*
      INTEGER IPB,IPT
      REAL*8 ZRES,ZDA1,ZDA2,ZDENO
      REAL*8 ZWB,ZWT
      REAL*8 ZLEV,ZPT,ZPB
      INTEGER IOBS,IK,ITYP
      INTEGER J,JDATA
      real*8, pointer :: gz_column(:),all_column(:)
!C
!C     Process all data within the domain of the model
!C
        DO JDATA=1, obs_numbody(lobsSpaceData)
          IF (lmaskzp(jdata) ) THEN
            IOBS = obs_elem_i(lobsSpaceData,'OBS ',JDATA)
            gz_column  => col_getColumn(lcolumn,IOBS,'GZ')
            all_column => col_getColumn(lcolumn,IOBS)
            ITYP = obs_elem_i(lobsSpaceData,'VNM ',JDATA)
            ZRES = obs_elem_r8(lobsSpaceData,'OMI ',JDATA)
            ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',JDATA)
            IK   = obs_elem_i(lobsSpaceData,'LYR ',JDATA)
            IPT  = IK  + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1
            ZPT  = col_getHeight(lcolumng,IK,IOBS,'NA')/RG
            ZPB  = col_getHeight(lcolumng,IK+1,IOBS,'NA')/RG
            ZDENO= ZPT-ZPB
            ZWB  = (ZPT-ZLEV)/ZDENO
            ZWT  = 1.0D0 - ZWB

            ZDA1= (ZLEV-ZPB)/(ZDENO**2)
            ZDA2= (ZPT-ZLEV)/(ZDENO**2)
!C
            gz_column(IK+1) = gz_column(IK+1) +    &
                 (col_getElem(lcolumng,IPB,IOBS)-col_getElem(lcolumng,IPT,IOBS))*ZDA2*ZRES/RG
            gz_column(IK) = gz_column(IK) +        &
                 (col_getElem(lcolumng,IPB,IOBS)-col_getElem(lcolumng,IPT,IOBS))*ZDA1*ZRES/RG
            all_column(IPB) = all_column(IPB) + ZWB*ZRES
            all_column(IPT) = all_column(IPT) + ZWT*ZRES

          ENDIF
        END DO
      RETURN
      END subroutine oda_HTzp


      SUBROUTINE oda_HTgp
!*
!***s/r  -oda_HTgp Adjoint of TL routine oda_Hgp
!*
!*
!*Author  : S. Macpherson *ARMA December 2004
!*    -------------------
!**    Purpose: Compute Ht*grad(Jo) for all GPS ZTD observations using
!*              adjoint of gpsztdop
!*
      REAL*8 ZLAT
      REAL*8 ZLON
      REAL*8, allocatable :: ZETA(:)
      REAL*8, allocatable :: ZTT (:)
      REAL*8, allocatable :: ZHU (:)
      REAL*8, allocatable :: ZGZ (:)
      REAL*8, allocatable :: ZTTB (:)
      REAL*8, allocatable :: ZHUB (:)
      REAL*8 ZP0
      REAL*8 ZP0B
      REAL*8 ZPT
      REAL*8 ZMT
      REAL*8 ZHX, ZLEV
      REAL*8 ZHXB
      REAL*8, allocatable :: DZTT (:)
      REAL*8, allocatable :: DZHU (:)
      REAL*8 DZP0
      INTEGER JL
      integer :: index_header, index_body
      LOGICAL  ASSIM, LLOK
      INTEGER NH, NH1
      real*8, pointer :: all_column(:),tt_column(:),hu_column(:),ps_column(:)
!C
!C     * 1.  Initializations
!C     *     ---------------
!C
      allocate(ZETA(col_getNumLev(lcolumn)))
      allocate(ZTT (col_getNumLev(lcolumn)))
      allocate(ZHU (col_getNumLev(lcolumn)))
      allocate(ZGZ (col_getNumLev(lcolumn)))
      allocate(ZTTB (col_getNumLev(lcolumn)))
      allocate(ZHUB (col_getNumLev(lcolumn)))
      allocate(DZTT (col_getNumLev(lcolumn)))
      allocate(DZHU (col_getNumLev(lcolumn)))
!C
!C     *    .   1.1  Eta vector
!C     *    .        ----------
!C
      DO JL = 1, col_getNumLev(lcolumn)
         ZETA(JL) = vco_anl%dhyb_m(JL)
      ENDDO

      write(*,fmt='(/,4x,A)') 'AVGPSZTD- Adjoint Version: GPS ZTD observations'

      ! loop over all header indices of the 'GP' family (GPS observations)
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,'GP')
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER

         tt_column  => col_getColumn(lcolumn,index_header,'TT')
         hu_column  => col_getColumn(lcolumn,index_header,'HU')
         ps_column  => col_getColumn(lcolumn,index_header,'P0')
         DZTT(:) = 0.0
         DZHU(:) = 0.0
         DZP0 = 0.0
!C
!C       Scan for requested ZTD assimilation
!C
         NH = 0
         ASSIM = .FALSE.
         ! loop over all body indices (still in the 'GP' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            LLOK = ( lmaskgp(INDEX_BODY) )
            IF ( LLOK ) THEN
               ASSIM = .TRUE.
               NH = NH + 1
            ENDIF
         ENDDO BODY
!C
!C     * If ZTD assimilation, apply the AD observation operator
!C
         IF (ASSIM) THEN
!C
!C     *    LR background profile:
!C
            ZLAT = obs_elem_r8(lobsSpaceData,'LAT ',INDEX_HEADER) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
            ZLON = obs_elem_r8(lobsSpaceData,'LON ',INDEX_HEADER) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
            DO JL = 1, col_getNumLev(lcolumn)
              ZTTB(JL) = col_getElem(lcolumng,JL,INDEX_HEADER,'TT')
              ZTT(JL)  = 0.0
              ZHUB(JL) = EXP(col_getElem(lcolumng,JL,INDEX_HEADER,'HU'))
              ZHU(JL)  = 0.0
              ZGZ(JL)  = col_getHeight(lcolumng,JL,INDEX_HEADER,'NA')
            ENDDO
            ZP0B = col_getElem(lcolumng,1,INDEX_HEADER,'P0')
            ZP0  = 0.0
            ZPT  = col_getPressure(LCOLUMNG,1,INDEX_HEADER,'NA')
            ZMT  = ZGZ(col_getNumLev(lcolumn))/GRAV
!C
!C     *       Apply AD of ZTD observation operator to get 
!C             Ht*grad(Index_header) = Ht*(H'dx - d)/sigma_o^2
!C
            NH1 = 0
            ! loop over all body indices (still in the 'GP' family)
                                        ! Start at the beginning of the list)
            call obs_set_current_body_list(lobsSpaceData, index_header)
            BODY_2: do 
               index_body = obs_getBodyIndex(lobsSpaceData)
               if (index_body < 0) exit BODY_2

               IF ( lmaskgp(INDEX_BODY) ) THEN
                  NH1 = NH1 + 1
!C                call obs_set_r8(lobsSpaceData,'OMI ',INDEX_BODY, grad(Index_header) 
!c                                        = (H'dx - d)/sigma_o^2)
                  ZHX = obs_elem_r8(lobsSpaceData,'OMI ',INDEX_BODY)

!C     *          Observation height (m)
                  ZLEV = obs_elem_r8(lobsSpaceData,'PPP ',INDEX_BODY)
!C     *          Call GP-ZTD adjoint operator: input = ZHX,
!c                   output = ZTT,ZHU,ZP0
                  CALL GPSZTDOPAD(ZLAT,ZLON,ZLEV,ZETA,ZTTB,   &
                                  ZHUB,ZP0B,ZPT,ZMT,ZGZ,ZHXB,ZTT,ZHU,ZP0,ZHX,col_getNumLev(lcolumn))

                  DZTT(:) = DZTT(:) + ZTT(:)
!C                dJo/dQ ---> dJo/d(lnQ) 
                  DZHU(:) = DZHU(:) + ZHUB(:)*ZHU(:)
                  DZP0 = DZP0 + ZP0
               ENDIF
            ENDDO BODY_2

         ENDIF ! ASSIM
!c
!C      *   Store Ht*grad(Index_header) in COMMVO
!c
         DO JL = 1, col_getNumLev(lcolumn)
            tt_column(JL) = DZTT(JL)
            hu_column(JL) = DZHU(JL)
         ENDDO
         ps_column(1) = DZP0
      ENDDO HEADER

      deallocate(ZETA)
      deallocate(ZTT)
      deallocate(ZHU)
      deallocate(ZGZ)
      deallocate(ZTTB)
      deallocate(ZHUB)
      deallocate(DZTT)
      deallocate(DZHU)

      RETURN
      END subroutine oda_HTgp



end subroutine oda_HT
