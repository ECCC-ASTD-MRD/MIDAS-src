!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
! MODULE bMatrixChem:  Contains routines involving preparation and application
!                      of background-error covariance matrix(ces). Matrix
!                      based on horizontally homogeneous/isotropic
!                      correlations.  prefix="bchm_" used for routines in 
!                      this module ("chm_" in other modules).
!
! Purpose: Holds routines for (1) reading and preparing the static bacground 
!          error covariance matrix (if reading of balance operators if any are
!          eventually added) and (2) transformations from control 
!          vector (spectral space) to analysis increments (and its adjoint) 
!          using the background error covariance matrix (and the balance 
!          operators when present).
!
!          Based on bmatrixHI_mod.ftn90. See bmatrix_mod.ftn90 for usage of public routines.
!
! Author: Ping Du (based on bMatrixHI_mod.ftn90 by Mark Buehner), July-Sept 2014
!         - Code changes mainly pertain to the addition of all aspects related to
!           O3 as constituent and the introduction of the variables *_chm
!         - Partial removal of bMatrixHI_mod components related to standard weather
!           incremental variables
!
! Revisions:
!        Ping Du, Jan 2015
!         - Change from btr/tr to bchm/chm prefixes/suffixes.
!        Yves Rochon, October 2014 - Feb 2015
!        - Addition and modification of comments.
!        - Generalizations for any constituent or set of constituents.
!        - Extended use of nsposit and numvar*d instead of nlev_* beyond
!          bchm_setup.
!        - Main revised routines: BCHM_setup, BCHM_copyToStatevector,
!                 BCHM_copyFromStatevector, BCHM_readcorns2, BCHM_convol,
!                 BCHM_rdspstd, BCHM_rdstsrtd_newfmt, BCHM_sucorns2, BCHM_finalize
!        - Addition of corvert and corverti. 
!
! Comments and  questions:
!
! (1) Covariances uncoupled from weather variable.
!
! (2) Currently assumes univariate constituent assimilation (constituent variables 
!     currently uncorrelated). See routines BCHM_READCORNS2 and BCHM_SUCORNS2. These 
!     routines would need to be modified if cross-correlations were included.
!
! (3) One could potentially make public the functions/routines which are identical to
!     those in bmatrixhi_mod.ftn90 (except possibly in name) so that one copy is 
!     present in the code. 
!
! (4) For multiple univariate variables (or univarite blocks of one to multiple variables), 
!     one could alternatively have multiple sets of covariance matrices within this module
!     instead of a single covariance matrix setup (similarly to what was done for corvert*_chm).
!
! Public Subroutines (which call other internal routines/functions):
!    BCHM_setup:      Must be called first. Sets of background covariance matrix
!                     (and balance operators if any are eventually added)
!                     calls BCHM_sunewsta ts (BCHM_readcorns2, BCHM_rdspstd_newfmt,
!                                             BCHM_scalestd), 
!                           BCHM_sucorns2 (gasparicohn, bchm_corvert_setup, dsyev, 
!                                          rpn_comm_allreduce)
!    BCHM_BSqrt:      Transformations from control vector to analysis increments 
!                     in the minimization process.
!                     calls BCHM_cain, BCHM_spa2gd (dgemul), BCHM_copytoStatevector 
!    BCHM_BSqrtAd:    Adjoint of BCHM_BSqrt.
!                     calls BCHM_copyFromStatvector, BCHM_spa2gdad (dgemul), BCHM_cainad
!    BCHM_Finalize    Deallocate internal module arrays.
!    BCHM_expandToMPIglobal
!    BCHM_reduceToMPIlocal:  calls rpn_comm_*
!    BCHM_getScaleFactor
!    BCHM_corvert_mult: Multiple an input matrix/array with 'corvert' or 'corverti'
!    BCHM_getsigma:   Obtain background error std. dev. profile at obs/specified
!                     location. Calls gst_getrlati.
!    bchm_is_initialized: checks if B_chm has been intialized.
!
! Other subroutines/functions info:
!    BCHM_readcorns2:        calls BCHM_convol (zleginv, zlegdir)
!    BCHM_rdspstd:           calls zleginv2
!    BCHM_rdspstd_newfmt:    calls gst_setID, gst_zlegpol, zleginv2, BCHM_rdspstd
!
! Dependencies:
!    globalSpectralTransform, ....
!
!--------------------------------------------------------------------------
MODULE BmatrixChem
  use topLevelControl_mod
  use mpivar_mod
  use MathPhysConstants_mod
  use earthConstants_mod
  use gridStateVector_mod
  use globalSpectralTransform
  use gaussGrid_mod
  use horizontalCoord_mod
  use verticalCoord_mod
  use varNameList_mod
  implicit none
  save
  private

  ! public procedures
  public :: bchm_Setup,bchm_BSqrt,bchm_BSqrtAd,bchm_Finalize
  public :: bchm_expandToMPIglobal,bchm_reduceToMPIlocal,bchm_getScaleFactor
  public :: bchm_corvert_mult, bchm_getsigma, bchm_is_initialized
  
  logical             :: initialized = .false.                    
  integer             :: nj_l,ni_l                    
  integer             :: nlev_M,nlev_T,nlev_T_even,nkgdim,nkgdim2    
  integer             :: nla_mpiglobal,nla_mpilocal           
  integer             :: cvDim_mpilocal,cvDim_mpiglobal           
  integer             :: gstID, gstID2          
  integer             :: nlev_bdl           
  type(struct_vco),pointer :: vco_anl          

  real(8), pointer    :: pressureProfile_M(:),pressureProfile_T(:)

  integer             :: mymBeg,mymEnd,mymSkip,mymCount
  integer             :: mynBeg,mynEnd,mynSkip,mynCount
  integer             :: maxMyNla
  integer             :: myLatBeg,myLatEnd
  integer             :: myLonBeg,myLonEnd
  integer, pointer    :: ilaList_mpiglobal(:)
  integer, pointer    :: ilaList_mpilocal(:)

! String indicating if calcs for 'BackgroundCheck' or 'Analysis'
! Note: analysisMode above could be alternatively used.
  character(len=15) :: bchm_mode
  logical :: analysisMode
                            
  integer             :: get_max_rss
  integer             :: nulbgst=0

! Bacgkround error covariance matrix elements.
! One could add an additional dimension to corns  
! for separate block-univariate correlation matrices.
! This would also permit merging of bmatrixhi_mod and bmatrixchem_mod 
! into one module.

  real(8),allocatable :: rgsig(:,:)
  real(8),allocatable :: corns(:,:,:)
  real(8),allocatable :: rstddev(:,:)

! Physical space (total) vertical correlation matrices and its inverse.
  
  real(8), allocatable, dimension(:,:,:) :: corvert,corverti

! Parameters of the NAMBCHM namelist

  integer             :: ntrunc
  real(8)             :: rpor(100)
  real(8)             :: rvloc(100)
  integer,parameter   :: maxNumLevels=200
  real(8)             :: scaleFactor(maxNumLevels,100)
  real(8)             :: scaleFactor_sigma(maxNumLevels,100)
  integer             :: numModeZero  ! number of eigenmodes to set to zero

! Number of incremental variables/fields
  integer             :: numvar3d,numvar2d
! Start position of each field in composite arrays
  integer, allocatable :: nsposit(:)
! Name list of incremental variables/fields
  character(len=4),allocatable    :: varNameList(:)


CONTAINS

!-------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_setup(hco_in,vco_in,CVDIM_OUT,mode)
    implicit none

    type(struct_hco),pointer :: hco_in
    type(struct_vco),pointer :: vco_in
    integer                  :: cvDim_out
    character(len=*), intent(in), optional :: mode

    integer :: jlev, mpiMode, nulnam, ierr, fnom, fclos, jm, jn, status
    integer :: latPerPE, lonPerPE
    logical :: llfound
    real(8) :: zps
    logical :: makeEven_in = .false. ! to avoid the even number requirement in mpivar_setup_levels_npex 
  
    integer :: jvar
    
    NAMELIST /NAMBCHM/ntrunc,rpor,rvloc,scaleFactor,numModeZero

    call tmg_start(90,'BCHM_SETUP')

    numvar3d=0
    numvar2d=0
    allocate(varNameList(vnl_numvarmax))
    allocate(nsposit(vnl_numvarmax+1))
    nsposit(1)=1

    if ( present(mode) ) then
       if ( trim(mode) == 'Analysis' .or. trim(mode) == 'BackgroundCheck') then
         bchm_mode = trim(mode)
         if(mpi_myid.eq.0) write(*,*)
         if(mpi_myid.eq.0) write(*,*) 'bchm_setup: Mode activated = ', trim(bchm_mode)
       else
          write(*,*)
          write(*,*) 'mode = ', trim(mode)
          call abort3d('bchm_setup: unknown mode')
       end if
    else
       bchm_mode = 'Analysis'
       if(mpi_myid.eq.0) write(*,*)
       if(mpi_myid.eq.0) write(*,*) 'bchm_setup: Analysis mode activated (by default)'
    end if

!   Identify if analysis mode (top_nconf=141) as this determines if all actions
!   are needed or not. (could be used instead of 

!!    analysisMode=top_AnalysisMode()
     
!   Set vertical dimensions

    vco_anl => vco_in
    nLev_M = vco_anl%nlev_M
    nLev_T = vco_anl%nlev_T
    if(mod(nLev_T,2).ne.0) then
      nLev_T_even = nLev_T+1
    else
      nLev_T_even = nLev_T
    endif
    if(mpi_myid.eq.0) write(*,*) 'BCHM_setup: nLev_T, nLev_T_even=',nLev_T, nLev_T_even
    
!   Find the 3D variables (within NAMSTATE namelist)

    do jvar = 1, vnl_numvarmax3D    
       if(gsv_varExist(vnl_varNameList3D(jvar))) then

          if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then
             numvar3d = numvar3d + 1
             nsposit(numvar3d+1)=nsposit(numvar3d)+nLev_T
             varNameList(numvar3d)=vnl_varNameList3D(jvar)
          end if

       end if
    end do

!   Find the 2D variables (within NAMSTATE namelist)

    do jvar=1,vnl_numvarmax2D
       if(gsv_varExist(vnl_varNameList2D(jvar))) then

          if (vnl_varKindFromVarname(vnl_varNameList(jvar)).eq.'CH') then
             numvar2d = numvar2d + 1
             nsposit(numvar3d+numvar2d+1)=nsposit(numvar3d+numvar2d)+1
             varNameList(numvar2d)=vnl_varNameList2D(jvar)
          end if
          
       end if       
    end do
    
    if (numvar3d+numvar2d.eq.0) then    
       if(mpi_myid.eq.0) then
           write(*,*) 'Bhi matrix for CH family not produced.'
           write(*,*) 'No chemical assimilation to be performed.'
           write(*,*) 'END OF BCHM_SETUP'
       end if
       call tmg_stop(90)
       return
    else if (mpi_myid.eq.0) then
       if (numvar3d.gt.0) &
       write(*,*) 'BCHM_setup: Number of 3D variables', numvar3d,varNameList(1:numvar3d)
       if (numvar2d.gt.0) &
       write(*,*) 'BCHM_setup: Number of 2D variables', numvar2d,varNameList(numvar3d+1:numvar3d+numvar2d)
    end if

    nkgdim =  nsposit(numvar3d+numvar2d+1)-1
    nkgdim2 = nkgdim

    ! Initialization of namelist NAMBCHM parameters
    
    ntrunc=108
    rpor(:)=3000.D3
    rvloc(:)=4.0D0
    scaleFactor(:,:) = 1.0d0
    numModeZero = 0
 
    ! Read namelist input
    
    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=NAMBCHM,iostat=ierr)
    if(ierr.ne.0) call abort3d('BCHM_setup: Error reading namelist')
    if(mpi_myid.eq.0) write(*,nml=NAMBCHM)
    ierr = fclos(nulnam)

    ! Assumes the input 'scalefactor' is a scaling factor of the variances.
    
    where (scaleFactor(1:max(nLev_M,nLev_T),1:numvar3d+numvar2d).lt.0.0) &
           scaleFactor(1:max(nLev_M,nLev_T),1:numvar3d+numvar2d)=1.0d0
    scaleFactor_sigma(1:max(nLev_M,nLev_T),1:numvar3d+numvar2d)=   &
       sqrt(scaleFactor(1:max(nLev_M,nLev_T),1:numvar3d+numvar2d))

    nla_mpiglobal = (ntrunc+1)*(ntrunc+2)/2
    ni_l = hco_in%ni
    nj_l = hco_in%nj

    ! Begin calcs.
    
    ! Need an even number of levels for spectral transform (gstID2)
    
    mpiMode = 4
    gstID  = gst_setup(ni_l,nj_l,ntrunc,mpiMode,nkgdim,makeEven_in)
    gstID2 = gst_setup(ni_l,nj_l,ntrunc,mpiMode,nlev_T_even)
    if(mpi_myid.eq.0) write(*,*) 'BCHM:returned value of gstID =',gstID
    if(mpi_myid.eq.0) write(*,*) 'BCHM:returned value of gstID2=',gstID2

    call mpivar_setup_latbands(nj_l,latPerPE,myLatBeg,myLatEnd)
    call mpivar_setup_lonbands(ni_l,lonPerPE,myLonBeg,myLonEnd)

    call mpivar_setup_m(ntrunc,mymBeg,mymEnd,mymSkip,mymCount)
    call mpivar_setup_n(ntrunc,mynBeg,mynEnd,mynSkip,mynCount)

    call gst_ilaList_mpiglobal(ilaList_mpiglobal,nla_mpilocal,maxMyNla,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
    call gst_ilaList_mpilocal(ilaList_mpilocal,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)

    ! compute mpilocal control vector size
    do jm = mymBeg, mymEnd, mymSkip
      do jn = mynBeg, mynEnd, mynSkip
        if(jm.le.jn) then
          if(jm.eq.0) then
            ! only real component for jm=0
            cvDim_mpilocal = cvDim_mpilocal + 1*nkgdim2
          else
            ! both real and imaginary components for jm>0
            cvDim_mpilocal = cvDim_mpilocal + 2*nkgdim2
          endif
        endif
      enddo
    enddo
    cvDim_out = cvDim_mpilocal

    ! also compute mpiglobal control vector dimension
    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_mpiglobal,1,"mpi_integer","mpi_sum","GRID",ierr)

    allocate(rgsig(nj_l,nkgdim))
    allocate(corns(nkgdim,nkgdim,0:ntrunc))  
    allocate(rstddev(nkgdim,0:ntrunc))  
    allocate(corvert(nlev_T,nlev_T,numvar3d+numvar2d))
    allocate(corverti(nlev_T,nlev_T,numvar3d+numvar2d))

    zps = 101000.D0
    status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_M, levels=pressureProfile_M, &
                         sfc_field=zps, in_log=.false.)
    status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_T, levels=pressureProfile_T, &
                         sfc_field=zps, in_log=.false.)

    call BCHM_sunewstats
    call BCHM_sucorns2

    if(mpi_myid.eq.0) write(*,*) 'END OF BCHM_SETUP'
    
    initialized = .true.

    call tmg_stop(90)

  END SUBROUTINE BCHM_setup
!-----------------------------------------------------------------------------------------------
  logical function bchm_is_initialized()
!
! Author  : M. Sitwell, May 2015
!
! Purpose: Checks if B_chm has been initialized
!
!-----------------------------------------------------------------------------------------

    bchm_is_initialized = initialized

  end function bchm_is_initialized

!-----------------------------------------------------------------------------------------------
  subroutine bchm_getScaleFactor(scaleFactor_out)
!
! Revisions: 
!           Y.J. Rochon, ARQI/AQRD, Mar 2015
!           - Changed from 1D to 2D arrays
!           - Use of nsposit.
!
    implicit none
    real(8) :: scaleFactor_out(:,:)
    integer :: jlev,jvar

    do jvar = 1, numvar3d+numvar2d
    do jlev = 1, nsposit(jvar+1)-nsposit(jvar)
       scaleFactor_out(jlev,jvar) = scaleFactor(jlev,jvar)
    end do
    enddo

  end subroutine bchm_getScaleFactor
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_SUNEWSTATS
   implicit none

    integer :: ierr, fnom, fstouv, fstfrm, fclos
    logical :: lExists
    character(len=12) :: bFileName = './bgchemcov'

    inquire(file=bFileName,exist=lExists)
    IF ( lexists )then
      ierr = fnom(nulbgst,bFileName,'RND+OLD+R/O',0)
      if ( ierr .eq. 0 ) then
        ierr =  fstouv(nulbgst,'RND+OLD')
      else
        call abort3d('BCHM_SUNEWSTATS: NO BACKGROUND CHEMICAL CONSTITUENT STAT FILE!!')
      endif
    endif

    call BCHM_readcorns2

    call BCHM_rdspstd_newfmt 
    
    call BCHM_scalestd
    
    ierr = fstfrm(nulbgst)
    ierr = fclos(nulbgst)

  END SUBROUTINE BCHM_SUNEWSTATS
!-------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_scalestd
    implicit none

    integer :: jlon, jlat, jvar

    do jvar = 1,numvar3d+numvar2d
!       do jlon = 1, ni_l
       do jlat = 1, nj_l
           rgsig(jlat,nsposit(jvar):nsposit(jvar+1)-1) = &
               scaleFactor_sigma(nsposit(jvar):nsposit(jvar+1)-1,jvar)* &
               rgsig(jlat,nsposit(jvar):nsposit(jvar+1)-1)
!           rgsig(jlon,jlat,nsposit(jvar):nsposit(jvar+1)-1) = &
!               scaleFactor_sigma(nsposit(jvar):nsposit(jvar+1)-1,jvar)*
!               rgsig(jlon,jlat,nsposit(jvar):nsposit(jvar+1)-1)
       enddo
!       enddo
    enddo

  END SUBROUTINE BCHM_scalestd
!-------------------------------------------------------------------------------------------
 SUBROUTINE BCHM_bSqrt(controlvector_in,statevector)
  
   implicit none

    real(8)   :: controlVector_in(cvDim_mpilocal)
    type(struct_gsv) :: statevector
    real(8),allocatable :: gd_out(:,:,:)
    real(8)   :: hiControlVector(nla_mpilocal,2,nkgdim)
    integer   :: jvar, ilev1, ilev2

    if(.not. initialized) return

    if(mpi_myid.eq.0) write(*,*) 'BCHM_bsqrt: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(gd_out(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd))

    call bchm_cain(controlVector_in,hiControlVector)

    call bchm_spa2gd(hiControlVector,gd_out)

    call bchm_copyToStatevector(statevector,gd_out)

    deallocate(gd_out)

    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrt: done'

  END SUBROUTINE BCHM_bSqrt
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_cain(controlVector_in,hiControlVector_out)
    implicit none

    real(8) :: controlVector_in(cvDim_mpilocal)
    real(8) :: hiControlVector_out(nla_mpilocal,2,nkgdim)

    integer :: jdim, jlev, jm, jn, ila_mpilocal, ila_mpiglobal

    jdim = 0
    hiControlVector_out(:,:,:) = 0.0d0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,1,jlev) = controlVector_in(jdim)
            else
              ! both real and imaginary components for jm>0
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,1,jlev) = controlVector_in(jdim)
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,2,jlev) = controlVector_in(jdim)
            endif
          endif
        enddo
      enddo
    enddo

  end SUBROUTINE BCHM_cain
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_copyToStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real(8) :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    integer :: jlon, jlev, jlev2, jlat, jvar, ilev1, ilev2
    real(8), pointer :: field(:,:,:)

    do jvar = 1,numvar3d+numvar2d
        field => gsv_getField3D(statevector,varNameList(jvar))
        
        ilev1 = nsposit(jvar)
        ilev2 = nsposit(jvar+1)-1 
        
!!!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,jlon)
        do jlat = myLatBeg, myLatEnd
          do jlev = ilev1, ilev2
            jlev2 = jlev-ilev1+1
            do jlon = myLonBeg, myLonEnd
              field(jlon,jlev2,jlat) = gd(jlon,jlev,jlat)
            enddo
          enddo
        enddo
!!!$OMP END PARALLEL DO
    enddo
  END SUBROUTINE BCHM_copyToStatevector
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_bSqrtAd(statevector,controlVector_out)
    implicit none

    real(8)   :: controlVector_out(cvDim_mpilocal)
    type(struct_gsv) :: statevector
    real(8), allocatable :: gd_in(:,:,:)
    real(8)   :: hiControlVector(nla_mpilocal,2,nkgdim)
    integer   :: jvar, ilev1, ilev2

    if(.not. initialized) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixChem not initialized'
      return
    endif

    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrtad: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    allocate(gd_in(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd))
    call bchm_copyFromStatevector(statevector,gd_in)

    call bchm_spa2gdad(gd_in,hiControlVector)

    call bchm_cainad(hiControlVector,controlVector_out)

    deallocate(gd_in)

    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'BCHM_bsqrtad: done'

  END SUBROUTINE BCHM_bSqrtAd
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_copyFromStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real(8)          :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    integer :: jlon, jlev, jlev2, jlat, jvar, ilev1, ilev2
    real(8), pointer :: field(:,:,:)

    do jvar = 1,numvar3d+numvar2d
        field => gsv_getField3D(statevector,varNameList(jvar))

        ilev1 = nsposit(jvar)
        ilev2 = nsposit(jvar+1)-1 

!!!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,jlon)
        do jlat = myLatBeg, myLatEnd
          do jlev = ilev1, ilev2
            jlev2 = jlev-ilev1+1
            do jlon = myLonBeg, myLonEnd
              gd(jlon,jlev,jlat) = field(jlon,jlev2,jlat)
            enddo
          enddo
        enddo
!!!$OMP END PARALLEL DO
    enddo

  END SUBROUTINE BCHM_copyFromStatevector
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_READCORNS2
!
! N.B.: Currently assumes distinct block diagonal matrices (no cross-correlations)
!  
    implicit none

    integer :: jn, istdkey,icornskey,jvar
    integer :: jcol,jrow,jstart,jnum
    real(8) :: zwork
    real(8), allocatable, dimension(:) :: zstdsrc
    real(8), allocatable, dimension(:,:) :: zcornssrc

    ! Standard file variables
    integer :: ini,inj,ink,in1,in2
    integer :: ip1,ip2,ip3,idateo
    character(len=2)  :: cltypvar
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    rstddev(:,:)=0.0d0
    corns(:,:,:)=0.0d0
    
    do jvar = 1,numvar3d+numvar2d
   
       clnomvar=varNameList(jvar)
       jstart=nsposit(jvar)
       jnum=nsposit(jvar+1)-nsposit(jvar)
       allocate(zcornssrc(jnum,jnum))
       allocate(zstdsrc(jnum))

       do jn = 0, ntrunc

          ! Looking for FST record parameters..
      
          idateo = -1
          cletiket = 'RSTDDEV'
          ip1 = -1
          ip2 = jn
          ip3 = -1
          cltypvar = 'X'
          
          istdkey = vfstlir(ZSTDSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
          
          if (istdkey.lt.0) call abort3d('BCHM_READCORNS2: Problem with constituents background stat file')
          if (ini.ne.jnum)  call abort3d('BCHM_READCORNS2: Constituents background stat levels inconsitencies')

          ! Looking for FST record parameters..

          idateo = -1
          cletiket = 'CORRNS'
          ip1 = -1
          ip2 = jn
          ip3 = -1
          cltypvar = 'X'
          icornskey = vfstlir(ZCORNSSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

          if (icornskey.lt.0) call abort3d('BCHM_READCORNS2: Problem with constituents background stat file')
          if (ini.ne.jnum.and.inj.ne.jnum) call abort3d('BCHM_READCORNS2: Constituents BG stat levels inconsitencies')

          rstddev(jstart:jstart+jnum-1,jn) = zstdsrc(1:jnum)
          corns(jstart:jstart+jnum-1,jstart:jstart+jnum-1,jn)=zcornssrc(1:jnum,1:jnum)
          
       enddo
       
       deallocate(zcornssrc)
       deallocate(zstdsrc)

    enddo

    ! Apply convolution to RSTDDEV correlation

    call BCHM_convol
    
    do jn = 0, ntrunc

      ! Re-build correlation matrix: factorization of corns with convoluted RSTDDEV
      do jcol = 1, nkgdim
        do jrow = 1, nkgdim
          corns(jrow,jcol,jn) = rstddev(jrow,jn) * corns(jrow,jcol,jn)* rstddev(jcol,jn)
        enddo
      enddo

    enddo

    !write(*,*) 'Done in BCHM_READCORNS2'
  END SUBROUTINE BCHM_READCORNS2
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_convol
    implicit none

    real(8) dlfact2,dlc,dsummed
    real(8) dtlen,zr,dlfact
    integer ilen,jn,jlat,jk,jvar
    real(8) zlegi(0:ntrunc, nj_l),zleg(0:ntrunc, nj_l),zsp(0:ntrunc,nkgdim),zgr(nj_l,nkgdim)
    real(8) dlwti(nj_l),zrmu(nj_l)

    integer inracp
    real(8) zpg(nj_l),zsia(nj_l),zrad(nj_l),zpgssin2(nj_l)
    real(8) zsinm1(nj_l),zsinm2(nj_l),zsin2(nj_l),zsinlat(nj_l)
    real(8) dlfact1, dln
    real(8) dlnorm(0:ntrunc)

    do jlat = 1, nj_l
       dlwti(jlat) = gst_getrwt(jlat,gstID)
       zrmu(jlat)  = gst_getrmu(jlat,gstID)
    end do

    do jlat = 1, nj_l
       zleg(0,jlat) = sqrt(0.5d0)
       zleg(1,jlat) = sqrt(1.5d0)*zrmu(jlat)
    enddo
    do jn = 0, ntrunc
       dln = 1.d0*real(jn,8)
       dlnorm(jn) = dsqrt((2.d0*dln + 1.d0)/2.d0)
    enddo
    do jn = 1, ntrunc-1
       dln = real(jn,8)
       dlfact1 = ((2.d0*dln+1.d0)/(dln+1.d0))*(dlnorm(jn+1)/dlnorm(jn))
       dlfact2 = (dln/(dln+1.d0))*(dlnorm(jn+1)/dlnorm(jn-1))
       do jlat = 1, nj_l
          zleg(jn+1,jlat) = dlfact1*zrmu(jlat)*zleg(jn,jlat) - dlfact2*zleg(jn-1,jlat)
       enddo
    enddo

    do jlat = 1, nj_l
       do jn = 0, ntrunc
         zlegi(jn,jlat) = zleg(jn,jlat)
       enddo
    enddo

!     1.2 CONVERT THE CORRELATIONS IN SPECTRAL SPACE INTO SPECTRAL
!         COEFFICIENTS OF THE CORRELATION FUNCTION AND FUNCTION TO BE
!         SELF-CONVOLVED

    do jn = 0, ntrunc
      dlfact = ((2.0d0*jn+1)/2.0d0)**0.25d0
      dlfact2 = ((2.0d0*JN +1.0d0)/2.0d0)**(0.25d0)
      do jk = 1, nkgdim
        zsp(jn,jk) = rstddev(jk,jn)*dlfact*dlfact2
      enddo
    enddo

    ! Transform to physical space
    call zleginv(zgr,zsp,zlegi,dlwti,ntrunc,nj_l,nkgdim,nj_l,nkgdim,ntrunc)

    ! Truncate in horizontal extent with Gaussian window
    
    jvar=1
    do jk = 1, nkgdim
      if (jk.eq.nsposit(jvar)) then
        dtlen = rpor(jvar)
        jvar=jvar+1 
      endif
      if(dtlen.gt.0.0d0) then
        dlc = 1.d0/dble(dtlen)
        dlc = 0.5d0*dlc*dlc
        do jlat = 1, nj_l
          zr = ra * acos(zrmu(jlat))
          dlfact = dexp(-(zr**2)*dlc)
          zgr(jlat,jk) = dlfact*zgr(jlat,jk)
        enddo
      endif

      !write(*,*) 'zeroing length (km)=',jk,dtlen/1000.0
    enddo

    ! Transform back to spectral space
    call zlegdir(zgr,zsp,zlegi,dlwti,ntrunc,nj_l,nkgdim,nj_l,nkgdim,ntrunc)

    ! Convert back to correlations
    do jk = 1, nkgdim
      do jn = 0, ntrunc
         zsp(jn,jk) = zsp(jn,jk)*(2.0d0/(2.0d0*jn+1.0))**(0.25d0)
      enddo
    enddo

    ! PUT BACK INTO RSTDDEV
    do jn = 0, ntrunc
      do jk = 1, nkgdim
         rstddev(jk,jn) = zsp(jn,jk)
      enddo
    enddo

    ! Re-normalize to ensure correlations
    do jk = 1, nkgdim
      dsummed = 0.d0
      do jn = 0, ntrunc
        dsummed = dsummed+ dble(rstddev(jk,jn)**2)*sqrt(((2.d0*jn)+1.d0)/2.d0)
      enddo
      dsummed = sqrt(dsummed)
      do jn = 0, ntrunc
        if(dsummed.gt.1.d-30) rstddev(jk,jn) = rstddev(jk,jn)/dsummed
      enddo
    enddo

    !     CONVERT THE SPECTRAL COEFFICIENTS OF THE CORRELATION FUNCTION
    !     .  BACK INTO CORRELATIONS OF SPECTRAL COMPONENTS
    do jn = 0, ntrunc
      dlfact = sqrt(0.5d0)*(1.0d0/((2.0d0*jn+1)/2.0d0))**0.25d0
      do jk = 1, nkgdim
        rstddev(jk,jn) = rstddev(jk,jn)*dlfact
      enddo
    enddo

  END SUBROUTINE BCHM_convol
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_RDSPSTD
    implicit none

    integer :: jvar,jn,inix,injx,inkx
    integer :: ikey, jlevo, jlat,firstn,lastn
    real(8) :: zsp(0:ntrunc,max(nlev_M,nlev_T)),zspbuf(max(nlev_M,nlev_T)),zwork
    real(8) :: zleg(0:ntrunc,nj_l),zgr(nj_l,max(nlev_M,nlev_T)),zstddev(nkgdim,nj_l)
    
    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ipak,ipas
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo,nlev_MT
    character(len=1)  :: clgrtyp
    character(len=2)  :: cltypvar
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    call gst_setID(gstID)
    call gst_zlegpol(zleg)

    rgsig(:,:) = 0.0d0
    
!   Reading the Legendre poly representation of the 2D background error std. dev. field

    idate(1) = -1
    ip1      = -1
    ip2      = -1
    ip3      = -1

    cletiket = 'SPSTDDEV'
    cltypvar = 'X'
    
    do jvar = 1,numvar3d+numvar2d
      clnomvar=varNameList(jvar)
      nlev_MT=nsposit(jvar+1)-nsposit(jvar)
      
      firstn = -1
      do jn = 0, ntrunc
        ip2 = jn
        ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf(1:nlev_MT),nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        else
          if(firstn.eq.-1) firstn = jn
          lastn = jn
          zspbuf(:) = 0.0d0
        endif

        if (ini.ne.nlev_MT) call abort3d('RDSPSTD: Constituents background stat levels inconsitencies')

        do jlevo = 1, nlev_MT
          zsp(jn,jlevo) = zspbuf(jlevo)
        enddo
      enddo
      
      if(mpi_myid.eq.0.and.firstn.ne.-1) write(*,*) 'WARNING: CANNOT FIND SPSTD FOR ',clnomvar, &
            ' AT N BETWEEN ',firstn,' AND ',lastn,', SETTING TO ZERO!!!'

      call zleginv2(zgr(:,1:nlev_MT),zsp(:,1:nlev_MT),zleg,ntrunc,nj_l,nlev_MT,nj_l,nlev_MT,ntrunc)

      rgsig(1:nj_l,nsposit(jvar):nsposit(jvar+1)-1)= zgr(1:nj_l,1:nlev_MT)

    enddo 

  END SUBROUTINE BCHM_RDSPSTD
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_RDSPSTD_NEWFMT
    implicit none

    integer :: jvar,jn,inix,injx,inkx,ntrunc_file
    integer :: ikey,jlevo,jlat
    real(8) :: zsp(0:ntrunc,max(nlev_M,nlev_T)),zspbuf(0:ntrunc),zwork
    real(8) :: zleg(0:ntrunc,nj_l),zgr(nj_l,max(nlev_M,nlev_T)),zstddev(nkgdim,nj_l)

    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ipak,ipas
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo,nlev_MT
    character(len=1)  :: clgrtyp
    character(len=2)  :: cltypvar
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    call gst_setID(gstID)
    call gst_zlegpol(zleg)

    rgsig(:,:) = 0.0d0

!   Reading the data

    idate(1) = -1
    ip2      = -1
    ip3      = -1

    cletiket = 'SPSTDDEV'
    cltypvar = 'X'

    ! Check if file is old format
    
    ip1 = -1
    clnomvar = varNameList(1) 
    ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
    write(*,*) 'ini,inj,ink=',inix,injx,inkx
    if(inix.gt.1) then
      write(*,*) 'BCHM_RDSPSTD_NEWFMT: ini>1, SPSTDDEV is in old format, calling BCHM_RDSPSTD...'
      call BCHM_rdspstd
      return
    endif

    ! write(*,*) 'Reading for 3D and 2D variables'
    
    do jvar = 1,numvar3d+numvar2d
      clnomvar=varNameList(jvar)
      nlev_MT=nsposit(jvar+1)-nsposit(jvar)

      !write(*,*) 'Reading ',clnomvar

      do jlevo = 1, nlev_MT
        if (nlev_MT.eq.1) then
           ip1=-1
        else if(vnl_varTypeFromVarName(clnomvar).eq.'MM') then
          ip1 = vco_anl%ip1_M(jlevo)
        else
          ip1 = vco_anl%ip1_T(jlevo)
        endif
        
        ikey = fstinf(nulbgst,inix,ntrunc_file,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        ntrunc_file = ntrunc_file-1

        if(ntrunc_file.gt.ntrunc) call abort3d('RDSPSTD_NEWFMT: ntrunc in file > ntrunc for analysis!')

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf(0:ntrunc_file),nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        else
          write(*,*) 'RDSPSTD_NEWFMT: ',jvar,clnomvar,nlev_MT,jlevo,ikey,ntrunc,ntrunc_file
          call abort3d('RDSPSTD_NEWFMT: SPSTDDEV record not found')
        endif

        zsp(:,jlevo) = 0.0d0
        do jn = 0, ntrunc_file
          zsp(jn,jlevo) = zspbuf(jn)
        enddo
      enddo

      call zleginv2(zgr(:,1:nlev_MT),zsp(:,1:nlev_MT),zleg,ntrunc,nj_l,nlev_MT,nj_l,nlev_MT,ntrunc)

      rgsig(1:nj_l,nsposit(jvar):nsposit(jvar+1)-1)= zgr(1:nj_l,1:nlev_MT)

    enddo

  END SUBROUTINE BCHM_RDSPSTD_NEWFMT
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_SUCORNS2
    implicit none

    real(8) :: eigenval(nkgdim), eigenvec(nkgdim,nkgdim),result(nkgdim,nkgdim)
    real(8) :: eigenvalsqrt(nkgdim)

    integer :: jlat,jn,jk1,jk2,jk3,jr,jvar
    integer :: ilwork,info,jnum
    integer :: ikey, nsize

    real(8) :: zwork(2*4*nkgdim)
    real(8) :: ztlen,zcorr,zr,zpres1,zpres2,eigenvalmax
    real(8),allocatable :: corns_temp(:,:,:)
    
    ! Standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas,ntrials
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo
    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf
    integer :: fnom,fstouv,fstfrm,fclos

    ! Apply vertical localization to correlations of 3D fields.
    ! Currently assumes no-cross correlations for variables (block diagonal matrix)
    
    do jvar = 1,numvar3d
        ztlen = rvloc(jvar)    ! specify length scale (in units of ln(Pressure))
        
        jnum=nsposit(jvar+1)-nsposit(jvar)
        
        if(ztlen.gt.0.0d0) then
           ! calculate 5'th order function (from Gaspari and Cohn)
           do jk1 = 1,jnum
              zpres1 = log(pressureProfile_T(jk1))
              do jk2 = 1,jnum
                 zpres2 = log(pressureProfile_T(jk2))
                 zr = abs(zpres2 - zpres1)
                 zcorr = gasparicohn(ztlen,zr)
                 corns(nsposit(jvar)-1+jk1,nsposit(jvar)-1+jk2,0:ntrunc)= &
                       corns(nsposit(jvar)-1+jk1,nsposit(jvar)-1+jk2,0:ntrunc)*zcorr  
              enddo
           enddo
         endif
    enddo

    ! Compute total vertical correlations and its inverse (currently for each block matrix).

    call bchm_corvert_setup
    
    if (trim(bchm_mode) == 'BackgroundCheck') return
!!    if (.not.analysisMode) return

    ! Following assumes full matrices. It does not take advantage of any block diagonal structure.
    ! Accounting for block diagonal structures would/might improve computation time.
    
    ! compute square-root of corns for each total wavenumber
    
    allocate(corns_temp(nkgdim,nkgdim,0:ntrunc))
    corns_temp(:,:,:)=0.0d0
    do jn = mpi_myid, ntrunc, mpi_nprocs

      eigenvec(1:nkgdim,1:nkgdim) = corns(1:nkgdim,1:nkgdim,jn)

      ! CALCULATE EIGENVALUES AND EIGENVECTORS.
      ilwork = 4*nkgdim*2
      call dsyev('V','U',nkgdim,eigenvec,nkgdim,eigenval,zwork,ilwork,info)
      if(info.ne.0) then
        write(*,*) 'BCHM_sucorns2: non-zero value of info =',info,' returned by dsyev for wavenumber ',jn
        call abort3d('BCHM_SUCORNS')
      endif
      
      ! set selected number of eigenmodes to zero
      if(numModeZero.gt.0) then
        write(*,*) 'bchm_sucorns2: setting ',numModeZero,' eigenvalues to zero for wavenumber n=',jn
        write(*,*) 'bchm_sucorns2: original eigenvalues=',eigenval(:)
        do jk1 = 1, numModeZero
          eigenval(jk1) = 0.0d0
        enddo
        write(*,*) 'bchm_sucorns2: modified eigenvalues=',eigenval(:)
      endif

      eigenvalmax=maxval(eigenval(1:jnum))
      do jk1 = 1, nkgdim
!        if(eigenval(jk1).lt.1.0d-15) then
        if(eigenval(jk1).lt.1.0d-8*eigenvalmax) then
          eigenvalsqrt(jk1) = 0.0d0
        else
          eigenvalsqrt(jk1) = sqrt(eigenval(jk1))
        endif
      enddo

      ! E * lambda^1/2
      do jk1 = 1, nkgdim
         result(1:nkgdim,jk1) = eigenvec(1:nkgdim,jk1)*eigenvalsqrt(jk1)
      enddo

      ! (E * lambda^1/2) * E^T
      do jk1 = 1, nkgdim
      do jk2 = 1, nkgdim
         do jk3 = 1, nkgdim
           corns_temp(jk2,jk1,jn) = corns_temp(jk2,jk1,jn) + result(jk2,jk3)*eigenvec(jk1,jk3)
         enddo
      enddo
      enddo

    enddo ! jn

    nsize = nkgdim*nkgdim*(ntrunc+1)
    call rpn_comm_allreduce(corns_temp,corns,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)
    deallocate(corns_temp)

  END SUBROUTINE BCHM_SUCORNS2
!-----------------------------------------------------------------------------------------------
  FUNCTION GASPARICOHN(ztlen,zr)

    real(8)  :: gasparicohn
    real(8)  :: ztlen,zr,zlc

    zlc = ztlen/2.0d0
    if(zr.le.zlc) then
      gasparicohn = -0.250d0*(zr/zlc)**5+0.5d0*(zr/zlc)**4             &
                  +0.625d0*(zr/zlc)**3-(5.0d0/3.0d0)*(zr/zlc)**2+1.0d0
    elseif(zr.le.(2.0d0*zlc)) then
      gasparicohn = (1.0d0/12.0d0)*(zr/zlc)**5-0.5d0*(zr/zlc)**4         &
                  +0.625d0*(zr/zlc)**3+(5.0d0/3.0d0)*(zr/zlc)**2       &
                  -5.0d0*(zr/zlc)+4.0d0-(2.0d0/3.0d0)*(zlc/zr)
    else
      gasparicohn = 0.0d0
    endif
    if(gasparicohn.lt.0.0d0) gasparicohn = 0.0d0

  END FUNCTION GASPARICOHN
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_SPA2GD(hiControlVector_in,gd_out)
    IMPLICIT NONE

    real(8) :: hiControlVector_in(nla_mpilocal,2,nkgdim)
    real(8) :: gd_out(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)

    real(8) :: sp(maxMyNla,2,nkgdim)

    integer :: jn,jm,ila_mpilocal,ila_mpiglobal,icount
    real(8) :: sq2, zp
    real(8) , allocatable :: zsp(:,:,:), zsp2(:,:,:)
    integer :: ilon, jlev, jlon, jlat, jla_mpilocal
    real(8), target  :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    real(8) :: dla2, dl1sa2, zpsb(myLonBeg:myLonEnd,myLatBeg:myLatEnd)

    call tmg_start(82,'BCHM_SPA2GD1')

    ! maybe not needed:
    sp(:,:,:) = 0.0d0
    sq2 = sqrt(2.0d0)

    allocate(zsp(nkgdim,2,mymCount))
    allocate(zsp2(nkgdim,2,mymCount))

!$OMP PARALLEL DO PRIVATE(jn,jm,jlev,ila_mpiglobal,ila_mpilocal,zsp2,zsp,icount)
    do jn = mynBeg, mynEnd, mynSkip

      icount = 0
      do jm = mymBeg, mymEnd, mymSkip
        if(jm.le.jn) then
          icount = icount+1
          ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            zsp(jlev,1,icount) = hiControlVector_in(ila_mpilocal,1,jlev)
            zsp(jlev,2,icount) = hiControlVector_in(ila_mpilocal,2,jlev)
          enddo
        endif
      enddo
      if(icount.gt.0) then

        CALL DGEMUL(corns(1,1,jn),nkgdim,'N',zsp(1,1,1),nkgdim,'N',zsp2(1,1,1),nkgdim,nkgdim,nkgdim,2*icount)

        icount = 0
        do jm = mymBeg, mymEnd, mymSkip
          if(jm.le.jn) then
            icount = icount+1
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
            do jlev = 1, nkgdim
              sp(ila_mpilocal,1,jlev) = zsp2(jlev,1,icount)
              sp(ila_mpilocal,2,jlev) = zsp2(jlev,2,icount)
            enddo
          endif
        enddo

      endif

      ! make adjustments for jm=0
      if(mymBeg.eq.0) then

        ila_mpiglobal = gst_getNind(0,gstID) + jn
        ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)

        do jlev = 1, nkgdim
          sp(ila_mpilocal,1,jlev) = sp(ila_mpilocal,1,jlev)*sq2
          sp(ila_mpilocal,2,jlev) = 0.0d0
        enddo

      endif

    enddo
!$OMP END PARALLEL DO
    deallocate(zsp)
    deallocate(zsp2)
    call tmg_stop(82)


!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
          gd(jlon,jlev,jlat) = 0.0d0
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_start(84,'BCHM_SPEREE')
    call gst_setID(gstID)
    call gst_speree4(sp,gd)
    call gst_setID(gstID2)
    call tmg_stop(84)

    call tmg_start(85,'BCHM_SPA2GD2')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlon)
    do jlat = myLatBeg, myLatEnd

      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
            gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo
    enddo  ! jlat
!$OMP END PARALLEL DO
    call tmg_stop(85)

!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
          gd_out(jlon,jlev,jlat) = gd(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE BCHM_SPA2GD
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_SPA2GDAD(gd_in,hiControlVector_out)
    implicit none

    real(8) :: hiControlVector_out(nla_mpilocal,2,nkgdim)
    real(8) :: gd_in(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)

    real(8) :: sp(maxMyNla,2,nkgdim)

    integer :: jn, jm, ila_mpilocal, ila_mpiglobal, icount
    real(8) :: sq2, zp
    real(8), allocatable :: zsp(:,:,:), zsp2(:,:,:)

    integer :: ilon, jlev, jlon, jlat, jla_mpilocal
    real(8) :: dl1sa2, dla2, zpsb(myLonBeg:myLonEnd,myLatBeg:myLatEnd)
    real(8), target :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)


!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd                                                      
          gd(jlon,jlev,jlat) = gd_in(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

   call tmg_start(85,'BCHM_SPA2GD2')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlon)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
            gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo


    enddo
!$OMP END PARALLEL DO
    call tmg_stop(85)

    call tmg_start(86,'BCHM_REESPE')
    call gst_setID(gstID)
    call gst_reespe4(sp,gd)
    call tmg_stop(86)

    call tmg_start(82,'BCHM_SPA2GD1')

    hiControlVector_out(:,:,:) = 0.0d0
    sq2 = sqrt(2.0d0)
    allocate(zsp(nkgdim,2,mymCount))
    allocate(zsp2(nkgdim,2,mymCount))
!$OMP PARALLEL DO PRIVATE(JN,JM,JLEV,ILA_MPILOCAL,ILA_MPIGLOBAL,zsp,zsp2,icount)
    do jn = mynBeg, mynEnd, mynSkip

      icount = 0
      do jm = mymBeg, mymEnd, mymSkip
        if(jm.le.jn) then
          icount = icount+1
          ila_mpiglobal = gst_getNind(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            zsp2(jlev,1,icount) = sp(ila_mpilocal,1,jlev)
            zsp2(jlev,2,icount) = sp(ila_mpilocal,2,jlev)
          enddo
        endif
      enddo

      if(icount.gt.0) then

        CALL DGEMUL(corns(1,1,jn),nkgdim,'T',zsp2(1,1,1),nkgdim,'N',zsp(1,1,1),nkgdim,nkgdim,nkgdim,2*icount)

        icount = 0
        do jm = mymBeg, jn, mymSkip
          icount=icount+1
          ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            hiControlVector_out(ila_mpilocal,1,jlev) = zsp(jlev,1,icount)
            hiControlVector_out(ila_mpilocal,2,jlev) = zsp(jlev,2,icount)
          enddo
        enddo

      endif

      ! make adjustments for jm=0
      if(mymBeg.eq.0) then

        ila_mpiglobal = gst_getNIND(0,gstID) + jn
        ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)

       do jlev = 1, nkgdim
          hiControlVector_out(ila_mpilocal,1,jlev) = hiControlVector_out(ila_mpilocal,1,jlev)*sq2
          hiControlVector_out(ila_mpilocal,2,jlev) = hiControlVector_out(ila_mpilocal,2,jlev)*sq2
        enddo

      endif

    enddo
!$OMP END PARALLEL DO
    deallocate(zsp)
    deallocate(zsp2)
    call tmg_stop(82)

  END SUBROUTINE BCHM_SPA2GDAD
!----------------------------------------------------------------------------------------------- 
  SUBROUTINE BCHM_cainAd(hiControlVector_in,controlVector_out)
    IMPLICIT NONE

    real(8) :: controlVector_out(cvDim_mpilocal)
    real(8) :: hiControlVector_in(nla_mpilocal,2,nkgdim)

    integer :: jdim, jlev, jm, jn, ila_mpilocal, ila_mpiglobal

    jdim = 0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,1,jlev)
            else
              ! both real and imaginary components for jm>0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,1,jlev)*2.0d0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,2,jlev)*2.0d0
            endif
          endif
        enddo
      enddo
    enddo

  END SUBROUTINE BCHM_cainAd
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_Finalize()
    implicit none

    if(initialized) then
       deallocate(pressureProfile_M)
       deallocate(pressureProfile_T)
       deallocate(rgsig)
       deallocate(corns)
       deallocate(rstddev)
       deallocate(corvert,corverti)
    end if

  END SUBROUTINE BCHM_Finalize
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(8) :: cv_mpilocal(cvDim_mpilocal)
    real(8) :: cv_mpiglobal(cvDim_mpiglobal)
    integer :: cvDim_mpilocal_out

    integer :: jlev,jn,jm,ila_mpilocal,ila_mpiglobal,jdim_mpilocal,jdim_mpiglobal

    if(.not. initialized) return

    cvDim_mpilocal_out = cvDim_mpilocal

    jdim_mpilocal = 0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then

            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm

            ! figure out index into global control vector
            if(jm.eq.0) then
              ! for jm=0 only real part
              jdim_mpiglobal = ila_mpiglobal
            else
              ! for jm>0 both real and imaginary part
              jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
            endif
            ! add offset for level
            jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)

            ! index into local control vector computer as in cain
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
            else
              ! both real and imaginary components for jm>0
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal+1)
            endif

            if(jdim_mpilocal.gt.cvDim_mpilocal)   &
              write(*,*) 'ERROR: jdim,cvDim,mpilocal=',jdim_mpilocal,cvDim_mpilocal,jlev,jn,jm
            if(jdim_mpiglobal.gt.cvDim_mpiglobal)   &
              write(*,*) 'ERROR: jdim,cvDim,mpiglobal=',jdim_mpiglobal,cvDim_mpiglobal,jlev,jn,jm

          endif
        enddo
      enddo
    enddo

  END SUBROUTINE BCHM_reduceToMPILocal
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none
    real(8) :: cv_mpilocal(cvDim_mpilocal)
    real(8) :: cv_mpiglobal(cvDim_mpiglobal)
    integer :: cvDim_mpiglobal_out

    real(8), allocatable :: cv_maxmpilocal(:)
    real(8), pointer :: cv_allmaxmpilocal(:,:) => null()
    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)
    integer :: jlev, jn, jm, jproc, ila_mpiglobal, jdim_mpilocal, jdim_mpiglobal, ierr, cvDim_maxmpilocal

    if(.not. initialized) return

    cvDim_mpiglobal_out = cvDim_mpiglobal

    ! gather all local control vectors onto mpi task 0
    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_maxmpilocal,1,"mpi_integer","mpi_max","GRID",ierr)

    allocate(cv_maxmpilocal(cvDim_maxmpilocal))
    if(mpi_myid.eq.0) allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

    cv_maxmpilocal(:) = 0.0d0
    cv_maxmpilocal(1:cvDim_mpilocal) = cv_mpilocal(1:cvDim_mpilocal)

    call tmg_start(87,'BCHM_COMM')
    call rpn_comm_gather(cv_maxmpilocal,    cvDim_maxmpilocal, "mpi_double_precision",  &
                         cv_allmaxmpilocal, cvDim_maxmpilocal, "mpi_double_precision", 0, "GRID", ierr )
    call tmg_stop(87)

    deallocate(cv_maxmpilocal)

    allocate(allnBeg(mpi_nprocs))
    call rpn_comm_allgather(mynBeg,1,"mpi_integer",       &
                            allnBeg,1,"mpi_integer","GRID",ierr)
    allocate(allnEnd(mpi_nprocs))
    call rpn_comm_allgather(mynEnd,1,"mpi_integer",       &
                            allnEnd,1,"mpi_integer","GRID",ierr)
    allocate(allnSkip(mpi_nprocs))
    call rpn_comm_allgather(mynSkip,1,"mpi_integer",       &
                            allnSkip,1,"mpi_integer","GRID",ierr)

    allocate(allmBeg(mpi_nprocs))
    call rpn_comm_allgather(mymBeg,1,"mpi_integer",       &
                            allmBeg,1,"mpi_integer","GRID",ierr)
    allocate(allmEnd(mpi_nprocs))
    call rpn_comm_allgather(mymEnd,1,"mpi_integer",       &
                            allmEnd,1,"mpi_integer","GRID",ierr)
    allocate(allmSkip(mpi_nprocs))
    call rpn_comm_allgather(mymSkip,1,"mpi_integer",       &
                            allmSkip,1,"mpi_integer","GRID",ierr)

    ! reorganize gathered mpilocal control vectors into the mpiglobal control vector
    if(mpi_myid.eq.0) then
      cv_mpiglobal(:) = 0.0d0

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
      do jproc = 0, (mpi_nprocs-1)
        jdim_mpilocal = 0

        do jlev = 1, nkgdim
          do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
            do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)
              if(jm.le.jn) then

                ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm

                ! figure out index into global control vector
                if(jm.eq.0) then
                  ! for jm=0 only real part
                  jdim_mpiglobal = ila_mpiglobal
                else
                  ! for jm>0 both real and imaginary part
                  jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                endif
                ! add offset for level
                jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)

                ! index into local control vector
                if(jm.eq.0) then
                  ! only real component for jm=0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                else
                  ! both real and imaginary components for jm>0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal+1) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                endif

                if(jdim_mpiglobal.gt.cvDim_mpiglobal)   &
                  write(*,*) 'ERROR: jdim,cvDim,mpiglobal=',jdim_mpiglobal,cvDim_mpiglobal,jlev,jn,jm

              endif
            enddo
          enddo
        enddo
      enddo ! jproc
!$OMP END PARALLEL DO

    endif ! myid .eq. 0

    deallocate(allnBeg)
    deallocate(allnEnd)
    deallocate(allnSkip)
    deallocate(allmBeg)
    deallocate(allmEnd)
    deallocate(allmSkip)
    if(mpi_myid.eq.0) deallocate(cv_allmaxmpilocal)

  end SUBROUTINE BCHM_expandToMPIGlobal
!-----------------------------------------------------------------------------------------------
  SUBROUTINE ZLEGINV(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV  - Direct Legendre transform restricted to
!*     .           fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   DDWT(KNJDIM)         : weights of the Gaussian quadrature
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL(8) :: DDWT(KNJDIM)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGINV
!-----------------------------------------------------------------------------------------------
  SUBROUTINE ZLEGINV2(PF,PN,PLEG,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV2  - Direct Legendre transform restricted to
!*     .            fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,KLEVDIM), PN(0:KNDIM, KLEVDIM), PLEG(0:KNDIM,KNJDIM)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGINV2
!-----------------------------------------------------------------------------------------------
  SUBROUTINE ZLEGDIR(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!**s/r ZLEGDIR  - Direct Legendre transform restricted to
!
!*Arguments
!*     i   PF(KNJDIM,KLEVDIM)   : field in physical space
!*     o   PN(0:KNDIM, KLEVDIM ): spectral coefficients
!*     o   PLEG(0:KNDIM, KNJDIM): Legendre polynomials evaluated at the Gaussian latitudes
!*     i   DDWT(KNJDIM)          : weights of the Gaussian quadrature
!*     i   KNJ                  : number of Gaussian latitudes
!*     i   KTRUNC               : spectral truncation
!*     i   KLEV                 : number of fields to transform
!*     i   KNJDIM               : dimensioning of the field (in latitude)
!*     i   KLEVDIM              : dimensioning of the field (in KLEV)
!*     I   KNDIM                : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL(8) :: DDWT(KNJ)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))
      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)*DDWT(J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'N',PF(1,1),KNJDIM,'N',PN(0,1),KNDIM+1,KNDIM+1,KNJ,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGDIR
!-----------------------------------------------------------------------------------------------
  SUBROUTINE BCHM_corvert_setup
!
! Purpose: Compute total vertical correlations (corvert) and its inverse (corverti; currently 
!          for each block matrix).
!
! Author: Y.J. Rochon, ARQI/AQRD, Mar 2015
!
! Revisions:
!
! Comments:
!
! (A) Currently assumes no cross-correlations 
!
!-----------------------------------------------------------------------------------------------
    implicit none

    real(8) :: eigenval(nkgdim), eigenvec(nkgdim,nkgdim),result(nkgdim,nkgdim)

    integer :: jn,jk1,jk2,jk3,jvar
    integer :: ilwork,info,jnum
    integer :: ikey
    logical :: lldebug

    real(8) :: zwork(2*4*nkgdim)
    real(8) :: zr,eigenvalmax
    integer iulcorvert
    
    ! Standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas,ntrials
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo
    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf
    integer :: fnom,fstouv,fstfrm,fclos

    lldebug=.false.
    
    ! Compute total vertical correlations and its inverse (currently for each block matrix).

    if(mpi_myid == 0) then
       iulcorvert = 0
       ierr = fnom(iulcorvert,'corvert_modular_chm.fst','RND',0)
       ierr = fstouv(iulcorvert,'RND')
    end if
    
    do jvar = 1,numvar3d
   
       jnum=nsposit(jvar+1)-nsposit(jvar)
       
       corvert(1:jnum,1:jnum,jvar) = 0.0d0
       do jn = 0, ntrunc
            corvert(1:jnum,1:jnum,jvar) = corvert(1:jnum,1:jnum,jvar)+ ((2*jn+1)* &
                corns(nsposit(jvar):nsposit(jvar+1)-1,nsposit(jvar):nsposit(jvar+1)-1,jn))
       enddo

!       where (abs(corvert(1:jnum,1:jnum,jvar)) .lt. 1.E-3) corvert(1:jnum,1:jnum,jvar)=0.0D0

       if(mpi_myid == 0) then
          ikey = fstinf(NULBGST,ini,inj,ink,-1,'CORRNS',-1,0,-1,' ',varNameList(jvar))
          ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits        &
             ,idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp      &
             ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2      &
             ,iextr3)

          ini = jnum
          inj = jnum
          ink = 1
          ip1 = 0
          ip2 = ntrunc
          ip3 = 0
          clnomvar = varNameList(jvar)
          cletiket = 'CORVERT'
          idatyp = 5

          ierr = vfstecr(corvert(1:jnum,1:jnum,jvar),corvert(1:jnum,1:jnum,jvar) &
             , -inbits, iulcorvert, idateo    &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,      &
             .true.)

          if(lldebug) then
             write(701,*)
             write(701,*) varNameList(jvar)
             write(701,*) 'Total correlation matrix'
             write(701,*) corvert(1:jnum,1:jnum,jvar)
          endif
                     
       endif
       
       ! Inverse not needed if not in analysis mode
       if (trim(bchm_mode) == 'BackgroundCheck') cycle
!!       if (.not.analysisMode) cycle
       
       eigenvec(1:jnum,1:jnum)=corvert(1:jnum,1:jnum,jvar)       

       ! CALCULATE EIGENVALUES AND EIGENVECTORS.
       ilwork = 4*jnum*2
       call dsyev('V','U',jnum,eigenvec(1:jnum,1:jnum),jnum,eigenval,zwork,ilwork,info)
       if(info.ne.0) then
         write(*,*) 'BCHM_sucorns2: non-zero value of info =',info,' returned by dsyev for wavenumber ',jn
         call abort3d('BCHM_SUCORNS')
       endif
      
       ! Set selected number of eigenmodes to zero
       if(numModeZero.gt.0) then
         do jk1 = 1, numModeZero
           eigenval(jk1) = 0.0d0
         enddo
       endif

       ! E * lambda^{-1}
       eigenvalmax=maxval(eigenval(1:jnum))
       do jk1 = 1, jnum
          if (eigenval(jk1).gt.1.0d-8*eigenvalmax) then
             result(1:jnum,jk1) = eigenvec(1:jnum,jk1)/eigenval(jk1)
          else
             result(1:jnum,jk1)=0.0D0
          end if
       enddo

       ! E * lambda^{-1} * E^T
       corverti(1:jnum,1:jnum,jvar)=0.0D0
       do jk1 = 1, jnum
       do jk2 = 1, jnum
          do jk3 = 1, jnum
             corverti(jk2,jk1,jvar) = corverti(jk2,jk1,jvar) + result(jk2,jk3)*eigenvec(jk1,jk3)
          enddo
       enddo
       enddo

       ! Check inverse (for output when mpi_myid is 0)
       result(1:jnum,1:jnum)=0.0D0
       do jk1 = 1, jnum
       do jk2 = 1, jnum
          do jk3 = 1, jnum
             result(jk2,jk1) = result(jk2,jk1) + &
                corvert(jk2,jk3,jvar)*corverti(jk3,jk1,jvar)
          enddo
       enddo
       enddo

!       zr=maxval(abs(corverti(1:jnum,1:jnum,jvar)))
!       where (abs(corverti(1:jnum,1:jnum,jvar)) .lt. 1.E-5*zr) corverti(1:jnum,1:jnum,jvar)=0.0D0
            
       if(mpi_myid == 0) then

          cletiket = 'CORVERTI'

          ierr = vfstecr(corverti(1:jnum,1:jnum,jvar),corverti(1:jnum,1:jnum,jvar) &
             ,  -inbits, iulcorvert, idateo    &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,      &
             .true.)

          cletiket = 'C*C^-1'
          
          ierr = vfstecr(result(1:jnum,1:jnum),result(1:jnum,1:jnum) &
             ,  -inbits, iulcorvert, idateo    &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,      &
             .true.)

          if(lldebug) then
             write(701,*) 'Inverse'
             write(701,*) corverti(1:jnum,1:jnum,jvar)
             write(701,*) 'Product'
             write(701,*) result(1:jnum,1:jnum)
          endif
                     
       endif

    end do
    
    if(mpi_myid == 0) then
       ierr = fstfrm(iulcorvert)
       ierr = fclos(iulcorvert)
    end if

  END SUBROUTINE BCHM_corvert_setup
!-----------------------------------------------------------------------------------------------
  Subroutine bchm_corvert_mult(varName,rmat_in,rmat_out,lvl_top,lvl_bot,ndim1,ndim2,ndim3, &
                               lrgsig,itype,rsig)
!
! Purpose: Multiplication with local matrix C=corvert (itype>0) or CI=corverti (itype<0).
!
!          Given A=rmat_in (=input)
!
!          itype       Output
!          -----       ------
!            0          D(i,j)=A(i,j)/sum(C(1:n,i))
!            1          A*C
!            2          C*A
!            3          A*C*A^T
!           -1          A*CI
!           -2          CI*A
!           -3          A*CI*A^T
!
! Author: Y.J. Rochon, ARQI/AQRD, Mar 2015
!
! Revisions:
!
! Arguments:
!
!  Input
!
!           varName              -- Variable name
!           rmat_in(ndim1,ndim2) -- Input matrix/vector A (see comments sections)
!           lvl_top(ndim1)       -- Top level of non-zero values in rmat_in
!           lvl_bot(ndim1)       -- Bottom level of non-zero values in rmat_in
!           ndim1,ndim2          -- Matrix dimensions
!                                   ndim1 to be 1 one 1D input vectors
!           ndim3                -- Expected output dimension.
!                                   =ndim1 for itype= +/-3
!                                   =ndim2 otherwise
!           lrgsig               -- Logical indicating if rsig to be included as part of C or CI below.
!           rsig                 -- Input error standard deviations.
!                                   Required when lrgsig=.true.
!           itype                -- Type of operator (see above).        
!
!  Output:
!
!           rmat_out(ndim1,ndim3) -- Output matrix/vector (see comments sections)
!                                    ndim3 Output is actually rmat_out(ndim1,ndim1) for itype=3.
!
! Comments:
!
! (A) If rmat_in is a 1-D vector, then 
!     
!     for cases +/- 2, one should have set ndim2=1 and ndim1=vector-length.
!     for cases +/- 1,3, one should have set ndim1=1 and ndim2=vector-length.
!
! (B) rmat_out assumed to be initialized prior to call to bchm_corvert_mult.
!
! (C) corverti is the inverse of corvert.
!
!-----------------------------------------------------------------------------------------------
    implicit none
    character(len=*), intent(in) :: varName
    integer, intent(in) :: ndim1,ndim2,ndim3,itype
    integer, intent(in) :: lvl_top(ndim1),lvl_bot(ndim1)
    logical, intent(in) :: lrgsig
    real(8), intent(in) :: rmat_in(ndim1,ndim2)
    real(8), intent(inout) :: rmat_out(ndim1,ndim3)
    real(8), intent(in), optional :: rsig(ndim2)
   
    integer :: jvar,jk1,jk2,jk3,nsize
    real(8) :: rmat_work(ndim2,ndim2),rsum

    if (.not.initialized) return
 
    if (.not.present(rsig).and.lrgsig) call abort3d('BCHM_corvert_mult: Missing rsig')  

!   Determine location and size in corvert/corverti
    
    do jvar=1,numvar3d+numvar2d
       if (trim(varName).eq.trim(varNameList(jvar))) exit
    end do
    if  (jvar.gt.numvar3d+numvar2d) call abort3d('BCHM_corvert_mult: Variable not found')
    
    nsize=nsposit(jvar+1)-nsposit(jvar)
    
!   Apply matrix/vector multiplication.
    
    rmat_work(:,:)=0.0D0
    
    if (itype.eq.3) then

!      A*C*A^T
       
       if (ndim3.ne.ndim1.or.ndim2.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=3')
       if (lrgsig) then
          do jk1=1,nsize
          do jk2=1,ndim1
             do jk3=lvl_top(jk2),lvl_bot(jk2)     ! Instead of do jk3=1,ndim2
                rmat_work(jk1,jk2)=rmat_work(jk1,jk2)+corvert(jk1,jk3,jvar)*rsig(jk3)*rsig(jk1)*rmat_in(jk2,jk3)
             end do
          end do
          end do
       else
          do jk1=1,nsize
          do jk2=1,ndim1
             do jk3=lvl_top(jk2),lvl_bot(jk2)   ! Instead of do jk3=1,ndim2
                rmat_work(jk1,jk2)=rmat_work(jk1,jk2)+corvert(jk1,jk3,jvar)*rmat_in(jk2,jk3)
             end do
          end do
          end do
       end if
       do jk1=1,ndim1
       do jk2=1,ndim1
          do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
             rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*rmat_work(jk3,jk2)
          end do
       end do
       end do
 
    else if (itype.eq.-3) then

!      A*CI*A^T
       
       if (ndim3.ne.ndim1.or.ndim2.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=3')
       if (lrgsig) then
          do jk1=1,nsize
          do jk2=1,ndim1
             do jk3=lvl_top(jk2),lvl_bot(jk2)     ! Instead of do jk3=1,ndim2
                rmat_work(jk1,jk2)=rmat_work(jk1,jk2)+corverti(jk1,jk3,jvar)*rmat_in(jk2,jk3)/(rsig(jk3)*rsig(jk1))
             end do
          end do
          end do
       else
          do jk1=1,nsize
          do jk2=1,ndim1
             do jk3=lvl_top(jk2),lvl_bot(jk2)     ! Instead of do jk3=1,ndim2
                rmat_work(jk1,jk2)=rmat_work(jk1,jk2)+corverti(jk1,jk3,jvar)*rmat_in(jk2,jk3)
             end do
          end do
          end do
       endif
       
       do jk1=1,ndim1
       do jk2=1,ndim1
          do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
             rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*rmat_work(jk3,jk2)
          end do
       end do
       end do
      
    else if (itype.eq.2) then
    
!      C*A

       if (ndim3.ne.ndim2.or.ndim1.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=2')
       if (lrgsig) then
          do jk1=1,nsize
          do jk3=1,nsize
             do jk2=lvl_top(jk3),lvl_bot(jk3)     ! Instead of do jk2=1,ndim2
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+corvert(jk1,jk3,jvar)*rsig(jk3)*rsig(jk1)*rmat_in(jk3,jk2)
             end do
          end do
          end do
       else
          do jk1=1,nsize
          do jk3=1,nsize
             do jk2=lvl_top(jk3),lvl_bot(jk3)     ! Instead of do jk2=1,ndim2
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+corvert(jk1,jk3,jvar)*rmat_in(jk3,jk2)
             end do
          end do
          end do
       endif

    else if (itype.eq.-2) then
    
!      CI*A

       if (ndim3.ne.ndim2.or.ndim1.ne.nsize) call abort3d('BCHM_corvert_mult: Size does match - itype=-2')
       if (lrgsig) then
          do jk1=1,nsize
          do jk3=1,nsize
             do jk2=lvl_top(jk3),lvl_bot(jk3)     ! Instead of do jk2=1,ndim2
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+corverti(jk1,jk3,jvar)*rmat_in(jk3,jk2)/(rsig(jk3)*rsig(jk1))
             end do
          end do
          end do
       else
          do jk1=1,nsize
          do jk3=1,nsize
             do jk2=lvl_top(jk3),lvl_bot(jk3)     ! Instead of do jk2=1,ndim2
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+corverti(jk1,jk3,jvar)*rmat_in(jk3,jk2)
             end do
          end do
          end do
       endif
          
    else if (itype.eq.1) then
    
!      A*C

       if (ndim3.ne.ndim2.or.ndim2.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=1')
       if (lrgsig) then
          do jk1=1,ndim1
          do jk2=1,nsize
             do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*corvert(jk3,jk2,jvar)*rsig(jk3)*rsig(jk2)
             end do
          end do
          end do
       else
          do jk1=1,ndim1
          do jk2=1,nsize
             do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
                 rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*corvert(jk3,jk2,jvar)
             end do
          end do
          end do
       endif
          
    else if (itype.eq.-1) then

!      A*CI

       if (ndim3.ne.ndim2.or.ndim2.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=-1')
       if (lrgsig) then
          do jk1=1,ndim1
          do jk2=1,nsize
             do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*corverti(jk3,jk2,jvar)/(rsig(jk3)*rsig(jk2))
             end do
          end do
          end do
       else
          do jk1=1,ndim1
          do jk2=1,nsize
             do jk3=lvl_top(jk1),lvl_bot(jk1)     ! Instead of do jk3=1,nsize
                rmat_out(jk1,jk2)=rmat_out(jk1,jk2)+rmat_in(jk1,jk3)*corverti(jk3,jk2,jvar)
             end do
          end do
          end do
       endif

    else if (itype.eq.0) then

!      Instead of A*CI do D(i,j)=A(i,j)/sum(C(1:n,i))

       if (ndim3.ne.ndim2.or.ndim2.ne.nsize) call abort3d('BCHM_corvert_mult: Size does not match - itype=0')
       if (lrgsig) then
          do jk1=1,ndim1
          do jk2=lvl_top(jk1),lvl_bot(jk1)   ! instead of do jk2=1,nsize
              rmat_out(jk1,jk2)=rmat_in(jk1,jk2)/rsig(jk2) &
                  /sum(corvert(1:nsize,jk2,jvar)/rsig(1:nsize))
          end do
          end do
       else
          do jk1=1,ndim1
          do jk2=lvl_top(jk1),lvl_bot(jk1)   ! instead of do jk2=1,nsize
              rmat_out(jk1,jk2)=rmat_in(jk1,jk2)/sum(corvert(1:nsize,jk2,jvar))
          end do
          end do
       endif

    else
       call abort3d('BCHM_corvert_mult: Requested type not found')
    end if
   
  end subroutine bchm_corvert_mult
!-----------------------------------------------------------------------------------------------
  Subroutine bchm_getsigma(varName,ndim2,rlat,rsig,nsize)
!
! Purpose: Interpolate error std. dev. to obs location.
!
! Author: Y.J. Rochon, ARQI/AQRD, Mar 2015
!
! Revisions:
!
! Arguments:
!
!  Input
!
!           varName        -- Variable name
!           ndim2          -- Max array size 
!           rlat           -- Target latitude.   
!
!  Output:
!
!           rsig(nsize)    -- Error std. dev.
!           nsize          -- Dimension
!
!-----------------------------------------------------------------------------------------------
    implicit none
    character(len=*), intent(in) :: varName
    integer, intent(in) :: ndim2
    real(8), intent(in) :: rlat 
    
    real(8), intent(out) :: rsig(ndim2)
    integer, intent(out) :: nsize
   
    integer :: jvar,jlat
    real(8) :: rlati(ndim2),zc1,zc2,rlat1,rlat2

    if (.not.initialized) return
    
!   Determine location and size of background error std. dev.

    do jvar=1,numvar3d+numvar2d
       if (trim(varName).eq.trim(varNameList(jvar))) exit
    end do
    if  (jvar.gt.numvar3d+numvar2d) call abort3d('BCHM_getsigma: Variable not found')
    
    nsize=nsposit(jvar+1)-nsposit(jvar)
    if (nsize.ne.ndim2) then
        write(6,*) 'NSIZE, NDIM2: ',nsize,ndim2
        call abort3d('BCHM_getsigma: Inconsistent size')
    end if
     
!   Determine reference latitude index  

    jlat=2
    do while (rlat.lt.gst_getrlati(jlat,gstID).and.jlat.le.nj_l) 
        jlat=jlat+1
    enddo

!   Set interpolation weights

    rlat1=gst_getrlati(jlat,gstID)
    rlat2=gst_getrlati(jlat-1,gstID)
    
    zc1=(rlat-rlat1)/(rlat2-rlat1)
    zc2=1.0-zc1

!   Apply interpolation of variances and take square root.

    rsig(1:nsize) =sqrt(rgsig(jlat,nsposit(jvar):nsposit(jvar+1)-1)*rgsig(jlat,nsposit(jvar):nsposit(jvar+1)-1)*zc2 &
                 +rgsig(jlat-1,nsposit(jvar):nsposit(jvar+1)-1)*rgsig(jlat-1,nsposit(jvar):nsposit(jvar+1)-1)*zc1)
    
  end subroutine bchm_getsigma
!-----------------------------------------------------------------------------------------------
  
END MODULE BmatrixChem
