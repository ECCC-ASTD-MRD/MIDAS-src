! MODULE bMatrixChem : Contains routines involving preparation and application
!                         of background-error covariance matrix(ces). Matrix
!                         based on horizontally homogeneous/isotropic
!                         correlations.  prefix="bchm" for constituents
!
! Purpose: Performs transformation from control vector to analysis increment
!          using the background error covariance matrix
!
! Subroutines:
!    bchm_setup (public)
!    bchm_BSqrt (public)
!    bchm_BSqrtAd (public)
!    bchm_cain
!    bchm_cainAd
!
! Dependencies:
!    globalSpectralTransform
!
! Author: Ping Du (based on bMatrixHI_mod.ftn90 by Mark Buehner), July-Sept 2014
!         - Code changes mainly pertain to the addition of all aspects related to
!           constituents and the introduction of the variables *_tr
!         - Partial removal of bMatrixHI_mod components related to standard weather
!           incremental variables
!         - Additions currently hardcoded to assume O3 as the one and only constituent variable.
!
! Revisions:
!        Yves Rochon, October 2014
!        - Addition and modification of comments
!
!--------------------------------------------------------------------------
MODULE BmatrixChem
  use mpivar_mod
  use MathPhysConstants_mod
  use earthConstants_mod
  use gridStateVector_mod
  use globalSpectralTransform
  use gaussGrid_mod
  use horizontalCoord_mod
  use verticalCoord_mod
  use varNameList_mod
  implicit none
  save
  private

  ! public procedures
  public :: bchm_Setup,bchm_BSqrt,bchm_BSqrtAd,bchm_Finalize,bchm_expandToMPIglobal,bchm_reduceToMPIlocal

  logical             :: initialized = .false.                    
  integer             :: nj_l,ni_l                    
  integer             :: nlev_M,nlev_T,nlev_T_even,nkgdim,nkgdim2    
  integer             :: ntrunc,nla_mpiglobal,nla_mpilocal           
  integer             :: cvDim_mpilocal,cvDim_mpiglobal           
  integer             :: gstID, gstID2          
  integer             :: nlev_bdl           
  type(struct_vco),pointer :: vco_anl          


  real(8),pointer     :: rgsig(:,:)
  real(8),pointer     :: rgsigo3(:,:)

  real(8),allocatable :: corns(:,:,:)
  real(8),allocatable :: rstddev(:,:)

  ! originally from common blocks and possibly from the namelist:
  integer,parameter   :: maxNumLevels=200
  integer             :: nulbgst=0
  real(8)             :: rvloctr=4.0d0

  ! this should come from state vector object
  integer             :: numvar3d
  integer             :: numvar2d

! new variables for chemical constituents  
  integer             :: numvar3d_tr
  integer             :: numvar2d_tr
  integer             :: nspositO3
  character(len=4),allocatable    :: vnl_varNameList3D_tr(:)
  character(len=4),allocatable    :: vnl_varNameList2D_tr(:)

  real(8), pointer    :: pressureProfile_M(:),pressureProfile_T(:)

  integer             :: mymBeg,mymEnd,mymSkip,mymCount
  integer             :: mynBeg,mynEnd,mynSkip,mynCount
  integer             :: maxMyNla
  integer             :: myLatBeg,myLatEnd
  integer             :: myLonBeg,myLonEnd
  integer, pointer    :: ilaList_mpiglobal(:)
  integer, pointer    :: ilaList_mpilocal(:)

  integer             :: get_max_rss


CONTAINS

    SUBROUTINE BCHM_setup(hco_in,vco_in,CVDIM_OUT)
    implicit none

    type(struct_hco),pointer :: hco_in
    type(struct_vco),pointer :: vco_in
    integer                  :: cvDim_out

    integer :: jlev, mpiMode, nulnam, ierr, fnom, fclos, jm, jn, status
    integer :: latPerPE, lonPerPE
    logical :: llfound
    real(8) :: zps
    logical :: makeEven_in = .false. ! to avoid the even number requirement in mpivar_setup_levels_npex 
  
    integer :: jvar

    NAMELIST /NAMBCHM/ntrunc
    call tmg_start(15,'BCHM_SETUP')

    vco_anl => vco_in
    nLev_M = vco_anl%nlev_M
    nLev_T = vco_anl%nlev_T
    ! need an even number of levels for spectral transform (gstID2)
    if(mod(nLev_T,2).ne.0) then
      nLev_T_even = nLev_T+1
    else
      nLev_T_even = nLev_T
    endif
    if(mpi_myid.eq.0) write(*,*) 'BCHM_setup: nLev_T, nLev_T_even=',nLev_T, nLev_T_even


    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=nambchm,iostat=ierr)
    if(ierr.ne.0) call abort3d('bchm_setup: Error reading namelist')
    if(mpi_myid.eq.0) write(*,nml=nambchm)
    ierr = fclos(nulnam)

    numvar3d_tr=0
    numvar2d_tr=0
    allocate(vnl_varNameList3D_tr(vnl_numvarmax3D))
    allocate(vnl_varNameList2D_tr(vnl_numvarmax2D))

  
! to find the 3D chemical constituent variable
    do jvar = 1, vnl_numvarmax3D
     if(gsv_varExist(vnl_varNameList3D(jvar))) then

      select case (vnl_varNameList3D(jvar))
      case ('UU','VV','TT','HU')
       numvar3d = numvar3d + 1
      case ('O3') 
       numvar3d_tr = numvar3d_tr + 1
       vnl_varNameList3D_tr(numvar3d_tr)='O3  '
      case ('NO2') 
       numvar3d_tr = numvar3d_tr + 1 
       vnl_varNameList3D_tr(numvar3d_tr)='NO2 '
      case ('CO2') 
       numvar3d_tr = numvar3d_tr + 1 
       vnl_varNameList3D_tr(numvar3d_tr)='CO2 '
      case default
      end select
     end if
    end do
  ! for 2D chemical constituent variable (not well done, need to be modified)
!   do jvar=1,vnl_numvarmax2D
!      if(gsv_varExist(vnl_varNameList2D(jvar))) then
!
!       select case (vnl_varNameList2D(jvar))
!        case ('P0','TG')
!         numvar2d = numvar2d + 1
!       case ('NO2 ')
!         numvar2d_tr = numvar2d_tr + 1
!         vnl_varNameList2D_tr(numvar2d_tr) = 'NO2 '
!       case default
!         write(*,*) 'PDD-no more 2D variable'
!       end select
!      end if
!    end do

    write(*,*) 'PDD Number of 3D variable', numvar3d_tr,vnl_varNameList3D_tr(numvar3d_tr)
!    write(*,*) 'PDD Number of 2D variable', numvar2d_tr,vnl_varNameList2D_tr(numvar2d_tr)


    nspositO3 = 1

    nkgdim =  nLev_T*numvar3d_tr + numvar2d_tr
!    nkgdim2 = nkgdim+nLev_T
    nkgdim2 = nkgdim

    nla_mpiglobal = (ntrunc+1)*(ntrunc+2)/2

    ni_l = hco_in%ni
    nj_l = hco_in%nj

    mpiMode = 4
    gstID  = gst_setup(ni_l,nj_l,ntrunc,mpiMode,nkgdim,makeEven_in)
    gstID2 = gst_setup(ni_l,nj_l,ntrunc,mpiMode,nlev_T_even)
    if(mpi_myid.eq.0) write(*,*) 'BCHM:returned value of gstID =',gstID
    if(mpi_myid.eq.0) write(*,*) 'BCHM:returned value of gstID2=',gstID2

    call mpivar_setup_latbands(nj_l,latPerPE,myLatBeg,myLatEnd)
    call mpivar_setup_lonbands(ni_l,lonPerPE,myLonBeg,myLonEnd)

    call mpivar_setup_m(ntrunc,mymBeg,mymEnd,mymSkip,mymCount)
    call mpivar_setup_n(ntrunc,mynBeg,mynEnd,mynSkip,mynCount)

    call gst_ilaList_mpiglobal(ilaList_mpiglobal,nla_mpilocal,maxMyNla,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)
    call gst_ilaList_mpilocal(ilaList_mpilocal,gstID,mymBeg,mymEnd,mymSkip,mynBeg,mynEnd,mynSkip)

    ! compute mpilocal control vector size
    do jm = mymBeg, mymEnd, mymSkip
      do jn = mynBeg, mynEnd, mynSkip
        if(jm.le.jn) then
          if(jm.eq.0) then
            ! only real component for jm=0
            cvDim_mpilocal = cvDim_mpilocal + 1*nkgdim2
          else
            ! both real and imaginary components for jm>0
            cvDim_mpilocal = cvDim_mpilocal + 2*nkgdim2
          endif
        endif
      enddo
    enddo
    cvDim_out = cvDim_mpilocal


    ! also compute mpiglobal control vector dimension
    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_mpiglobal,1,"mpi_integer","mpi_sum","GRID",ierr)

    allocate(rgsig(nj_l,nkgdim))
    rgsigo3 =>  rgsig(1:nj_l,nspositO3:nspositO3+nlev_T-1)
    allocate(corns(nkgdim,nkgdim,0:ntrunc))  
    allocate(rstddev(nkgdim,0:ntrunc))       

    zps = 101000.D0
    status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_M, levels=pressureProfile_M, &
                         sfc_field=zps, in_log=.false.)
    status = vgd_levels( vco_anl%vgrid, ip1_list=vco_anl%ip1_T, levels=pressureProfile_T, &
                         sfc_field=zps, in_log=.false.)



    call BCHM_sunewstats
    call BCHM_sucorns2


    if(mpi_myid.eq.0) write(*,*) 'END OF BCHM_SETUP'
    
    initialized = .true.

    call tmg_stop(15)

  END SUBROUTINE BCHM_setup

  SUBROUTINE BCHM_SUNEWSTATS
   implicit none

    integer :: ierr, fnom, fstouv, fstfrm, fclos
    logical :: lExists
    character(len=12) :: bFileName = './bgchemcov'

    inquire(file=bFileName,exist=lExists)
    IF ( lexists )then
      ierr = fnom(nulbgst,bFileName,'RND+OLD+R/O',0)
      if ( ierr .eq. 0 ) then
        ierr =  fstouv(nulbgst,'RND+OLD')
      else
        call abort3d('BCHM_SUNEWSTATS:NO BACKGROUND CHEMICAL CONSTITUENT STAT FILE!!')
      endif
    endif

    call BCHM_readcorns2


    call BCHM_rdspstd_newfmt 
    call BCHM_rdspstd

    ierr = fstfrm(nulbgst)
    ierr = fclos(nulbgst)

  END SUBROUTINE BCHM_SUNEWSTATS

 SUBROUTINE BCHM_bSqrt(controlvector_in,statevector)
  
   implicit none

    real(8)   :: controlVector_in(cvDim_mpilocal)
    type(struct_gsv) :: statevector
   real(8),allocatable :: gd_out(:,:,:)
    real(8)   :: hiControlVector(nla_mpilocal,2,nkgdim)
    integer   :: jvar, ilev1, ilev2

    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrt: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    if(.not. initialized) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixChem not initialized'
      return
    endif

    allocate(gd_out(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd))

     call bchm_cain(controlVector_in,hiControlVector)

     call bchm_spa2gd(hiControlVector,gd_out)

     call copyToStatevector(statevector,gd_out)

     deallocate(gd_out)


    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrt: done'

  END SUBROUTINE BCHM_bSqrt

    SUBROUTINE BCHM_cain(controlVector_in,hiControlVector_out)
    implicit none

    real(8) :: controlVector_in(cvDim_mpilocal)
    real(8) :: hiControlVector_out(nla_mpilocal,2,nkgdim)

    integer :: jdim, jlev, jm, jn, ila_mpilocal, ila_mpiglobal

    jdim = 0
    hiControlVector_out(:,:,:) = 0.0d0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,1,jlev) = controlVector_in(jdim)
            else
              ! both real and imaginary components for jm>0
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,1,jlev) = controlVector_in(jdim)
              jdim = jdim + 1
              hiControlVector_out(ila_mpilocal,2,jlev) = controlVector_in(jdim)
            endif
          endif
        enddo
      enddo
    enddo

  end SUBROUTINE BCHM_cain



  SUBROUTINE copyToStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real(8) :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    integer :: jlon, jlev, jlev2, jlat, jvar, ilev1, ilev2
    real(8), pointer :: field(:,:,:)



    do jvar=1,vnl_numvarmax 
     if(gsv_varExist(vnl_varNameList(jvar))) then
        field => gsv_getField3D(statevector,vnl_varNameList(jvar))
        if(vnl_varNameList(jvar).eq.'O3  ') then
          ilev1 = nspositO3
        else
         cycle    
        endif
        ilev2 = ilev1 - 1 + gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))
        
!!!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,jlon)
        do jlat = myLatBeg, myLatEnd
          do jlev = ilev1, ilev2
            jlev2 = jlev-ilev1+1
            do jlon = myLonBeg, myLonEnd
              field(jlon,jlev2,jlat) = gd(jlon,jlev,jlat)
            enddo
          enddo
        enddo
!!!$OMP END PARALLEL DO
      endif
    enddo
  END SUBROUTINE copyToStatevector



  SUBROUTINE BCHM_bSqrtAd(statevector,controlVector_out)
    implicit none

    real(8)   :: controlVector_out(cvDim_mpilocal)
    type(struct_gsv) :: statevector
    real(8), allocatable :: gd_in(:,:,:)
    real(8)   :: hiControlVector(nla_mpilocal,2,nkgdim)
    integer   :: jvar, ilev1, ilev2

    if(.not. initialized) then
      if(mpi_myid.eq.0) write(*,*) 'bMatrixTR not initialized'
      return
    endif

    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrtad: starting'
    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'



    allocate(gd_in(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd))
    call bchm_copyFromStatevector(statevector,gd_in)

    call bchm_spa2gdad(gd_in,hiControlVector)

    call bchm_cainad(hiControlVector,controlVector_out)

    deallocate(gd_in)

    if(mpi_myid.eq.0) write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    if(mpi_myid.eq.0) write(*,*) 'bchm_bsqrtad: done'

  END SUBROUTINE BCHM_bSqrtAd

  SUBROUTINE BCHM_copyFromStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real(8)          :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    integer :: jlon, jlev, jlev2, jlat, jvar, ilev1, ilev2
    real(8), pointer :: field(:,:,:)

    do jvar = 1, vnl_numvarmax
      if(gsv_varExist(vnl_varNameList(jvar))) then
        field => gsv_getField3D(statevector,vnl_varNameList(jvar))
        if(vnl_varNameList(jvar).eq.'O3  ') then
          ilev1 = nspositO3
        else
          cycle
        endif
        ilev2 = ilev1 - 1 + gsv_getNumLev(statevector,vnl_vartypeFromVarname(vnl_varNameList(jvar)))
!!!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlev2,jlon)
        do jlat = myLatBeg, myLatEnd
          do jlev = ilev1, ilev2
            jlev2 = jlev-ilev1+1
            do jlon = myLonBeg, myLonEnd
              gd(jlon,jlev,jlat) = field(jlon,jlev2,jlat)
            enddo
          enddo
        enddo
!!!$OMP END PARALLEL DO
      endif
    enddo

  END SUBROUTINE BCHM_copyFromStatevector




  SUBROUTINE BCHM_READCORNS2
    implicit none

    integer :: kip1
    integer :: jn, istdkey,icornskey
    integer :: iksdim,jcol,jrow,jblock,jlevo,jlevi
    real(8) :: zwork
    real(8), allocatable, dimension(:) :: zstdsrc
    real(8), allocatable, dimension(:,:) :: zcornssrc

    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo
    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    iksdim = nlev_T*numvar3d_tr+numvar2d_tr     
    allocate(zcornssrc(iksdim,iksdim))
    allocate(zstdsrc(iksdim))

    kip1 = -1

    do jn = 0, ntrunc

      ! Looking for FST record parameters..

      idateo = -1
      cletiket = 'RSTDDEV'
      ip1 = kip1
      ip2 = jn
      ip3 = -1
      cltypvar = 'X'
      clnomvar = 'O3'

      istdkey = vfstlir(ZSTDSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      if(istdkey .lt.0 ) then
        call abort3d('READCORNS2: Problem with TRACER background stat file')
      endif

      if (ini .ne. iksdim) then
        call abort3d('READCORNS2: TRACER background stat levels inconsitencies')
      endif

      ! Looking for FST record parameters..

      idateo = -1
      cletiket = 'CORRNS'
      ip1 = kip1
      IP2 = JN
      ip3 = -1
      cltypvar = 'X'
      clnomvar = 'O3'
      icornskey = vfstlir(ZCORNSSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      if(icornskey .lt.0 ) then
        call abort3d('READCORNS2: Problem with TRACER background stat file')
      endif

      if (ini .ne. iksdim .or. inj .ne. iksdim) then
        call abort3d('READCORNS2: TRACER BG stat levels inconsitencies')
      endif

      do jcol = 1, nkgdim
        rstddev(jcol,jn) = 0.0d0
        do jrow = 1, nkgdim
          corns(jrow,jcol,jn) = 0.0d0 
        enddo
      enddo

      do jcol = 1, iksdim
        do jrow = 1, iksdim
          corns(jrow,jcol,jn) = zcornssrc(jrow,jcol)
        enddo
      enddo


      do jrow = 1, iksdim
        rstddev(jrow,jn) = zstdsrc(jrow)
      enddo

    enddo

    

    ! Apply convolution to RSTDDEV correlation

    call BCHM_convol

    do jn = 0, ntrunc

      ! Re-build of correlation matrix: factorization of corns with convoluted RSTDDEV
      do jcol = 1, nkgdim
        do jrow = 1, nkgdim
          corns(jrow,jcol,jn) = rstddev(jrow,jn) * corns(jrow,jcol,jn)* rstddev(jcol,jn)
        enddo
      enddo

    enddo

    deallocate(zcornssrc)
    deallocate(zstdsrc)

    !write(*,*) 'Done in BCHM_READCORNS2'
  END SUBROUTINE BCHM_READCORNS2

  SUBROUTINE BCHM_convol
    implicit none

    real(8) dlfact2,dlc,dsummed
    real(8) dtlen,zr,dlfact
    integer ilen,jn,jlat,jk
    real(8) zlegi(0:ntrunc, nj_l),zleg(0:ntrunc, nj_l),zsp(0:ntrunc,nkgdim),zgr(nj_l,nkgdim)
    real(8) dlwti(nj_l),zrmu(nj_l)

    integer inracp
    real(8) zpg(nj_l),zsia(nj_l),zrad(nj_l),zpgssin2(nj_l)
    real(8) zsinm1(nj_l),zsinm2(nj_l),zsin2(nj_l),zsinlat(nj_l)
    real(8) dlfact1, dln
    real(8) dlnorm(0:ntrunc)

    real(8)         :: RPORTR   = 3000.D3

    do jlat = 1, nj_l
       dlwti(jlat) = gst_getrwt(jlat,gstID)
       zrmu(jlat)  = gst_getrmu(jlat,gstID)
    end do

    do jlat = 1, nj_l
       zleg(0,jlat) = sqrt(0.5d0)
       zleg(1,jlat) = sqrt(1.5d0)*zrmu(jlat)
    enddo
    do jn = 0, ntrunc
       dln = 1.d0*real(jn,8)
       dlnorm(jn) = dsqrt((2.d0*dln + 1.d0)/2.d0)
    enddo
    do jn = 1, ntrunc-1
       dln = real(jn,8)
       dlfact1 = ((2.d0*dln+1.d0)/(dln+1.d0))*(dlnorm(jn+1)/dlnorm(jn))
       dlfact2 = (dln/(dln+1.d0))*(dlnorm(jn+1)/dlnorm(jn-1))
       do jlat = 1, nj_l
          zleg(jn+1,jlat) = dlfact1*zrmu(jlat)*zleg(jn,jlat) - dlfact2*zleg(jn-1,jlat)
       enddo
    enddo

    do jlat = 1, nj_l
       do jn = 0, ntrunc
         zlegi(jn,jlat) = zleg(jn,jlat)
       enddo
    enddo

!     1.2 CONVERT THE CORRELATIONS IN SPECTRAL SPACE INTO SPECTRAL
!         COEFFICIENTS OF THE CORRELATION FUNCTION AND FUNCTION TO BE
!         SELF-CONVOLVED
    do jn = 0, ntrunc
      dlfact = ((2.0d0*jn+1)/2.0d0)**0.25d0
      dlfact2 = ((2.0d0*JN +1.0d0)/2.0d0)**(0.25d0)
      do jk = 1, nkgdim
        zsp(jn,jk) = rstddev(jk,jn)*dlfact*dlfact2
      enddo
    enddo

    ! Transform to physical space
    call zleginv(zgr,zsp,zlegi,dlwti,ntrunc,nj_l,nkgdim,nj_l,nkgdim,ntrunc)

    ! Truncate in horizontal extent with Gaussian window
    do jk = 1, nkgdim
      if (jk.eq.nspositO3) then
        dtlen = rportr 
      endif
      if(dtlen.gt.0.0d0) then
        dlc = 1.d0/dble(dtlen)
        dlc = 0.5d0*dlc*dlc
        do jlat = 1, nj_l
          zr = ra * acos(zrmu(jlat))
          dlfact = dexp(-(zr**2)*dlc)
          zgr(jlat,jk) = dlfact*zgr(jlat,jk)
        enddo
      endif

      !write(*,*) 'zeroing length (km)=',jk,dtlen/1000.0
    enddo

    ! Transform back to spectral space
    call zlegdir(zgr,zsp,zlegi,dlwti,ntrunc,nj_l,nkgdim,nj_l,nkgdim,ntrunc)

    ! Convert back to correlations
    do jk = 1, nkgdim
      do jn = 0, ntrunc
         zsp(jn,jk) = zsp(jn,jk)*(2.0d0/(2.0d0*jn+1.0))**(0.25d0)
      enddo
    enddo

    ! PUT BACK INTO RSTDDEV
    do jn = 0, ntrunc
      do jk = 1, nkgdim
         rstddev(jk,jn) = zsp(jn,jk)
      enddo
    enddo

    ! Re-normalize to ensure correlations
    do jk = 1, nkgdim
      dsummed = 0.d0
      do jn = 0, ntrunc
        dsummed = dsummed+ dble(rstddev(jk,jn)**2)*sqrt(((2.d0*jn)+1.d0)/2.d0)
      enddo
      dsummed = sqrt(dsummed)
      do jn = 0, ntrunc
        if(dsummed.gt.1.d-30) rstddev(jk,jn) = rstddev(jk,jn)/dsummed
      enddo
    enddo

    !     CONVERT THE SPECTRAL COEFFICIENTS OF THE CORRELATION FUNCTION
    !     .  BACK INTO CORRELATIONS OF SPECTRAL COMPONENTS
    do jn = 0, ntrunc
      dlfact = sqrt(0.5d0)*(1.0d0/((2.0d0*jn+1)/2.0d0))**0.25d0
      do jk = 1, nkgdim
        rstddev(jk,jn) = rstddev(jk,jn)*dlfact
      enddo
    enddo

  END SUBROUTINE BCHM_convol


  SUBROUTINE BCHM_RDSPSTD
      implicit none

    integer, parameter  :: inbrvar3d=1
    integer, parameter  :: inbrvar2d=2
    integer :: jvar,jn,inix,injx,inkx
    integer :: ikey, jlevo, jlat,firstn,lastn
    real(8) :: zsp(0:ntrunc,max(nlev_M,nlev_T)),zspbuf(max(nlev_M,nlev_T)),zwork
    real(8) :: zleg(0:ntrunc,nj_l),zgr(nj_l,max(nlev_M,nlev_T)),zgsig(1,nj_l,max(nlev_M,nlev_T)),zstddev(nkgdim,nj_l)
    character(len=4) :: varName3d(inbrvar3d),varName2d(inbrvar2d)

    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ipak,ipas
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo,nlev_MT
    character(len=1)  :: clgrtyp
    character(len=2)  :: cltypvar
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    data varName3d/'O3  '/

    call gst_setID(gstID)
    call gst_zlegpol(zleg)

    rgsig(:,:) = 0.0d0
!   2. Reading the data

    idate(1) = -1
    ip1      = -1
    ip2      = -1
    ip3      = -1

    cletiket = 'SPSTDDEV'
    cltypvar = 'X'

    do jvar = 1, inbrvar3d
      clnomvar = varName3d(jvar)
      if(vnl_varTypeFromVarName(clnomvar).eq.'MM') then
        nlev_MT = nlev_M
      else
        nlev_MT = nlev_T
      endif
      firstn = -1
      do jn = 0, ntrunc
        ip2 = jn
        ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf(1:nlev_MT),nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        else
          if(firstn.eq.-1) firstn = jn
          lastn = jn
          zspbuf(:) = 0.0d0
        endif

        if (ini .ne. nlev_MT) then
          call abort3d('RDSPSTD: TRACER background stat levels inconsitencies')
        endif

        do jlevo = 1, nlev_MT
          zsp(jn,jlevo) = zspbuf(jlevo)
        enddo
      enddo
      if(mpi_myid.eq.0.and.firstn.ne.-1) then
        write(*,*) 'WARNING: CANNOT FIND SPSTD FOR ',clnomvar, &
                     ' AT N BETWEEN ',firstn,' AND ',lastn,', SETTING TO ZERO!!!'
      endif
      call zleginv2(zgr(:,1:nlev_MT),zsp(:,1:nlev_MT),zleg,ntrunc,nj_l,nlev_MT,nj_l,nlev_MT,ntrunc)

      if(clnomvar .eq. 'O3') then
        do jlat = 1, nj_l
          do jlevo = 1, nlev_MT
            rgsigo3(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      endif


     enddo 

  END SUBROUTINE BCHM_RDSPSTD

   SUBROUTINE BCHM_RDSPSTD_NEWFMT
    implicit none

    integer, parameter  :: inbrvar3d=1
    integer, parameter  :: inbrvar2d=2
    integer :: jvar,jn,inix,injx,inkx,ntrunc_file
    integer :: ikey,jlevo,jlat
    real(8) :: zsp(0:ntrunc,max(nlev_M,nlev_T)),zspbuf(0:ntrunc),zwork
    real(8) :: zleg(0:ntrunc,nj_l),zgr(nj_l,max(nlev_M,nlev_T)),zgsig(1,nj_l,max(nlev_M,nlev_T)),zstddev(nkgdim,nj_l)
    character(len=4) :: varName3d(inbrvar3d),varName2d(inbrvar2d)

    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ipak,ipas
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo,nlev_MT
    character(len=1)  :: clgrtyp
    character(len=2)  :: cltypvar
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf

    data varName3d/'O3  '/
    
    call gst_setID(gstID)
    call gst_zlegpol(zleg)

    rgsig(:,:) = 0.0d0

!   2. Reading the data

    idate(1) = -1
    ip2      = -1
    ip3      = -1

    cletiket = 'SPSTDDEV'
    cltypvar = 'X'

    ! check if file is old format
    ip1 = -1
    clnomvar = varName3d(1)
    ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
    write(*,*) 'ini,inj,ink=',inix,injx,inkx
    if(inix.gt.1) then
      write(*,*) 'BCHM_RDSPSTD_NEWFMT: ini>1, SPSTDDEV is in old format, calling BCHM_RDSPSTD...'
      call bchm_rdspstd
      return
    endif

    !write(*,*) 'Reading 3D variables'
    do jvar = 1, inbrvar3d
      clnomvar = varName3d(jvar)
      if(vnl_varTypeFromVarName(clnomvar).eq.'MM') then
        nlev_MT = nlev_M
      else
        nlev_MT = nlev_T
      endif
      !write(*,*)'Reading ',clnomvar
      do jlevo = 1, nlev_MT
        if(vnl_varTypeFromVarName(clnomvar).eq.'MM') then
          ip1 = vco_anl%ip1_M(jlevo)
        else
          ip1 = vco_anl%ip1_T(jlevo)
        endif
        ikey = fstinf(nulbgst,inix,ntrunc_file,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        ntrunc_file = ntrunc_file-1

        if(ntrunc_file.gt.ntrunc) call abort3d('RDSPSTD_NEWFMT: ntrunc in file > ntrunc for analysis!')

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf(0:ntrunc_file),nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        else
          write(*,*) 'RDSPSTD_NEWFMT: ',jvar,clnomvar,nlev_MT,jlevo,ikey,ntrunc,ntrunc_file
          call abort3d('RDSPSTD_NEWFMT: SPSTDDEV record not found')
        endif

        zsp(:,jlevo) = 0.0d0
        do jn = 0, ntrunc_file
          zsp(jn,jlevo) = zspbuf(jn)
        enddo
      enddo

      call zleginv2(zgr(:,1:nlev_MT),zsp(:,1:nlev_MT),zleg,ntrunc,nj_l,nlev_MT,nj_l,nlev_MT,ntrunc)

      if(clnomvar .eq. 'O3') then
        do jlat = 1, nj_l
          do jlevo = 1, nlev_T
            rgsigo3(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      endif

    enddo

  END SUBROUTINE BCHM_RDSPSTD_NEWFMT

   SUBROUTINE BCHM_SUCORNS2
    implicit none

    real(8) :: eigenval(nkgdim), eigenvec(nkgdim,nkgdim),result(nkgdim,nkgdim)
    real(8) :: eigenvalsqrt(nkgdim)

    integer :: jlat,jn,jk1,jk2,jk3,jr
    integer :: ilwork,info,klatPtoT
    integer :: ikey, nsize

    real(8) :: zwork(2*4*nkgdim)
    real(8) :: ztt(nlev_T,nlev_T,(ntrunc+1)),ztpsi(nlev_T,nlev_M,(ntrunc+1))
    real(8) :: ztlen,zcorr,zr,zpres1,zpres2
    real(8) :: zfact,zfact2,zcoriolis
    real(8) :: zpsi(nlev_M,nlev_M),zfacttb(nj_l,nlev_T),zfactpsb(nj_l)
    real(8),allocatable :: corns_temp(:,:,:)
    logical :: lldebug

    ! standard file variables
    integer :: ini,inj,ink, inpas, inbits, idatyp, ideet
    integer :: ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf
    integer :: iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas,ntrials
    integer :: iliste(100),idate(100),idimax,infon,iheures,idateo
    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer :: vfstlir,vfstecr,fstprm,fstinf
    integer :: fnom,fstouv,fstfrm,fclos

    lldebug = .false.



    ztlen = rvloctr    ! specify length scale (in units of ln(Pressure))
    if(ztlen.gt.0.0d0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1 = 1, nlev_T
        zpres1 = log(pressureProfile_T(jk1))
        do jk2 = 1, nlev_T
          zpres2 = log(pressureProfile_T(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr = gasparicohn(ztlen,zr)
          do jn = 0, ntrunc
            corns(jk1,jk2,jn)  =       &
                 corns(jk1,jk2,jn)*zcorr  
          enddo
        enddo
      enddo
    endif





    ! compute square-root of corns for each total wavenumber
    allocate(corns_temp(nkgdim,nkgdim,0:ntrunc))
    corns_temp(:,:,:)=0.0d0
    do jn = mpi_myid, ntrunc, mpi_nprocs

      do jk1 = 1, nkgdim
         do jk2 = 1, nkgdim
            eigenvec(jk2,jk1) = corns(jk2,jk1,jn)
         enddo
      enddo

      ! CALCULATE EIGENVALUES AND EIGENVECTORS.
      ilwork = 4*nkgdim*2
      call dsyev('V','U',nkgdim,eigenvec,nkgdim,eigenval,zwork,ilwork,info)
      if(info.ne.0) then
        write(*,*) 'bchm_sucorns2: non-zero value of info =',info,' returned by dsyev for wavenumber ',jn
        call abort3d('BCHM_SUCORNS')
      endif
      

      do jk1 = 1, nkgdim
        if(eigenval(jk1).lt.1.0d-15) then
          eigenvalsqrt(jk1) = 0.0d0
        else
          eigenvalsqrt(jk1) = sqrt(eigenval(jk1))
        endif
      enddo

      ! E * lambda^1/2
      do jk1 = 1, nkgdim
         do jk2 = 1, nkgdim
            result(jk2,jk1) = eigenvec(jk2,jk1)*eigenvalsqrt(jk1)
         enddo
      enddo

      ! (E * lambda^1/2) * E^T
      do jk1 = 1, nkgdim
         do jk2 = 1, nkgdim
            do jk3 = 1, nkgdim
              corns_temp(jk2,jk1,jn) = corns_temp(jk2,jk1,jn) + result(jk2,jk3)*eigenvec(jk1,jk3)
            enddo
         enddo
      enddo

    enddo ! jn

    nsize = nkgdim*nkgdim*(ntrunc+1)
    call rpn_comm_allreduce(corns_temp,corns,nsize,"mpi_double_precision","mpi_sum","GRID",ierr)
    deallocate(corns_temp)

 END SUBROUTINE BCHM_SUCORNS2

  FUNCTION GASPARICOHN(ztlen,zr)

    real(8)  :: gasparicohn
    real(8)  :: ztlen,zr,zlc

    zlc = ztlen/2.0d0
    if(zr.le.zlc) then
      gasparicohn = -0.250d0*(zr/zlc)**5+0.5d0*(zr/zlc)**4             &
                  +0.625d0*(zr/zlc)**3-(5.0d0/3.0d0)*(zr/zlc)**2+1.0d0
    elseif(zr.le.(2.0d0*zlc)) then
      gasparicohn = (1.0d0/12.0d0)*(zr/zlc)**5-0.5d0*(zr/zlc)**4         &
                  +0.625d0*(zr/zlc)**3+(5.0d0/3.0d0)*(zr/zlc)**2       &
                  -5.0d0*(zr/zlc)+4.0d0-(2.0d0/3.0d0)*(zlc/zr)
    else
      gasparicohn = 0.0d0
    endif
    if(gasparicohn.lt.0.0d0) gasparicohn = 0.0d0

  END FUNCTION GASPARICOHN


 SUBROUTINE BCHM_SPA2GD(hiControlVector_in,gd_out)
    IMPLICIT NONE

    real(8) :: hiControlVector_in(nla_mpilocal,2,nkgdim)
    real(8) :: gd_out(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)

    real(8) :: sp(maxMyNla,2,nkgdim)

    integer :: jn,jm,ila_mpilocal,ila_mpiglobal,icount
    real(8) :: sq2, zp
    real(8) , allocatable :: zsp(:,:,:), zsp2(:,:,:)
    integer :: ilon, jlev, jlon, jlat, jla_mpilocal, klatPtoT
    real(8), target  :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)
    real(8) :: dla2, dl1sa2, zcoriolis, zpsb(myLonBeg:myLonEnd,myLatBeg:myLatEnd)

    klatPtoT = 1

    call tmg_start(53,'BCHM_SPA2GD1')

    ! maybe not needed:
    sp(:,:,:) = 0.0d0
    sq2 = sqrt(2.0d0)

    allocate(zsp(nkgdim,2,mymCount))
    allocate(zsp2(nkgdim,2,mymCount))

!$OMP PARALLEL DO PRIVATE(jn,jm,jlev,ila_mpiglobal,ila_mpilocal,zsp2,zsp,icount)
    do jn = mynBeg, mynEnd, mynSkip

      icount = 0
      do jm = mymBeg, mymEnd, mymSkip
        if(jm.le.jn) then
          icount = icount+1
          ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            zsp(jlev,1,icount) = hiControlVector_in(ila_mpilocal,1,jlev)
            zsp(jlev,2,icount) = hiControlVector_in(ila_mpilocal,2,jlev)
          enddo
        endif
      enddo
      if(icount.gt.0) then

  CALL DGEMUL(corns(1,1,jn),nkgdim,'N',zsp(1,1,1),nkgdim,'N',zsp2(1,1,1),nkgdim,nkgdim,nkgdim,2*icount)

        icount = 0
        do jm = mymBeg, mymEnd, mymSkip
          if(jm.le.jn) then
            icount = icount+1
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
            do jlev = 1, nkgdim
              sp(ila_mpilocal,1,jlev) = zsp2(jlev,1,icount)
              sp(ila_mpilocal,2,jlev) = zsp2(jlev,2,icount)
            enddo
          endif
        enddo

      endif

      ! make adjustments for jm=0
      if(mymBeg.eq.0) then

        ila_mpiglobal = gst_getNind(0,gstID) + jn
        ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)

        do jlev = 1, nkgdim
          sp(ila_mpilocal,1,jlev) = sp(ila_mpilocal,1,jlev)*sq2
          sp(ila_mpilocal,2,jlev) = 0.0d0
        enddo

      endif

    enddo
!$OMP END PARALLEL DO
    deallocate(zsp)
    deallocate(zsp2)
    call tmg_stop(53)


!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
          gd(jlon,jlev,jlat) = 0.0d0
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_start(55,'BCHM_SPEREE')
    call gst_setID(gstID)
    call gst_speree4(sp,gd)
    call gst_setID(gstID2)
    call tmg_stop(55)

    call tmg_start(54,'BCHM_SPA2GD2')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlon)
    do jlat = myLatBeg, myLatEnd

     do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
            gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo
    enddo  ! jlat
!$OMP END PARALLEL DO
    call tmg_stop(54)

!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
          gd_out(jlon,jlev,jlat) = gd(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE BCHM_SPA2GD

    SUBROUTINE BCHM_SPA2GDAD(gd_in,hiControlVector_out)
    implicit none

    real(8) :: hiControlVector_out(nla_mpilocal,2,nkgdim)
    real(8) :: gd_in(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)

    real(8) :: sp(maxMyNla,2,nkgdim)

    integer :: jn, jm, ila_mpilocal, ila_mpiglobal, icount
    real(8) :: sq2, zp
    real(8) ,allocatable :: zsp(:,:,:), zsp2(:,:,:)

    integer :: ilon, jlev, jlon, jlat, jla_mpilocal, klatPtoT
    real(8) :: dl1sa2, dla2, zcoriolis, zpsb(myLonBeg:myLonEnd,myLatBeg:myLatEnd)
    real(8), target :: gd(myLonBeg:myLonEnd,nkgdim,myLatBeg:myLatEnd)


!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
                                                      
          gd(jlon,jlev,jlat) = gd_in(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

   call tmg_start(54,'BCHM_SPA2GD2')

!$OMP PARALLEL DO PRIVATE(jlat,jlev,jlon)
    do jlat = myLatBeg, myLatEnd
      do jlev = 1, nkgdim
        do jlon = myLonBeg, myLonEnd
            gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo


    enddo
!$OMP END PARALLEL DO
    call tmg_stop(54)

    call tmg_start(56,'BCHM_REESPE')
    call gst_setID(gstID)
    call gst_reespe4(sp,gd)
    call tmg_stop(56)

    call tmg_start(53,'BCHM_SPA2GD1')

    hiControlVector_out(:,:,:) = 0.0d0
    sq2 = sqrt(2.0d0)
    allocate(zsp(nkgdim,2,mymCount))
    allocate(zsp2(nkgdim,2,mymCount))
!$OMP PARALLEL DO PRIVATE(JN,JM,JLEV,ILA_MPILOCAL,ILA_MPIGLOBAL,zsp,zsp2,icount)
    do jn = mynBeg, mynEnd, mynSkip

      icount = 0
      do jm = mymBeg, mymEnd, mymSkip
        if(jm.le.jn) then
          icount = icount+1
          ila_mpiglobal = gst_getNind(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            zsp2(jlev,1,icount) = sp(ila_mpilocal,1,jlev)
            zsp2(jlev,2,icount) = sp(ila_mpilocal,2,jlev)
          enddo
        endif
      enddo

      if(icount.gt.0) then

       CALL DGEMUL(corns(1,1,jn),nkgdim,'T',zsp2(1,1,1),nkgdim,'N',zsp(1,1,1),nkgdim,nkgdim,nkgdim,2*icount)

        icount = 0
        do jm = mymBeg, jn, mymSkip
          icount=icount+1
          ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
          ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)
          do jlev = 1, nkgdim
            hiControlVector_out(ila_mpilocal,1,jlev) = zsp(jlev,1,icount)
            hiControlVector_out(ila_mpilocal,2,jlev) = zsp(jlev,2,icount)
          enddo
        enddo

      endif

      ! make adjustments for jm=0
      if(mymBeg.eq.0) then

        ila_mpiglobal = gst_getNIND(0,gstID) + jn
        ila_mpilocal = ilaList_mpilocal(ila_mpiglobal)

       do jlev = 1, nkgdim
          hiControlVector_out(ila_mpilocal,1,jlev) = hiControlVector_out(ila_mpilocal,1,jlev)*sq2
          hiControlVector_out(ila_mpilocal,2,jlev) = hiControlVector_out(ila_mpilocal,2,jlev)*sq2
        enddo

      endif

    enddo
!$OMP END PARALLEL DO
    deallocate(zsp)
    deallocate(zsp2)
    call tmg_stop(53)

  END SUBROUTINE BCHM_SPA2GDAD
 
  SUBROUTINE BCHM_cainAd(hiControlVector_in,controlVector_out)
    IMPLICIT NONE

    real(8) :: controlVector_out(cvDim_mpilocal)
    real(8) :: hiControlVector_in(nla_mpilocal,2,nkgdim)

    integer :: jdim, jlev, jm, jn, ila_mpilocal, ila_mpiglobal

    jdim = 0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then
            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm
            ila_mpilocal  = ilaList_mpilocal(ila_mpiglobal)
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,1,jlev)
            else
              ! both real and imaginary components for jm>0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,1,jlev)*2.0d0
              jdim = jdim + 1
              controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(ila_mpilocal,2,jlev)*2.0d0
            endif
          endif
        enddo
      enddo
    enddo

  END SUBROUTINE BCHM_cainAd


  SUBROUTINE BCHM_Finalize()
    implicit none

    deallocate(pressureProfile_M)
    deallocate(pressureProfile_T)
    deallocate(rgsig)
    deallocate(corns)
    deallocate(rstddev)

  END SUBROUTINE BCHM_Finalize

  SUBROUTINE BCHM_reduceToMPILocal(cv_mpilocal,cv_mpiglobal,cvDim_mpilocal_out)
    implicit none
    real(8) :: cv_mpilocal(cvDim_mpilocal)
    real(8) :: cv_mpiglobal(cvDim_mpiglobal)
    integer :: cvDim_mpilocal_out

    integer :: jlev,jn,jm,ila_mpilocal,ila_mpiglobal,jdim_mpilocal,jdim_mpiglobal

    cvDim_mpilocal_out = cvDim_mpilocal

    jdim_mpilocal = 0
    do jlev = 1, nkgdim
      do jm = mymBeg, mymEnd, mymSkip
        do jn = mynBeg, mynEnd, mynSkip
          if(jm.le.jn) then

            ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm

            ! figure out index into global control vector
            if(jm.eq.0) then
              ! for jm=0 only real part
              jdim_mpiglobal = ila_mpiglobal
            else
              ! for jm>0 both real and imaginary part
              jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
            endif
            ! add offset for level
            jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)

            ! index into local control vector computer as in cain
            if(jm.eq.0) then
              ! only real component for jm=0
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
            else
              ! both real and imaginary components for jm>0
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal)
              jdim_mpilocal = jdim_mpilocal + 1
              cv_mpilocal(jdim_mpilocal) = cv_mpiglobal(jdim_mpiglobal+1)
            endif

            if(jdim_mpilocal.gt.cvDim_mpilocal)   &
              write(*,*) 'ERROR: jdim,cvDim,mpilocal=',jdim_mpilocal,cvDim_mpilocal,jlev,jn,jm
            if(jdim_mpiglobal.gt.cvDim_mpiglobal)   &
              write(*,*) 'ERROR: jdim,cvDim,mpiglobal=',jdim_mpiglobal,cvDim_mpiglobal,jlev,jn,jm

          endif
        enddo
      enddo
    enddo

  END SUBROUTINE BCHM_reduceToMPILocal

  SUBROUTINE BCHM_expandToMPIGlobal(cv_mpilocal,cv_mpiglobal,cvDim_mpiglobal_out)
    implicit none
    real(8) :: cv_mpilocal(cvDim_mpilocal)
    real(8) :: cv_mpiglobal(cvDim_mpiglobal)
    integer :: cvDim_mpiglobal_out

    real(8), allocatable :: cv_maxmpilocal(:)
    real(8), pointer :: cv_allmaxmpilocal(:,:) => null()
    integer, allocatable :: allnBeg(:),allnEnd(:),allnSkip(:)
    integer, allocatable :: allmBeg(:),allmEnd(:),allmSkip(:)
    integer :: jlev, jn, jm, jproc, ila_mpiglobal, jdim_mpilocal, jdim_mpiglobal, ierr, cvDim_maxmpilocal

    cvDim_mpiglobal_out = cvDim_mpiglobal

    ! gather all local control vectors onto mpi task 0
    call rpn_comm_allreduce(cvDim_mpilocal,cvDim_maxmpilocal,1,"mpi_integer","mpi_max","GRID",ierr)

    allocate(cv_maxmpilocal(cvDim_maxmpilocal))
    if(mpi_myid.eq.0) allocate(cv_allmaxmpilocal(cvDim_maxmpilocal,mpi_nprocs))

    cv_maxmpilocal(:) = 0.0d0
    cv_maxmpilocal(1:cvDim_mpilocal) = cv_mpilocal(1:cvDim_mpilocal)

    call tmg_start(59,'BCHM_COMM')
    call rpn_comm_gather(cv_maxmpilocal,    cvDim_maxmpilocal, "mpi_double_precision",  &
                         cv_allmaxmpilocal, cvDim_maxmpilocal, "mpi_double_precision", 0, "GRID", ierr )
    call tmg_stop(59)

    deallocate(cv_maxmpilocal)

    allocate(allnBeg(mpi_nprocs))
    call rpn_comm_allgather(mynBeg,1,"mpi_integer",       &
                            allnBeg,1,"mpi_integer","GRID",ierr)
    allocate(allnEnd(mpi_nprocs))
    call rpn_comm_allgather(mynEnd,1,"mpi_integer",       &
                            allnEnd,1,"mpi_integer","GRID",ierr)
    allocate(allnSkip(mpi_nprocs))
    call rpn_comm_allgather(mynSkip,1,"mpi_integer",       &
                            allnSkip,1,"mpi_integer","GRID",ierr)

    allocate(allmBeg(mpi_nprocs))
    call rpn_comm_allgather(mymBeg,1,"mpi_integer",       &
                            allmBeg,1,"mpi_integer","GRID",ierr)
    allocate(allmEnd(mpi_nprocs))
    call rpn_comm_allgather(mymEnd,1,"mpi_integer",       &
                            allmEnd,1,"mpi_integer","GRID",ierr)
    allocate(allmSkip(mpi_nprocs))
    call rpn_comm_allgather(mymSkip,1,"mpi_integer",       &
                            allmSkip,1,"mpi_integer","GRID",ierr)

    ! reorganize gathered mpilocal control vectors into the mpiglobal control vector
    if(mpi_myid.eq.0) then
      cv_mpiglobal(:) = 0.0d0

!$OMP PARALLEL DO PRIVATE(jproc,jdim_mpilocal,jlev,jm,jn,ila_mpiglobal,jdim_mpiglobal)
      do jproc = 0, (mpi_nprocs-1)
        jdim_mpilocal = 0

        do jlev = 1, nkgdim
          do jm = allmBeg(jproc+1), allmEnd(jproc+1), allmSkip(jproc+1)
            do jn = allnBeg(jproc+1), allnEnd(jproc+1), allnSkip(jproc+1)
              if(jm.le.jn) then

                ila_mpiglobal = gst_getNIND(jm,gstID) + jn - jm

                ! figure out index into global control vector
                if(jm.eq.0) then
                  ! for jm=0 only real part
                  jdim_mpiglobal = ila_mpiglobal
                else
                  ! for jm>0 both real and imaginary part
                  jdim_mpiglobal = 2*ila_mpiglobal-1 - (ntrunc+1)
                endif
                ! add offset for level
                jdim_mpiglobal = jdim_mpiglobal + (jlev-1) * (ntrunc+1)*(ntrunc+1)

                ! index into local control vector
                if(jm.eq.0) then
                  ! only real component for jm=0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                else
                  ! both real and imaginary components for jm>0
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                  jdim_mpilocal = jdim_mpilocal + 1
                  cv_mpiglobal(jdim_mpiglobal+1) = cv_allmaxmpilocal(jdim_mpilocal,jproc+1)
                endif

                if(jdim_mpiglobal.gt.cvDim_mpiglobal)   &
                  write(*,*) 'ERROR: jdim,cvDim,mpiglobal=',jdim_mpiglobal,cvDim_mpiglobal,jlev,jn,jm

              endif
            enddo
          enddo
        enddo
      enddo ! jproc
!$OMP END PARALLEL DO

    endif ! myid .eq. 0

    deallocate(allnBeg)
    deallocate(allnEnd)
    deallocate(allnSkip)
    deallocate(allmBeg)
    deallocate(allmEnd)
    deallocate(allmSkip)
    if(mpi_myid.eq.0) deallocate(cv_allmaxmpilocal)

  end SUBROUTINE BCHM_expandToMPIGlobal

  SUBROUTINE ZLEGINV(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV  - Direct Legendre transform restricted to
!*     .           fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   DDWT(KNJDIM)         : weights of the Gaussian quadrature
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL(8) :: DDWT(KNJDIM)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGINV
  SUBROUTINE ZLEGINV2(PF,PN,PLEG,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV2  - Direct Legendre transform restricted to
!*     .            fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,KLEVDIM), PN(0:KNDIM, KLEVDIM), PLEG(0:KNDIM,KNJDIM)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGINV2

  SUBROUTINE ZLEGDIR(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!**s/r ZLEGDIR  - Direct Legendre transform restricted to
!
!*Arguments
!*     i   PF(KNJDIM,KLEVDIM)   : field in physical space
!*     o   PN(0:KNDIM, KLEVDIM ): spectral coefficients
!*     o   PLEG(0:KNDIM, KNJDIM): Legendre polynomials evaluated at the Gaussian latitudes
!*     i   DDWT(KNJDIM)          : weights of the Gaussian quadrature
!*     i   KNJ                  : number of Gaussian latitudes
!*     i   KTRUNC               : spectral truncation
!*     i   KLEV                 : number of fields to transform
!*     i   KNJDIM               : dimensioning of the field (in latitude)
!*     i   KLEVDIM              : dimensioning of the field (in KLEV)
!*     I   KNDIM                : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER :: KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL(8) :: PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL(8) :: DDWT(KNJ)

      INTEGER :: J, JN
      REAL(8), ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))
      DO J = 1, KNJ
         DO JN = 0, KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)*DDWT(J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'N',PF(1,1),KNJDIM,'N',PN(0,1),KNDIM+1,KNDIM+1,KNJ,KLEV)

      DEALLOCATE(ZWORK)

  END SUBROUTINE ZLEGDIR



END MODULE BmatrixChem
