! Should test OBS_REAL=4, too?
#define OBS_REAL 8

module testObs_mod
   use pFUnit
   use obsSpaceData_mod
   implicit none
   private

   public :: getTestSuite_obs

   character(len=4), parameter, dimension(21) :: columns_int_head &
            = (/ 'RLN','ONM','INS','OTP','ITY','SAT','TEC','DAT','ETM', &
                 'NLV','OFL','PAS','REG','IP', 'AZA','SZA','SUN','CLF', &
                 'ST1','IDO','IDF' /)
   character(len=4), parameter, dimension(9) :: columns_int_body &
            = (/ 'VNM','FLG','KFA','ASS','OBS','VCO','LYR','XTR','IDD' /)
   character(len=4), parameter, dimension(6) :: columns_real_head &
            = (/ 'LAT','LON','ALT','BX','BY','BZ' /)
   character(len=4), parameter, dimension(14) :: columns_real_body &
            = (/ 'PPP ','SEM ','POB ','VAR ','OMP ','OMP6','OMF ','OMA ','OMI ',&
                 'OMN ','OER ','HPHT','PRM ','ZHA ' /)
   character(len=4), parameter, dimension(1) :: columns_char_head &
            = (/ 'STID' /)
                                        ! value of environment variable of the
                                        ! same name
   character(len=200) :: unit_test_obs_data_dir

contains

   subroutine PlaceKeeper()
      call fail('----->>>>> *** TEST HAS BEEN TURNED OFF *** <<<<<-----')
   end subroutine PlaceKeeper

   function getTestSuite_obs() result(suite_obs)
      type (TestSuite_type) :: suite_obs

      call get_environment_variables()

      ! Build suite from test procedures:
      suite_obs = TestSuite('ObsSpaceData tests')
      call add(suite_obs, get_obsBasicTests())
!call add(suite_obs, TestCase('obsBasicTests', PlaceKeeper))
      call add(suite_obs, get_obsObjectManipulationTests())
!call add(suite_obs, TestCase('get_obsObjectManipulationTests', PlaceKeeper))

   end function getTestSuite_obs

   function get_obsBasicTests() result(suite_obs)
      type (TestSuite_type) :: suite_obs
      ! This suite is of fundamental tests of operations on elemental parts
      ! of the ObsSpaceData module.

      ! Build suite from test procedures:
      suite_obs = TestSuite('ObsSpaceData basic tests')

      call add(suite_obs, TestCase('obs_init', test_obs_init))
      call add(suite_obs, TestCase('AddHeaderElement', test_AddHeaderElement))
      call add(suite_obs, TestCase('SetAndRead_IntegerHeaderElement', &
                                   test_headerElement_i))
      call add(suite_obs, TestCase('SetAndRead_IntegerBodyElement', &
                                   test_bodyElement_i))
      call add(suite_obs, TestCase('SetAndRead_RealHeaderElement', &
                                   test_headerElement_r))
      call add(suite_obs, TestCase('SetAndRead_RealBodyElement', &
                                   test_bodyElement_r))
      call add(suite_obs, TestCase('SetAndRead_CharHeaderElement', &
                                   test_headerElement_c))
      call add(suite_obs, TestCase('SetAndRead_DateStamp', test_dateStamp))
      call add(suite_obs, TestCase('obsStatus', test_obsStatus))
   end function get_obsBasicTests

   function get_obsObjectManipulationTests() result(suite_obs)
      type (TestSuite_type) :: suite_obs
      ! This suite is of tests of whole-object operations of the ObsSpaceData
      ! module.

      ! Build suite from test procedures:
      suite_obs = TestSuite('ObsSpaceData whole-object tests')

      call add(suite_obs, TestCase('obs_append', test_obs_append))
      call add(suite_obs, TestCase('obs_copy',   test_obs_copy))
      call add(suite_obs, TestCase('obs_count_headers', test_obs_count_headers))
      call add(suite_obs, TestCase('WriteAndReadBinaryFile', test_binaryFile))
      call add(suite_obs, TestCase('obs_select', test_obs_select))
      call add(suite_obs, TestCase('obs_order', test_obs_order))
      call add(suite_obs, TestCase('ReadBinaryFileOnePass', test_binaryFileOnePass))
      call add(suite_obs, TestCase('obs_clean_g1', test_obs_clean_g1))
      call add(suite_obs, TestCase('obs_clean_g2', test_obs_clean_g2))
      call add(suite_obs, TestCase('obs_clean_g3', test_obs_clean_g3))
   end function get_obsObjectManipulationTests

   subroutine get_environment_variables()
      integer :: length, status
      character(len=300) :: msg
      call get_environment_variable('UNIT_TEST_OBS_DATA_DIR', &
                                    unit_test_obs_data_dir, length, status)
      if(status /= 0) then
         write(msg,*)"ERROR retrieving the environment variable, ", &
                     " UNIT_TEST_OBS_DATA_DIR.  Status = ", status
         call fail(msg)
      end if
   end subroutine get_environment_variables

   subroutine test_obs_init()
      ! Start with the basics:  does the object initializer allocate okay?
      use obsSpaceData_mod
      implicit none

      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=3, BOD_MAX=7
      integer :: num_heads, num_bods

      ! Method under test
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Examine the results & test the inspection methods
      num_heads = obs_numheader_max(myobs)
      call assertEqual(HEAD_MAX, num_heads, 'obs_numheader_max')

      num_bods = obs_numbody_max(myobs)
      call assertEqual(BOD_MAX, num_bods, 'obs_numbody_max')

      num_heads = obs_numheader(myobs)
      call assertEqual(0, num_heads, 'obs_numheader')

      num_bods = obs_numbody(myobs)
      call assertEqual(0, num_bods, 'obs_numbody')

      call obs_finalize(myobs)
   end subroutine test_obs_init

   subroutine test_AddHeaderElement()
      ! A new header element is (currently) added by assigning a value to the
      ! family of the *next* header.  So, assign some families and check to see
      ! that the number of header elements has increased.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: num_heads, headerIndex
      character(len=10) :: Family_in
      character(len=4) :: family

      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Confirm the starting point
      num_heads = obs_numheader(myobs)
      call assertEqual(0, num_heads, 'obs_numheader')

      ! Add a header element
      headerIndex = 1
      Family_in = 'JB'
      call obs_setFamily(myobs, Family_in, headerIndex)

      ! Confirm that the element has been added
      num_heads = obs_numheader(myobs)
      call assertEqual(1, num_heads, 'obs_numheader(2)')

      ! Confirm the value of Family
      family = obs_getFamily(myobs, headerIndex)
      call assertEqual('JB', family, 'family')


      ! Revise the header element
      headerIndex = 1
      Family_in = 'JWB'
      call obs_setFamily(myobs, Family_in, headerIndex)

      ! Confirm that it is not a new element
      num_heads = obs_numheader(myobs)
      call assertEqual(1, num_heads, 'obs_numheader(3)')

      ! Confirm the value of Family
      family = obs_getFamily(myobs, headerIndex)
      call assertEqual('JW', family, 'family(2)')



      ! Add another header element ... incorrectly
      headerIndex = 3
      Family_in = 'OZ'
      call obs_setFamily(myobs, Family_in, headerIndex)

      ! Confirm that the element has not been added:  number
      num_heads = obs_numheader(myobs)
      call assertEqual(1, num_heads, 'obs_numheader(4)')

      ! Some kind of error signal should have been sent,
      ! because headerIndex has too great a value

      call obs_finalize(myobs)
   end subroutine test_AddHeaderElement

   subroutine test_headerElement_i()
      ! Test the setting of all integer header members:  obs_set_i().  One must
      ! use obs_elem_i() in order to verify the result.  Thus, this is a test for
      ! both methods at once.
      !
      ! Note:  writing all of the values before reading any back verifies that no
      !        two column names are assigned to the same column number.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer, dimension(size(columns_int_head)) :: expected
      integer :: found
      integer :: num, ndx, nchar

      num = size(columns_int_head)
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Assign unique integer values to obsSpaceData
      do ndx=1,num
         expected(ndx) = 0
         do nchar=1,4
                                        ! -30 to keep expected <100
            expected(ndx) =   100*expected(ndx) &
                            + iachar(columns_int_head(ndx)(nchar:nchar)) &
                            - 30
         end do

         call obs_set_i (myobs, columns_int_head(ndx), 1, expected(ndx))
      end do

      ! Read the values back from obsSpaceData, and verify them
      do ndx=1,num
        write(6,*)"test:  ", columns_int_head(ndx), &
                        " for test_headerElement_i.  Expected=",expected(ndx)
         found = obs_elem_i(myobs, columns_int_head(ndx), 1)
         call assertEqual(expected(ndx), found, columns_int_head(ndx))
      end do

      call obs_finalize(myobs)
   end subroutine test_headerElement_i

   subroutine test_bodyElement_i()
      ! Test the setting of all integer body members:  obs_set_i().  One must use
      ! obs_elem_i() in order to verify the result.  Thus, this is a test for
      ! both methods at once.
      !
      ! Note:  writing all of the values before reading any back verifies that no
      !        two column names are assigned to the same column number.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer, dimension(size(columns_int_body)) :: expected
      integer :: found
      integer :: num, ndx, nchar

      num = size(columns_int_body)
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Assign unique integer values to obsSpaceData
      do ndx=1,num
         expected(ndx) = 0
         do nchar=1,4
                                        ! -30 to keep expected <100
            expected(ndx) =   100*expected(ndx) &
                            + iachar(columns_int_body(ndx)(nchar:nchar)) &
                            - 30
         end do

         call obs_set_i (myobs, columns_int_body(ndx), 1, expected(ndx))
      end do

      ! Read the values back from obsSpaceData, and verify them
      do ndx=1,num
        write(6,*)"test:  ", columns_int_body(ndx), &
                        " for test_bodyElement_i.  Expected=",expected(ndx)
         found = obs_elem_i(myobs, columns_int_body(ndx), 1)
         call assertEqual(expected(ndx), found, columns_int_body(ndx))
      end do

      call obs_finalize(myobs)
   end subroutine test_bodyElement_i

   subroutine test_headerElement_r()
      ! Test the setting of all real header members:  obs_set_r().  One must use
      ! obs_elem_r() in order to verify the result.  Thus, this is a test for
      ! both methods at once.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      real(kind=OBS_REAL), dimension(size(columns_real_head)) :: expected
      real(kind=OBS_REAL) :: found
      integer :: num, ndx, nchar

      num = size(columns_real_head)
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Assign unique real values to obsSpaceData
      do ndx=1,num
         expected(ndx) = 0.
         do nchar=1,4
                                        ! -30 to keep expected <100
            expected(ndx) =   100.*expected(ndx) &
                            + real(iachar(columns_real_head(ndx)(nchar:nchar))) &
                            - 30.
         end do

         call obs_set_r (myobs, columns_real_head(ndx), 1, expected(ndx))
      end do

      ! Read the values back from obsSpaceData, and verify them
      do ndx=1,num
        write(6,*)"test:  ", columns_real_head(ndx), &
                        " for test_headerElement_r.  Expected=",expected(ndx)
         found = obs_elem_r(myobs, columns_real_head(ndx), 1)
         call assertEqual(expected(ndx), found, columns_real_head(ndx))
      end do

      call obs_finalize(myobs)
   end subroutine test_headerElement_r

   subroutine test_bodyElement_r()
      ! Test the setting of all real body members:  obs_set_r().  One must use
      ! obs_elem_r() in order to verify the result.  Thus, this is a test for
      ! both methods at once.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      real(kind=OBS_REAL), dimension(size(columns_real_body)) :: expected
      real(kind=OBS_REAL) :: found
      integer :: num, ndx, nchar

      num = size(columns_real_body)
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Assign unique real values to obsSpaceData
      do ndx=1,num
         expected(ndx) = 0.
         do nchar=1,4
                                        ! -30 to keep expected <100
            expected(ndx) =   100.*expected(ndx) &
                            + real(iachar(columns_real_body(ndx)(nchar:nchar))) &
                            - 30.
         end do

         call obs_set_r (myobs, columns_real_body(ndx), 1, expected(ndx))
      end do

      ! Read the values back from obsSpaceData, and verify them
      do ndx=1,num
        write(6,*)"test:  ", columns_real_body(ndx), &
                        " for test_bodyElement_r.  Expected=",expected(ndx)
         found = obs_elem_r(myobs, columns_real_body(ndx), 1)
         call assertEqual(expected(ndx), found, columns_real_body(ndx))
      end do

      call obs_finalize(myobs)
   end subroutine test_bodyElement_r

   subroutine test_headerElement_c()
      ! Test the setting of all character header members:  obs_set_r().  One must
      ! use obs_elem_r() in order to verify the result.  Thus, this is a test for
      ! both methods at once.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      character(len=12), dimension(size(columns_char_head)) :: expected
      character(len=12) :: found
      integer :: num, ndx, nchar

      num = size(columns_char_head)
      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Assign unique character values to obsSpaceData
      expected(1) = 'sTiD56789012'
      call obs_set_c(myobs, columns_char_head(1), 1, expected(1))

      ! Read the values back from obsSpaceData, and verify them
      do ndx=1,num
        write(6,*)"test:  ", columns_char_head(ndx), &
                        " for test_headerElement_c.  Expected=",expected(ndx)
         found = obs_elem_c(myobs, columns_char_head(ndx), 1)
         call assertEqual(expected(ndx), found, columns_char_head(ndx))
      end do

      call obs_finalize(myobs)
   end subroutine test_headerElement_c

   subroutine test_dateStamp()
      ! Test obs_set_datestamp() and obs_get_datestamp().
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: expectedDate, observedDate

      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      expectedDate = 380122984
      call obs_set_datestamp(myobs, expectedDate)
      observedDate = obs_get_datestamp(myobs)

      call assertEqual(expectedDate, observedDate)
      call obs_finalize(myobs)
   end subroutine test_dateStamp



   subroutine setUp_OneHeaderAndBodies(myobs, hdx, bod_offset, nbdy, fp)
      ! This is a utility for use by the test routines.  Given:
      !    - myobs:      the ObsSpaceData_mod object
      !    - hdx:        a header index number
      !    - bod_offset: the number of bodies already in the table
      !    - nbdy:       the number of bodies to create
      !    - fp:         a fingerprint (unique integer) to apply to each datum
      ! this routine will:
      !    - create one header at the indicated index, hdx
      !    - completely fill the header with values known to verify_obs()
      !    - create nbdy bodies, beginning at bod_offset
      !    - completely fill the body with values known to verify_obs()
      implicit none
      type(struct_obs), intent(inout) :: myobs
      integer, intent(in) :: hdx        ! header index to populate
      integer, intent(in) :: bod_offset ! number of bodies already in the table
      integer, intent(in) :: nbdy       ! number of body elements to create
      integer, intent(in) :: fp         ! fingerprint applied to each datum

      integer :: num, ndx, bdx

      ! POPULATE THE HEADER
      call obs_setFamily(myobs, 'FA',   hdx)
      call obs_set_c    (myobs, 'STID', hdx, 'MyStation' // achar(fp+30))
      call obs_set_datestamp(myobs, 43219876)

      num = size(columns_real_head)
      do ndx=1,num
         call obs_set_r (myobs, columns_real_head(ndx), hdx, &
                         real(ndx, OBS_REAL)*100. + fp + .003)
      end do

      num = size(columns_int_head)
      do ndx=1,num
         call obs_set_i (myobs, columns_int_head(ndx), hdx, ndx*1000 + fp)
      end do

      ! POPULATE THE BODIES
      do bdx = 1,nbdy
         num = size(columns_real_body)
         do ndx=1,num
            call obs_set_r (myobs, columns_real_body(ndx), bdx+bod_offset, &
                            real(ndx, OBS_REAL)*10000. + fp + .003 &
                                                      + 100.*real(bdx, OBS_REAL))
         end do

         num = size(columns_int_body)
         do ndx=1,num
            call obs_set_i (myobs, columns_int_body(ndx), bdx+bod_offset, &
                            ndx*100000 + fp + 100*bdx)
         end do
      end do ! bdx

      ! SET VALUES THAT ARE MEANINGFUL TO THE MANIPULATION OF OBSDAT ITSELF.
      call obs_set_i    (myobs, 'RLN',  hdx, bod_offset+1)
      call obs_set_i    (myobs, 'NLV',  hdx, nbdy)
      call obs_set_i    (myobs, 'ONM',  hdx, hdx)
      call obs_set_i    (myobs, 'PAS',  hdx, hdx)
   end subroutine setUp_OneHeaderAndBodies

   subroutine verify_obs(obs_found, hdx, bod_offset, nbdy, fp, msg, omit_zha, &
                         omit_ip, omit_pas, omit_onm)
      ! This is a utility for use by the test routines.  Given:
      !    - obs_found:  the obs object that resulted from an obs method
      !    - hdx:        a header index number
      !    - bod_offset: number of bodies, previous to the ones being examined
      !    - nbdy:       the number of bodies being examined
      !    - fp:         a fingerprint (unique integer) expected in each datum
      !    - msg:        incorporated into any error message
      !    - omit_*:     optional flags to omit the verification of some members.
      !                  This is useful when these values are altered by the
      !                  obs method being tested.
      ! this routine will:
      !    - completely verify the content of the indicated header, hdx
      !    - completely verify the content of the indicated bodies:
      !          (bod_offset + 1) to (bod_offset + nbdy)
      implicit none
      type(struct_obs), intent(in) :: obs_found
      integer, intent(in) :: hdx        ! header index to verify
      integer, intent(in) :: bod_offset ! number of bodies already in the table
      integer, intent(in) :: nbdy       ! number of body elements expected
      integer, intent(in) :: fp         ! expected fingerprint for each datum
      character(len=*), intent(in) ::msg! incorporated into any error message

      logical, optional :: omit_zha,  omit_ip,  omit_pas,  omit_onm
      logical ::           omit_zha_, omit_ip_, omit_pas_, omit_onm_
      integer :: num, ndx, bdx
      character(len=12) :: found_c
      real(kind=OBS_REAL) :: found_r, expected_r
      integer :: found_i, expected_i, expected_rln, expected_nlv

      if(present(omit_zha))then
         omit_zha_ = omit_zha
      else
         omit_zha_ = .false.
      end if

      if(present(omit_ip))then
         omit_ip_ = omit_ip
      else
         omit_ip_ = .false.
      end if

      if(present(omit_pas))then
         omit_pas_ = omit_pas
      else
         omit_pas_ = .false.
      end if

      if(present(omit_onm))then
         omit_onm_ = omit_onm
      else
         omit_onm_ = .false.
      end if

      ! VERIFY THE HEADER MEMBERS
      found_c = obs_getFamily(obs_found, hdx)
      call assertEqual('FA', found_c, msg//' FA')

      found_c = obs_elem_c(obs_found, 'STID', hdx)
      call assertEqual('MyStation' // achar(fp+30), found_c, msg//' STID')

      call assertEqual(43219876, obs_get_datestamp(obs_found), msg//' datestamp')

      num = size(columns_real_head)
      do ndx=1,num
         expected_r = real(ndx, OBS_REAL)*100. + fp + .003
         found_r = obs_elem_r (obs_found, columns_real_head(ndx), hdx)
         call assertEqual(expected_r, found_r, msg//' '//columns_real_head(ndx))
      end do

      num = size(columns_int_head)
      do ndx=1,num
         ! Skip tests as directed
         if(omit_ip_  .and. columns_int_head(ndx) == 'IP' ) cycle
         if(omit_pas_ .and. columns_int_head(ndx) == 'PAS') cycle
         if(omit_onm_ .and. columns_int_head(ndx) == 'ONM') cycle

         ! Calculate expected values for special members
         select case(columns_int_head(ndx))
         case('RLN')
                                     ! Because each sample header has nbdy bodies
            expected_rln = bod_offset
            expected_i = expected_rln + 1

         case('NLV')
            expected_nlv = nbdy
            expected_i = expected_nlv

         case('ONM')
            expected_i = hdx

         case('PAS')
            expected_i = hdx

         case default
            expected_i = ndx*1000 + fp
         end select

         found_i = obs_elem_i (obs_found, columns_int_head(ndx), hdx)
         call assertEqual(expected_i, found_i, msg//' '//columns_int_head(ndx))
      end do

      ! VERIFY THE BODY MEMBERS
      do bdx = 1, nbdy
         num = size(columns_real_body)
         do ndx=1,num
                                        ! Skip tests as directed
            if(omit_zha_ .and. columns_real_body(ndx) == 'ZHA') cycle

            expected_r = real(ndx, OBS_REAL)*10000. + fp + .003 &
                                                       + 100.*real(bdx, OBS_REAL)
            found_r = obs_elem_r (obs_found, columns_real_body(ndx), &
                                  expected_rln + bdx)
            call assertEqual(expected_r, found_r, &
                             msg//' '//columns_real_body(ndx))
         end do

         num = size(columns_int_body)
         do ndx=1,num
            expected_i = ndx*100000 + fp + 100*bdx
            found_i = obs_elem_i (obs_found, columns_int_body(ndx), &
                                  expected_rln + bdx)
            call assertEqual(expected_i, found_i, &
                             msg//' '//columns_int_body(ndx))
         end do
      end do
   end subroutine verify_obs

   subroutine test_ascii_output(testout_unit, fileNamePath)
      ! Compares two files, one already opened and positioned on unit, &
      ! testout_unit, the other residing at fileNamePath.

      character(len=*), intent(in) :: fileNamePath
      integer, intent(in) :: testout_unit

      integer, parameter :: TESTREF_UNIT = 9
      integer :: status, statusMethod
      character(len=1000) :: fromMethod, fromRef
      character(len=100) :: msg

      open(unit=TESTREF_UNIT, file=fileNamePath, &
                              status='OLD', &
                              action='READ', &
                              iostat=status)
      if(status /= 0) write(*,*)"ERROR opening reference file, ", fileNamePath, &
                                ": ", status

      read(TESTREF_UNIT,'(a)', iostat=status, end=100)fromRef
      do while(status == 0)
         read(testout_unit,'(a)', end=101)fromMethod
         call assertEqual(fromRef, fromMethod, 'bad output to listing')
         read(TESTREF_UNIT,'(a)', iostat=status)fromRef
         cycle
  100    write(*,*)"ERROR:  End of file while reading the reference"
         exit
  101    write(*,*)"ERROR:  End of file while reading nobsout from obs_select"
         exit
      end do

      ! Test for excess output
      read(testout_unit,'(a)', iostat=statusMethod)fromMethod
      msg = 'method produced excess output: ' // fromMethod
      call assertTrue(statusMethod /= 0, msg)
   end subroutine test_ascii_output

   subroutine test_obsStatus()
      ! Verify that obs_status() returns correct values, and verify its
      ! contribution to the listing.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs
      integer, parameter :: HEAD_MAX=3, BOD_MAX=100
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      logical :: obs_full
      integer :: numstns_out, numobs_out
      integer :: TESTOUT_UNIT = 8
      integer :: status, statusMethod
      character(len=100) :: fromMethod, msg

      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Direct the output to a file so that it can be verified
      open(unit=TESTOUT_UNIT, status='SCRATCH', &
                              action='READWRITE', &
                              iostat=status)
      if(status /= 0) write(*,*)"ERROR opening a scratch file in ", &
                                "test_obs_status: ", status

      ! TEST 1:  Set up obs table, but don't make it full
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 2
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! THE METHOD BEING TESTED
      obs_full = .true.
      numstns_out = 100
      numobs_out  = 100
      call obs_status(myobs, obs_full, numstns_out, numobs_out, TESTOUT_UNIT)

      call assertFalse(obs_full, 'obs_full')
      call assertEqual(2, numstns_out, 'numstns_out')
      call assertEqual(4, numobs_out, 'numobs_out')

      ! Test for excess output (any output at all is excess)
      endfile(unit=TESTOUT_UNIT)
      rewind(unit=TESTOUT_UNIT)

      read(TESTOUT_UNIT,'(a)', iostat=statusMethod)fromMethod
      msg = 'method produced excess output: ' // fromMethod
      call assertTrue(statusMethod /= 0, msg)

      ! TEST 2:  Now, fill up obs table
      header_position = 3
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      rewind(unit=TESTOUT_UNIT)

      ! THE METHOD BEING TESTED (call it again)
      obs_full = .true.
      numstns_out = 100
      numobs_out  = 100
      call obs_status(myobs, obs_full, numstns_out, numobs_out, TESTOUT_UNIT)

      call assertTrue(obs_full, 'obs_full')
      call assertEqual(3, numstns_out, 'numstns_out')
      call assertEqual(6, numobs_out, 'numobs_out')

      ! Verify the output
      endfile(unit=TESTOUT_UNIT)
      rewind (unit=TESTOUT_UNIT)

      read(TESTOUT_UNIT,'(a)', iostat=statusMethod)fromMethod
      call assertEqual('  OBSDAT FILE FULL', fromMethod, 'bad output to listing')

      ! Test for excess output
      read(TESTOUT_UNIT,'(a)', iostat=statusMethod)fromMethod
      msg = 'method produced excess output: ' // fromMethod
      call assertTrue(statusMethod /= 0, msg)

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs)
   end subroutine test_obsStatus

   subroutine test_obs_append()
      ! Verify that one obs object is correctly and completely appended to
      ! another.  Verify also that the original object is unchanged.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1, myobs2
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: idx_i, idx_j
      real(8) :: hx_in         (2,5), hx_out         (2,5), &
                 hx_in_original(2,5), hx_out_original(2,5)

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)

      ! Set up two obs tables
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs2, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Verify the starting point
      call assertEqual(1, obs_numheader(myobs1), 'initial no. headers in myobs1')
      call assertEqual(1, obs_numheader(myobs2), 'initial no. headers in myobs2')
      call assertEqual(num_bodies, obs_numbody(myobs1), &
                       'initial no. bodies in myobs1')
      call assertEqual(num_bodies, obs_numbody(myobs2), &
                       'initial no. bodies in myobs2')

      ! Set up two hx tables
      do idx_j = 1,2
         do idx_i = 1,2
            hx_in (idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 8
            hx_out(idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 9
         end do
      end do
      hx_in_original (:,:) = hx_in (:,:)
      hx_out_original(:,:) = hx_out(:,:)

      ! THE METHOD BEING TESTED:  Append myobs1 to myobs2
      call obs_append(myobs1, hx_in, myobs2, hx_out)

      ! Confirm the original data
      fingerprint     = 1
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, 'i1:')
      fingerprint     = 2
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'i2:')
      call assertEqual(1, obs_numheader(myobs1), 'final no. headers in myobs1')
      call assertEqual(num_bodies, obs_numbody(myobs1), &
                       'final no. bodies in myobs1')
      call assertEqual( hx_in_original(1:2,1:2), hx_in (1:2,1:2), 'hx_in')
      call assertEqual(hx_out_original(1:2,1:2), hx_out(1:2,1:2), &
                       'original portion of hx_out')

      ! Confirm the addition of data
      header_position = 2
      bod_offset      = 2
      fingerprint     = 1
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, '1 at end of 2:')
      call assertEqual(2, obs_numheader(myobs2), 'final no. headers in myobs2')
      call assertEqual(num_bodies, obs_numbody(myobs2), &
                       'final no. bodies in myobs2')
      call assertEqual( hx_in_original(1:2,1:2), hx_out (1:2,3:4), &
                        'data of hx_in inside hx_out')

      call obs_finalize(myobs1)
      call obs_finalize(myobs2)
   end subroutine test_obs_append

   subroutine test_obs_copy()
      ! Verify that one obs object is correctly and completely copied to another.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1, myobs2
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)

      ! Set up the first table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! THE METHOD BEING TESTED:  Copy myobs1 to myobs2
      call obs_copy(myobs1, myobs2)

      ! Verify the result
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, 'obs1:')
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'obs2:')
      call assertEqual(1, obs_numheader(myobs1), 'no. headers in myobs1')
      call assertEqual(1, obs_numheader(myobs2), 'no. headers in myobs2')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs1), &
                       'max. no. headers in myobs1')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs2), &
                       'max. no. headers in myobs2')

      call assertEqual(2, obs_numbody(myobs1), 'no. bodies in myobs1')
      call assertEqual(2, obs_numbody(myobs2), 'no. bodies in myobs2')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs1), &
                       'max. no. bodies in myobs1')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs2), &
                       'max. no. bodies in myobs2')

      call obs_finalize(myobs1)
      call obs_finalize(myobs2)
   end subroutine test_obs_copy

   subroutine test_obs_count_headers()
      ! Verify that the numbers of headers and bodies are reported correctly in
      ! the listing.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: TESTOUT_UNIT = 8
      integer :: status

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)

      ! Set up the table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Direct the output to a file so that it can be verified
      open(unit=TESTOUT_UNIT, status='SCRATCH', &
                              action='READWRITE', &
                              iostat=status)
      if(status /= 0) write(*,*)"ERROR opening a scratch file in ", &
                                "test_obs_count_headers: ", status

      ! THE METHOD BEING TESTED
      call obs_count_headers(myobs1, TESTOUT_UNIT)

      ! Verify the output
      endfile(unit=TESTOUT_UNIT)
      rewind(unit=TESTOUT_UNIT)
      call test_ascii_output(TESTOUT_UNIT, &
                   trim(unit_test_obs_data_dir) // '/test_obs_count_headers.dat')

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs1)
   end subroutine test_obs_count_headers

   subroutine test_binaryFile()
      ! It can be noted that writing an obs object to a binary file, and then
      ! reading it back is simply one way to make a copy.  This test verifies
      ! that the copy is correct and complete.  This test differs, however, from
      ! test_obs_copy(), because the binary 'copy' simultaneously makes a copy of
      ! the hx array, and that is also verified.

      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1, myobs2
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      real(8) :: hx_in(2,5), hx_out(2,5), hx_in_original(2,5)
      integer :: idx_i, idx_j
      integer :: nens, nens_out, headers_written, bodies_written
      integer :: unitnum, status

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)

      ! Set up the table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Set up the hx table
      do idx_j = 1,2
         do idx_i = 1,2
            hx_in (idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 8
            hx_out(idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 9
         end do
      end do
      hx_in_original (:,:) = hx_in (:,:)

      ! Open the binary files
      do unitnum=11,13
         open(unit=unitnum, status='SCRATCH', &
                            action='READWRITE', &
                            form  ='UNFORMATTED', &
                            iostat=status)
         if(status /= 0) write(*,*)"ERROR opening the scratch file, ", unitnum,&
                                   ", in test_binaryFile: ", status
      end do

      unitnum = 14
      open(unit=unitnum, status='SCRATCH', &
                         action='READWRITE', &
                         form  ='FORMATTED', &
                         iostat=status)
      if(status /= 0) write(*,*)"ERROR opening the scratch file, ", unitnum,&
                                ", in test_binaryFile: ", status

      ! THE METHODS BEING TESTED:  Copy myobs1 to myobs2, via a binary file
      nens = size(hx_in, 1)
      !                           Unit no.
      !                   hdr       11
      !                   bdy       12
      !                   hx        13
      !                   dim       14
      call obs_write(myobs1,hx_in, nens,11,12,13,14)
      do unitnum=11,14
         rewind(unit=unitnum)
      end do
      call obs_initialize(myobs2, 1, num_bodies)
      call obs_read (myobs2,hx_out,     11,12,13)

      ! Verify the result: myobs
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, 'obs1:')
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'obs2:')
      call assertEqual(1, obs_numheader(myobs1), 'no. headers in myobs1')
      call assertEqual(1, obs_numheader(myobs2), 'no. headers in myobs2')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs1), &
                       'max. no. headers in myobs1')
      call assertEqual(1, obs_numheader_max(myobs2), &
                       'max. no. headers in myobs2')

      call assertEqual(2, obs_numbody(myobs1), 'no. bodies in myobs1')
      call assertEqual(2, obs_numbody(myobs2), 'no. bodies in myobs2')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs1), &
                       'max. no. bodies in myobs1')
      call assertEqual(num_bodies, obs_numbody_max(myobs2), &
                       'max. no. bodies in myobs2')

      ! Verify the result:  hx
      call assertEqual( hx_in_original(1:2,1:2), hx_in (1:2,1:2), &
                        'data of hx in the original')
      call assertEqual( hx_in_original(1:2,1:2), hx_out (1:2,1:2), &
                        'data of hx in the copy')

      ! Verify the result:  dims
      read(14,*)headers_written
      read(14,*)bodies_written
      read(14,*)nens_out

      call assertEqual(1, headers_written, 'number of headers written')
      call assertEqual(2, bodies_written, 'number of bodies written')
      call assertEqual(nens, nens_out, 'number of ensembles')

!     obs_read has already closed the files 11, 12, 13
      close(unit=14)

      call obs_finalize(myobs1)
      call obs_finalize(myobs2)
   end subroutine test_binaryFile

   subroutine test_obs_select()
      ! Verify that bodies (and their headers) are selected (i.e. not deleted)
      ! correctly, according to their values of ZHA.  Verify also, that the
      ! original obs object and hx array are unaltered.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1, myobs2
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: idx_i, idx_j
      real(8) :: hx_in         (2,10), hx_out         (2,10), &
                 hx_in_original(2,10)
      integer, parameter :: NENS = 2
      real(8) :: zhamin, zhamax
      integer :: body_ndx
      real(OBS_REAL) :: value
      integer :: TESTOUT_UNIT = 8, TESTREF_UNIT = 9
      integer :: status, statusMethod
      character(len=1000) :: fromMethod, fromRef
      character(len=100) :: msg

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)

      ! Direct the output to a file so that it can be verified
      open(unit=TESTOUT_UNIT, status='SCRATCH', &
                              action='READWRITE', &
                              iostat=status)
      if(status /= 0) write(*,*)"ERROR opening a scratch file in ", &
                                "test_obs_select: ", status

      ! Set up one obs table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2  ! sets body indices 1, 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 2
      bod_offset      = 2
      num_bodies      = 3  ! sets body indices 3, 4, 5
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 3
      bod_offset      = 5
      num_bodies      = 4  ! sets body indices 6,7,8,9
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Set the values that will be selected
      body_ndx=1;value=2.5d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!select
      body_ndx=2;value=2.2d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!no

      body_ndx=3;value=2.8d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!no
      body_ndx=4;value=2.4d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!no
      body_ndx=5;value=2.0d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!no

      body_ndx=6;value=2.45d0;call obs_set_r(myobs1, 'ZHA',body_ndx,value)!select
      body_ndx=7;value=2.7d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!select
      body_ndx=8;value=2.65d0;call obs_set_r(myobs1, 'ZHA',body_ndx,value)!select
      body_ndx=9;value=2.8d0; call obs_set_r(myobs1, 'ZHA',body_ndx,value)!no

      ! Prepare the array, hx, to match
      do idx_j = 1,9
         do idx_i = 1,NENS
            hx_in (idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 8
            hx_out(idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 9
         end do
      end do
      hx_in_original (:,:) = hx_in (:,:)

      !
      ! METHOD UNDER TEST:  Select the values, zha, such that 2.4 < zha <= 2.7
      !
      zhamin = 2.4d0
      zhamax = 2.7d0
      call obs_select(myobs1, hx_in, myobs2, hx_out, zhamin, zhamax, NENS, &
                      TESTOUT_UNIT)

      !
      ! CONFIRM THE ORIGINAL DATA
      !
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, &
                      'input header 1:', omit_zha=.true.)
      call assertEqual(2.5d0, obs_elem_r(myobs1, 'ZHA', 1))
      call assertEqual(2.2d0, obs_elem_r(myobs1, 'ZHA', 2))

      header_position = 2
      bod_offset      = 2
      num_bodies      = 3  ! sets body indices 3, 4, 5
      fingerprint     = 2
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, &
                      'input header 2:', omit_zha=.true.)
      call assertEqual(2.8d0, obs_elem_r(myobs1, 'ZHA', 3))
      call assertEqual(2.4d0, obs_elem_r(myobs1, 'ZHA', 4))
      call assertEqual(2.0d0, obs_elem_r(myobs1, 'ZHA', 5))

      header_position = 3
      bod_offset      = 5
      num_bodies      = 4  ! sets body indices 6,7,8,9
      fingerprint     = 3
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, &
                      'input header 3:', omit_zha=.true.)
      call assertEqual(2.45d0,obs_elem_r(myobs1, 'ZHA', 6))
      call assertEqual(2.7d0, obs_elem_r(myobs1, 'ZHA', 7))
      call assertEqual(2.65d0,obs_elem_r(myobs1, 'ZHA', 8))
      call assertEqual(2.8d0, obs_elem_r(myobs1, 'ZHA', 9))


      call assertEqual(3, obs_numheader(myobs1), 'final no. headers in myobs1')
      call assertEqual(9, obs_numbody(myobs1), &
                       'final no. bodies in myobs1')
      call assertEqual( hx_in_original(1:2,1:2), hx_in (1:2,1:2), 'hx_in')

      !
      ! CONFIRM THE SELECTED DATA
      !
           ! This first case verifies that all of the obs structure has been
           ! correctly copied
      header_position = 1
      bod_offset      = 0
      num_bodies      = 1  ! The second one should have been rejected
      fingerprint     = 1
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, &
                      'output header 1:', omit_zha=.true.)
      call assertEqual(2.5d0, obs_elem_r(myobs2, 'ZHA',1),'selected zha, body 1')

           ! For the remaining cases, test only that the correct bodies and
           ! headers have been selected
      call assertEqual(2.45d0,obs_elem_r(myobs2, 'ZHA',2),'selected zha, body 3')
      call assertEqual(2.7d0, obs_elem_r(myobs2, 'ZHA',3),'selected zha, body 4')
      call assertEqual(2.65d0,obs_elem_r(myobs2, 'ZHA',4),'selected zha, body 5')
      call assertEqual(4, obs_numbody  (myobs2), 'number of selected bodies')
      call assertEqual(2, obs_numheader(myobs2), 'number of selected headers')

      !
      ! TEST THE ASCII OUTPUT
      !
      endfile(unit=TESTOUT_UNIT)
      rewind (unit=TESTOUT_UNIT)
      call test_ascii_output(TESTOUT_UNIT, &
                          trim(unit_test_obs_data_dir) // '/test_obs_select.dat')

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs1)
      call obs_finalize(myobs2)
   end subroutine test_obs_select

   subroutine test_obs_order()
      ! Verify that the obs headers have been correctly placed in the order that
      ! is determined by their ONM values.
      ! It can be noted that the obs bodies are unchanged by obs_order().
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: head_ndx, value

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)

      ! Set up one obs table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2  ! sets body indices 1, 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 2
      bod_offset      = 2
      num_bodies      = 3  ! sets body indices 3, 4, 5
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 3
      bod_offset      = 5
      num_bodies      = 2  ! sets body indices 6,7
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 4
      bod_offset      = 7
      num_bodies      = 2  ! sets body indices 8,9
      fingerprint     = 4
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 5
      bod_offset      = 9
      num_bodies      = 1  ! sets body indices 10
      fingerprint     = 5
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Set the values that will be ordered
      head_ndx=1;value=5; call obs_set_i(myobs1, 'ONM',head_ndx,value)
      head_ndx=2;value=2; call obs_set_i(myobs1, 'ONM',head_ndx,value)
      head_ndx=3;value=1; call obs_set_i(myobs1, 'ONM',head_ndx,value)
      head_ndx=4;value=3; call obs_set_i(myobs1, 'ONM',head_ndx,value)
      head_ndx=5;value=4; call obs_set_i(myobs1, 'ONM',head_ndx,value)

      ! METHOD UNDER TEST :  order the headers in the table
      call obs_order(myobs1)

      ! Verify the order of the headers
      call assertEqual(1 , obs_elem_i(myobs1, 'ONM', 1), 'ONM of header 1')
      call assertEqual(2 , obs_elem_i(myobs1, 'ONM', 2), 'ONM of header 2')
      call assertEqual(3 , obs_elem_i(myobs1, 'ONM', 3), 'ONM of header 3')
      call assertEqual(4 , obs_elem_i(myobs1, 'ONM', 4), 'ONM of header 4')
      call assertEqual(5 , obs_elem_i(myobs1, 'ONM', 5), 'ONM of header 5')

      ! Verify the sources of the headers
      call assertEqual(3 , obs_elem_i(myobs1, 'PAS', 1), 'PAS of header 1')
      call assertEqual(2 , obs_elem_i(myobs1, 'PAS', 2), 'PAS of header 2')
      call assertEqual(4 , obs_elem_i(myobs1, 'PAS', 3), 'PAS of header 3')
      call assertEqual(5 , obs_elem_i(myobs1, 'PAS', 4), 'PAS of header 4')
      call assertEqual(1 , obs_elem_i(myobs1, 'PAS', 5), 'PAS of header 5')

      ! Verify the content of the obs
      ! REMEMBER:  only the headers have been moved.  The bodies are still in
      !            their original positions.
      header_position = 1
      bod_offset      = 5
      num_bodies      = 2
      fingerprint     = 3
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, '1st header:', omit_pas=.true.)

      header_position = 2
      bod_offset      = 2
      num_bodies      = 3
      fingerprint     = 2
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, '1st header:', omit_pas=.true.)

      header_position = 3
      bod_offset      = 7
      num_bodies      = 2
      fingerprint     = 4
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, '1st header:', omit_pas=.true.)

      header_position = 4
      bod_offset      = 9
      num_bodies      = 1
      fingerprint     = 5
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, '4th header:', omit_pas=.true.)

      header_position = 5
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
      call verify_obs(myobs1, header_position, bod_offset, num_bodies, &
                      fingerprint, '4th header:', omit_pas=.true.)


      call obs_finalize(myobs1)
   end subroutine test_obs_order

   subroutine test_binaryFileOnePass()
      ! It can be noted that writing an obs object to a binary file and then
      ! reading it back is simply one way to make a copy.  The method under test
      ! makes such a copy, but it does so only one group of headers (with its
      ! bodies and hx array) at a time.  This test verifies that the (partial)
      ! copy is correct and complete.
      !
      ! A group of headers is identified by their common value in their PAS
      ! members.  The PAS values count upward from 1.
      !
      ! NOTE:  the expected results cannot all be tested by the routine,
      !        verify_obs():
      !           - IP  - manipulated by obs_readstns() so as to contain
      !                   mod(2000+fingerprint, 2)
      !           - PAS - was manipulated by this test, after being set up by
      !                   setUp_OneHeaderAndBodies().  Obs_readstns() acts on 
      !                   these values so as to return in myobs2 the entries that
      !                    have PAS == passNum
      !           - ONM - verify_obs assumes that the value of ONM is the same
      !                   as the header index.  However, because obs_readstns()
      !                   has taken only a selection of the headers, the value of
      !                   ONM reflects instead the index of its original position

      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1, myobs2
      integer :: header_position, bod_offset, num_bodies
      integer :: fingerprint            ! a finger print for a data set
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      real(8) :: hx_in(2,5)
      integer :: idx_i, idx_j
      integer :: nens
      integer :: unitnum, status
      integer :: passNum, regionNum, head_ndx, value
      integer, parameter :: NUMPE = 2

      call obs_initialize(myobs1, HEAD_MAX, BOD_MAX)

      !
      ! SET UP THE TABLE
      !
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 2
      bod_offset      = 2
      num_bodies      = 2
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 3
      bod_offset      = 4
      num_bodies      = 2
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 4
      bod_offset      = 6
      num_bodies      = 2
      fingerprint     = 4
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)
      header_position = 5
      bod_offset      = 8
      num_bodies      = 2
      fingerprint     = 5
      call setUp_OneHeaderAndBodies(myobs1, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Set the values that divide the data into passes
      head_ndx=1;value=1; call obs_set_i(myobs1, 'PAS',head_ndx,value)
      head_ndx=2;value=1; call obs_set_i(myobs1, 'PAS',head_ndx,value)
      head_ndx=3;value=2; call obs_set_i(myobs1, 'PAS',head_ndx,value)
      head_ndx=4;value=3; call obs_set_i(myobs1, 'PAS',head_ndx,value)
      head_ndx=5;value=3; call obs_set_i(myobs1, 'PAS',head_ndx,value)

      ! Set up the hx table
      do idx_j = 1,2
         do idx_i = 1,2
            hx_in (idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 8
         end do
      end do

      ! OPEN THE BINARY FILES
      do unitnum=11,13
         open(unit=unitnum, status='SCRATCH', &
                            action='READWRITE', &
                            form  ='UNFORMATTED', &
                            iostat=status)
         if(status /= 0) write(*,*)"ERROR opening the scratch file, ", unitnum, &
                                   ", in test_binaryFileOnePass: ", status
      end do

      unitnum=14
      open(unit=unitnum, status='SCRATCH', &
                         action='WRITE', &
                         form  ='FORMATTED', &
                         iostat=status)
      if(status /= 0) write(*,*)"ERROR opening the scratch file, ", unitnum,&
                                ", in test_binaryFileOnePass: ", status

      ! WRITE THE BINARY FILES
      nens = size(hx_in, 1)
      !                           Unit no.
      !                   hdr       11
      !                   bdy       12
      !                   hx        13
      !                   dim       14
      call obs_write(myobs1,hx_in, nens,11,12,13,14)
      call obs_finalize(myobs1)

      ! Close files 13, 14 - obs_readstns will close units 11, 12
      do unitnum=13,14
         close(unit=unitnum)
      end do

      ! Rewind files 11, 12
      do unitnum=11,12
         rewind(unit=unitnum)
      end do

      !
      ! THE METHOD BEING TESTED:  it is the selective reading back that is being
      !                           tested
      ! READ BACK AND VERIFY THE DATA FOR PASS 1
      !
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)
      passNum = 1
      call obs_readstns(myobs2, 0, passNum, regionNum, 11, 12, NUMPE, &
                        HEAD_MAX, BOD_MAX)

                                        ! 13002 since the last REG value takes
                                        ! precedence (with real data, the REG
                                        ! values should all be the same for a
                                        ! single pass
      call assertEqual(13002, regionNum, 'regionNum for pass 1')

      call assertEqual(2, obs_numheader(myobs2), 'no. headers in pass 1')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs2), &
                       'max. no. headers in pass 1')
      call assertEqual(4, obs_numbody(myobs2), 'no. bodies in pass 1')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs2), &
                       'max. no. bodies in pass 1')

      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 1
                                        ! ONM will test okay for the first pass
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'pass 1 header 1:', &
                      omit_ip=.true., omit_pas=.true.)
      call assertEqual(1, obs_elem_i(myobs2, 'IP',  1), 'pass1 h1 IP')
      call assertEqual(1, obs_elem_i(myobs2, 'PAS', 1), 'pass1 h1 PAS')

      header_position = 2
      bod_offset      = 2
      num_bodies      = 2
      fingerprint     = 2
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'pass 1 header 2', &
                      omit_ip=.true., omit_pas=.true.)
      call assertEqual(0, obs_elem_i(myobs2, 'IP',  2), 'pass1 h2 IP')
      call assertEqual(1, obs_elem_i(myobs2, 'PAS', 2), 'pass1 h2 PAS')

      call obs_finalize(myobs2)


      !
      ! READ BACK AND VERIFY THE DATA FOR PASS 2
      !
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)
      passNum = 2
      call obs_readstns(myobs2, 0, passNum, regionNum, 11, 12, NUMPE, &
                        HEAD_MAX, BOD_MAX)

      call assertEqual(13003, regionNum, 'regionNum for pass 2')

      call assertEqual(1, obs_numheader(myobs2), 'no. headers in pass 2')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs2), &
                       'max. no. headers in pass 2')
      call assertEqual(2, obs_numbody(myobs2), 'no. bodies in pass 2')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs2), &
                       'max. no. bodies in pass 2')

      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 3
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'pass 2 header 1:', &
                      omit_ip=.true., omit_pas=.true., omit_onm=.true.)
      call assertEqual(1, obs_elem_i(myobs2, 'IP',  1), 'pass2 h1 IP')
      call assertEqual(2, obs_elem_i(myobs2, 'PAS', 1), 'pass2 h1 PAS')
      call assertEqual(3, obs_elem_i(myobs2, 'ONM', 1), 'pass2 h1 ONM')

      call obs_finalize(myobs2)


      !
      ! READ BACK AND VERIFY THE DATA FOR PASS 3
      !
      call obs_initialize(myobs2, HEAD_MAX, BOD_MAX)
      passNum = 3
      call obs_readstns(myobs2, 0, passNum, regionNum, 11, 12, NUMPE, &
                        HEAD_MAX, BOD_MAX)

                                        ! 13005 since the last REG value takes
                                        ! precedence (with real data, the REG
                                        ! values should all be the same for a
                                        ! single pass
      call assertEqual(13005, regionNum, 'regionNum for pass 3')

      call assertEqual(2, obs_numheader(myobs2), 'no. headers in pass 3')
      call assertEqual(HEAD_MAX, obs_numheader_max(myobs2), &
                       'max. no. headers in pass 3')
      call assertEqual(4, obs_numbody(myobs2), 'no. bodies in pass 3')
      call assertEqual(BOD_MAX, obs_numbody_max(myobs2), &
                       'max. no. bodies in pass 3')

      header_position = 1
      bod_offset      = 0
      num_bodies      = 2
      fingerprint     = 4
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'pass 3 header 1:', &
                      omit_ip=.true., omit_pas=.true., omit_onm=.true.)
      call assertEqual(0, obs_elem_i(myobs2, 'IP',  1), 'pass3 h1 IP')
      call assertEqual(3, obs_elem_i(myobs2, 'PAS', 1), 'pass3 h1 PAS')
      call assertEqual(4, obs_elem_i(myobs2, 'ONM', 1), 'pass3 h1 ONM')

      header_position = 2
      bod_offset      = 2
      num_bodies      = 2
      fingerprint     = 5
      call verify_obs(myobs2, header_position, bod_offset, num_bodies, &
                      fingerprint, 'pass 3 header 2', &
                      omit_ip=.true., omit_pas=.true., omit_onm=.true.)
      call assertEqual(1, obs_elem_i(myobs2, 'IP',  2), 'pass3 h2 IP')
      call assertEqual(3, obs_elem_i(myobs2, 'PAS', 2), 'pass3 h2 PAS')
      call assertEqual(5, obs_elem_i(myobs2, 'ONM', 2), 'pass3 h2 ONM')

      call obs_finalize(myobs2)
   end subroutine test_binaryFileOnePass

   subroutine setup_obs_clean(myobs, hx, nens, testout_unit)
      ! This is a setup utility for the tests on obs_clean.  It sets up the obs
      ! object, and a matching hx array.  In addition, it initializes all of the
      ! ZHA values to -1 so as to ensure that by default all bodies will be
      ! 'cleaned' (i.e. deleted).
      use obsSpaceData_mod
      implicit none
      type(struct_obs), intent(out) :: myobs
      real(8), intent(out) :: hx(2,10)
      integer, intent(in) :: nens
      integer, intent(in) :: testout_unit

      integer :: status
      integer, parameter :: HEAD_MAX=10, BOD_MAX=100
      integer :: header_position, bod_offset, num_bodies, fingerprint
      integer :: idx_i, idx_j, body_ndx

      call obs_initialize(myobs, HEAD_MAX, BOD_MAX)

      ! Direct the output to a file so that it can be verified
      open(unit=testout_unit, status='SCRATCH', &
                              action='READWRITE', &
                              iostat=status)
      if(status /= 0) write(*,*)"ERROR opening a scratch file in ", &
                                "test_obs_select: ", status

      ! Set up the obs table
      header_position = 1
      bod_offset      = 0
      num_bodies      = 2  ! sets body indices 1, 2
      fingerprint     = 1
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      header_position = 2
      bod_offset      = 2
      num_bodies      = 3  ! sets body indices 3, 4, 5
      fingerprint     = 2
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      header_position = 3
      bod_offset      = 5
      num_bodies      = 4  ! sets body indices 6,7,8,9
      fingerprint     = 3
      call setUp_OneHeaderAndBodies(myobs, header_position, bod_offset, &
                                    num_bodies, fingerprint)

      ! Prepare the array, hx, to match
      do idx_j = 1,9
         do idx_i = 1,nens
            hx (idx_i, idx_j) = idx_i * 100 + idx_j * 10 + 8
         end do
      end do
                                        ! To ensure that all uncontrolled
                                        ! elements are cleaned, set the value of
                                        ! ZHA to -1.0d0
      do body_ndx = 1,9
         call obs_set_r(myobs, 'ZHA', body_ndx, -1.0d0)
      end do
   end subroutine setup_obs_clean

   subroutine test_obs_clean_g1()
      ! Verify that group 1 of bodies are retained (i.e. not cleaned) correctly.
      ! Test the 3 ways of removing one condition, all with qcvar = .false.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1
      real(OBS_REAL) :: hx_in(2,10), hx_in_original(2,10)
      integer, parameter :: NENS = 2
      integer :: body_ndx
      integer, parameter :: TESTOUT_UNIT = 8
      integer, parameter :: BIT12=4096
      logical :: qcvar

      call setup_obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT)
      hx_in_original (:,:) = hx_in (:,:)

      ! Set the values that will be selected.  A body (and its associated header)
      ! will be retained if these three conditions are all met:
      !    1) either of:
      !         1a) btest(obsdat%mobdata(NCM_FLG,jdata),12)
      !         1b) .not. qcvar (the 5th parameter of obs_clean)
      !    2) obsdat%mobdata(NCM_ASS,jdata) .eq. 1
      !    3) obsdat%robdata(NCM_ZHA,jdata) .ge. 0.0

      ! Set up a case where all four conditions are met
      body_ndx = 1 ! will be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.5d0)

      ! Set up a case where condition 1a) is not met [but 1b) is still met]
      body_ndx = 2 ! will be retained
                                        ! set bits 0->20, then remove bit 12
      call obs_set_i(myobs1, 'FLG', body_ndx, 1048576 -1 -BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.5d0)

      ! Set up a case where condition 3) is not met
      body_ndx = 3 ! will not be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, -0.5d0)

      ! Set up a case where condition 2) is not met
      body_ndx = 4 ! will not be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 13)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.5d0)

      qcvar = .false.                   ! meets condision 1b)

      ! METHOD UNDER TEST
      call obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT, qcvar)

      call assertEqual(1, obs_numheader(myobs1), 'group 1, numheader')
      call assertEqual(2, obs_numbody(myobs1), 'group 1, numbody')
      call assertEqual(hx_in_original(:, 1:2), hx_in(:, 1:2), 'group 1, hx')

      !
      ! TEST THE ASCII OUTPUT
      !
      endfile(unit=TESTOUT_UNIT)
      rewind (unit=TESTOUT_UNIT)
      call test_ascii_output(TESTOUT_UNIT, &
                        trim(unit_test_obs_data_dir) // '/test_obs_clean_g1.dat')

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs1)
   end subroutine test_obs_clean_g1

   subroutine test_obs_clean_g2()
      ! Verify that group 2 of bodies are retained (i.e. not cleaned) correctly.
      ! Test the ZHA condition close to its cut-off value, all with qcvar=.false.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1
      real(OBS_REAL) :: hx_in(2,10), hx_in_original(2,10)
      integer, parameter :: NENS = 2
      integer :: body_ndx
      integer, parameter :: TESTOUT_UNIT = 8
      integer, parameter :: BIT12=4096
      logical :: qcvar
      real(OBS_REAL), parameter :: SMALL = 0.d0

      call setup_obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT)
      hx_in_original (:,:) = hx_in (:,:)

      ! Set the values that will be selected.  A body (and its associated header)
      ! will be retained if these three conditions are all met:
      !    1) either of:
      !         1a) btest(obsdat%mobdata(NCM_FLG,jdata),12)
      !         1b) .not. qcvar (the 5th parameter of obs_clean)
      !    2) obsdat%mobdata(NCM_ASS,jdata) .eq. 1
      !    3) obsdat%robdata(NCM_ZHA,jdata) .ge. 0.0

      ! Set up a case where condition 3) is met, but just
      body_ndx = 3 ! will be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, tiny(SMALL))

      ! Set up another case where condition 3) is met, but just
      body_ndx = 4 ! will be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.0d0)

      qcvar = .false.                   ! meets condision 1b)

      ! METHOD UNDER TEST
      call obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT, qcvar)

      call assertEqual(1, obs_numheader(myobs1), 'group 2, numheader')
      call assertEqual(2, obs_numbody(myobs1), 'group 2, numbody')
      call assertEqual(hx_in_original(:, 3:4), hx_in(:, 1:2), 'group 2, hx')

      !
      ! TEST THE ASCII OUTPUT
      !
      endfile(unit=TESTOUT_UNIT)
      rewind (unit=TESTOUT_UNIT)

      call test_ascii_output(TESTOUT_UNIT, &
                        trim(unit_test_obs_data_dir) // '/test_obs_clean_g2.dat')

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs1)
   end subroutine test_obs_clean_g2

   subroutine test_obs_clean_g3()
      ! Verify that group 3 of bodies are retained (i.e. not cleaned) correctly.
      ! Test the bit-12 condition, all with qcvar = .true.
      use obsSpaceData_mod
      implicit none
      type(struct_obs) :: myobs1
      real(OBS_REAL) :: hx_in(2,10), hx_in_original(2,10)
      integer, parameter :: NENS = 2
      integer :: body_ndx
      integer, parameter :: TESTOUT_UNIT = 8
      integer, parameter :: BIT12=4096
      logical :: qcvar

      call setup_obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT)
      hx_in_original (:,:) = hx_in (:,:)

      ! Set the values that will be selected.  A body (and its associated header)
      ! will be retained if these three conditions are all met:
      !    1) either of:
      !         1a) btest(obsdat%mobdata(NCM_FLG,jdata),12)
      !         1b) .not. qcvar (the 5th parameter of obs_clean)
      !    2) obsdat%mobdata(NCM_ASS,jdata) .eq. 1
      !    3) obsdat%robdata(NCM_ZHA,jdata) .ge. 0.0

      ! Set up a case where all three conditions are met [but not 1b)]
      body_ndx = 7 ! will be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.5d0)

      ! Set up a case where condition 1a) is not met
      body_ndx = 3 ! will not be retained
      call obs_set_i(myobs1, 'FLG', body_ndx, 1048576 -1 -BIT12)
      call obs_set_i(myobs1, 'ASS', body_ndx, 1)
      call obs_set_r(myobs1, 'ZHA', body_ndx, 0.5d0)

      qcvar = .true.                   ! does not meet condision 1b)

      ! METHOD UNDER TEST
      call obs_clean(myobs1, hx_in, NENS, TESTOUT_UNIT, qcvar)

      call assertEqual(1, obs_numheader(myobs1), 'group 3, numheader')
      call assertEqual(1, obs_numbody(myobs1), 'group 3, numbody')
      call assertEqual(hx_in_original(:, 7), hx_in(:, 1), 'group 3, hx')

      !
      ! TEST THE ASCII OUTPUT
      !
      endfile(unit=TESTOUT_UNIT)
      rewind (unit=TESTOUT_UNIT)
      call test_ascii_output(TESTOUT_UNIT, &
                        trim(unit_test_obs_data_dir) // '/test_obs_clean_g3.dat')

      close(unit=TESTOUT_UNIT)
      call obs_finalize(myobs1)
   end subroutine test_obs_clean_g3
end module testObs_mod
