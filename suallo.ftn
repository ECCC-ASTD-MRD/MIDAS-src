!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE SUALLO(KULOUT)
#if defined (DOC)
*
***s/r SUALLO  - Memory allocation for the model variables
*
*Author  : P. Gauthier *ARMA/AES  June 9, 1992
*Revision:
*     P. Gauthier *ARMA/AES May 25, 1993
*     .           -Allocation for specific humidity and surface pressure
*     .            for spectral/gridpoint model states and forecast
*     .            error correlation
*     .           -Allocation of specific humidity is triggered by setting
*     .           -Allocation of surface pressure is triggered by setting
*     .            NVSP2D = 1.
*     .           -SUALLO has also been rearranged by grouping similar states
*     .            together (e.g., COMSP, COMSP1, COMSPG)
*     P. Gauthier *ARMA/AES September 28, 1993
*     .           -Allocation of RDEVSTD in COMSPG
*     C. Charette *ARMA/AES January 1996
*                 -Add 'compstat.cdk'.
*                 -Allocation for prediction error statistics.
*     S. Pellerin *ARMA/AES Sept 97.
*                 - Control of the different model state of the 3Dvar
*                   through COMSTATE, COMSTATEC and COMSTNUM common
*                   blocks variables (comstate.cdk).
*     P. Koclas   *CMC/AES Nov 97.
*                 -alocation of scalpm1 variable
*     S. Pellerin **ARMA/AES Jan 98.
*                 -Dynamic allocation of DAMPLIBG (COMPSTAT) previously
*                  hard coded to 240x120.
*     L. Fillion  *ARMA/AES (originally Oct 1996)
*                 -Add 'comode.cdk'.
*     C. Charette *ARMA/AES  FEV 1999
*                 -Add 'compdg.cdk'.
*     C. Charette *ARMA/AES SEP 1999
*                 - Operator PTOT as a function of latitude
*     J. Halle    *CMDA/AES Oct 99.
*                 - Added ground temperature (TG) to the model state.
*     M. Tanguay  *ARMN/MSC Jan. 2005
*                 - Introduction of minimizer N1CG1
*     M. Buehner    *ARMA/MSC Oct 2004.
*                 - Changed DAMPLIBG to 3D.
*     M. Buehner    *ARMA May 2008
*                 - Added variables for new approach with PtoT and
*                   localized Tb correlations (NANALVAR=4)
*     L. Fillion/C.Page    ARMA/MSC/UQAM 0ct 2003.
*                 - Limited-Area LAM4D arrays.: Adaptation to v10_0_0 26 Apr 2006.
*     L. Fillion   ARMA/MSC - 30 Nov 2004.: Adaptation to v10_0_0 26 Apr 2006.
*                 - Convection Jacobian arrays
*     L. Fillion   ARMA/MSC - 18 Mar 2005.: Adaptation to v10_0_0 26 Apr 2006.
*                 - High-Res. LAM Background geometrical arrays.
*     L. Fillion   ARMA/MSC - 07 Jul 2005.: Adaptation to v10_0_0 26 Apr 2006.
*                 - Add dxlam and dxlam arrays.
*     L. Fillion   ARMA/EC - 24 Mar 2006.: Adaptation to v10_0_0 26 Apr 2006.
*                 - Add RR9 array for basic-state instantaneous KF convective RR.
*     L. Fillion   ARMA/EC - 14 Aug 2007 - Update lam4d to v_10_0_3.
*     L. Fillion   ARMA/EC - 21 Apr 2008 - Introduce spectral ptot matrix in lam4d mode.
*     L. Fillion   ARMA/EC - 26 Aug 2008 - Introduce horizontal correlation scales based on rstddev arrays.
*     L. Fillion   ARMA/EC - 19 Sep 2008 - Introduce tile structure of gridpoint PTOT in LAM4D mode.
*     L. Fillion   ARMA/EC - 12 Jan 2009 - Upgrade lam4d to v_10_1_2.
*     L. Fillion   ARMA/EC - 27 Feb 2009 - Upgrade lam4d to v_10_2_1 and introduce idim for corns in LU and GU modes.
*     L. Fillion   ARMA/EC - 12 Oct 2009 - Generalise according to grd_roule rather than grd_typ .eq. 'LU'
*     L. Fillion   ARMA/EC - 4 May 2010 - Upgrade on v_11_01_2b.
*     L. Fillion   ARMA/EC - 13 May 2010 - Introduce Hemispheric spectral transforms.
*
*Arguments
*     i   KULOUT: unit used for optional printing
*
#endif
C
      IMPLICIT NONE
*implicits
#include "pardim.cdk"
#include "comct0.cdk"
#include "comlun.cdk"
#include "comdim.cdk"
#include "comgd0.cdk"
#include "comgd1.cdk"
#include "compdg.cdk"
#include "comsp.cdk"
#include "comsp1.cdk"
#include "comspg.cdk"
#include "comgem.cdk"
#include "comstate.cdk"
#include "comode.cdk"
#include "comgdpar.cdk"
*
      INTEGER KULOUT, ILEN, IERR, ILMU, ILENUT0, ILENSPV
C
      INTEGER iloc, jvar, idim
      EXTERNAL HPALLOC
C
      WRITE(KULOUT,FMT='(//,6('' ***********''))')
      WRITE(KULOUT,*)'     suallo:  Memory allocation of 3D',
     S     ' variational assimilation'
      WRITE(KULOUT,FMT='(6('' ***********''))')
C
C     2. Grid point model state
C     .  ----------------------
C
 200  CONTINUE
C
C     .     2.1 Main states (COMGD0, COMG1) and forecast error standard
C     .         deviation in physical space (in COMSPG or comrgsigla)
C     .         -------------------------------------------------------
C
 210  CONTINUE
C
      ILEN = (NI)*NKGDIM*(NJ)
      CALL HPALLOC(PTGD,MAX(ILEN,1),IERR,8)
      IF(NCONF.NE.307) THEN
         CALL HPALLOC(PTGD1,MAX(ILEN,1),IERR,8)
       END IF
cbue
       ILEN=(NJ)*(NI)*NFLEV
       CALL HPALLOC(PTTB0,MAX(ILEN,1),IERR,8)
       CALL HPALLOC(PTTB1,MAX(ILEN,1),IERR,8)
       ILEN = NLA*2*NFLEV
       CALL HPALLOC(PTSPTB,MAX(ILEN,1),IERR,8)
       ILEN = NI*NJ*NFLEV
       CALL HPALLOC(PTTB_out,MAX(ILEN,1),IERR,8)
C
C     .     2.2 Splitting  of states (COMGD0, COMG1) and RSIG in COMSPG
C     .         -------------------------------------------------------
C
 220  CONTINUE
C
C     2.2.1 Pointer initialisations
C           -----------------------
C
      PTUT0 = -1
      PTUT1 = -1
C
      PTVT0 = -1
      PTVT1 = -1
C
      PTT0 = -1
      PTT1 = -1
C
      PTQ0 = -1
      PTQ1 = -1
C
      PTGZ0 = -1
      PTQ1 = -1
C
      PTOZ0 = -1
      PTOZ1 = -1
C
      PTTR0 = -1
      PTTR1 = -1
C
      PTGPS0 = -1
      PTGPS1 = -1
C
      PTGTG0 = -1
      PTGTG1 = -1
C
      iloc = 1
      do jvar = 1,jpnvarmax
        if(jvar .eq. nguu) then
          NGPOSIT(nguu)=iloc
          if(NGEXIST(nguu).eq.1) then
            PTUT0   = LOC(GD(1,iloc,1))
            PTUT1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngvv) then
          NGPOSIT(ngvv)=iloc
          if(NGEXIST(ngvv).eq.1) then
            PTVT0   = LOC(GD(1,iloc,1))
            PTVT1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nggz) then
          NGPOSIT(nggz)=iloc
          if(NGEXIST(nggz).eq.1) then
            write(nulout,*) 'suallo: GZ allocated'
            PTGZ0   = LOC(GD(1,iloc,1))
            PTGZ1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngq) then
          NGPOSIT(ngq)=iloc
          if(NGEXIST(ngq).eq.1) then
            PTQ0   = LOC(GD(1,iloc,1))
            PTQ1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngtt) then
          NGPOSIT(ngtt)=iloc
          if(NGEXIST(ngtt).eq.1) then
            PTT0   = LOC(GD(1,iloc,1))
            PTT1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngoz) then
          NGPOSIT(ngoz)=iloc
          if(NGEXIST(ngoz).eq.1) then
            PTOZ0   = LOC(GD(1,iloc,1))
            PTOZ1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngtr) then
          NGPOSIT(ngtr)=iloc
          if(NGEXIST(ngtr).eq.1) then
            PTTR0   = LOC(GD(1,iloc,1))
            PTTR1   = LOC(GD1(1,iloc,1))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. ngps) then
          NGPOSIT(ngps)=iloc
          if(NGEXIST(ngps).eq.1) then
            PTGPS0   = LOC(GD(1,iloc,1))
            PTGPS1   = LOC(GD1(1,iloc,1))
            iloc = iloc + 1
          end if
        elseif(jvar .eq. ngtg) then
          NGPOSIT(ngtg)=iloc
          if(NGEXIST(ngtg).eq.1) then
            PTGTG0   = LOC(GD(1,iloc,1))
            PTGTG1   = LOC(GD1(1,iloc,1))
            iloc = iloc + 1
          end if
        endif
      enddo
C
      ILEN = (NI)*NKGDIM*(NJ)
      ILENUT0 = (NI)*NFLEV*(NJ)
C
      WRITE(KULOUT,FMT='(/,''  Arrays in COMGD0 are allocated'',
     S     '' the following space:'')')
      WRITE(KULOUT,FMT='(''   GD :'',I10,10x
     S     ,'' (3D-fields):'',I10)')  ILEN,ILENUT0
C
      IF(NCONF.NE.307) THEN
         WRITE(KULOUT,FMT='(/,''  Arrays in COMGD1 are allocated'',
     S        '' the following space:'')')
         WRITE(KULOUT,FMT='(''   GD1:'',I10,10x
     S        ,'' (3D-fields ):'',I10)')  ILEN,ILENUT0
      END IF
C
C     3.  Spectral model states
C     .   ---------------------
C
 300  CONTINUE
C
C     .     3.1  Main state (COMSP, COMSP1, COMSPG)
C     .          ---------------------------------
C
 310  CONTINUE
      ILEN = NLA * 2 * NKSDIM
      CALL HPALLOC(PTSP  ,MAX(ILEN,1),IERR,8)
      IF(NCONF.NE.307) THEN
         CALL HPALLOC(PTSP1 ,MAX(ILEN,1),IERR,8)
         CALL HPALLOC(PTSPG ,MAX(ILEN,1),IERR,8)
      END IF
C
C     .     3.2 Splitting  of states (COMSP, COMSP1, COMSPG)
C     .         --------------------------------------------
C
 320  CONTINUE
C
C     2.2.1 Pointer initialisations
C           -----------------------
C
      PTSVOR = -1
      PTSVOR1 = -1
      PTSVORG = -1
C
      PTSDIV = -1
      PTSDIV1 = -1
      PTSDIVG = -1
C
      PTSTT  = -1
      PTSTT1  = -1
      PTSTTG  = -1
C
      PTSPQ = -1
      PTSPQ1 = -1
      PTSPQG = -1
C
      PTSPGZ = -1
      PTSPGZ1  = -1
      PTGZG  = -1
C
      PTSPOZ = -1
      PTSPOZ1  = -1
      PTOZG  = -1
C
      PTSPTR = -1
      PTSPTR1  = -1
      PTTRG  = -1
C
      PTSPPS = -1
      PTSPPS1 = -1
      PTSPPSG = -1
C
      PTSPTG = -1
      PTSPTG1 = -1
      PTSPTGG = -1
C
      iloc = 1
      do jvar = 1,jpnvarmax
        if(jvar .eq. nsvor) then
          NSPOSIT(nsvor)=iloc
          if(NSEXIST(nsvor).eq.1) then
            PTSVOR   = LOC(SP(1,1,ILOC))
            PTSVOR1 = LOC(SP1(1,1,ILOC))
            PTSVORG = LOC(SPG(1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nsdiv) then
          NSPOSIT(nsdiv)=iloc
          if(NSEXIST(nsdiv).eq.1) then
            PTSDIV  = LOC(SP (1,1,iloc))
            PTSDIV1 = LOC(SP1(1,1,ILOC))
            PTSDIVG = LOC(SPG(1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nsgz) then
          NSPOSIT(nsgz)=iloc
          if(NSEXIST(nsgz).eq.1) then
            PTSPGZ  = LOC(SP  (1,1,iloc))
            PTSPGZ1  = LOC(SP1  (1,1,ILOC))
            PTGZG  = LOC(SPG  (1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nsq) then
          NSPOSIT(nsq)=iloc
          if(NSEXIST(nsq).eq.1) then
            PTSPQ  = LOC(SP  (1,1,iloc))
            PTSPQ1 = LOC(SP1 (1,1,ILOC))
            PTSPQG = LOC(SPG (1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nstt) then
          NSPOSIT(nstt)=iloc
          if(NSEXIST(nstt).eq.1) then
            PTSTT   = LOC(SP (1,1,iloc))
            PTSTT1  = LOC(SP1(1,1,ILOC))
            PTSTTG  = LOC(SPG(1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nsoz) then
          NSPOSIT(nsoz)=iloc
          if(NSEXIST(nsoz).eq.1) then
            PTSPOZ  = LOC(SP  (1,1,iloc))
            PTSPOZ1  = LOC(SP1  (1,1,ILOC))
            PTOZG  = LOC(SPG  (1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nstr) then
          NSPOSIT(nstr)=iloc
          if(NSEXIST(nstr).eq.1) then
            PTSPTR  = LOC(SP  (1,1,iloc))
            PTSPTR1  = LOC(SP1  (1,1,ILOC))
            PTTRG  = LOC(SPG  (1,1,ILOC))
            iloc = iloc + nflev
          end if
        elseif(jvar .eq. nsps) then
          NSPOSIT(nsps)=iloc
          if(NSEXIST(nsps).eq.1) then
            PTSPPS  = LOC(SP  (1,1,iloc))
            PTSPPS1 = LOC( SP1(1,1,ILOC))
            PTSPPSG = LOC( SPG(1,1,ILOC))
            iloc = iloc + 1
          end if
        elseif(jvar .eq. nstg) then
          NSPOSIT(nstg)=iloc
          if(NSEXIST(nstg).eq.1) then
            PTSPTG  = LOC(SP  (1,1,iloc))
            PTSPTG1 = LOC( SP1(1,1,ILOC))
            PTSPTGG = LOC( SPG(1,1,ILOC))
            iloc = iloc + 1
          end if
        endif
      enddo
C
      ILENSPV = NLA * 2 * NFLEV
      WRITE(KULOUT,FMT='(/,"  Arrays in COMSP are allocated",
     S     " the following space:")')
      WRITE(KULOUT,FMT='(8X,"   SP :",I6,10x
     S     ," (3D-fields SPXXX):",I8)')  ILEN,ILENSPV
C
      IF(NCONF.NE.307) THEN
         WRITE(KULOUT,FMT='(/,"  Arrays in COMSP1 are allocated",
     S        " the following space:")')
         WRITE(KULOUT,FMT='(8X,"   SP1 :",I6,10x
     S        ," (3D-fields SPXXX1):",I8)')  ILEN,ILENSPV
C
         WRITE(KULOUT,FMT='(/,"  Arrays in COMSPG are allocated",
     S        " the following space:")')
         WRITE(KULOUT,FMT='(8X,"   SPG :",I6,10x
     S        ," (3D-fields SPXXXG):",I8)')  ILEN,ILENSPV
C
      END IF
C
C*    4. Arrays needed to define the geometry of the model (in COMGEM)
C     .  ------------------------------------------------------------
C
 400  CONTINUE
C
      ILEN = NLA
      CALL HPALLOC(PTNNP1, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PT1SNP1,MAX(ILEN,1),IERR,8)
      WRITE(KULOUT,FMT='(8X," (RNNP1,R1SNP1)  =",I4)')ILEN
C
C
      ILEN = NJ
      CALL HPALLOC(PTCONPHY,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTCONIMA,MAX(ILEN,1),IERR,8)
!!!
!!! MOVED CODE FOR CONTROL VECTOR TO SUCOV
!!!
C
C*    8. Arrays required for model coordinate analysis
C     .  ---------------------------------------------
C
 800  CONTINUE
      ILEN = NFLEV
c
c     arrays for T to P and P to T transforms
c
      CALL HPALLOC(PTVMA, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVMB, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVMC, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVMD, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVME, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVMF, MAX(ILEN,1),IERR,8)
c
c     arrays for mean T profile and Equivalent-depths
c
      ILEN = NFLEV
      CALL HPALLOC(PTTMEANH, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTEQDEPTH, MAX(ILEN,1),IERR,8)
c
c     arrays for vertical mode transform
c
      ILEN = NFLEV*NFLEV
      CALL HPALLOC(PTVMAT, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVINV, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTTVMAT, MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTTVINV, MAX(ILEN,1),IERR,8)
C
c
c     arrays of background-related fields on background grid (compdg)
c     N.B.: Doesnt assume global structure as GD0,GD1 for instance.   ! WARNING!!!!
c
      ILEN = NI*NFLEV*NJ
      CALL HPALLOC(PTUTG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTVTG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTTG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTQG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTCHIG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTOMEGAG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTGDGZG,MAX(ILEN,1),IERR,8)
      ILEN = NI*NJ
      CALL HPALLOC(PTGPSG,MAX(ILEN,1),IERR,8)
      CALL HPALLOC(PTGPTG,MAX(ILEN,1),IERR,8)
C
      RETURN
      END
