module writeIncrement_mod
  use MathPhysConstants_mod
  use EarthConstants_mod
  use controlVector_mod
  use columnData_mod
  use minimization_mod
  use bmatrix_mod
  use mpi
  use gridStateVector_mod
  use HorizontalCoord_mod
  use timeCoord_mod
  use physicsFunctions_mod
  implicit none
  save
  private

  public :: calcWriteIncrement,writeIncrement

  ! this is set to true when supost runs
  logical :: initialized = .false. 

  ! namelist variables
  character(len=4)  :: CPPCVAR(20)
  character(len=12) :: CETIKINC
  integer :: NPPCVAR
  logical :: write4dInc,useTL_LQtoHU

  contains

    SUBROUTINE SUPOST
      !
      !**s/r SUPOST  - initialize the post-processing of the model state
      !
      IMPLICIT NONE
      INTEGER IERR,jvar,ihu,itt,ivt,imin,igz,ip0,ilq
      integer :: nulnam,fnom,fclos
      logical :: lvtout,lgzout
      NAMELIST /NAMPOST/NPPCVAR,CPPCVAR,CETIKINC,WRITE4DINC,useTL_LQtoHU

      write(*,*) '========================================='
      write(*,*) 'supost:  initialization of postprocessing'
      write(*,*) '========================================='
      initialized=.true.
      !
      ! 1. Set default values
      !
      CETIKINC = 'UNDEFINED***'
      NPPCVAR=6
      CPPCVAR(:) = '    '
      CPPCVAR(1) = 'UU'
      CPPCVAR(2) = 'VV'
      CPPCVAR(3) = 'TT'
      CPPCVAR(4) = 'LQ'
      CPPCVAR(5) = 'P0'
      CPPCVAR(6) = 'TG'
      WRITE4DINC = .false.
      useTL_LQtoHU = .false.
      !
      ! 2. Read the parameters from NAMPOST
      !
      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=nampost,iostat=ierr)
      if(ierr.ne.0) call abort3d('supost: Error reading namelist')
      if(mpi_myid.eq.0) write(*,nml=nampost)
      ierr=fclos(nulnam)
      !
      ! reordering cppcvar for dependent variables in writeIncrement
      !
      ip0 = 0
      ihu = 0
      itt = 0
      ivt = 0
      lgzout = .false.
      lvtout = .false.

      do jvar = 1,nppcvar
        if(cppcvar(jvar).eq.'P0') then
          ip0 = jvar
        endif
        if(cppcvar(jvar).eq.'TT') then
          itt = jvar
        endif
        if(cppcvar(jvar).eq.'GZ') then
          igz = jvar
          lgzout = .true.
        endif
        if(cppcvar(jvar).eq.'HU') then
          ihu = jvar
        endif
        if(cppcvar(jvar).eq.'VT') then
          ivt = jvar
          lvtout = .true.
        endif
        if(cppcvar(jvar).eq.'LQ') then
          ilq = jvar
        endif
      enddo

      if((lgzout.or.lvtout).and.ihu.eq.0) then
        ! Make sure that HU is part of the list
        ihu = nppcvar+1
        cppcvar(ihu) = 'HU'
        nppcvar = ihu
      endif

      if(ihu.ne.0) then
        ! Make sure that TT is part of the list
        imin = min(itt,ihu)
        if (imin.eq.0) then
          ! TT is not requested: put it in the list before HU
          cppcvar(ihu) = 'TT'
          cppcvar(nppcvar+1) = 'HU'
          nppcvar = nppcvar + 1
        else
          ! TT is requested: make sure that TT is before HU in the list
          cppcvar(max(itt,ihu)) = 'HU'
          cppcvar(imin) = 'TT'
        endif
      endif

      if(ip0 .gt. 1) then
        do jvar = ip0, 2,-1
          cppcvar(jvar) = cppcvar(jvar -1)
        enddo
        cppcvar(1) = 'P0'
      endif
      !
      ! 4. Print the values
      !
      DO jvar = 1, NPPCVAR
        if(mpi_myid.eq.0) WRITE(*,FMT='(4X,"VAR NO.",I3,":",2X,"CPPCVAR= ",A5)') jvar,CPPCVAR(jvar)
      ENDDO

    END SUBROUTINE SUPOST


    subroutine calcWriteIncrement(lcolumng,lcolumnhr,indexAnalysis)
      !
      !  s/r calcWriteIncrement - calculate and write analysis increment after minimization
      !
      implicit none

      type(struct_columnData),target :: lcolumng,lcolumnhr
      integer :: indexAnalysis

      type(struct_hco),      pointer :: hco_anl
      type(struct_vco), pointer :: vco_anl
      type(struct_gsv) :: statevector,statevectorg
      integer jk,jj,ji,jstep,nlev_M,ierr,fnom,fstouv,fstfrm,fclos
      integer :: datestamplist(tim_nstepobsinc)
      real*8  :: hu_anl,deltaHours
      real*8, allocatable :: zes(:,:,:)
      real*8, allocatable :: ztv(:,:,:)
      real*8, allocatable :: zgz(:,:,:)
      real*8, allocatable :: zhu(:,:,:)
      real*8, pointer :: lq_inc_ptr(:,:,:,:),hu_trl_ptr(:,:,:,:)
      character(len=4) :: flnum 
      character(len=3) :: flnum2
      character(len=128) :: incFileName
      integer             :: get_max_rss

      write(*,*) '-------------------------------'
      write(*,*) '--Starting subroutine calcWriteIncrement--'
      write(*,*) '-------------------------------'
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      call tmg_start(3,'WRITEINCR')
      !
      ! Read namelist and do some setup
      !
      if(.not.initialized) call supost
      !
      ! Check that we have at least as many processors as increment timesteps
      !
      if(mpi_nprocs .lt. tim_nstepobsinc) then
        write(*,*) 'mpi_nprocs=',mpi_nprocs,', nstepobsinc=',tim_nstepobsinc
        call abort3d('calcWriteIncrement: number of cpus < number of increment timesteps, aborting!')
      endif
      !
      ! Compute the analysis increment
      !
      call tmg_start(91,'POST_COMPUTEDX')

      vco_anl => col_getVco(lcolumng)
      hco_anl => hco_Get('Analysis')
      call gsv_setVco(statevector,vco_anl)

      call gsv_setHco(statevector, hco_anl)

      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      call gsv_allocate(statevector,tim_nstepobsinc, &
           datestamp=tim_getDatestamp(),mpi_local=.true.)
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

      if(write4dInc) then
        ! mpiglobal result for 4D increment only on myid=(increment_time_step -1)
        call gsv_commMPIGlobal(statevector)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      else
        ! mpiglobal result for 3D increment only on myid=0 
        call gsv_commMPIGlobal3D(statevector)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      endif
      call tmg_stop(91)

      WRITE(*,*)' calcWriteIncrement: Transform analysis variables to model variables -'

      call tmg_start(92,'POST_DIAG')
      !
      ! Prepare background fields (only P0, TT, HU) at each analysis time for flow-dependent 
      ! control variables (NOTE: mpiglobal result only on myid=increment_time_step-1)
      !
      call gsv_setVco(statevectorg,vco_anl)
      call gsv_setHco  ( statevectorg, hco_anl )
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      call gsv_allocate(statevectorg,1,datestamp=tim_getDatestamp(),mpi_local=.false.)

      do jstep=1,tim_nstepobsinc
        datestamplist(jstep)=gsv_getDateStamp(statevector,jstep)
      enddo
      if(write4dInc) then
        ! read in the background fields at all increment timesteps
        call subasic_gd(statevectorg,lcolumnhr,tim_nstepobsinc,datestamplist,indexAnalysis)
      else
        ! only read in the background fields at the "analysis" timestep (usually the middle)
        call subasic_gd(statevectorg,lcolumnhr,1,datestamplist(statevector%anltime),indexAnalysis)
      endif
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      ! if 3D increment: background fields only on myid=0, so only do calculations for myid=0
      ! if 4D increment: background fields for jstep on myid=jstep-1, do calculations for first numstep procs
      if( (write4dInc      .and. mpi_myid .lt. tim_nstepobsinc) .or.  &
          (.not.write4dInc .and. mpi_myid .eq. 0          ) ) then

        if(write4dInc) then
          jstep=mpi_myid+1
        else
          jstep=statevector%anltime
        endif

        write(*,*) 'calcWriteIncrement: computing the diag variables for timestep:',jstep
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

        nlev_M = vco_getNumLev(vco_anl,'MM')
        allocate( zes(hco_anl%ni, nlev_M, hco_anl%nj) )
        allocate( ztv(hco_anl%ni, nlev_M, hco_anl%nj) )
        allocate( zgz(hco_anl%ni, nlev_M, hco_anl%nj) )
        allocate( zhu(hco_anl%ni, nlev_M, hco_anl%nj) )

        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
        !
        ! Compute HU increment from LQ increment
        !
        hu_trl_ptr => gsv_getField(statevectorg,'HU')  ! this is HU_b
        lq_inc_ptr => gsv_getField(statevector ,'HU')  ! this is delta LQ
!$OMP PARALLEL DO PRIVATE(jj,jk,ji,hu_anl)
        do jj = 1,statevectorg%nj
          do jk = 1,nlev_M
            do ji = 1,statevectorg%ni
              ! choose either tangent linear or nonlinear operator for LQ to HU
              if(useTL_LQtoHU) then
                zhu(ji,jk,jj) = lq_inc_ptr(ji,jk,jj,1)*hu_trl_ptr(ji,jk,jj,1)
              else
                hu_anl = log(hu_trl_ptr(ji,jk,jj,1)) + lq_inc_ptr(ji,jk,jj,1)
                zhu(ji,jk,jj) = EXP(hu_anl) - hu_trl_ptr(ji,jk,jj,1)
              endif
            enddo
          enddo
        enddo
!$OMP END PARALLEL DO
        !
        ! Compute ES increment
        !
        call lq2esgd(zes,statevector,statevectorg)
        !
        ! Compute GZ increment
        !
        call lt2tvgd(ztv,statevector,statevectorg)
        call ltt2phigd(zgz,ztv,statevectorg)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
        !
        ! Now, write out the increment, including diagostic variables
        !
        if(write4dInc) then
          call difdatr(datestamplist(jstep),tim_getDatestamp(),deltaHours)
          if(nint(deltaHours*60.0d0).lt.0) then
            write(flnum,'(I4.3)') nint(deltaHours*60.0d0)
          else
            write(flnum,'(I3.3)') nint(deltaHours*60.0d0)
          endif
          write(*,*) 'calcWriteIncrement: dates=',datestamplist(jstep),tim_getDatestamp(),deltaHours,nint(deltaHours*60.0d0)
          write(*,*) 'calcWriteIncrement: flnum=###',trim(flnum),'###'
          incFileName = './rebm_'//trim(flnum)//'m'
        else
          incFileName = './rebm'
        endif
        if(indexAnalysis.gt.0) then
          write(flnum2,'(I3.3)') indexAnalysis
          incFileName = trim(incFileName) // '_' // trim(flnum2)
        endif
        call writeIncrement(incFileName,statevector,zes,ztv,zgz,zhu,jstep)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
 
        deallocate(zes)
        deallocate(ztv)
        deallocate(zgz)
        deallocate(zhu)

      endif

      ! free up some memory related to increment
      call gsv_deallocate(statevectorg)
      call gsv_deallocate(statevector)

      call tmg_stop(92)

      call tmg_stop (3)
      write(*,*) 'LEAVING calcWriteIncrement'

    END SUBROUTINE calcWriteIncrement


    SUBROUTINE writeIncrement(incFileName,statevector,zes,ztv,zgz,zhu,jstep)
      !
      !**s/r writeIncrement  - Transfer of the contents of statevector into an RPN
      !                        standard file
      !
      implicit none
      character(len=*) :: incFileName
      type(struct_gsv) :: statevector
      real*8 :: zes(:,:,:),ztv(:,:,:),zgz(:,:,:),zhu(:,:,:)
      integer :: jstep

      integer write_encode_hyb,fnom,fstouv,fstfrm,fclos,vfstecr
      integer jvar,jlev,ierr,numlev,nulfile
      integer datestamp,inpak_inc
      real*8 zwork
      real*8, allocatable :: zbuffer(:)
      real   zptop_r4, zpref_r4,zrcoef_r4
      integer nip1,nip2,nip3,ndeet,npas,nidatyp,nig1,nig2,nig3,nig4
      character(len=1)  :: cgrtyp
      character(len=2)  :: cltypinc
      character(len=12) :: cletiket
      real*8 :: zlowvar(statevector%ni,statevector%nj)
      logical llimplemented,FlipLatitude

      WRITE(*,FMT='(/,4X,"Starting writeIncrement",//)')
      !
      ! Read namelist and do some setup
      !
      if(.not.initialized) call supost

      nulfile = 0
      write(*,*)'writeIncrement: increment file name = ',trim(incFileName)
      ierr    = fnom(nulfile,trim(incFileName),'RND',0)
      if(ierr.ge.0)then
        write(*,*)'writeIncrement: increment file opened with unit number ',nulfile
        ierr  =  fstouv(nulfile,'RND')
      else
        call abort3d('writeIncrement: problem opening increment file, aborting!')
      end if

      if(nulfile.eq.0) then
        write(*,*) 'writeIncrement: unit number for increment file not valid!'
        return
      endif

      WRITE(*,FMT='(/,4X,''Transfer of the gridpoint model state on file at iteration No.'',I3)') min_niter
      !
      ! Setup packing for each variable
      !
      inpak_inc  = -32                  ! 32 bits are needed by AAI
      write(*,*)'************************************** '
      write(*,*) 'PACKING for increments   is ',inpak_inc
      write(*,*)'************************************** '
      !     
      ! Write TIC-TAC if needed
      !
      if ( statevector % hco % grtyp == 'Z' ) then
        ndeet      =  0
        NIP1       =  statevector % hco % ig1
        NIP2       =  statevector % hco % ig2
        NIP3       =  0
        NPAS       =  0
        NIDATYP    =  1
        CGRTYP     = 'E'
        CLTYPINC   = 'X'
        cletiket   =  cetikinc
        datestamp  =  gsv_getDateStamp(statevector) 

        call cxgaig ( CGRTYP,   &                                     ! IN
                      NIG1, NIG2, NIG3, NIG4, &                       ! OUT
                      real(statevector % hco % xlat1), real(statevector % hco % xlon1), & ! IN
                      real(statevector % hco % xlat2), real(statevector % hco % xlon2) ) ! IN

        allocate(zbuffer(statevector % hco % ni))
        zbuffer(:)= statevector % hco % lon(:) * MPC_DEGREES_PER_RADIAN_R8
        IERR = VFSTECR(zbuffer,zwork,inpak_inc, &
               nulfile,datestamp,ndeet,npas,statevector%ni,1,1,nip1,  &
               nip2,nip3,cltypinc,'>>',cletiket,cgrtyp,nig1,          &
               nig2,nig3,nig4,nidatyp,.true.)
        deallocate(zbuffer)

        allocate(zbuffer(statevector % hco % nj))
        zbuffer(:)= statevector % hco % lat(:) * MPC_DEGREES_PER_RADIAN_R8
        IERR = VFSTECR(zbuffer,zwork,inpak_inc, &
               nulfile,datestamp,ndeet,npas,1,statevector%nj,1,nip1,  &
               nip2,nip3,cltypinc,'^^',cletiket,cgrtyp,nig1,          &
               nig2,nig3,nig4,nidatyp,.true.)
        deallocate(zbuffer)

      end if
      !
      ! Write analysis increments
      !
      ndeet=0
      NIP2       =  0
      NIP3       =  min_niter
      NPAS       =  0
      NIDATYP    =  1
      CGRTYP     = statevector % hco % grtyp
      CLTYPINC   = 'R'
      NIG1       =  statevector % hco % ig1
      if ( statevector % hco % grtyp == 'G' .and.  &
           statevector % hco % ig2   ==  1   ) then
        FlipLatitude  = .true. 
        NIG2          = 0
      else
        FlipLatitude  = .false.
        NIG2          =  statevector % hco % ig2
      end if
      NIG3       =  statevector % hco % ig3
      NIG4       =  statevector % hco % ig4
      cletiket=cetikinc
      datestamp=gsv_getDateStamp(statevector,jstep)

      write(*,*) 'Writing fields for datestamp= ',datestamp

      write(*,*) 'Writing variable HY on analysis-increment file'

      zptop_r4 = statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8
      zpref_r4 = statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8
      zrcoef_r4 = statevector%vco%drcf1
      ierr    = write_encode_hyb(nulfile,'HY',nip2,nip3,cletiket,  &
                                 datestamp,zptop_r4,zpref_r4,zrcoef_r4)
      !
      ! Analysis grid hybrid vertical coordinate parameters
      !
      write(*,*)' '
      write(*,*)'************************************** '
      write(*,*) ' The hybride coordinate parameters from increment', &
                 ' analysis  grid are:'
      write(*,*) ' PTOP = ',statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' PREF = ',statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' RCOEF= ',statevector%vco%drcf1
      write(*,*)'************************************** '
      write(*,*)' '

      do jvar = 1, nppcvar
        !
        ! Some variable may be request for other to be computed but not
        ! necessaraly wanted as output..
        !
        llimplemented = .true.

        write(*,*) 'Writing variable ',cppcvar(jvar)

        numlev = gsv_getNumLev(statevector,vnl_vartypeFromVarname(cppcvar(jvar)))
        write(*,*) 'numlev=',numlev

        do jlev=1,numlev
          call gdout2(cppcvar(jvar),ZLOWVAR,jlev,  &
               llimplemented,nip1,FlipLatitude,statevector,zes,ztv,zgz,zhu)
          if(.not.llimplemented) exit

          IERR  = VFSTECR(ZLOWVAR,zwork,inpak_inc  &
             ,nulfile,datestamp,ndeet,npas,statevector%ni,statevector%nj,1,nip1  &
             ,nip2,nip3,cltypinc,cppcvar(jvar),cletiket,cgrtyp,nig1  &
             ,nig2,nig3,nig4,nidatyp,.true.)

          if(nip1.eq.0) exit

        enddo

      enddo

      ierr =  fstfrm(nulfile)
      ierr =  fclos(nulfile)        

      write(*,*) 'END of writeIncrement'

    END SUBROUTINE writeIncrement


    subroutine lq2esgd(pesinc,statevector,statevectorg)
      !
      !**S/R lq2esgd  -  Computes increments of ES=T-TD FROM T AND lnq
      !                  increments in Grid-Point Space.
      !
      !Arguments:
      !
      ! Out:
      !      pesinc : Dew-point depression increment on the analysis grid
      ! IN:
      !      statevector    : increment
      !      statevectorg   : Background state on analysis grid
      !
      !Object:   For Postprocessing analysis increment (called by DIAG3DVAR):
      !          calculate the TLM OF dew point depression from TLM specific
      !          humidity, temperature and pressure.  No ice phase is
      !          CONSIDERED.
      !
      IMPLICIT NONE
      type(struct_gsv) :: statevector,statevectorg
      real*8 pesinc(:,:,:)
      integer ji,jj,jk,nlev
      REAL*8 ZE, ZEL, ZTD, ZTDL, ZGAMMA, zpres
      real*8, pointer :: ps_trl_ptr(:,:,:,:),ps_inc_ptr(:,:,:,:),hu_trl_ptr(:,:,:,:),hu_inc_ptr(:,:,:,:),tt_inc_ptr(:,:,:,:)

      WRITE(*,FMT='(/,4X,"Starting LQ2ESGD",//)')
      ps_trl_ptr => gsv_getField(statevectorg,'P0')
      ps_inc_ptr => gsv_getField(statevector ,'P0')
      hu_trl_ptr => gsv_getField(statevectorg,'HU')
      hu_inc_ptr => gsv_getField(statevector ,'HU')
      tt_inc_ptr => gsv_getField(statevector ,'TT')

      nlev = gsv_getNumLev(statevectorg)
!$OMP PARALLEL DO PRIVATE(jk,jj,ji,zpres,ze,zel,ztd,zgamma,ztdl)
      do jj=1,statevectorg%nj
        do jk=1,nlev
          do ji=1,statevectorg%ni
            zpres  = statevectorg%vco%da_M(jk) + statevectorg%vco%db_M(jk)*ps_trl_ptr(ji,1,jj,1)
            !
            ! First do the forward branch to get saturated vapour pressure from q
            !
            ZE = FOEFQ8(max(hu_trl_ptr(ji,jk,jj,1),1.d-12), zpres)
            !
            ! TLM of the saturated vapor pressure from q (specific humidity)
            !
            ZEL = FOEFQL(hu_inc_ptr(ji,jk,jj,1),ps_inc_ptr(ji,1,jj,1),  &
                         hu_trl_ptr(ji,jk,jj,1),zpres,statevectorg%vco%dhyb_m(jk))
            !
            ! TLM of the dewpoint temperature calculation from Teten's relation
            !
            ZTD=FOTW8(ZE)
            ZGAMMA=FODTW8(ZTD,ZE)
            ZTDL = ZGAMMA*ZEL

            pesinc(ji,jk,jj) = tt_inc_ptr(ji,jk,jj,1) - ZTDL

          enddo
        enddo
      enddo
!$OMP END PARALLEL DO

    END subroutine lq2esgd


    subroutine lt2tvgd(ptv,statevector,statevectorg)
      !
      ! s/r lt2tvgd: TL transform from delT to delTv
      !
      IMPLICIT NONE
      type(struct_gsv) :: statevector,statevectorg
      real*8  ptv(:,:,:)
      real*8, pointer :: hu_trl_ptr(:,:,:,:),tt_inc_ptr(:,:,:,:),hu_inc_ptr(:,:,:,:)
      integer ji,jj,jk,nlev

      WRITE(*,FMT='(/,4X,"Starting LT2TVGD",//)')
      hu_trl_ptr => gsv_getField(statevectorg,'HU')
      tt_inc_ptr => gsv_getField(statevector ,'TT')
      hu_inc_ptr => gsv_getField(statevector ,'HU')

      nlev = gsv_getNumLev(statevector)
!$OMP PARALLEL DO PRIVATE(jj,jk,ji)
      do jj = 1, statevector%nj
        do jk = 1, nlev
          do ji = 1, statevector%ni
            ptv(ji,jk,jj)=(1.D0+MPC_DELTA_R8*hu_trl_ptr(ji,jk,jj,1))*tt_inc_ptr(ji,jk,jj,1) +  &
                MPC_DELTA_R8*hu_trl_ptr(ji,jk,jj,1)*tt_inc_ptr(ji,jk,jj,1)*hu_inc_ptr(ji,jk,jj,1)
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO

    END subroutine lt2tvgd


    SUBROUTINE ltt2phigd(pgz,ptt,statevectorg)
      !
      !**s/r ltt2phigd  - Grid-point version of ltt2phi.ftn
      !
      !Arguments
      !     in-
      !   ptt    : 4D Temperature Incr. appearing on r.h.s. of TL-eq.
      !     out-
      !   pgz    : 4D GZ fields computed from TL-Hydrostatic equation

      IMPLICIT NONE

      type(struct_gsv) :: statevectorg
      real*8 pgz(:,:,:)
      real*8 ptt(:,:,:)

      real*8, allocatable :: vma(:),vmb(:),vmc(:),vmd(:),vme(:),vmf(:)
      INTEGER JLEV, JLAT, JLON, NLEV
      real*8  zalpha
      real*8, allocatable :: zprof(:)
      real*8, pointer :: ps_ptr(:,:,:,:), zpres3d_ptr(:,:,:)
      real*8, pointer :: zps2d(:,:) 
      integer status

      WRITE(*,FMT='(/,4X,"Starting LTT2PHIGD",//)')

      nlev = gsv_getNumLev(statevectorg)
      zalpha=-1.0D0

      allocate(vma(nlev))
      allocate(vmb(nlev))
      allocate(vmc(nlev))
      allocate(vmd(nlev))
      allocate(vme(nlev))
      allocate(vmf(nlev))
      allocate(zprof(nlev))
      !
      ! Prepare r.h.s. for TL-Hydrostatic equation
      !
      ps_ptr => gsv_getField(statevectorg,'P0')
      zps2d => ps_ptr(:,1,:,1)
      status=vgd_levels(statevectorg%vco%vgrid,  &
                        ip1_list=statevectorg%vco%ip1_M,  &
                        levels=zpres3d_ptr,sfc_field=zps2d,in_log=.false.)
      if(status.ne.VGD_OK)then
        call abort3d('ERROR with vgd_levels for desired levels ')
      endif

      do jlat = 1, statevectorg%nj
        do jlon = 1, statevectorg%ni
          do jlev = 1,nlev
            zprof(jlev) = zpres3d_ptr(jlon,jlat,jlev)
          enddo
          call matapat(zprof,zalpha,nlev,vma,vmb,vmc,vmd,vme,vmf)
          call lvtapgd(pgz,ptt,jlon,jlat) 
        enddo
      enddo

      deallocate(vma)
      deallocate(vmb)
      deallocate(vmc)
      deallocate(vmd)
      deallocate(vme)
      deallocate(vmf)
      deallocate(zprof)

      RETURN

      CONTAINS

      subroutine lvtapgd(pgz,ptt,ki,kj)
        !S/P LVTAPGD:
        !
        !         CALCULE Y A PARTIR DE R PAR SOLUTION DE L'EQUATION R*CON=S**E*D(Y)
        !         AVEC UN SCHEME DU 4EME ORDRE DU A J. COTE.
        !         NOTE: CET ALGORITHME EST EXACTEMENT REVERSIBLE (VOIR VPAT).
        !
        !         ON DOIT FOURNIR LA COND
        !         A LA LIMITE INF. Y(N). LA MATRICE MATAP A ETE CALCULEE DANS LA
        !         SUBR. MATAPAT.
        !
        IMPLICIT NONE
        integer ki,kj

        INTEGER  IKLEVM2, JK, IK
        REAL*8    ZAK, ZBK, ZCK, ZCON
        real*8    pgz(:,:,:)
        real*8    ptt(:,:,:)
        !
        ! ptt : working vector of virtual temperatures.
        !
        ZCON = -MPC_RGAS_DRY_AIR_R8
        ZAK = -2.0D0*ZCON*VMA(nlev)
        ZBK = -2.0D0*ZCON*VMB(nlev)
        ZCK = -2.0D0*ZCON*VMC(nlev)
        pgz(ki,nlev,kj) = 0.0D0
        pgz(ki,nlev-1,kj)=ZAK*ptt(ki,nlev-1,kj)+  &
            ZBK*ptt(ki,nlev,kj)+  &
            ZCK*ptt(ki,nlev-2,kj)+  &
            pgz(ki,nlev,kj)

        IKLEVM2 = nlev-2
        do JK = 1, IKLEVM2
          IK = nlev-1-JK
          ZAK = -2.0D0*ZCON*VMA(IK+1)
          ZBK = -2.0D0*ZCON*VMB(IK+1)
          ZCK = -2.0D0*ZCON*VMC(IK+1)
          pgz(ki,ik,kj)= ZAK*ptt(ki,IK,kj)+  &
              ZBK*ptt(ki,IK+1,kj)+  &
              ZCK*ptt(ki,IK+2,kj)+  &
              pgz(ki,IK+2,kj)
        enddo

      END SUBROUTINE lvtapgd

    END subroutine ltt2phigd


    SUBROUTINE GDOUT2(varName,pptrans,KLEV,lplok,kip1,FlipLatitude,statevector,zes,ztv,zgz,zhu)
      !
      !**s/r GDOUT2  - Transfer of the content of COMGD0 on a RPN
      !     .          standard file.
      !
      !Arguments
      !     i   varName : variable name
      !     i   KLEV    : index of the level to be transferred
      ! OUTPUT
      !     o   pptrans : vector containing the variable
      !     o   lplok   : logical indicating if the variable has been
      !                   implemented
      !     o   kip1    : ip1 of the corresponding level

      IMPLICIT NONE
      INTEGER klev,kip1
      type(struct_gsv) :: statevector
      real*8, pointer :: field_ptr(:,:,:,:)
      real*8 :: pptrans(:,:)
      real*8 :: zes(:,:,:)
      real*8 :: ztv(:,:,:)
      real*8 :: zgz(:,:,:)
      real*8 :: zhu(:,:,:)
      character(len=*) :: varName
      logical lplok, FlipLatitude

      INTEGER JLON, JGL
      REAL*8 ZTEMP, ZGEOP, ZDAM, ZCON

      kiP1      =  statevector%vco%ip1_M(klev)
      !
      lplok = .true.
      !
      IF(trim(varName).EQ.'VT') THEN
        !
        ! Virtual temperature field
        !
        DO JLON = 1, statevector%ni
          DO JGL = 1, statevector%nj
            PPTRANS(JLON,JGL) = ZTV(JLON,KLEV,JGL)
          END DO
        END DO
      ELSE IF(trim(varName).EQ.'GZ') THEN
        !
        ! Geopotential field
        !
        ZGEOP  = 10.0d0 * RG
        ZDAM   = 1.0d0/ZGEOP
        DO JLON = 1, statevector%ni
          DO JGL = 1, statevector%nj
            PPTRANS(JLON,JGL) = ZDAM * zgz(JLON,KLEV,JGL)
          END DO
        END DO
      ELSE IF(trim(varName).EQ.'UU'.or.trim(varName).EQ.'VV') THEN
        !
        ! Wind component (in Knots)
        !
        field_ptr => gsv_getField(statevector,varName)
        DO JGL = 1, statevector%nj
          DO JLON = 1, statevector%ni
            PPTRANS(JLON,JGL) = field_ptr(JLON,KLEV,JGL,1)*MPC_KNOTS_PER_M_PER_S_R8
          END DO
        END DO
      ELSE IF(trim(varName).EQ.'ES') THEN
        !
        ! Humidity field
        !
        DO JLON = 1, statevector%ni
          DO JGL = 1, statevector%nj
            PPTRANS(JLON,JGL) = zes(JLON,KLEV,JGL)
          END DO
        END DO

      ELSE IF(trim(varName).EQ.'LQ') THEN
        field_ptr => gsv_getField(statevector,'HU')
        DO JLON = 1, statevector%ni
          DO JGL = 1, statevector%nj
            PPTRANS(JLON,JGL) = field_ptr(JLON,KLEV,JGL,1)
          END DO
        END DO

      ELSE IF(trim(varName).EQ.'HU') THEN
          DO JLON = 1, statevector%ni
            DO JGL = 1, statevector%nj
              PPTRANS(JLON,JGL) = zhu(JLON,KLEV,JGL)
            END DO
          END DO
      ELSE IF(trim(varName).EQ.'P0') THEN
        !
        ! Surface Pressure from units of Pascal to millibar
        !
        kip1=0
        field_ptr => gsv_getField(statevector,varName)
        DO JLON = 1, statevector%ni
          DO JGL = 1, statevector%nj
            PPTRANS(JLON,JGL) = field_ptr(JLON,1,JGL,1)*MPC_MBAR_PER_PA_R8
          END DO
        END DO
      else
        !
        ! All remaining 2D and 3D variables that do not require unit conversions
        !
        if(gsv_varExist(varName)) then
          field_ptr => gsv_getField(statevector,varName)
          if(vnl_vartypeFromVarname(varName).eq.'SF') then
            kip1=0
            do jlon = 1, statevector%ni
              do jgl = 1, statevector%nj
                pptrans(jlon,jgl) = field_ptr(jlon,1,jgl,1)
              enddo
            enddo
          else
            do jlon = 1, statevector%ni
              do jgl = 1, statevector%nj
                pptrans(jlon,jgl) = field_ptr(jlon,klev,jgl,1)
              enddo
            enddo
          endif
        else
          LPLOK = .FALSE.
          WRITE(*,*)' ****************************************'
          WRITE(*,'(" GDOUT2: THE FOLLOWING FIELD IS NOT SUPPORTED  varName= ",A2)')varName
          WRITE(*,*)' ****************************************'
        endif
      ENDIF

      IF (lplok .and. FlipLatitude) THEN
         DO JLON   = 1, statevector%ni
            DO JGL = 1, statevector%nj/2
               ZTEMP = pptrans(JLON,JGL)
               pptrans(JLON,JGL)                 = pptrans(JLON,statevector%nj-JGL+1)
               pptrans(JLON,statevector%nj-JGL+1)= ZTEMP
            end do
         end do
      END IF

    END subroutine gdout2


end module writeIncrement_mod
