      SUBROUTINE varout(kulfile,statevector,zes,ztv,zgz,zhu,num_iter)
#if defined (DOC)
*
***s/r varout  - Transfert of the content of COMGD0 on a RPN
*     .          standard file
*
*Author  : S. Pellerin *ARMA/AES  April 2000
*
#endif
C
      use MathPhysConstants_mod
      use gridStateVector_mod
      IMPLICIT NONE
      integer kulfile,num_iter
      type(struct_gsv) :: statevector
      real*8 :: zes(statevector%ni,statevector%nlev,statevector%nj)
      real*8 :: ztv(statevector%ni,statevector%nlev,statevector%nj)
      real*8 :: zgz(statevector%ni,statevector%nlev,statevector%nj)
      real*8 :: zhu(statevector%ni,statevector%nlev,statevector%nj)
      integer write_encode_hyb,vfstecr
      integer jvar,jlev,ierr
      integer ibrpstamp,inpak_inc
      real*8 zwork
      real   zptop4, zpref4,zrcoef4,zdummy
      integer nip1,nip2,nip3,ndeet,npas,nidatyp,nig1,nig2,nig3,nig4
      character(len=1)  :: cgrtyp
      character(len=2)  :: cltypinc
      character(len=12) :: cletiket
      real*8 :: zlowvar(statevector%ni,statevector%nj)
      logical llimplemented,llvarout
! previously from compost.cdk
      integer          NPPCVAR
      character(len=4)  :: CPPCVAR(20)
      character(len=12) :: CETIKINC
      logical lttout,lvtout,lhuout,lgzout
!
      WRITE(*,FMT='(/,4X,"Starting VAROUT",//)')
c
      if(kulfile.eq.0) then
        write(*,*) 'varout: unit number for rebm file not valid!'
        return
      endif

      call supost

      WRITE(*,FMT='(/,4X,''Transfer of the gridpoint model'',
     S     '' state on file at iteration No.'',I3)')
     S     num_iter
c
      ndeet=0
      NIP2       =  0
      NIP3       =  num_iter
      NPAS       =  0
      NIDATYP    =  1
      CGRTYP     = 'G'
      CLTYPINC   = 'R'
      NIG1       =  0
      NIG2       =  0
      NIG3       =  0
      NIG4       =  0
      cletiket=cetikinc
      ibrpstamp=gsv_getDateStamp(statevector)

      write(*,*) 'Writing fields for ibrpstamp= ',ibrpstamp
c
c ****************************************************************
c
      write(*,*) 'Writing variable HY on analysis-increment file'
c
      zptop4 = statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8
      zpref4 = statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8
      zrcoef4 = statevector%vco%drcf1
      ierr    = write_encode_hyb(kulfile,'HY',nip2,nip3,cletiket
     &              ,ibrpstamp,zptop4,zpref4,zrcoef4)
c
c-----Analysis grid hybride vertical coordinate parameters
c

      write(*,*)' '
      write(*,*)'************************************** '
      write(*,*)
     &     ' The hybride coordinate parameters from increment'
     &     ,' analysis  grid are:'
      write(*,*) ' PTOP = ',statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' PREF = ',statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' RCOEF= ',statevector%vco%drcf1
      write(*,*)'************************************** '
      write(*,*)' '
c
c-----Setup packing for each variable
c
      inpak_inc  = -32                  ! 32 bits are needed by AAI
      write(*,*)' '
      write(*,*)'************************************** '
      write(*,*)
      write(*,*) 'PACKING for increments   is ',inpak_inc
      write(*,*)' '
      write(*,*)'************************************** '
c
      do jvar = 1, nppcvar
c
c Some variable may be request for other to be computed but not
c necessaraly wanted as output..
c
        if(cppcvar(jvar).eq.'TT'.and..not.lttout) cycle
        if(cppcvar(jvar).eq.'HU'.and..not.lhuout) cycle
c
        llimplemented = .true.
c
        write(*,*) 'Writing variable ',cppcvar(jvar)
c
        do jlev=1,statevector%nlev
          call gdout2(cppcvar(jvar),ZLOWVAR,jlev,
     &         llimplemented,nip1,nig2,statevector,zes,ztv,zgz,zhu)
          if(.not.llimplemented) exit
c
          IERR  = VFSTECR(ZLOWVAR,zwork,inpak_inc
     &       ,kulfile,ibrpstamp,ndeet,npas,statevector%ni,statevector%nj,1,nip1
     &       ,nip2,nip3,cltypinc,cppcvar(jvar),cletiket,cgrtyp,nig1
     &       ,nig2,nig3,nig4,nidatyp,.true.)
c
          if(nip1.eq.0) exit
c
        enddo
c
      enddo
c
      write(*,*) 'END of VAROUT'
c
      RETURN

      CONTAINS

      SUBROUTINE SUPOST
***s/r SUPOST  - initialize the post-processing of the model state
*     .
*
*Author  : P. Gauthier *ARMA/AES  Sept. 20, 1993
*Revision: C. Charette *ARMA/AES  Jan 96
*     .       -Initialize RPN standard file parameters
*           C. Charette *ARMA/AES  Jan 96
*     .       -Documented the compulsary and diagnostic variables
*              available for each mode of execution of the 3dvar
*           L. Fillion *ARMA/MSC  Feb 05
*     .       -Include LAM4D limited area analysis option.
*           L. Fillion ARMA/EC May 2006: Mesovar upgrade to v10_0_0.
*           L. Fillion ARMA/EC 15 Aug 2007: LAM4D upgrade to v10_0_3.
*           L. Fillion ARMA/EC 31 May 2010: Improve output of LQ and HU.
*     .
*
      IMPLICIT NONE
      INTEGER JLEV, IERR,jvar,ihu,itt,ivt,imin,igz,ip0,ilq
      integer :: nulnam,fnom,fclos
      NAMELIST /NAMPOST/NPPCVAR,CPPCVAR,CETIKINC

      WRITE(*,FMT=9000)
 9000 FORMAT(//,1X,6("***********")
     S     ,/,6X,'SUPOST:  initialization of postprocessing'
     S     ,1X,6("***********"))
C
C*    1. Set default values
C
      CETIKINC = 'UNDEFINED***'
      NPPCVAR=6
      CPPCVAR(:) = '    '
      CPPCVAR(1) = 'UU'
      CPPCVAR(2) = 'VV'
      CPPCVAR(3) = 'TT'
      CPPCVAR(4) = 'LQ'
      CPPCVAR(5) = 'P0'
      CPPCVAR(6) = 'TG'
C
C*    2. Read the parameters from NAMPOST
C
 200  CONTINUE
C
      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      write(*,*) 'varout: reading namelist, ierr=',ierr
      read(nulnam,nml=nampost)
      write(*,nml=nampost)
      ierr=fclos(nulnam)
C
C*    3. Define the levels at which postprocessing is to occur
C
 300  CONTINUE
C
c reordering cppcvar for dependent variables in varout.ftn
c
      ip0 = 0
      ihu = 0
      itt = 0
      ivt = 0
      lttout = .false.
      lhuout = .false.
      lgzout = .false.
c
!
      do jvar = 1,nppcvar
        if(cppcvar(jvar).eq.'P0') then
          ip0 = jvar
        endif
        if(cppcvar(jvar).eq.'TT') then
          itt = jvar
          lttout = .true.
        endif
        if(cppcvar(jvar).eq.'GZ') then
          igz = jvar
          lgzout = .true.
        endif
        if(cppcvar(jvar).eq.'HU') then
          ihu = jvar
          lhuout = .true.
        endif
        if(cppcvar(jvar).eq.'VT') then
          ivt = jvar
          lvtout = .true.
        endif
        if(cppcvar(jvar).eq.'LQ') then
          ilq = jvar
        endif
      enddo
c
      if((lgzout.or.lvtout).and.ihu.eq.0) then
c Make sure that HU is part of the list
        ihu = nppcvar+1
        cppcvar(ihu) = 'HU'
        nppcvar = ihu
      endif
c
      if(ihu.ne.0) then
c Make sure that TT is part of the list
        imin = min(itt,ihu)
        if (imin.eq.0) then
c TT is not requested: put it in the list before HU
          cppcvar(ihu) = 'TT'
          cppcvar(nppcvar+1) = 'HU'
          nppcvar = nppcvar + 1
        else
C TT is requested: make sure that TT is before HU in the list
          cppcvar(max(itt,ihu)) = 'HU'
          cppcvar(imin) = 'TT'
        endif
      endif
c
      if(ip0 .gt. 1) then
        do jvar = ip0, 2,-1
          cppcvar(jvar) = cppcvar(jvar -1)
        enddo
        cppcvar(1) = 'P0'
      endif
C
C*     4. Print the values
C
 400  CONTINUE
C
      DO jvar = 1, NPPCVAR
        WRITE(*,FMT='(4X,"VAR NO.",I3,":",2X,"CPPCVAR= ",A5)')
     S        jvar,CPPCVAR(jvar)
      ENDDO
      RETURN
      END SUBROUTINE SUPOST

      END SUBROUTINE VAROUT
