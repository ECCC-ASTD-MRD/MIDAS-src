!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Fill tangent linear profiles structure by interpolating 
!!            contents of columnData to RTTOV space
!!
!! @author j. halle *cmda/aes  april 12, 2005
!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                 -add ozone from climatology to all sensors
!
!revision 002  : j. halle  *cmda/smc  march 2007
!                 -fix zvlev for hybrid coordinate
!revision 003  : S. Heilliette septembre 2011
!                 -adapt to rttv-10
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
subroutine tovs_fill_profiles_tl(column,columng)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use obsSpaceData_mod
  use columnData_mod
  use tovs_extrap_mod
  use rttov_const ,only : gas_unit_specconc
  use parkind1, Only : jpim     ,jprb
  use presProfileOperators_mod
  use utilities_mod
  implicit none

  type(struct_columnData) :: column,columng

  type(struct_vco), pointer :: vco_anl
  integer, allocatable :: iptobs    (:) 
  integer, allocatable :: iptobscma (:) 

  integer :: alloc_status(15)
  logical :: diagTtop,TopAt10hPa
  integer :: omp_get_num_threads, nthreads
  integer :: istride, ilen, imodulo
  integer :: nlevels,nobmax
  integer :: j, i, sensor_id, iobs, jj, stat
  integer :: ilowlvl_M,ilowlvl_T,count_profile,header_index,nlv_M,nlv_T
  integer :: jk, jn, jl
  integer :: status, Vcode

  real(8), allocatable :: to_tl    (:,:)
  real(8), allocatable :: lqo_tl   (:,:)
  real(8), allocatable :: toext_tl (:,:)
  real(8), allocatable :: qoext_tl (:,:)
  real(8), allocatable :: zvlev    (:,:)
  real(8), allocatable :: dPdPs    (:,:)
  real(8), allocatable :: zt_tl    (:,:)
  real(8), allocatable :: zlq_tl   (:,:)
  real(8), allocatable :: zt       (:,:)
  real(8), allocatable :: zlq      (:,:)
  real(8), allocatable :: qoext    (:,:)
  real(8), allocatable :: zps_tl   (:)
  real(8), allocatable :: xpres    (:)

  real(8) :: zptop, zptopmbs
  real(8), pointer :: delTT(:), delLQ(:), TTb(:), HUb(:), Pres(:)

  if(TVS_NOBTOV==0) return    ! exit if there are not tovs data
  write(*,*) "Debut de tovs_fill_profiles_tl "

  !     1.    Set index for model's lowest level and model top
  !     .     ------------------------------------------------

  nlv_M = col_getNumLev(columng,'MM')
  nlv_T = col_getNumLev(columng,'TH')

  if (  col_getPressure(columng,1,1,'TH') < col_getPressure(columng,nlv_T,1,'TH') ) then
     ilowlvl_M = nlv_M
     ilowlvl_T = nlv_T
  else
     ilowlvl_M = 1
     ilowlvl_T = 1
  endif

  vco_anl => col_getVco(columng)
  status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode)
  diagTtop = (Vcode==5002)

  nlevels=coefs(1) %coef%  nlevels
  allocate (xpres(nlevels))
  xpres(1:nlevels) = coefs(1)% coef % ref_prfl_p(1:nlevels)

  ! find model level top, within 0.000001 mbs.
  zptop    = col_getPressure(columng,1,1,'TH')
  zptopmbs = zptop/100.d0
  zptopmbs = zptopmbs - 0.000001d0

  TopAt10hPa = ( abs( zptopmbs - 10.0d0 ) <= .1d0 )

  jpmotop = 1
  do jl = 2, nlevels
     if ( zptopmbs >= xpres(jl-1) .and.       &
          zptopmbs < xpres(jl)        ) then
        jpmotop = jl
        exit
     endif
  enddo
  jpmolev = (nlevels-jpmotop+1)

!     1.1   Number of threads and memory allocation
!     .     ---------------------------------------

!$omp parallel 
  nthreads = omp_get_num_threads()
!$omp end parallel

!
!     2.  Fill profiles structure
!     .   -----------------------
! loop over all instruments
  sensor_loop: do sensor_id=1,tvs_nsensors
     ! loop over all obs.
     count_profile = 0
     xpres(1:nlevels) = coefs(sensor_id)% coef % ref_prfl_p(1:nlevels)

     obs_loop1: do iobs = 1,TVS_NOBTOV
        if (tvs_lsensor(iobs)/=sensor_id) cycle obs_loop1
        NOBMAX=iobs
        count_profile =count_profile +1
     enddo obs_loop1

     if (count_profile == 0) cycle sensor_loop

     alloc_status(:) = 0
     allocate (iptobs    (count_profile)          ,stat= alloc_status(1) )
     allocate (iptobscma (count_profile)          ,stat= alloc_status(2) )
     allocate (to_tl     (jpmolev,count_profile)  ,stat= alloc_status(3) )
     allocate (lqo_tl    (jpmolev,count_profile)  ,stat= alloc_status(4) )
     allocate (toext_tl  (nlevels  ,count_profile),stat= alloc_status(5) )
     allocate (qoext_tl  (nlevels  ,count_profile),stat= alloc_status(6) )
     allocate (zvlev     (nlv_T,count_profile)    ,stat= alloc_status(7) )
     allocate (dPdPs     (nlv_T,count_profile)    ,stat= alloc_status(8) )
     allocate (zt_tl     (nlv_T,count_profile)    ,stat= alloc_status(9) )
     allocate (zlq_tl    (nlv_T,count_profile)    ,stat= alloc_status(10))
     allocate (zt        (nlv_T,count_profile)    ,stat= alloc_status(11))
     allocate (zlq       (nlv_T,count_profile)    ,stat= alloc_status(12))
     allocate (qoext     (nlevels,count_profile)  ,stat= alloc_status(13))
     allocate (zps_tl    (count_profile)          ,stat= alloc_status(14))

     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_fill_profiles_tl : memory allocation error'
        call utl_abort('tovs_fill_profiles_tl')
     end if
    
     iptobs   (:) = 0 
     iptobscma(:) = 0 
     toext_tl (:,:) = 0.0d0
     zvlev    (:,:) = 0.0d0
     dPdPs    (:,:) = 0.0d0
     zt_tl    (:,:) = 0.0d0
     zlq_tl   (:,:) = 0.0d0
     zt       (:,:) = 0.0d0
     zlq      (:,:) = 0.0d0
     qoext    (:,:) = 0.0d0
     zps_tl   (:)   = 0.0d0
     to_tl    (:,:) = 0.0d0
     lqo_tl   (:,:) = 0.0d0

     count_profile = 0

     obs_loop2: do iobs = 1, NOBMAX
        if (tvs_lsensor(iobs)/=sensor_id) cycle obs_loop2

        header_index = tvs_lobsno(iobs)

        count_profile = count_profile + 1

        zps_tl  (count_profile) = col_getElem(column,1,header_index,'P0')*MPC_MBAR_PER_PA_R8
        delTT => col_getColumn(column,header_index,'TT')
        delLQ => col_getColumn(column,header_index,'HU')
        TTb => col_getColumn(columng,header_index,'TT')
        HUb => col_getColumn(columng,header_index,'HU')
        Pres => col_getColumn(columng,header_index,'PR','TH')
        do jl = 1, nlv_T
           zt_tl (jl,count_profile) = delTT(jl)
           zlq_tl(jl,count_profile) = delLQ(jl)
           zt   (jl,count_profile)  = TTb(jl)
           zlq  (jl,count_profile)  = HUb(jl)
           zvlev(jl,count_profile)  = Pres(jl) *MPC_MBAR_PER_PA_R8
           dPdPs(jl,count_profile)  = col_getPressureDeriv(columng,jl,header_index,'TH')
        enddo

        ! Fix pour eviter probleme au toit avec GEM 4
        ! (grosse varibilite temperature au dernier niveau thermo due 
        !  a l'extrapolation utilisee)
        if ( diagTtop ) then
           zt_tl   (1,count_profile) =  0.d0
           zlq_tl  (1,count_profile) =  0.d0
           zt   (1,count_profile) =  zt   (2,count_profile) + mesosphere_lapse_rate *  &
                log( col_getPressure(columng,1,header_index,'TH') /  &
                col_getPressure(columng,2,header_index,'TH') )
           zlq  (1,count_profile) =  zlq  (2,count_profile)
        endif

        iptobs   (count_profile) = iobs
        iptobscma(count_profile) = header_index


     enddo obs_loop2
 
!     .  2.1  Vertical interpolation of model temperature and logarithm of
!             specific humidity to pressure levels required by tovs rt model
!     .       --------------------------------------------------------------

     do jn = 1, count_profile
        qoext(1:nlevels,jn) =  profiles(iptobs(jn)) % q(1:nlevels) !/ q_mixratio_to_ppmv
     enddo
  
     to_tl (:,:) = 0.0d0
     lqo_tl(:,:) = 0.0d0
     imodulo = mod(count_profile,nthreads)
     if ( imodulo == 0 ) then
        istride = max(1,(count_profile/nthreads))
     else
        istride = max(1,(count_profile/nthreads)+1)
     endif
!$omp parallel do private(jn,ilen)
     do jn=1,count_profile,istride
        ilen = min (count_profile-jn+1,istride)
        if ( ilen .gt. 0) then

           call ppo_IntAvgTl(zvlev(:,jn:jn+ilen-1),dPdPs(:,jn:jn+ilen-1),zt_tl(:,jn:jn+ilen-1),zt(:,jn:jn+ilen-1), &
                zps_tl(jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),to_tl(:,jn:jn+ilen-1))
           call ppo_IntAvgTl(zvlev(:,jn:jn+ilen-1),dPdPs(:,jn:jn+ilen-1),zlq_tl(:,jn:jn+ilen-1),zlq(:,jn:jn+ilen-1), &
                zps_tl(jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),lqo_tl(:,jn:jn+ilen-1))

        endif
     enddo
!$omp end parallel do

!     .  2.2  Extrapolation of temperature profile above 10mb
!     .       -----------------------------------------------
     toext_tl(:,:) = 0.0d0
     if ( .not. TopAt10hPa ) then
        do jn = 1, count_profile
           toext_tl(jpmotop:nlevels,jn)=to_tl(1:jpmolev,jn)
           toext_tl(1:jpmotop-1,jn)=0.d0
        enddo
     else
        call lextrap (to_tl,toext_tl,jpmolev,nlevels,count_profile)
     endif
     


        !     .  2.3  Extrapolation of humidity profile (kg/kg)
        !             above rlimlvhu (normally 300mbs or 70mbs)
        !     .       -----------------------------------------

     qoext_tl(:,:) = 0.0d0
     
     do jn = 1, count_profile
        do jk = 1, jpmotop-1
           qoext_tl(jk,jn) = 0.d0
        enddo
        do jk = 1, jpmolev
           qoext_tl(nlevels-jpmolev+jk,jn) = qoext(nlevels-jpmolev+jk,jn)*lqo_tl(jk,jn)
        enddo
     enddo
     
     if ( TopAt10hPa ) then
        if ( ldbgtov ) then
           do jn = 1, count_profile
              write(*,*)'qoext_tl*1000 avant exthum4    = '
              write(*,9263)(qoext_tl(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
        call lexthum4 (count_profile,nlevels,xpres(1:nlevels),qoext_tl,qoext)
        if ( ldbgtov ) then
           do jn = 1, count_profile
              write(*,*)'qoext_tl*1000 apres exthum4    = '
              write(*,9263)(qoext_tl(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
9263    format(1x,10f8.4)
     endif

        !     .  2.4  Fill profiles_tl structure
        !     .       --------------------------

     do  j = 1 , count_profile
        jj=iptobs(j)
        profiles_tl(jj) % gas_units       = gas_unit_specconc ! all gas profiles are supposed to be provided in kg/kg
        profiles_tl(jj) % nlevels         =  nlevels
        profiles_tl(jj) % nlayers         =  nlevels - 1
        if(coefs(sensor_id)%coef%nozone > 0) then
           profiles_tl(jj) % o3(:)        =  0.d0
        endif
        profiles_tl(jj) % ctp             = 0.0d0
        profiles_tl(jj) % cfraction       = 0.0d0
        profiles_tl(jj) % zenangle        = 0.0d0
        profiles_tl(jj) % azangle         = 0.0d0
        profiles_tl(jj) % skin % surftype = 0
        profiles_tl(jj) % skin % t        = col_getElem(column,1,iptobscma(j),'TG')
        profiles_tl(jj) % skin % fastem(:)= 0.0d0
        profiles_tl(jj) % skin % salinity = 0.0d0
        profiles_tl(jj) % s2m % t         = col_getElem(column,ilowlvl_T,iptobscma(j),'TT')

           !! The following line has been commented out because qoext(ilowlvl_T,j) may be out of bound
!!!        profiles_tl(jj) % s2m % q         = qoext(ilowlvl_T,j) * col_getElem(column,ilowlvl_T,iptobscma(j),'HU') * q_mixratio_to_ppmv
   !! The right code should be
        !!profiles_tl(jj) % s2m % q         = exp(gomq1(ilowlvl_T,iptobscma(j))) * pgomq_tl(ilowlvl_T,iptobscma(j)) * q_mixratio_to_ppmv
   !! but since the logical flag 'use_q2m' is set to .false. in rttov_const.F90 (in RTTOV code)
   !! this variable profiles_tl(jj) % s2m % q is not used so it can be set to 0
        profiles_tl(jj) % s2m % q         = 0.d0

        profiles_tl(jj) % s2m % p         = col_getElem(column,1,iptobscma(j),'P0')*MPC_MBAR_PER_PA_R8
        profiles_tl(jj) % s2m % u         = col_getElem(column,ilowlvl_M,iptobscma(j),'UU')
        profiles_tl(jj) % s2m % v         = col_getElem(column,ilowlvl_M,iptobscma(j),'VV')
        
        profiles_tl(jj) % p(1:nlevels)    = 0.d0
        profiles_tl(jj) % t(1:nlevels)    = toext_tl(1:nlevels,j)
        profiles_tl(jj) % q(1:nlevels)    = qoext_tl(1:nlevels,j) !* q_mixratio_to_ppmv

     end do

     alloc_status(:) = 0
     deallocate (iptobs    ,stat= alloc_status(1) )
     deallocate (iptobscma ,stat= alloc_status(2) )
     deallocate (to_tl     ,stat= alloc_status(3) )
     deallocate (lqo_tl    ,stat= alloc_status(4) )
     deallocate (toext_tl  ,stat= alloc_status(5) )
     deallocate (qoext_tl  ,stat= alloc_status(6) )
     deallocate (zvlev     ,stat= alloc_status(7) )
     deallocate (dPdPs     ,stat= alloc_status(8) )
     deallocate (zt_tl     ,stat= alloc_status(9) )
     deallocate (zlq_tl    ,stat= alloc_status(10))
     deallocate (zt        ,stat= alloc_status(11))
     deallocate (zlq       ,stat= alloc_status(12))
     deallocate (qoext     ,stat= alloc_status(13))
     deallocate (zps_tl    ,stat= alloc_status(14))

     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_fill_profiles_tl : memory deallocation error'
        call utl_abort('tovs_fill_profiles_tl')
     end if

  enddo sensor_loop

  deallocate (xpres     ,stat= alloc_status(1))
  if( alloc_status(1) /= 0)  then
     write(*,*) ' tovs_fill_profiles_tl : memory deallocation error'
     call utl_abort('tovs_fill_profiles_tl        ')
  end if

  !     3.  Close up
  !     .   --------

contains

  SUBROUTINE LEXTHUM4(KNPF,KLAPF,PPRES,PAV,PAV5)
    !
    !**** *lexthum4* - tangent linear of extrapolaatione upper level humidity profil!.
    !                 (adapted from exthumtl by J. Eyre)
    !
    !     purpose.
    !     --------
    !          to extend mixing ratio profile into stratosphere in
    !          a reasonable way.
    !
    !**   interface.
    !     ----------
    !          *call* *lexthum4(knpf,klapf,ppres,pav,pav5)*
    !               *knpf*:  no. of profiles to be processed.
    !               *klapf*: length of atm. profiles.
    !               *ppres*: pressure levels of atm. profiles.
    !               *pav*:   gradient humidity profiles.
    !               *pav5*:  humidity profiles.
    !
    !     method.
    !     -------
    !          take top tropospheric mixing ratio (e.g. near 300 mb) and
    !          extrapolate with given fall off into lower stratosphere
    !          (e.g. to 70 mb).  constrain mixing ratio to be >= zwmin
    !          (e.g. 0.000003 kg/kg).   in upper strat, mixing ratio = zwmin.
    !
    !     externals.
    !     ----------
    !          none.
    !
    !     reference.
    !     ----------
    !          ecmwf tech mem 176.
    !

    use MathPhysConstants_mod
    use obsFilter_mod
    IMPLICIT none
    !
    integer :: klapf, knpf
    REAL(8) PPRES(*),PAV(KLAPF,*),PAV5(KLAPF,*)
    !
    REAL(8) :: ZPRES3(KLAPF)
    !
    real(8) zwb5,zwb
    real(8) ,parameter :: ZP1 = 70.0D0  ! PRESS LIMITS (IN HPA) OF REGION  to be extrapolated
    integer :: inlvw,j,jnpf,ierr

    !
    !
    !*         1.   extrapolate humidity profile.
    !               ----------- -------- -------

    !
    !          find top level of given profile
    DO J=KLAPF,1,-1
       IF (PPRES(J)<FILT_RLIMLVHU) THEN
          INLVW=J
          GOTO 120
       ENDIF
    end do
    !
    !** Null extrapolation case
    !
    RETURN
    !
    !          constants defining p**3 fall off around tropopause
120 DO J=1,INLVW
       ZPRES3(J)=(PPRES(J)/PPRES(INLVW+1))**3
    end do
    !
    DO JNPF=1,KNPF
       ZWB =PAV (INLVW+1,JNPF)
       ZWB5=PAV5(INLVW+1,JNPF)
       DO J=1,INLVW
          IF (PPRES(J)<ZP1) THEN
             PAV(J,JNPF)=0.D0
          ELSE
             IF ( ZWB5*ZPRES3(J) <= MPC_MINIMUM_HU_R8 ) THEN
                PAV(J,JNPF)=0.D0
             ELSE
                PAV(J,JNPF)=ZWB*ZPRES3(J)
             ENDIF
          ENDIF
       end do
    end do
   
  END SUBROUTINE LEXTHUM4

end subroutine tovs_fill_profiles_tl
