!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE SETERRGPSRO(lcolumnhr,lobsSpaceData)
#if defined (DOC)
*
***s/r SETERRGPSRO - Computation of the estimated errors for GPSRO observations
*
*
*Author  : J. M. Aparicio Apr 2008
*    -------------------
**    Purpose:
*
*Arguments
*     None
*
#endif
      use MathPhysConstants_mod
      use stag_shared, only : tg_vco_trl,tg_vgrid_trl
      use modgps04profile
      use modgps05refstruct
      use modgps06gravity
      use modgps07geostruct
      use modgps08refop
      use obsSpaceData_mod
      use columnData_mod 
      IMPLICIT NONE
*implicits
#include "pardim.cdk"
#include "comdim.cdk"
#include "comgem.cdk"
#include "comdimo.cdk"
#include "comlun.cdk"
#include "comct0.cdk"
#include "comgpsro.cdk"
*
      type(struct_columnData) :: lcolumnhr
      type(struct_obs) :: lobsSpaceData
      REAL*8 PJO, PJOB, PJOM, PJOX, PJO1
C
      REAL*8 ZTODEG
      REAL*8 ZLAT, Lat
      REAL*8 ZLON, Lon
      REAL*8 ZETA(JPNFLEV)
      REAL*8 ZPP (JPNFLEV),ZDP (JPNFLEV)
      REAL*8 ZTT (JPNFLEV)
      REAL*8 ZHU (JPNFLEV)
      REAL*8 ZGZ (JPNFLEV)
      REAL*8 ZP0
      REAL*8 ZPT, ZPR, ZCF
      REAL*8 ZMT
      REAL*8 DH,DDH
      REAL*8 HNH1, ZOBS, SUM0, SUM1
C
      REAL*8 ZMHX
C
      INTEGER IDATYP
      INTEGER JL, JH, NGPSLEV
C
      LOGICAL  ASSIM, LSTAG

      INTEGER NH, NH1, IERR
      TYPE(GPSPROFILE)           :: PRF 
      REAL(DP)     , ALLOCATABLE :: H   (:), HGT(:)
      REAL(DP)     , ALLOCATABLE :: ZOFF(:),ZERR(:)
      TYPE(GPSDIFF), ALLOCATABLE :: RSTV(:)

      integer, dimension(:), allocatable :: list_header, list_body
      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body

      WRITE(NULOUT,*)'ENTER SETERRGPSRO'
C
      LSTAG = .FALSE.
      if (tg_vco_trl%iversion .eq. 5002) then
        LSTAG = .TRUE. 
        WRITE(NULOUT,*)'VERTICAL COORD OF TRIAL FIELDS IS STAGGERED'
        WRITE(NULOUT,*)'VCODE= ',tg_vco_trl%iversion,' LSTAG= ',LSTAG
        WRITE(NULOUT,*)'!!!!!!!!! CAUTION !!!!!!!!!!!!'
        WRITE(NULOUT,*)'STAGGERING NOT YET IMPLEMENTED IN DERIVATIVES'
      else
        WRITE(NULOUT,*)'VERTICAL COORD OF TRIAL FIELDS IS NOT STAGGERED'
        WRITE(NULOUT,*)'VCODE= ',tg_vco_trl%iversion,' LSTAG= ',LSTAG
      endif
C
C     * 1.  Initializations
C     *     ---------------
C
      ZTODEG = 180.0 / RPI
C
C     *    .   1.1  Eta vector
C     *    .        ----------
C
      NGPSLEV=LCOLUMNHR%NLEV
      DO JL = 1, LCOLUMNHR%NLEV
         ZETA(JL) = LCOLUMNHR%VHYB_T(JL)
      ENDDO
C
C*    *        1.2 Read the NAMELIST NAMGGPSRO
C     *       ---------------------------------------
      CALL READNML('NAMGPSRO',IERR)
      write(NULOUT,*)'NAMGPSRO',SURFMIN,HSFMIN,HTPMAX,BGCKBAND

      allocate(list_header( obs_num_stn     (lobsSpaceData) ))
      allocate(list_body  ( obs_num_obstotal(lobsSpaceData) ))

      !
      ! loop over all header indices of the 'RO' family
      !
      call obs_getHeaderIndices(lobsSpaceData, 'RO', list_header,
     &                          size_list_header)
      do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)
C     
C     *  Process only refractivity data (codtyp 169)
C
         IDATYP = MOD(obs_elem_i(lobsSpaceData,'ITY ',INDEX_HEADER),1000)
         IF ( IDATYP .EQ. 169 ) THEN
            ASSIM = .FALSE.
C
C           Scan for requested assimilations, and count them
C
            NH = 0

            !
            ! loop over all body indices (still in the 'RO' family)
            !
            call obs_getBodyIndices(lobsSpaceData, index_header, list_body,
     &                              size_list_body)
            do index_list_body = 1, size_list_body
               index_body = list_body(index_list_body)
               HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',index_body)
               IF ( HNH1.GE.0. .AND. HNH1.LE.HTPMAX ) THEN
                  ASSIM = .TRUE.
                  NH = NH + 1
               ENDIF
            ENDDO
C
C     *     If assimilations are requested, apply the observation operator
C
            IF (ASSIM) THEN
C     
C     *        Profile at the observation location:
C
               Lat  = obs_elem_r4(lobsSpaceData,'LAT ',INDEX_HEADER)
               Lon  = obs_elem_r4(lobsSpaceData,'LON ',INDEX_HEADER)
               ZLAT = Lat * ZTODEG
               ZLON = Lon * ZTODEG
                     ZP0 = lcolumnhr%ps(1,INDEX_HEADER)
               DO JL = 1, LCOLUMNHR%NLEV
C
C     *           Profile x
C
                  ZPP(JL) = LCOLUMNHR%RPPOBS_T(JL,INDEX_HEADER)
CCCCCCCCCCC          THIS IS ONLY A DUMMY IMPLEMENTATION OF ZDP (dP/dP0)
                  ZDP(JL) = ZPP(JL)/ZP0
                  ZTT(JL) = lcolumnhr%tt(JL,INDEX_HEADER)-273.15
                  ZHU(JL) = lcolumnhr%hu(JL,INDEX_HEADER)
                  ZGZ(JL) = lcolumnhr%gz_T(JL,INDEX_HEADER)
               ENDDO
               ZPT = LCOLUMNHR%RPPOBS_T(1,INDEX_HEADER)
               ZMT = ZGZ(LCOLUMNHR%NLEV)/RG
               ZMT = gpsgeopotential(Lat, ZMT)/RG
               ZPR = rprefinc
               ZCF = rcoefinc
C     
C     *        GPS profile structure:
C
                     IF (LSTAG) THEN
c     *                 Staggered hybrid trial field 
                        CALL GPSSTRUCT1S(NGPSLEV,ZLAT,ZLON,
     +                       ZPP,ZDP,ZTT,ZHU,ZMT,PRF)
                     ELSE
c     *                 ETA or HYBRID NONSTAGGERED trial field 
               CALL GPSSTRUCT1H(NGPSLEV,ZLAT,ZLON,ZETA,
     +              ZTT,ZHU,ZP0,ZMT,ZPT,ZPR,ZCF,PRF)
                     ENDIF
               CALL GPSGEO(PRF)
C
C     *        Prepare the vector of all the observations:
C
               ALLOCATE( HGT  (NH) )
               ALLOCATE( H    (NH) )
               ALLOCATE( ZOFF (NH) )
               ALLOCATE( ZERR (NH) )
               ALLOCATE( RSTV (NH) )
               NH1 = 0
               do index_list_body = 1, size_list_body
                  index_body = list_body(index_list_body)
                  HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',index_body)
                  IF ( HNH1.GE.0. .AND. HNH1.LE.HTPMAX ) THEN
                     NH1   = NH1 + 1
                     HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',index_body)
                     HGT(NH1)= HNH1
                     H(NH1)= gpsgeopotential(Lat,HNH1)/9.80616
                  ENDIF
               ENDDO
C
C     *        Apply the observation operator:
C  
               DH = 5000._dp
               CALL GPSREFOPV (H, PRF, RSTV)
C
C     *        Perform the (H(x)-Y)/S operation
C
               NH1 = 0
               do index_list_body = 1, size_list_body
                  index_body = list_body(index_list_body)
                  HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',index_body)
                  IF ( HNH1.GE.0. .AND. HNH1.LE.HTPMAX ) THEN
                     NH1   = NH1 + 1
C
C     *              Observation operator H(x)
C
                     ZMHX = RSTV(NH1)%VAR
C
C     *              Observation value    Y
C
                     ZOBS = obs_elem_r8(lobsSpaceData,'VAR ',index_body)
C
C     *              Normalized increment
C
                     ZOFF(NH1) = (ZOBS - ZMHX) / ZMHX
                  ENDIF
               ENDDO
C
C     *        The procedure below is well tested to collectively
C     *        create error profiles FROM data below 40 km, and
C     *        intended to be used FOR data below 40 km. The procedure
C     *        creates also a reasonable estimate for the error
C     *        profiles FOR data above, but only uses data FROM below
C     *        HTPMAX as input. Extending input for all HGT requires
C     *        research on the error characteristics of data above 40 km.
C
               DO NH1 = 1, NH
                  SUM0=0.
                  SUM1=0.
                  DO JH = 1, NH
                     IF ( HGT(JH) .LT. HTPMAX ) THEN
                        DDH=H(JH)-H(NH1)
                        SUM0=SUM0+EXP(-(DDH/DH)**2)
                        SUM1=SUM1+EXP(-(DDH/DH)**2)*ZOFF(JH)**2
                     ENDIF
                  ENDDO
                  ZERR(NH1)=SQRT(SUM1/SUM0)
                  IF ( ZERR(NH1) < 0.002 ) ZERR(NH1) = 0.002
               ENDDO

               NH1 = 0
               do index_list_body = 1, size_list_body
                  index_body = list_body(index_list_body)
                  HNH1  = obs_elem_r8(lobsSpaceData,'PPP ',index_body)
                  IF ( HNH1.GE.0. .AND. HNH1.LE.HTPMAX ) THEN
                     NH1 = NH1 + 1
C
C     *              Observation operator H(x)
C
                     ZMHX = RSTV(NH1)%VAR
C
C     *              Observation error    S
C
                     call obs_set_r8(lobsSpaceData,'OER ',index_body, ZERR(NH1) * ZMHX)
                  ENDIF
               ENDDO
               DEALLOCATE( RSTV )
               DEALLOCATE( ZERR )
               DEALLOCATE( ZOFF )
               DEALLOCATE( H    )
               DEALLOCATE( HGT  )
            ENDIF ! ASSIM
         ENDIF ! IDATYP .EQ. 169
      ENDDO ! index_header
      WRITE(NULOUT,*)'EXIT SETERRGPSRO'
      RETURN
      END
