!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine tovs_calc_jo(pjo,llprint,lobsSpaceData)
#if defined (doc)
!
!**s/r tovs_calc_jo  - computation of jo and the residuals to the tovs observations
!                     (adapted from part of code of dobstovs)
!
!
!author        : j. halle *cmda/aes  december 14, 2004
!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                  -modifications for AIRS (codtyp 183)
!
!revision 002  : r. sarrazin cmda  april 2008
!                  -modifications for CSR (codtyp 185)
!
!revision 003  : s. heilliette
!                  -modifications for IASI (codtyp 186)
!
!    -------------------
!     purpose:
!
!arguments
!     pjo: total value of jo for tovs
!
#endif
  use mod_tovs
  use obsSpaceData_mod
  use minimization_mod

  implicit none
#include "comlun.cdk"
#include "partov.cdk"
#include "comtov.cdk"
#include "comtovst.cdk"

  type(struct_obs) :: lobsSpaceData
  integer :: isens, indxchn, indxtovs

  real*8 zoer
  real*8 dlsum
  real*8 pjo, zdtb
  real*8 zjon,zgami,zqcarg,zpost

  real*8 zjoch  (0:jpch,jpnsat)
  real*8 zavgnrm(0:jpch,jpnsat)

  integer j, i, krtid, nchanperline, indxs, indxe
  integer inobsjo, incanjo
  integer idatyp
  integer ichn, ichNCM_A, jl
  integer kfailtot

  integer inobsch(0:jpch,jpnsat)
  integer lcanjo(jpch)

  integer :: index_header, index_body

  logical :: llprint

  integer  isrcheq
  external isrcheq
  external abort3d

  if(NOBTOV.eq.0) return    ! exit if there are not tovs data

!     1.  Computation of (hx - z)/sigma for tovs data only
!     .   ------------------------------------------------

  dlsum    = 0.
  inobsjo  = 0
  kfailtot = 0
  do j = 1, nsensors
     do i = 0, jpch
        inobsch(i,j) = 0
        zjoch  (i,j) = 0.0
        zavgnrm(i,j) = 0.0
     enddo
  enddo

  ! loop over all header indices of the 'TO' family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER

  !  .  1.1  Extract general information for this observation point
  !  .       ------------------------------------------------------

  !     process only radiance data to be assimilated?
  !     (data type=[164,168,180,181,182,183,185,186])

     idatyp = obs_elem_i(lobsSpaceData,'ITY ',index_header)
     if ( idatyp .ne. 164 .and.  &
          idatyp .ne. 168 .and.  &
          idatyp .ne. 180 .and.  &
          idatyp .ne. 181 .and.  &
          idatyp .ne. 182 .and.  &
          idatyp .ne. 183 .and.  &    
          idatyp .ne. 185 .and.  &    
          idatyp .ne. 186     ) then
        cycle HEADER                    ! Proceed to the next header_index
     end if

     indxtovs = ltovsno(index_header)
     if ( indxtovs .eq. 0 ) then
        write(nulout,fmt=9203)
9203    format(' tovs_calc_jo: error with indxtovs')
        call abort3d(nulout,'tovs_calc_jo    ')
     endif

     if (rttov_errorstatus(indxtovs) .lt. 20   ) then 
        isens = lsensor(indxtovs)

        ! loop over all body indices (still in the 'TO' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
        call obs_set_current_body_list(lobsSpaceData, index_header)
        BODY: do 
           index_body = obs_getBodyIndex(lobsSpaceData)
           if (index_body < 0) exit BODY

           if ( obs_elem_i(lobsSpaceData,'ASS ',index_body).ne.1 ) then
              cycle BODY                ! Proceed to the next body_index
           end if

           ichn = nint(obs_elem_r(lobsSpaceData,'PPP ',index_body))
           ichn = max(0,min(ichn,jpch+1))
           ichNCM_A = max(0,min(ichn,jpch+1))
           if(idatyp.ne.183 .and. idatyp.ne.186) &
              ichn=ichn-chanoffset(isens)
           indxchn = isrcheq (ichan(:,isens),nchan(isens),ichn)
           if ( indxchn .eq. 0 ) then
              write(nulout,fmt=9202)
9202          format(' tovs_calc_jo: error with channel number')
              call abort3d(nulout,'tovs_calc_jo    ')
           endif

           zdtb =   radiance_d (indxtovs) % out(indxchn) &
                  - obs_elem_r(lobsSpaceData,'PRM ',index_body)
           if ( ldbgtov ) then
              write(nulout,'(a,i4,2f8.2,f6.2)') ' ichn,sim,obs,diff= ', &
                           ichn,  radiance_d (indxtovs) % out(indxchn), &
                           obs_elem_r(lobsSpaceData,'PRM ',index_body), zdtb
           endif

           zoer = obs_elem_r(lobsSpaceData,'OER ',index_body)
           call obs_set_r(lobsSpaceData,'OMA ',index_body, zdtb/zoer)
           call obs_set_r(lobsSpaceData,'OMI ',index_body, &
                           obs_elem_r(lobsSpaceData,'OMA ',index_body))

           if (.not. lvarqc) then
              dlsum =  dlsum &
                     + (obs_elem_r(lobsSpaceData,'OMA ',index_body)* &
                        obs_elem_r(lobsSpaceData,'OMA ',index_body))/2.
           else
!             compute contribution of data with varqc
 
              zgami = obs_elem_r(lobsSpaceData,'POB ',index_body)
              zjon = (obs_elem_r(lobsSpaceData,'OMA ',index_body)* &
                      obs_elem_r(lobsSpaceData,'OMA ',index_body))/2.
              zqcarg = zgami + exp(-1.0*zjon)
              zpost = zgami/zqcarg
              dlsum= dlsum - log(zqcarg/(zgami+1.))
           endif

           inobsjo = inobsjo + 1
           inobsch(ichNCM_A,Isens) = inobsch(ichNCM_A,Isens) + 1
           zjoch(ichNCM_A,Isens)   = &
                    zjoch(ichNCM_A,Isens)   + &
                    obs_elem_r(lobsSpaceData,'OMA ',index_body)* &
                    obs_elem_r(lobsSpaceData,'OMA ',index_body)
           zavgnrm(ichNCM_A,Isens)   = &
                    zavgnrm(ichNCM_A,Isens) + &
                    obs_elem_r(lobsSpaceData,'OMA ',index_body)
        enddo BODY
     else
      kfailtot = kfailtot + 1
     endif

  enddo HEADER

!     2.  Close up, print summary
!     .   -----------------------

200 continue

  pjo = dlsum

!    printout of mean jo and normalized average for each sensor.

  nchanperline = 18
  if ( llprint .and. inobsjo .gt. 0 ) then
     write(nulout,fmt=9000)
     do krtid = 1, nsensors
        do i = 1, jpch
           inobsch(0,krtid) = inobsch(0,krtid) + &
                              inobsch(i,krtid)
           zjoch(0,krtid)   = zjoch(0,krtid) + &
                              zjoch(i,krtid)
           zavgnrm(0,krtid) = zavgnrm(0,krtid) + &
                              zavgnrm(i,krtid)
        enddo
     enddo
     if ( kfailtot .gt. 0 ) then
        write(nulout,'(/1x," rttov failures : ",i10)')  kfailtot
     endif
     do jl = 1, nsensors
        incanjo = 0
        do i = 0, jpch
           if ( inobsch(i,jl) .ne. 0 ) then
              incanjo = incanjo + 1
              lcanjo(incanjo) = i
           endif
        enddo
        if ( incanjo .ne. 0 ) then
           write(nulout,'(/1x,"sensor #",i2,". platform: ",a, &
                          &   "instrument: ",a)') &
                          jl, csatid(jl), cinstrumentid(jl)
           do j = 1, incanjo, nchanperline
              indxs = j
              indxe = min(j+nchanperline-1,incanjo)
              if ( j .eq. 1 ) then
                 write(nulout,'(1x,"channel",t13,"   all",17i6)') &
                    (lcanjo(i),i=indxs+1,indxe)
              else
                 write(nulout,'(1x,"channel",t13,18i6)') &
                    (lcanjo(i),i=indxs,indxe)
              endif
              write(nulout,'(1x,"no. obs.",t13,18i6)') &
                 (inobsch(lcanjo(i),jl),i=indxs,indxe)
              write(nulout,'(1x,"mean jo",t13,18f6.2)') &
                 (zjoch(lcanjo(i),jl)/max(1,inobsch(lcanjo(i),jl)) &
                 ,i=indxs,indxe)
              write(nulout,'(1x,"norm. bias",t13,18f6.2,/)') &
                 (zavgnrm(lcanjo(i),jl)/max(1,inobsch(lcanjo(i),jl)) &
                 ,i=indxs,indxe)
           enddo
        endif
     enddo
  endif

 9000 format(//,10x,"-tovs_calc_jo: computing jo and residuals to tovs" &
        &  ," observations")

end subroutine tovs_calc_jo
