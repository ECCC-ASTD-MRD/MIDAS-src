module columnData_mod
  implicit none
  save
!  private

!  public :: columnData

  type struct_columnData
    real*8,pointer :: gomobs(:,:)
    real*8,pointer :: gomu(:,:)
    real*8,pointer :: gomv(:,:)
    real*8,pointer :: gomt(:,:)
    real*8,pointer :: gomq(:,:)
    real*8,pointer :: gomoz(:,:)
    real*8,pointer :: gomgz(:,:)
    real*8,pointer :: gomtr(:,:)
    real*8,pointer :: gomes(:,:)
    real*8,pointer :: gomps(:,:)
    real*8,pointer :: gomtgr(:,:)
    real*8,pointer :: rppobs(:,:)
  end type struct_columnData

!  type(struct_columnData) :: columnData

    ! from commvo
    real*8,pointer :: gomobs(:,:)
    real*8,pointer :: gomu(:,:)
    real*8,pointer :: gomv(:,:)
    real*8,pointer :: gomt(:,:)
    real*8,pointer :: gomq(:,:)
    real*8,pointer :: gomoz(:,:)
    real*8,pointer :: gomgz(:,:)
    real*8,pointer :: gomtr(:,:)
    real*8,pointer :: gomes(:,:)
    real*8,pointer :: gomps(:,:)
    real*8,pointer :: gomtgr(:,:)
    real*8,pointer :: rppobs(:,:)
    real*8,pointer :: rmthobs(:)
    real*8,pointer :: rmtmobs(:)

    ! global version of commvo
    real*8,pointer :: gomu_g(:,:)
    real*8,pointer :: gomv_g(:,:)
    real*8,pointer :: gomt_g(:,:)
    real*8,pointer :: gomq_g(:,:)
    real*8,pointer :: gomoz_g(:,:)
    real*8,pointer :: gomgz_g(:,:)
    real*8,pointer :: gomtr_g(:,:)
    real*8,pointer :: gomps_g(:,:)
    real*8,pointer :: gomtgr_g(:,:)

    ! from commvo1
    real*8,pointer :: gomobs1(:,:)
    real*8,pointer :: gomu1(:,:)
    real*8,pointer :: gomv1(:,:)
    real*8,pointer :: gomt1(:,:)
    real*8,pointer :: gomq1(:,:)
    real*8,pointer :: gomoz1(:,:)
    real*8,pointer :: gomgz1(:,:)
    real*8,pointer :: gomtr1(:,:)
    real*8,pointer :: gomes1(:,:)
    real*8,pointer :: gomps1(:,:)
    real*8,pointer :: gomtgr1(:,:)

    ! from commvog
    real*8,pointer :: gomobsg(:,:)
    real*8,pointer :: gomug(:,:)
    real*8,pointer :: gomvg(:,:)
    real*8,pointer :: gomtg(:,:)
    real*8,pointer :: gomqg(:,:)
    real*8,pointer :: gomozg(:,:)
    real*8,pointer :: gomgzg(:,:)
    real*8,pointer :: gomtrg(:,:)
    real*8,pointer :: gomesg(:,:)
    real*8,pointer :: gompsg(:,:)
    real*8,pointer :: gomtgrg(:,:)

    real*8,pointer :: oltv(:,:,:),rtapfac(:,:)
    real*8,pointer :: ollq2es(:,:,:)
    real*8,pointer :: estdg(:,:), dlnesg(:,:)
    real*8,pointer :: rqgfac(:,:)

    ! from commvohr
    integer nlevtrl,nkgdimohr
    real*8,pointer ::  gomobshr(:,:)
    real*8,pointer ::  gomuhr(:,:)
    real*8,pointer ::  gomvhr(:,:)
    real*8,pointer ::  gomthr(:,:)
    real*8,pointer ::  gomqhr(:,:)
    real*8,pointer ::  gomozhr(:,:)
    real*8,pointer ::  gomgzhr(:,:)
    real*8,pointer ::  gomtrhr(:,:)
    real*8,pointer ::  gomeshr(:,:)
    real*8,pointer ::  gompshr(:,:)
    real*8,pointer ::  gomtgrhr(:,:)
    real*8,pointer ::  rppobshr(:,:)

    real*8,pointer ::  vlevhr(:)
    real*8,pointer ::  vhybhr(:)
    real*8,pointer ::  vmahr(:)
    real*8,pointer ::  vmbhr(:)
    real*8,pointer ::  vmchr(:)
    real*8,pointer ::  vmdhr(:)
    real*8,pointer ::  vmehr(:)
    real*8,pointer ::  vmfhr(:)

  contains

    SUBROUTINE col_allocateGlobal(klev,nobtotp)
      implicit none
      #include "comstate.cdk"
      integer :: nobtotp,klev,ierr

      write(*,*) 'allocating a global gomobs: ',klev,nobtotp
      call flush(6)

      ierr=0
      if(NGEXIST(nguu).eq.1) allocate(gomu_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=1',ierr
        call flush(6)
      endif
      if(NGEXIST(ngvv).eq.1) allocate(gomv_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=2',ierr
        call flush(6)
      endif
      if(NGEXIST(ngtt).eq.1) allocate(gomt_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=3',ierr
        call flush(6)
      endif
      if(NGEXIST(ngq ).eq.1) allocate(gomq_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=4',ierr
        call flush(6)
      endif
      if(NGEXIST(ngoz).eq.1) allocate(gomoz_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=5',ierr
        call flush(6)
      endif
      if(NGEXIST(nggz).eq.1) allocate(gomgz_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=6',ierr
        call flush(6)
      endif
      if(NGEXIST(ngtr).eq.1) allocate(gomtr_g(klev,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=7',ierr
        call flush(6)
      endif
      if(NGEXIST(ngps).eq.1) allocate(gomps_g(1:1,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=8',ierr
        call flush(6)
      endif
      if(NGEXIST(ngtg).eq.1) allocate(gomtgr_g(1:1,nobtotp),stat=ierr)
      if(ierr.ne.0) then
        write(*,*) 'columnData: Problem allocating memory! id=9',ierr
        call flush(6)
      endif

    END SUBROUTINE col_allocateGlobal 

    SUBROUTINE col_deallocateGlobal
      implicit none
      #include "comstate.cdk"

      if(NGEXIST(nguu).eq.1) deallocate(gomu_g)
      if(NGEXIST(ngvv).eq.1) deallocate(gomv_g)
      if(NGEXIST(ngtt).eq.1) deallocate(gomt_g)
      if(NGEXIST(ngq ).eq.1) deallocate(gomq_g)
      if(NGEXIST(ngoz).eq.1) deallocate(gomoz_g)
      if(NGEXIST(nggz).eq.1) deallocate(gomgz_g)
      if(NGEXIST(ngtr).eq.1) deallocate(gomtr_g)
      if(NGEXIST(ngps).eq.1) deallocate(gomps_g)
      if(NGEXIST(ngtg).eq.1) deallocate(gomtgr_g)

    END SUBROUTINE col_deallocateGlobal 


    SUBROUTINE col_expandToMpiGlobal2(klev,nobtot,nobtotp)
!
!**s/r col_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global column object by gathering
!                the necessary data from all processors (to all processors).
!
      USE obsSpaceData_mod, only: locObsTag
      IMPLICIT NONE
      #include "comstate.cdk"

      integer, intent(in) :: nobtot       ! Actual number of observations
      integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot
      integer, intent(in) :: klev

      INTEGER :: i,iobs,ierr,nsize

      print*,'Entering col_expandToMpiGlobal2:',nobtot,nobtotp  
      call flush(6)

!$OMP PARALLEL
!$OMP SECTIONS
!$OMP SECTION
      if(NGEXIST(nguu).eq.1) then
        gomu_g(:,:)=0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomu_g(:,iobs)  =gomu(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngvv).eq.1) then
        gomv_g(:,:)=0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomv_g(:,iobs)  =gomv(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngtt).eq.1) then
        gomt_g(:,:)=0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomt_g(:,iobs)  =gomt(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngq).eq.1) then
        gomq_g(:,:)=0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomq_g(:,iobs)  =gomq(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngoz).eq.1) then
        gomoz_g(:,:)  =0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomoz_g(:,iobs)  =gomoz(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(nggz).eq.1) then
        gomgz_g(:,:)  =0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomgz_g(:,iobs)  =gomgz(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngtr).eq.1) then
        gomtr_g(:,:)  =0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomtr_g(:,iobs)  =gomtr(:,i)
        ENDDO
      endif

!$OMP SECTION
      if(NGEXIST(ngps).eq.1) then
        gomps_g(1,:)  =0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomps_g(1,iobs)  =gomps(1,i)
        ENDDO
      endif

      if(NGEXIST(ngtg).eq.1) then
        gomtgr_g(1,:)  =0.0d0
        DO i=1,NOBTOT
          iobs=locObsTag(i)
          gomtgr_g(1,iobs)  =gomtgr(1,i)
        ENDDO
      endif
!$OMP END SECTIONS
!$OMP END PARALLEL

      write(*,*) 'starting allreduce'
      call flush(6)
      nsize=klev*NOBTOTP
      if(NGEXIST(nguu).eq.1) &
          CALL RPN_COMM_ALLReduce(gomu_g,gomu_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngvv).eq.1) &
          CALL RPN_COMM_ALLReduce(gomv_g,gomv_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtt).eq.1) &
          CALL RPN_COMM_ALLReduce(gomt_g,gomt_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngq ).eq.1) &
          CALL RPN_COMM_ALLReduce(gomq_g,gomq_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngoz).eq.1) &
          CALL RPN_COMM_ALLReduce(gomoz_g,gomoz_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(nggz).eq.1) &
          CALL RPN_COMM_ALLReduce(gomgz_g,gomgz_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtr).eq.1) &
          CALL RPN_COMM_ALLReduce(gomtr_g,gomtr_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      nsize=NOBTOTP
      if(NGEXIST(ngps).eq.1) &
          CALL RPN_COMM_ALLReduce(gomps_g,gomps_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)
      if(NGEXIST(ngtg).eq.1) &
          CALL RPN_COMM_ALLReduce(gomtgr_g,gomtgr_g,nsize, &
                                  "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving col_expandToMpiGlobal2' 
      call flush(6)
      RETURN

    END SUBROUTINE col_expandToMpiGlobal2

 
    SUBROUTINE col_expandToMpiGlobal(nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r col_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global column object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

    USE obsSpaceData_mod, only: locObsTag
    IMPLICIT NONE

    integer, intent(in) :: nulout       ! standard output unit
    integer, intent(in) :: nobtot       ! Actual number of observations
    integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot

!   Declare Local Variables. 
    REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
    
    INTEGER :: i,iobs,ierr,sizeRMTMOBS  
!!---------------------------------------------------------------

!!  1.  Release some memory. 
    print*,'Entering col_expandToMpiGlobal'  

!!  1.2 Added restore global array RMTMOBS
    ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
    IF(ierr /= 0)CALL ABORT3D(nulout,'Cant allocate Mem. to RMTMOBS_tmp,Abort!') 
    RMTMOBS_TMP=0.0D0 

!!  1.3 Retore global RMTMOBS
    DO i=1,NOBTOT
       iobs=locObsTag(i)
       RMTMOBS_tmp(iobs)=RMTMOBS(i)
    ENDDO  
    sizeRMTMOBS=NOBTOTP
    CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS, &
                            "mpi_double_precision","mpi_sum","GRID",ierr)


!!  DEALLOCATE(RMTMOBS)
    deallocate(rmtmobs)
    allocate(rmtmobs(nobtotp))
    RMTMOBS=RMTMOBS_tmp
    DEALLOCATE(RMTMOBS_tmp)

    print*,'Leaving col_expandToMpiGlobal' 
    RETURN
  END SUBROUTINE col_expandToMpiGlobal

end module columnData_mod
