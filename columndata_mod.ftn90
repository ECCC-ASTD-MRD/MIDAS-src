module columnData_mod
  implicit none
  save
!  private

  type struct_columnData
    integer nlev,nkgdimo,nobtot
    logical :: allocated=.false.
    real*8,pointer :: all(:,:)
    real*8,pointer :: uu(:,:)
    real*8,pointer :: vv(:,:)
    real*8,pointer :: tt(:,:)
    real*8,pointer :: hu(:,:)
    real*8,pointer :: gz(:,:)
    real*8,pointer :: tr(:,:)
    real*8,pointer :: es(:,:)
    real*8,pointer :: ps(:,:)
    real*8,pointer :: tg(:,:)
    real*8,pointer :: rppobs(:,:)
    real*8,pointer :: vlev(:)
    real*8,pointer :: vhyb(:)
    real*8,pointer :: rmtmobs(:)
  end type struct_columnData

  type(struct_columnData) :: column,columng,column1,columnhr,column_g

    real*8,pointer :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi transformation
    real*8,pointer :: ollq2es(:,:,:) ! Tangent linear operator of lnq to dewpoint conversion

    INTEGER,parameter :: JPNVARMAX=10
    INTEGER NMVOEXIST(JPNVARMAX), NMVOPOSIT(JPNVARMAX)
    INTEGER nouu,novv,noq,nogz,nott,notr,noes,nops,notg
    integer :: nvo3d,nvo2d

  contains

    SUBROUTINE col_setup(nflev)
      implicit none
      INTEGER JVAR, IPOS,NFLEV,nkgdimo
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER*2 CMVONEED(JPNVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED

!     Model state at the observation locations
      nouu = 1
      novv = 2
      nogz = 3
      nott = 4
      noq  = 5
      notr = 6
      noes = 7
      nops = 8
      notg = 9

      DO JVAR = 1, JPNVARMAX
         NMVOEXIST(JVAR) = 0
      END DO

!    2. Read NAMELIST NAMSTATE to find which fields are needed

      DO JVAR = 1, JPNVARMAX
        cmvoneed(jvar) = ' '
      enddo

      CMVONEED(1)   ='UU'
      CMVONEED(2)   ='VV'
      CMVONEED(3)   ='TT'
      CMVONEED(4)   ='HU'
      CMVONEED(5)   ='ES'
      CMVONEED(6)   ='GZ'
      CMVONEED(7)   ='P0'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'minimization: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      NVO3D  = 0
      NVO2D  = 0

      IPOS = 1
      DO JVAR = 1, JPNVARMAX
        IF (NOUU .EQ. JVAR) THEN
          IF (VARNEED('UU')) THEN
            NOUU = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOUU = -9
          ENDIF
        ELSEIF(NOVV .EQ. JVAR) THEN
          IF (VARNEED('VV')) THEN
            NOVV = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOVV = -9
          ENDIF
        ELSEIF(NOQ .EQ. JVAR) THEN
          IF (VARNEED('HU')) THEN
            NOQ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOQ = -9
          ENDIF
        ELSEIF(NOGZ .EQ. JVAR) THEN
          IF (VARNEED('GZ')) THEN
            NOGZ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOGZ = -9
          ENDIF
        ELSEIF(NOTT .EQ. JVAR) THEN
          IF (VARNEED('TT')) THEN
            NOTT = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTT = -9
          ENDIF
        ELSEIF(NOTR .EQ. JVAR) THEN
          IF (VARNEED('XT')) THEN
            NOTR = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTR = -9
          ENDIF
        ELSEIF(NOES .EQ. JVAR) THEN
          IF (VARNEED('ES')) THEN
            NOES = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOES = -9
          ENDIF
        ELSEIF(NOPS .EQ. JVAR) THEN
          IF (VARNEED('P0')) THEN
            NOPS = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO2D = NVO2D + 1
          ELSE
            NOPS = -9
          ENDIF
        elseif(notg .eq. jvar) then
          if (VARNEED('TG')) then
            notg = ipos
            nmvoexist(ipos) = 1
            ipos = ipos + 1
            NVO2D = NVO2D + 1
          else
            notg = -9
          endif
        ENDIF
      ENDDO
!
      IF(NOUU .EQ. -9) THEN
        NOUU = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOVV .EQ. -9) THEN
        NOVV = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOQ .EQ. -9) THEN
        NOQ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOGZ .EQ. -9) THEN
        NOGZ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTT .EQ. -9) THEN
        NOTT = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTR .EQ. -9) THEN
        NOTR = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOES .EQ. -9) THEN
        NOES = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOPS .EQ. -9) THEN
        NOPS = IPOS
        IPOS = IPOS + 1
      ENDIF
      if(notg .eq. -9) then
        notg = ipos
        ipos = ipos + 1
      endif

      NKGDIMO = NVO3D*NFLEV + NVO2D
      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D,NKGDIMO
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6,' NKGDIMO = ',I6)


      CONTAINS

        LOGICAL FUNCTION VARNEED(VARCHAR)
          character*2 :: varchar
          integer :: jvar
 
          varneed=.false.
          do jvar=1,JPNVARMAX
            if (varchar.eq.cmvoneed(jvar)) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_SUALOBSB(nflev,nobtot) 
      IMPLICIT NONE

      INTEGER nflev,nobtot
      INTEGER IERR

      WRITE(*,FMT='(//,6(" ***********"))')
      WRITE(*,*)'     SUALOBSB:  Memory allocation of the observation arrays'
      WRITE(*,FMT='(6(" ***********"))')

      allocate(oltv(2,nflev,nobtot))
      oltv(:,:,:)=0.0d0
      allocate(rtapfac(nflev,nobtot))
      allocate(ollq2es(3,nflev,nobtot))

      RETURN
    END SUBROUTINE col_sualobsb


    SUBROUTINE col_allocate(column,kstep,nobtot)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer :: kstep,nobtot
      integer :: ier

      integer iloc,jvar

      column%allocated=.true.
      column%nkgdimo = nvo3d*kstep + nvo2d
      column%nobtot = nobtot
      column%nlev = kstep
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo

      allocate(column%all(column%nkgdimo,column%nobtot))
      allocate(column%rppobs(column%nlev,column%nobtot))
      allocate(column%vlev(column%nlev))
      allocate(column%vhyb(column%nlev))
      allocate(column%rmtmobs(column%nobtot))
!      allocate(column%rmtmobs(250000))
      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
      column%rmtmobs(:)=0.0d0      

      iloc = 1
      do jvar = 1, jpnvarmax
        if(jvar.eq.nouu) then
          if(nmvoexist(nouu).eq.1) then
            column%uu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.novv) then
          if(nmvoexist(novv).eq.1) then
            column%vv => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nogz) then
          if(nmvoexist(nogz).eq.1) then
            column%gz => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noq) then
          if(nmvoexist(noq).eq.1) then
            column%hu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nott) then
          if(nmvoexist(nott).eq.1) then
            column%tt => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.notr) then
          if(nmvoexist(notr).eq.1) then
            column%tr => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noes) then
          if(nmvoexist(noes).eq.1) then
            column%es => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nops) then
          if(nmvoexist(nops).eq.1) then
            column%ps => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
        if(jvar.eq.notg) then
          if(nmvoexist(notg).eq.1) then
            column%tg => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
      enddo

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%all)
      deallocate(column%rppobs)
      deallocate(column%vlev)
      deallocate(column%vhyb)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_expandToMpiGlobal(nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r col_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global column object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

    USE obsSpaceData_mod, only: locObsTag
    IMPLICIT NONE

    integer, intent(in) :: nulout       ! standard output unit
    integer, intent(in) :: nobtot       ! Actual number of observations
    integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot

!   Declare Local Variables. 
    REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
    
    INTEGER :: i,iobs,ierr,sizeRMTMOBS  
!!---------------------------------------------------------------

!!  1.  Release some memory. 
    print*,'Entering col_expandToMpiGlobal'  

!!  1.2 Added restore global array RMTMOBS
    ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
    IF(ierr /= 0)CALL ABORT3D(nulout,'Cant allocate Mem. to RMTMOBS_tmp,Abort!') 
    RMTMOBS_TMP=0.0D0 

!!  1.3 Retore global RMTMOBS
    DO i=1,NOBTOT
       iobs=locObsTag(i)
       RMTMOBS_tmp(iobs)=columng%RMTMOBS(i)
    ENDDO  
    sizeRMTMOBS=NOBTOTP
    CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS, &
                            "mpi_double_precision","mpi_sum","GRID",ierr)

!!  DEALLOCATE(RMTMOBS)
    deallocate(columng%rmtmobs)
    allocate(columng%rmtmobs(nobtotp))
    columng%RMTMOBS=RMTMOBS_tmp
    DEALLOCATE(RMTMOBS_tmp)

    print*,'Leaving col_expandToMpiGlobal' 
    RETURN
  END SUBROUTINE col_expandToMpiGlobal


    SUBROUTINE col_expandToMpiGlobal3(column_local,column_global)
      USE obsSpaceData_mod, only: locObsTag
      IMPLICIT NONE

      type(struct_columnData) :: column_local,column_global

      INTEGER :: i,iobs,ierr,nsize

      print*,'Entering col_expandToMpiGlobal3:',  &
             column_local%nobtot,column_global%nobtot  
      call flush(6)

      column_global%all(:,:)=0.0d0
      DO i=1,column_local%nobtot
        iobs=locObsTag(i)
        column_global%all(:,iobs)  =column_local%all(:,i)
      ENDDO

      write(*,*) 'starting allreduce'
      call flush(6)
      nsize=column_global%nkgdimo*column_global%nobtot
      CALL RPN_COMM_ALLReduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving col_expandToMpiGlobal3' 
      call flush(6)
      RETURN

    END SUBROUTINE col_expandToMpiGlobal3

end module columnData_mod
