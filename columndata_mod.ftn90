module columnData_mod
  use varNameList_mod
  use verticalCoord_mod
  use MathPhysConstants_mod
  implicit none
  save
  private

  ! public variables and types
  public :: rhumin, struct_columnData

  ! public subroutines and functions
  public :: col_setup, col_allocate, col_deallocate, col_pointStagToUnstag, col_expandToMpiGlobal
  public :: col_varExist, col_getOffsetFromVarno
  public :: col_getNumLev, col_getNumCol, col_getNumStep, col_setNumStep
  public :: col_getTimeInterpWeight, col_setTimeInterpWeight
  public :: col_getPressure, col_getHeight, col_getMountain, col_setMountain
  public :: col_getLatLon, col_setLatLon, col_copyLatLon
  public :: col_zero, col_fillmvo, col_getColumn, col_getElem, col_getVco, col_setVco

  ! public entities accessed through inheritance
  public :: struct_vco, vco_calcpres, vco_AnlInit, vco_SetupFromFile
  public :: vnl_varnameFromVarnum, vnl_vartypeFromVarnum

  type struct_columnData
    integer           :: nlev,nlev_T,nlev_M
    integer           :: nkgdimo,numCol,nStepObs
    logical           :: allocated=.false.
    logical           :: mpi_local
    real*8,pointer    :: all(:,:)
    real*8,pointer    :: gz_T(:,:),gz_M(:,:)
    real*8,pointer    :: rppobs(:,:),rppobs_T(:,:),rppobs_M(:,:)
    real*8,pointer    :: timeInterpWeight(:,:)  ! weights for linear temporal interpolation of increment to obs times
    real*8,pointer    :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer    :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi calc.
    real*8,pointer    :: lat(:),lon(:)
    integer,pointer   :: tla(:)
    type(struct_vco), pointer  :: vco => null()
    integer,pointer   :: varOffset(:),varNumLev(:)
  end type struct_columnData

  real*8 :: rhumin
  logical nmvoexist(vnl_numvarmax)
  integer :: nvo3d,nvo2d
  integer, parameter :: mxstepobs=9 

  contains


    SUBROUTINE col_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER(len=4) :: CMVONEED(VNL_NUMVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED,rhumin

      write(*,*) 'col_setup: List of known (valid) variable names'
      write(*,*) 'col_setup: varNameList3D=',varNameList3D
      write(*,*) 'col_setup: varNameList2D=',varNameList2D
      write(*,*) 'col_setup: varNameList  =',varNameList

!     Read NAMELIST NAMSTATEO to find which fields are needed

      cmvoneed(:) = '    '
      rhumin = MPC_MINIMUM_HU_R8

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'col_setup: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      nvo3d  = 0
      nvo2d  = 0

      do jvar = 1, vnl_numvarmax3D
        if (varneed(varNameList3D(jvar))) then
          nmvoexist(jvar) = .true.
          nvo3d = nvo3d + 1
        else
          nmvoexist(jvar) = .false.
        endif
      enddo

      do jvar = 1, vnl_numvarmax2D
        if (varneed(varNameList2D(jvar))) then
          nmvoexist(jvar+vnl_numvarmax3D) = .true.
          nvo2d = nvo2d + 1
        else
          nmvoexist(jvar+vnl_numvarmax3D) = .false.
        endif
      enddo

      write(*,*) 'col_setup: nvo3d,nvo2d=',nvo3d,nvo2d
      write(*,*) 'col_setup: nmvoexist =',nmvoexist

      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6)

      CONTAINS

        LOGICAL FUNCTION VARNEED(varName)
          character(len=*) :: varName
          integer :: jvar
 
          varneed=.false.
          do jvar=1,VNL_NUMVARMAX
            if (trim(varName).eq.trim(cmvoneed(jvar))) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
    END SUBROUTINE col_zero


    SUBROUTINE col_allocate(column,numCol,nlev_M,nlev_T,mpi_local)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer, intent(in)           :: numCol
      integer, intent(in), optional :: nlev_M,nlev_T
      logical, optional             :: mpi_local
      integer :: ier

      integer iloc,jvar,jvar2

      column%numCol = numCol
      if(present(mpi_local)) then
        column%mpi_local=mpi_local
      else
        column%mpi_local=.true.
        write(*,*) 'col_allocate: assuming columnData is mpi-local'
      endif

      if( (.not.present(nlev_M)) .and. (.not.present(nlev_T)) ) then
        if(column%vco%initialized) then
          column%nlev = max(column%vco%nlev_M,column%vco%nlev_T)
          column%nlev_M = column%vco%nlev_M
          column%nlev_T = column%vco%nlev_T
        else
          write(*,*) 'col_allocate: VerticalCoord has not been initialized!'
          call flush(6)
          call qqexit(1)
        endif
      else
        column%nlev = max(nlev_M,nlev_T)
        column%nlev_M = nlev_M
        column%nlev_T = nlev_T
      endif

      allocate(column%varOffset(vnl_numvarmax))
      column%varOffset(:)=0
      allocate(column%varNumLev(vnl_numvarmax))
      column%varNumLev(:)=0

      iloc=0
      do jvar = 1, vnl_numvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=col_getNumLev(column,vnl_vartypeFromVarname(varNameList(jvar)))
          iloc = iloc + column%varNumLev(jvar)
        endif
      enddo
      do jvar2 = 1, vnl_numvarmax2d
        jvar=jvar2+vnl_numvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=1
          iloc = iloc + 1
        endif
      enddo
      column%nkgdimo=iloc

      allocate(column%all(column%nkgdimo,column%numCol))
      column%all(:,:)=0.0d0

      allocate(column%gz_T(column%nlev_T,column%numCol))
      allocate(column%gz_M(column%nlev_M,column%numCol))
      column%gz_T(:,:)=0.0d0
      column%gz_M(:,:)=0.0d0

      allocate(column%rppobs  (column%nlev  ,column%numCol))
      allocate(column%rppobs_T(column%nlev_T,column%numCol))
      allocate(column%rppobs_M(column%nlev_M,column%numCol))
      column%rppobs(:,:)=0.0d0
      column%rppobs_T(:,:)=0.0d0
      column%rppobs_M(:,:)=0.0d0

      allocate(column%lat(column%numCol))
      allocate(column%lon(column%numCol))
      allocate(column%tla(column%numCol))
      column%lat(:)=0.0d0
      column%lon(:)=0.0d0
      column%tla(:)=0

      allocate(column%oltv(2,column%nlev,numCol))
      column%oltv(:,:,:)=0.0d0
      allocate(column%rtapfac(column%nlev,numCol))
      column%rtapfac(:,:)=0.0d0

      allocate(column%timeInterpWeight(column%numCol,mxstepobs))
      column%timeInterpWeight(:,:)=0.0d0
 
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo
      write(*,*) 'col_allocate: varOffset=',column%varOffset
      write(*,*) 'col_allocate: varNumLev=',column%varNumLev

      column%allocated=.true.

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%varOffset)
      deallocate(column%varNumLev)
      deallocate(column%all)
      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)
      deallocate(column%lat)
      deallocate(column%lon)
      deallocate(column%tla)
      deallocate(column%oltv)
      deallocate(column%rtapfac)
      deallocate(column%timeInterpWeight)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_fillmvo(columnghr,varName,varType,pvar)
    !
    !**s/r fillmvo - Fill in values for a complete set of columns at once
    !
    !Arguments
    !
    !       input:
    !            columnghr          : HR or BG column object
    !             VARNAME (character*4): NOMVAR of the state variable
    !             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
    !             KNLEV (integer)     : number of levels of PVAR
    !             KNOBS (integer)     : number of observation profiles in variable PVAR
    use MathPhysConstants_mod
    implicit none

    type(struct_columnData) :: columnghr
    real*8 pvar(:,:)
    character(len=*) :: varName
    character(len=*) :: varType

    integer jobs,jlev,nlev
    real*8, pointer :: column_ptr(:)

    call tmg_start(30,'FILLMVO')

    ! Pressure
    select case(trim(varName))
    case('PP')
      if(varType.eq.'TH') then
        do jobs = 1,columnghr%numCol
          do jlev = 1,columnghr%nlev_T
            columnghr%rppobs_T(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      elseif(varType.eq.'MM') then
        do jobs = 1,columnghr%numCol
          do jlev = 1,columnghr%nlev_M
            columnghr%rppobs_M(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      else
        do jobs = 1,columnghr%numCol
          do jlev = 1,columnghr%nlev
            columnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! Height
    case('GZ')
      if(varType.eq.'TH') then
        do jobs = 1,columnghr%numCol
          do jlev = 1, columnghr%nlev_T
            columnghr%gz_T(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(varType.eq.'MM') then
        do jobs = 1,columnghr%numCol
          do jlev = 1, columnghr%nlev_M
            columnghr%gz_M(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      else
        nlev = col_getNumLev(columnghr,vnl_vartypeFromVarname(varName))
        do jobs = 1,columnghr%numCol
          column_ptr => col_getColumn(columnghr,jobs,varName)
          do jlev = 1, nlev
            column_ptr(jlev)=pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! All the other variables that are stored in column%all
    case default
      if(col_varExist(varName)) then
        nlev = col_getNumLev(columnghr,vnl_vartypeFromVarname(varName))
        do jobs = 1,columnghr%numCol
          column_ptr => col_getColumn(columnghr,jobs,varName)
          do jlev = 1, nlev
            column_ptr(jlev)=pvar(jlev,jobs) 
          enddo
        enddo

      ! Unknown variable name
      else
        write(*,*) 'col_fillmvo: Unknown variable name: ',varName
        call flush(6)
        call qqexit(1)
      endif

    end select

    call tmg_stop(30)

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_pointStagToUnstag(column)
      IMPLICIT NONE
      type(struct_columnData) :: column
      integer                 :: ilev1,ilev2

      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)

      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+1
      ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex('GZ')) 
      column%gz_T => column%all(ilev1:ilev2,:)
      column%gz_M => column%all(ilev1:ilev2,:)

      column%rppobs_T => column%rppobs
      column%rppobs_M => column%rppobs

      column%nlev_T=column%nlev
      column%nlev_M=column%nlev

    END SUBROUTINE col_pointStagToUnstag


    SUBROUTINE col_expandToMpiGlobal(column_local,column_global,lobsSpaceData)
      use obsSpaceData_mod
      implicit none

      type(struct_columnData) :: column_local,column_global
      type(struct_obs) :: lobsSpaceData

      integer :: iobs_local,iobs_global,ierr,nsize,sizeone
      real*8, allocatable :: mountain(:)

      ! determine the number of columns for mpiglobal object
      sizeone=1
      call rpn_comm_allreduce(column_local%numCol,column_global%numCol,sizeone,"mpi_integer", &
                              "mpi_sum","GRID",ierr)       

      print*,'Entering col_expandToMpiGlobal:',  &
             column_local%numCol,column_global%numCol  
      call flush(6)

      call col_allocate(column_global,column_global%numCol,col_getNumLev(column_local,'MM'),   &
                        col_getNumLev(column_local,'TH'),mpi_local=.false.)

      column_global%nStepObs     = column_local%nStepObs
      column_global%varOffset(:) = column_local%varOffset(:)
      column_global%varNumLev(:) = column_local%varNumLev(:)

      allocate(mountain(column_global%numCol))
      mountain(:)=0.0d0
      do iobs_local=1,column_local%numCol
        iobs_global=obs_elem_i(lobsSpaceData,'GHI ',iobs_local)
        column_global%all(:,iobs_global)              = column_local%all(:,iobs_local)
        column_global%timeInterpWeight(iobs_global,:) = column_local%timeInterpWeight(iobs_local,:)
        mountain(iobs_global)                         = column_local%gz_t(column_local%nlev_t,iobs_local)
        column_global%lat(iobs_global)                = column_local%lat(iobs_local)
        column_global%lon(iobs_global)                = column_local%lon(iobs_local)
        column_global%tla(iobs_global)                = column_local%tla(iobs_local)
      enddo

      write(*,*) 'starting allreduce'
      call flush(6)

      nsize=column_global%nkgdimo*column_global%numCol
      call rpn_comm_allreduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=column_global%numCol
      call rpn_comm_allreduce(mountain,mountain,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=column_global%numCol*mxStepObs
      call rpn_comm_allreduce(column_global%timeInterpWeight,column_global%timeInterpWeight,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=column_global%numCol
      call rpn_comm_allreduce(column_global%lat,column_global%lat,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%lon,column_global%lon,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%tla,column_global%tla,nsize, &
                              "mpi_integer","mpi_sum","GRID",ierr)

      do iobs_global=1,column_global%numCol
        column_global%gz_t(column_global%nlev_t,iobs_global) = mountain(iobs_global)
      enddo

      deallocate(mountain)

      write(*,*) 'Leaving col_expandToMpiGlobal' 
      call flush(6)
      return

    END SUBROUTINE col_expandToMpiGlobal

    function col_varExist(varName) result(varExist)
      implicit none
      character(len=*), intent(in) :: varName
      logical                      :: varExist 

      if(nmvoexist(vnl_varListIndex(varName))) then
        varExist = .true.
      else
        varExist = .false.
      endif

    end function col_varExist


    function col_getOffsetFromVarno(column,varnum) result(offset)
      implicit none
      type(struct_columnData) :: column
      integer, intent(in)     :: varnum
      integer                 :: offset

      offset=column%varOffset(vnl_varListIndex(vnl_varnameFromVarnum(varnum)))

    end function col_getOffsetFromVarno


    SUBROUTINE col_setTimeInterpWeight(column,weight_in,headerIndex,stepObs)
      implicit none
      type(struct_columnData), intent(inout) :: column
      integer, intent(in)    :: headerIndex,stepObs
      real(kind=8),intent(in):: weight_in

      column%timeInterpWeight(headerIndex,stepObs)=weight_in

    end SUBROUTINE col_setTimeInterpWeight


    FUNCTION col_getTimeInterpWeight(column,headerIndex,stepObs) result(weight_out)
      implicit none
      real(kind=8) weight_out
      type(struct_columnData),intent(in) :: column
      integer,intent(in)          :: headerIndex,stepObs

      weight_out=column%timeInterpWeight(headerIndex,stepObs)

    end FUNCTION col_getTimeInterpWeight


  function col_getPressure(column,ilev,headerIndex,varType) result(pressure)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character(len=*), intent(in)        :: varType
    real*8                              :: pressure

    if (varType .eq. 'NA') then
      pressure = column%rppobs(ilev,headerIndex)
    elseif (varType .eq. 'TH') then
      pressure = column%rppobs_t(ilev,headerIndex)
    elseif (varType .eq. 'MM' ) then
      pressure = column%rppobs_m(ilev,headerIndex)
    elseif (varType .eq. 'SF' ) then
      pressure = column%rppobs_t(column%nlev_t,headerIndex)
    else
      write(*,*) 'col_getPressure: Unknown variable type: ',varType
      call flush(6)
      call qqexit(1)
    endif

  end function col_getPressure
 

  function col_getHeight(column,ilev,headerIndex,varType) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character(len=*), intent(in)        :: varType
    real*8                              :: height
    integer                             :: ilev1

    if (varType .eq. 'NA') then
      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+ilev
      height = column%all(ilev1,headerIndex)
    elseif (varType .eq. 'TH') then
      height = column%gz_t(ilev,headerIndex)
    elseif (varType .eq. 'MM' ) then
      height = column%gz_m(ilev,headerIndex)
    elseif (varType .eq. 'SF' ) then
      height = column%gz_t(column%nlev_t,headerIndex)
    endif

  end function col_getHeight


  function col_getMountain(column,headerIndex) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: headerIndex
    real*8                              :: height

    height = column%gz_t(column%nlev_t,headerIndex)

  end function col_getMountain


  subroutine col_setMountain(column,headerIndex,height)
    implicit none
    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real*8, intent(in)                  :: height

    column%gz_t(column%nlev_t,headerIndex) = height

  end subroutine col_setMountain


  subroutine col_getLatLon(column,headerIndex,Lat,Lon,Tla)
    implicit none
    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real*8, intent(out)                  :: Lat,Lon
    integer, intent(out)                 :: Tla

    Lat = column%lat(headerIndex)
    Lon = column%lon(headerIndex)
    Tla = column%tla(headerIndex)

  end subroutine col_getLatLon


  subroutine col_setLatLon(column,headerIndex,Lat,Lon,Tla)
    implicit none
    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real*8, intent(in)                  :: Lat,Lon
    integer, intent(in)                 :: Tla

    column%lat(headerIndex) = Lat
    column%lon(headerIndex) = Lon
    column%tla(headerIndex) = Tla

  end subroutine col_setLatLon


  subroutine col_copyLatLon(column_in,column_out)
    implicit none
    type(struct_columnData)             :: column_in,column_out
    integer                             :: headerIndex

    do headerIndex=1,column_in%numCol
      column_out%lat(headerIndex) = column_in%lat(headerIndex)
      column_out%lon(headerIndex) = column_in%lon(headerIndex)
      column_out%tla(headerIndex) = column_in%tla(headerIndex)
    enddo

  end subroutine col_copyLatLon


  function col_getColumn(column,headerIndex,varName) result(onecolumn)
    implicit none
    type(struct_columnData), intent(in)    :: column
    integer, intent(in)                    :: headerIndex
    character(len=*), intent(in), optional :: varName
    real*8,pointer                         :: onecolumn(:)
    integer                                :: ilev1,ilev2

    if(present(varName)) then
      if(col_varExist(varName)) then
        ilev1 = column%varOffset(vnl_varListIndex(varName))+1
        ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(varName))
        onecolumn => column%all(ilev1:ilev2,headerIndex)
      else
        write(*,*) 'col_getColumn: Unknown variable name! ',varName
        call flush(6)
        call qqexit(1)
      endif
    else
      onecolumn => column%all(:,headerIndex)
    endif

  end function col_getColumn


  function col_getElem(column,ilev,headerIndex,varName) result(value)
    implicit none
    type(struct_columnData), intent(in)    :: column
    integer, intent(in)                    :: ilev
    integer, intent(in)                    :: headerIndex
    character(len=*), intent(in), optional :: varName
    real*8                                 :: value

    if(present(varName)) then
      value = column%all(column%varOffset(vnl_varListIndex(varName))+ilev,headerIndex)
    else
      value = column%all(ilev,headerIndex)
    endif

  end function col_getElem


  function col_getNumLev(column,varType) result(nlev)
    implicit none
    type(struct_columnData), intent(in)    :: column
    character(len=*), intent(in), optional :: varType
    integer                                :: nlev

    if(present(varType)) then
      if(varType.eq.'MM') then
        nlev = column%nlev_m
      elseif(varType.eq.'TH') then
        nlev = column%nlev_t
      elseif(varType.eq.'SF') then
        nlev = 1
      else
        write(*,*) 'col_getNumLev: Unknown variable type! ',varType
        call flush(6)
        call qqexit(1)
      endif
    else
      nlev = column%nlev
    endif

  end function col_getNumLev


  function col_getNumCol(column) result(numColumn)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer                             :: numColumn

    numColumn = column%numCol

  end function col_getNumCol


  function col_getNumStep(column) result(numStep)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer                             :: numStep

    numStep = column%nStepObs

  end function col_getNumStep


  subroutine col_setNumStep(column,numStep)
    implicit none
    type(struct_columnData), intent(inout) :: column
    integer, intent(in)                    :: numStep

    column%nStepObs = numStep

  end subroutine col_setNumStep


  function col_getVco(column) result(vco_ptr)
    implicit none
    type(struct_columnData)   :: column
    type(struct_vco), pointer :: vco_ptr

    vco_ptr => column%vco

  end function col_getVco


  subroutine col_setVco(column,vco_ptr)
    implicit none
    type(struct_columnData)   :: column
    type(struct_vco), pointer :: vco_ptr

    column%vco => vco_ptr

  end subroutine col_setVco

end module columnData_mod
