module columnData_mod
  use mpivar_mod
  use varNameList_mod
  use verticalCoord_mod
  use MathPhysConstants_mod
  use obsSpaceData_mod
  implicit none
  save
  private

  ! public variables and types
  public :: rhumin, struct_columnData

  ! public subroutines and functions
  public :: col_setup, col_allocate, col_deallocate, col_pointStagToUnstag, col_expandToMpiGlobal
  public :: col_varExist, col_getOffsetFromVarno
  public :: col_getNumLev, col_getNumCol
  public :: col_getPressure, col_calcPressure, col_vintProf, col_getHeight, col_getMountain, col_setMountain
  public :: col_getLatLon, col_setLatLon, col_copyLatLon
  public :: col_zero, col_fillmvo, col_getAllColumns, col_getColumn, col_getElem, col_getVco, col_setVco

  ! public entities accessed through inheritance
  public :: struct_vco, vco_SetupFromFile, vco_getNumLev
  public :: vnl_varnameFromVarnum, vnl_vartypeFromVarnum
  public :: vgd_get,vgd_levels,vgd_ok,vgd_dpidpis

  type struct_columnData
    integer           :: numCol
    logical           :: allocated=.false.
    logical           :: mpi_local
    real*8,pointer    :: all(:,:)
    real*8,pointer    :: gz_T(:,:),gz_M(:,:)
    real*8,pointer    :: rppobs(:,:),rppobs_T(:,:),rppobs_M(:,:)
    real*8,pointer    :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer    :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi calc.
    real*8,pointer    :: lat(:),lon(:)
    real(8),pointer   :: latRot(:),lonRot(:)
    real(8),pointer   :: ypos(:)
    real(8),pointer   :: xpos(:)
    type(struct_vco), pointer  :: vco => null()
    integer,pointer   :: varOffset(:),varNumLev(:)
  end type struct_columnData

  real*8 :: rhumin
  logical nmvoexist(vnl_numvarmax)
  integer :: nvo3d,nvo2d

  contains


    SUBROUTINE col_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER(len=4) :: CMVONEED(VNL_NUMVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED,rhumin

      if(mpi_myid.eq.0) write(*,*) 'col_setup: List of known (valid) variable names'
      if(mpi_myid.eq.0) write(*,*) 'col_setup: varNameList3D=',vnl_varNameList3D
      if(mpi_myid.eq.0) write(*,*) 'col_setup: varNameList2D=',vnl_varNameList2D
      if(mpi_myid.eq.0) write(*,*) 'col_setup: varNameList  =',vnl_varNameList

!     Read NAMELIST NAMSTATEO to find which fields are needed

      cmvoneed(:) = '    '
      rhumin = MPC_MINIMUM_HU_R8

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      if(ierr.ne.0) call abort3d('col_setup: Error reading namelist')
      if(mpi_myid.eq.0) write(*,nml=namstateo)
      ierr=fclos(nulnam)

      nvo3d  = 0
      nvo2d  = 0

      do jvar = 1, vnl_numvarmax3D
        if (varneed(vnl_varNameList3D(jvar))) then
          nmvoexist(jvar) = .true.
          nvo3d = nvo3d + 1
        else
          nmvoexist(jvar) = .false.
        endif
      enddo

      do jvar = 1, vnl_numvarmax2D
        if (varneed(vnl_varNameList2D(jvar))) then
          nmvoexist(jvar+vnl_numvarmax3D) = .true.
          nvo2d = nvo2d + 1
        else
          nmvoexist(jvar+vnl_numvarmax3D) = .false.
        endif
      enddo

      if(mpi_myid.eq.0) write(*,*) 'col_setup: nvo3d,nvo2d=',nvo3d,nvo2d
      if(mpi_myid.eq.0) write(*,*) 'col_setup: nmvoexist =',nmvoexist

      if(mpi_myid.eq.0) WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      if(mpi_myid.eq.0) WRITE(*,FMT=9120) NVO3D,NVO2D
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6)

      CONTAINS

        LOGICAL FUNCTION VARNEED(varName)
          character(len=*) :: varName
          integer :: jvar
 
          varneed=.false.
          do jvar=1,VNL_NUMVARMAX
            if (trim(varName).eq.trim(cmvoneed(jvar))) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      if(column%numCol.gt.0) then
        column%all(:,:)=0.0d0
        column%rppobs(:,:)=0.0d0
      endif

    END SUBROUTINE col_zero


    SUBROUTINE col_allocate(column,numCol,mpi_local)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer, intent(in)           :: numCol
      logical, optional             :: mpi_local
      integer :: nkgdimo,ier

      integer iloc,jvar,jvar2

      column%numCol = numCol
      if(present(mpi_local)) then
        column%mpi_local=mpi_local
      else
        column%mpi_local=.true.
        if(mpi_myid.eq.0) write(*,*) 'col_allocate: assuming columnData is mpi-local'
      endif

      if(.not.column%vco%initialized) then
        call abort3d('col_allocate: VerticalCoord has not been initialized!')
      endif

      allocate(column%varOffset(vnl_numvarmax))
      column%varOffset(:)=0
      allocate(column%varNumLev(vnl_numvarmax))
      column%varNumLev(:)=0

      iloc=0
      do jvar = 1, vnl_numvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=col_getNumLev(column,vnl_vartypeFromVarname(vnl_varNameList(jvar)))
          iloc = iloc + column%varNumLev(jvar)
        endif
      enddo
      do jvar2 = 1, vnl_numvarmax2d
        jvar=jvar2+vnl_numvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=1
          iloc = iloc + 1
        endif
      enddo
      nkgdimo=iloc

      if(column%numCol.le.0) then
        write(*,*) 'col_allocate: number of columns is zero, not allocated'
      else         
        allocate(column%all(nkgdimo,column%numCol))
        column%all(:,:)=0.0d0

        allocate(column%gz_T(col_getNumLev(column,'TH'),column%numCol))
        allocate(column%gz_M(col_getNumLev(column,'MM'),column%numCol))
        column%gz_T(:,:)=0.0d0
        column%gz_M(:,:)=0.0d0

        allocate(column%rppobs  (col_getNumLev(column)     ,column%numCol))
        allocate(column%rppobs_T(col_getNumLev(column,'TH'),column%numCol))
        allocate(column%rppobs_M(col_getNumLev(column,'MM'),column%numCol))
        column%rppobs(:,:)=0.0d0
        column%rppobs_T(:,:)=0.0d0
        column%rppobs_M(:,:)=0.0d0

        allocate(column%lat(column%numCol))
        allocate(column%lon(column%numCol))
        allocate(column%latRot(column%numCol))
        allocate(column%lonRot(column%numCol))
        allocate(column%ypos(column%numCol))
        allocate(column%xpos(column%numCol))
        column%lat(:)=0.0d0
        column%lon(:)=0.0d0
        column%latRot(:)=0.0d0
        column%lonRot(:)=0.0d0
        column%ypos(:)=0.0d0
        column%xpos(:)=0.0d0

        allocate(column%oltv(2,col_getNumLev(column),numCol))
        column%oltv(:,:,:)=0.0d0
        allocate(column%rtapfac(col_getNumLev(column),numCol))
        column%rtapfac(:,:)=0.0d0

      endif
 
      if(mpi_myid.eq.0) write(*,*) 'col_allocate: nkgdimo = ',nkgdimo
      if(mpi_myid.eq.0) write(*,*) 'col_allocate: varOffset=',column%varOffset
      if(mpi_myid.eq.0) write(*,*) 'col_allocate: varNumLev=',column%varNumLev

      column%allocated=.true.

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%varOffset)
      deallocate(column%varNumLev)

      if(column%numCol.gt.0) then
        deallocate(column%all)
        deallocate(column%gz_T)
        deallocate(column%gz_M)
        deallocate(column%rppobs)
        deallocate(column%rppobs_T)
        deallocate(column%rppobs_M)
        deallocate(column%lat)
        deallocate(column%lon)
        deallocate(column%latRot)
        deallocate(column%lonRot)
        deallocate(column%ypos)
        deallocate(column%xpos)
        deallocate(column%oltv)
        deallocate(column%rtapfac)
      endif

      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_fillmvo(columnghr,varName,varType,pvar)
    !
    !**s/r fillmvo - Fill in values for a complete set of columns at once
    !
    !Arguments
    !
    !       input:
    !            columnghr          : HR or BG column object
    !             VARNAME (character*4): NOMVAR of the state variable
    !             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
    !             KNLEV (integer)     : number of levels of PVAR
    !             KNOBS (integer)     : number of observation profiles in variable PVAR
    implicit none

    type(struct_columnData) :: columnghr
    real*8 pvar(:,:)
    character(len=*) :: varName
    character(len=*) :: varType

    integer jobs,jlev
    real*8, pointer :: column_ptr(:)

    ! Pressure
    select case(trim(varName))
    case('PP')
      if(varType.eq.'TH') then
        do jobs = 1,columnghr%numCol
          do jlev = 1,col_getNumLev(columnghr,'TH')
            columnghr%rppobs_T(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      elseif(varType.eq.'MM') then
        do jobs = 1,columnghr%numCol
          do jlev = 1,col_getNumLev(columnghr,'MM')
            columnghr%rppobs_M(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      else
        do jobs = 1,columnghr%numCol
          do jlev = 1,col_getNumLev(columnghr)
            columnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! Height
    case('GZ')
      if(varType.eq.'TH') then
        do jobs = 1,columnghr%numCol
          do jlev = 1, col_getNumLev(columnghr,'TH')
            columnghr%gz_T(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(varType.eq.'MM') then
        do jobs = 1,columnghr%numCol
          do jlev = 1, col_getNumLev(columnghr,'MM')
            columnghr%gz_M(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      else
        do jobs = 1,columnghr%numCol
          column_ptr => col_getColumn(columnghr,jobs,varName)
          do jlev = 1, col_getNumLev(columnghr,vnl_vartypeFromVarname(varName))
            column_ptr(jlev)=pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! All the other variables that are stored in column%all
    case default
      if(col_varExist(varName)) then
        do jobs = 1,columnghr%numCol
          column_ptr => col_getColumn(columnghr,jobs,varName)
          do jlev = 1, col_getNumLev(columnghr,vnl_vartypeFromVarname(varName))
            column_ptr(jlev)=pvar(jlev,jobs) 
          enddo
        enddo

      ! Unknown variable name
      else
        call abort3d('col_fillmvo: Unknown variable name: ' // varName)
      endif

    end select

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_pointStagToUnstag(column)
      IMPLICIT NONE
      type(struct_columnData) :: column
      integer                 :: ilev1,ilev2

      if(column%numCol.le.0) return

      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)

      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+1
      ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex('GZ')) 
      column%gz_T => column%all(ilev1:ilev2,:)
      column%gz_M => column%all(ilev1:ilev2,:)

      column%rppobs_T => column%rppobs
      column%rppobs_M => column%rppobs

    END SUBROUTINE col_pointStagToUnstag


    SUBROUTINE col_expandToMpiGlobal(column_local,column_global,lobsSpaceData)
      implicit none

      type(struct_columnData) :: column_local,column_global
      type(struct_obs) :: lobsSpaceData

      integer :: iobs_local,iobs_global,ierr,nsize,sizeone
      real*8, allocatable :: mountain(:)

      ! determine the number of columns for mpiglobal object
      sizeone=1
      call rpn_comm_allreduce(column_local%numCol,column_global%numCol,sizeone,"mpi_integer", &
                              "mpi_sum","GRID",ierr)       

      print*,'Entering col_expandToMpiGlobal:',  &
             column_local%numCol,column_global%numCol  

      call col_setVco(column_global,col_getVco(column_local))
      call col_allocate(column_global,column_global%numCol,mpi_local=.false.)

      column_global%varOffset(:) = column_local%varOffset(:)
      column_global%varNumLev(:) = column_local%varNumLev(:)

      allocate(mountain(column_global%numCol))
      mountain(:)=0.0d0
      do iobs_local=1,column_local%numCol
        iobs_global=obs_headerIndex_mpiglobal(lobsSpaceData,iobs_local)
        column_global%all(:,iobs_global)              = column_local%all(:,iobs_local)
        mountain(iobs_global)                         = column_local%gz_t(col_getNumLev(column_local,'TH'),iobs_local)
        column_global%lat(iobs_global)                = column_local%lat(iobs_local)
        column_global%lon(iobs_global)                = column_local%lon(iobs_local)
        column_global%latRot(iobs_global)             = column_local%latRot(iobs_local)
        column_global%lonRot(iobs_global)             = column_local%lonRot(iobs_local)
        column_global%ypos(iobs_global)                = column_local%ypos(iobs_local)
        column_global%xpos(iobs_global)                = column_local%xpos(iobs_local)
      enddo

      if(mpi_myid.eq.0) write(*,*) 'starting allreduce'

      nsize=size(column_global%all)
      call rpn_comm_allreduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=size(mountain)
      call rpn_comm_allreduce(mountain,mountain,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=size(column_global%lat)
      call rpn_comm_allreduce(column_global%lat,column_global%lat,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%lon,column_global%lon,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%latRot,column_global%lat,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%lonRot,column_global%lon,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%ypos,column_global%ypos,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(column_global%xpos,column_global%xpos,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      do iobs_global=1,column_global%numCol
        column_global%gz_t(col_getNumLev(column_global,'TH'),iobs_global) = mountain(iobs_global)
      enddo

      deallocate(mountain)

      if(mpi_myid.eq.0) write(*,*) 'Leaving col_expandToMpiGlobal' 

    END SUBROUTINE col_expandToMpiGlobal


    function col_varExist(varName) result(varExist)
      implicit none
      character(len=*), intent(in) :: varName
      logical                      :: varExist 

      if(nmvoexist(vnl_varListIndex(varName))) then
        varExist = .true.
      else
        varExist = .false.
      endif

    end function col_varExist


    function col_getOffsetFromVarno(column,varnum) result(offset)
      implicit none
      type(struct_columnData) :: column
      integer, intent(in)     :: varnum
      integer                 :: offset

      offset=column%varOffset(vnl_varListIndex(vnl_varnameFromVarnum(varnum)))

    end function col_getOffsetFromVarno


  subroutine col_calcPressure(column)
    implicit none
    type(struct_columnData), intent(inout) :: column

    real(kind=8), allocatable :: P_sfc(:,:),zppobs2(:,:)
    real(kind=8), pointer :: zppobs1(:,:,:) => null()
    integer :: jobs,status,iversion

    allocate(P_sfc(1,col_getNumCol(column)))
    do jobs = 1,col_getNumCol(column)
      P_sfc(1,jobs) = col_getElem(column,1,jobs,'P0')
    enddo

    ! check if vertical coordinate is unstaggered
    status = vgd_get(column%vco%vgrid,key='ig_1 - vertical coord code',value=iversion)
    if(iversion .eq. 5001) then
      write(*,*) 'col_calcPressure: computing pressure on UNstaggered levels'

      status=vgd_levels(column%vco%vgrid,ip1_list=column%vco%ip1_M,  &
                        levels=zppobs1,sfc_field=P_sfc,in_log=.false.)      
      if(status.ne.VGD_OK) then
         call abort3d('ERROR with vgd_levels for desired levels ')
      endif
      allocate(zppobs2(col_getNumLev(column),col_getNumCol(column)))
      zppobs2 = transpose(zppobs1(1,:,:))
      call col_fillmvo(column,'PP','NA',zppobs2)
      if (associated(zppobs1)) deallocate(zppobs1)
      deallocate(zppobs2)

    else
      write(*,*) 'col_calcPressure: computing pressure on staggered levels'

      status=vgd_levels(column%vco%vgrid,ip1_list=column%vco%ip1_M,  &
                        levels=zppobs1,sfc_field=P_sfc,in_log=.false.)
      if(status.ne.VGD_OK) call abort3d('ERROR with vgd_levels')
      allocate(zppobs2(col_getNumLev(column,'MM'),col_getNumCol(column)))
      zppobs2 = transpose(zppobs1(1,:,:))
      call col_fillmvo(column,'PP','MM',zppobs2)
      if (associated(zppobs1))  deallocate(zppobs1)
      deallocate(zppobs2)

      status=vgd_levels(column%vco%vgrid,ip1_list=column%vco%ip1_T,  &
                        levels=zppobs1,sfc_field=P_sfc,in_log=.false.)
      if(status.ne.VGD_OK) call abort3d('ERROR with vgd_levels')
      allocate(zppobs2(col_getNumLev(column,'TH'),col_getNumCol(column)))
      zppobs2 = transpose(zppobs1(1,:,:))
      call col_fillmvo(column,'PP','TH',zppobs2)
      if (associated(zppobs1)) deallocate(zppobs1)
      deallocate(zppobs2)

    endif

    deallocate(P_sfc)

  end subroutine col_calcPressure


  subroutine col_vintprof(column_in,column_out,varName)
    implicit none
    type(struct_columnData), intent(inout) :: column_out
    type(struct_columnData), intent(in) :: column_in
    character(len=*) :: varName

    real(kind=8), pointer :: column_ptr_in(:),column_ptr_out(:)
    character(len=2) :: varType
    real(kind=8)     :: zwb,zwt
    integer          :: jlevo,jlevi,jprof

    varType = vnl_vartypeFromVarname(varName)

    do jprof = 1, col_getNumCol(column_out)
      column_ptr_in  => col_getColumn(column_in ,jprof,varName)
      column_ptr_out => col_getColumn(column_out,jprof,varName)
      jlevi = 1
      do jlevo = 1, col_getNumLev(column_out,varType)
        jlevi = jlevi + 1
        do while(col_getPressure(column_out,jlevo,jprof,varType) .gt.  &
                 col_getPressure(column_in ,jlevi,jprof,varType) .and. &
                 jlevi .lt. col_getNumLev(column_in,varType) )
          jlevi = jlevi + 1
        enddo
        jlevi = jlevi - 1
        zwb = log(col_getPressure(column_out,jlevo,jprof,varType)/col_getPressure(column_in,jlevi,jprof,varType))/  &
              log(col_getPressure(column_in,jlevi+1,jprof,varType)/col_getPressure(column_in,jlevi,jprof,varType))
        zwt = 1. - zwb
        column_ptr_out(jlevo) = zwb*column_ptr_in(jlevi+1) + zwt*column_ptr_in(jlevi)
      enddo
    enddo

  end subroutine col_vintprof


  function col_getPressure(column,ilev,headerIndex,varType) result(pressure)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character(len=*), intent(in)        :: varType
    real*8                              :: pressure

    if (varType .eq. 'NA') then
      pressure = column%rppobs(ilev,headerIndex)
    elseif (varType .eq. 'TH') then
      pressure = column%rppobs_t(ilev,headerIndex)
    elseif (varType .eq. 'MM' ) then
      pressure = column%rppobs_m(ilev,headerIndex)
    elseif (varType .eq. 'SF' ) then
      pressure = column%rppobs_t(col_getNumLev(column,'TH'),headerIndex)
    else
      call abort3d('col_getPressure: Unknown variable type: ' // varType)
    endif

  end function col_getPressure
 

  function col_getHeight(column,ilev,headerIndex,varType) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character(len=*), intent(in)        :: varType
    real*8                              :: height
    integer                             :: ilev1

    if (varType .eq. 'NA') then
      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+ilev
      height = column%all(ilev1,headerIndex)
    elseif (varType .eq. 'TH') then
      height = column%gz_t(ilev,headerIndex)
    elseif (varType .eq. 'MM' ) then
      height = column%gz_m(ilev,headerIndex)
    elseif (varType .eq. 'SF' ) then
      height = column%gz_t(col_getNumLev(column,'TH'),headerIndex)
    endif

  end function col_getHeight


  function col_getMountain(column,headerIndex) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: headerIndex
    real*8                              :: height

    height = column%gz_t(col_getNumLev(column,'TH'),headerIndex)

  end function col_getMountain


  subroutine col_setMountain(column,headerIndex,height)
    implicit none
    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real*8, intent(in)                  :: height

    column%gz_t(col_getNumLev(column,'TH'),headerIndex) = height

  end subroutine col_setMountain


  subroutine col_getLatLon(column, headerIndex, Lat, Lon, &
                           ypos, xpos, LatRot, LonRot)
    implicit none

    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real(8), intent(out)                :: Lat, Lon
    real(8), intent(out)                :: LatRot, LonRot
    real(8), intent(out)                :: Ypos, Xpos

    Lat    = column % lat   (headerIndex)
    Lon    = column % lon   (headerIndex)
    LatRot = column % latRot(headerIndex)
    LonRot = column % lonRot(headerIndex)
    ypos   = column % ypos  (headerIndex)
    xpos   = column % xpos  (headerIndex)

  end subroutine col_getLatLon


  subroutine col_setLatLon(column, headerIndex, Lat, Lon, &
                           Ypos, Xpos, LatRot, LonRot)
    implicit none

    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real(8), intent(in)                 :: Lat,Lon
    real(8), intent(in)                 :: LatRot,LonRot
    real(8), intent(in)                 :: Ypos, Xpos

    column % lat   (headerIndex) = Lat
    column % lon   (headerIndex) = Lon
    column % latRot(headerIndex) = LatRot
    column % lonRot(headerIndex) = LonRot
    column % ypos  (headerIndex) = Ypos
    column % xpos  (headerIndex) = Xpos

  end subroutine col_setLatLon


  subroutine col_copyLatLon(column_in,column_out)
    implicit none
    type(struct_columnData)             :: column_in,column_out
    integer                             :: headerIndex

    do headerIndex = 1, column_in % numCol
      column_out % lat   (headerIndex) = column_in % lat   (headerIndex)
      column_out % lon   (headerIndex) = column_in % lon   (headerIndex)
      column_out % latRot(headerIndex) = column_in % latRot(headerIndex)
      column_out % lonRot(headerIndex) = column_in % lonRot(headerIndex)
      column_out % ypos  (headerIndex) = column_in % ypos  (headerIndex)
      column_out % xpos  (headerIndex) = column_in % xpos  (headerIndex)
    end do

  end subroutine col_copyLatLon

  function col_getAllColumns(column,varName) result(allColumns)
    implicit none
    type(struct_columnData), intent(in)    :: column
    character(len=*), intent(in), optional :: varName
    real*8,pointer                         :: allColumns(:,:)
    integer                                :: ilev1,ilev2

    if ( column%numCol > 0 ) then
      if(present(varName)) then
        if(col_varExist(varName)) then
          ilev1 = column%varOffset(vnl_varListIndex(varName))+1
          ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(varName))
          allColumns => column%all(ilev1:ilev2,:)
        else
          call abort3d('col_getColumn: Unknown variable name! ' // varName)
        endif
      else
        allColumns => column%all(:,:)
      endif
    else
      allColumns => null()
    end if

  end function col_getAllColumns

  function col_getColumn(column,headerIndex,varName,varType) result(onecolumn)
    implicit none
    type(struct_columnData), intent(in)    :: column
    integer, intent(in)                    :: headerIndex
    character(len=*), intent(in), optional :: varName
    character(len=*), intent(in), optional :: varType
    real*8,pointer                         :: onecolumn(:)
    integer                                :: ilev1,ilev2

    if(present(varName)) then
      if(col_varExist(varName)) then
        select case(trim(varName))
        case('PP')
          if(present(varType)) then 
            if(varType.eq.'TH') then
              onecolumn => column%rppobs_T(:,headerIndex)
            elseif(varType.eq.'MM') then
              onecolumn => column%rppobs_M(:,headerIndex)
            else
              onecolumn => column%rppobs(:,headerIndex)
            endif
          else
            onecolumn => column%rppobs(:,headerIndex)
          endif
        case('GZ')
          if(present(varType)) then 
            if(varType.eq.'TH') then
              onecolumn => column%gz_T(:,headerIndex)
            elseif(varType.eq.'MM') then
              onecolumn => column%gz_M(:,headerIndex)
            else
              ilev1 = column%varOffset(vnl_varListIndex(varName))+1
              ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(varName))
              onecolumn => column%all(ilev1:ilev2,headerIndex)
            endif
          else
            ilev1 = column%varOffset(vnl_varListIndex(varName))+1
            ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(varName))
            onecolumn => column%all(ilev1:ilev2,headerIndex)
          endif
        case default ! all other variable names
          ilev1 = column%varOffset(vnl_varListIndex(varName))+1
          ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(varName))
          onecolumn => column%all(ilev1:ilev2,headerIndex)
        end select
      else
        call abort3d('col_getColumn: Unknown variable name! ' // varName)
      endif
    else
      onecolumn => column%all(:,headerIndex)
    endif

  end function col_getColumn


  function col_getElem(column,ilev,headerIndex,varName) result(value)
    implicit none
    type(struct_columnData), intent(in)    :: column
    integer, intent(in)                    :: ilev
    integer, intent(in)                    :: headerIndex
    character(len=*), intent(in), optional :: varName
    real*8                                 :: value

    if(present(varName)) then
      value = column%all(column%varOffset(vnl_varListIndex(varName))+ilev,headerIndex)
    else
      value = column%all(ilev,headerIndex)
    endif

  end function col_getElem


  function col_getNumLev(column,varType) result(nlev)
    implicit none
    type(struct_columnData), intent(in)    :: column
    character(len=*), intent(in), optional :: varType
    integer                                :: nlev

    if(present(varType)) then
      nlev = vco_getNumLev(column%vco,varType)
    else
      nlev = vco_getNumLev(column%vco)
    endif

  end function col_getNumLev


  function col_getNumCol(column) result(numColumn)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer                             :: numColumn

    numColumn = column%numCol

  end function col_getNumCol


  function col_getVco(column) result(vco_ptr)
    implicit none
    type(struct_columnData)   :: column
    type(struct_vco), pointer :: vco_ptr

    vco_ptr => column%vco

  end function col_getVco


  subroutine col_setVco(column,vco_ptr)
    implicit none
    type(struct_columnData)   :: column
    type(struct_vco), pointer :: vco_ptr

    column%vco => vco_ptr

  end subroutine col_setVco

end module columnData_mod
