module columnData_mod
  use verticalCoord_mod
  implicit none
  save
!  private

  type struct_columnData
    integer :: nlev,nlev_T,nlev_M
    integer :: nkgdimo,nobtot
    logical :: allocated=.false.
    real*8,pointer :: all(:,:)
    real*8,pointer :: uu(:,:)
    real*8,pointer :: vv(:,:)
    real*8,pointer :: tt(:,:)
    real*8,pointer :: hu(:,:)
    real*8,pointer :: gz(:,:),gz_T(:,:),gz_M(:,:)
    real*8,pointer :: tr(:,:)
    real*8,pointer :: ps(:,:)
    real*8,pointer :: tg(:,:)
    real*8,pointer :: rppobs(:,:),rppobs_T(:,:),rppobs_M(:,:)
    real*8,pointer :: vhyb(:),vhyb_T(:),vhyb_M(:)
    real*8,pointer :: rmtmobs(:)
  end type struct_columnData

    real*8,pointer :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi transformation

    INTEGER,parameter :: JPNVARMAX=10
    INTEGER NMVOEXIST(JPNVARMAX)
    INTEGER nouu,novv,noq,nogz,nott,notr,nops,notg
    integer :: nvo3d,nvo2d
    real*8 :: rhumin

  contains

    SUBROUTINE col_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER*2 CMVONEED(JPNVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED,rhumin

!     Model state at the observation locations
      nouu = 1
      novv = 2
      nogz = 3
      nott = 4
      noq  = 5
      notr = 6
      nops = 7
      notg = 8

      DO JVAR = 1, JPNVARMAX
         NMVOEXIST(JVAR) = 0
      END DO

!    2. Read NAMELIST NAMSTATE to find which fields are needed

      DO JVAR = 1, JPNVARMAX
        cmvoneed(jvar) = ' '
      enddo

      CMVONEED(1)   ='UU'
      CMVONEED(2)   ='VV'
      CMVONEED(3)   ='TT'
      CMVONEED(4)   ='HU'
      CMVONEED(5)   ='GZ'
      CMVONEED(6)   ='P0'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'col_setup: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      NVO3D  = 0
      NVO2D  = 0

      IPOS = 1
      DO JVAR = 1, JPNVARMAX
        IF (NOUU .EQ. JVAR) THEN
          IF (VARNEED('UU')) THEN
            NOUU = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOUU = -9
          ENDIF
        ELSEIF(NOVV .EQ. JVAR) THEN
          IF (VARNEED('VV')) THEN
            NOVV = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOVV = -9
          ENDIF
        ELSEIF(NOQ .EQ. JVAR) THEN
          IF (VARNEED('HU')) THEN
            NOQ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOQ = -9
          ENDIF
        ELSEIF(NOGZ .EQ. JVAR) THEN
          IF (VARNEED('GZ')) THEN
            NOGZ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOGZ = -9
          ENDIF
        ELSEIF(NOTT .EQ. JVAR) THEN
          IF (VARNEED('TT')) THEN
            NOTT = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTT = -9
          ENDIF
        ELSEIF(NOTR .EQ. JVAR) THEN
          IF (VARNEED('XT')) THEN
            NOTR = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTR = -9
          ENDIF
        ELSEIF(NOPS .EQ. JVAR) THEN
          IF (VARNEED('P0')) THEN
            NOPS = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO2D = NVO2D + 1
          ELSE
            NOPS = -9
          ENDIF
        elseif(notg .eq. jvar) then
          if (VARNEED('TG')) then
            notg = ipos
            nmvoexist(ipos) = 1
            ipos = ipos + 1
            NVO2D = NVO2D + 1
          else
            notg = -9
          endif
        ENDIF
      ENDDO
!
      IF(NOUU .EQ. -9) THEN
        NOUU = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOVV .EQ. -9) THEN
        NOVV = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOQ .EQ. -9) THEN
        NOQ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOGZ .EQ. -9) THEN
        NOGZ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTT .EQ. -9) THEN
        NOTT = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTR .EQ. -9) THEN
        NOTR = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOPS .EQ. -9) THEN
        NOPS = IPOS
        IPOS = IPOS + 1
      ENDIF
      if(notg .eq. -9) then
        notg = ipos
        ipos = ipos + 1
      endif

      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6)


      CONTAINS

        LOGICAL FUNCTION VARNEED(VARCHAR)
          character*2 :: varchar
          integer :: jvar
 
          varneed=.false.
          do jvar=1,JPNVARMAX
            if (varchar.eq.cmvoneed(jvar)) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_SUALOBSB(nflev,nobtot) 
      IMPLICIT NONE

      INTEGER nflev,nobtot
      INTEGER IERR

      WRITE(*,FMT='(//,6(" ***********"))')
      WRITE(*,*)'     SUALOBSB:  Memory allocation of the observation arrays'
      WRITE(*,FMT='(6(" ***********"))')

      allocate(oltv(2,nflev,nobtot))
      oltv(:,:,:)=0.0d0
      allocate(rtapfac(nflev,nobtot))

      RETURN
    END SUBROUTINE col_sualobsb

    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
      column%rmtmobs(:)=0.0d0      
    END SUBROUTINE col_zero

    SUBROUTINE col_allocate(column,kstep,nobtot)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer :: kstep,nobtot
      integer :: ier

      integer iloc,jvar

      column%allocated=.true.
      column%nkgdimo = nvo3d*kstep + nvo2d
      column%nobtot = nobtot
      column%nlev = kstep
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo

      allocate(column%all(column%nkgdimo,column%nobtot))
      column%all(:,:)=0.0d0

      allocate(column%gz_T(column%nlev,column%nobtot))
      allocate(column%gz_M(column%nlev,column%nobtot))
      column%gz_T(:,:)=0.0d0
      column%gz_M(:,:)=0.0d0

      allocate(column%rppobs(column%nlev,column%nobtot))
      allocate(column%rppobs_T(column%nlev,column%nobtot))
      allocate(column%rppobs_M(column%nlev,column%nobtot))
      column%rppobs(:,:)=0.0d0
      column%rppobs_T(:,:)=0.0d0
      column%rppobs_M(:,:)=0.0d0

      allocate(column%vhyb(column%nlev))
      allocate(column%vhyb_T(column%nlev))
      allocate(column%vhyb_M(column%nlev))

      allocate(column%rmtmobs(column%nobtot))
      column%rmtmobs(:)=0.0d0      

      iloc = 1
      do jvar = 1, jpnvarmax
        if(jvar.eq.nouu) then
          if(nmvoexist(nouu).eq.1) then
            column%uu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.novv) then
          if(nmvoexist(novv).eq.1) then
            column%vv => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nogz) then
          if(nmvoexist(nogz).eq.1) then
            column%gz => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noq) then
          if(nmvoexist(noq).eq.1) then
            column%hu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nott) then
          if(nmvoexist(nott).eq.1) then
            column%tt => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.notr) then
          if(nmvoexist(notr).eq.1) then
            column%tr => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nops) then
          if(nmvoexist(nops).eq.1) then
            column%ps => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
        if(jvar.eq.notg) then
          if(nmvoexist(notg).eq.1) then
            column%tg => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
      enddo

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%all)
      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)
      deallocate(column%vhyb)
      deallocate(column%vhyb_T)
      deallocate(column%vhyb_M)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_copy2d(column_in,column_out)
      IMPLICIT NONE

      type(struct_columnData) :: column_in,column_out
      integer :: jobs,jv,jv_in,jv_out
 
      do jobs = 1, column_in%nobtot
        do jv = 1, nvo2d
          jv_in   = jv + nvo3d*column_in%nlev
          jv_out  = jv + nvo3d*column_out%nlev
          column_out%all(jv_out,jobs) =  column_in%all(jv_in,jobs)
        enddo
      enddo
      column_out%rmtmobs(:) =  column_in%rmtmobs(:)

    END SUBROUTINE col_copy2d


    SUBROUTINE col_fillmvo(lcolumnghr,cdvar,cdlev,pvar,knlev,knobs)
!
!**s/r fillmvo - Fill in COMMVOG and/or COMMVOHR
!
!     Author  : S. Pellerin ARMA/AES SEPT. 2000
!     Revision:
!
!*    Purpose: Fill in COMMVOG/COMMVOHR with trial profiles
!
!Arguments
!
!       input:
!            lcolumnghr          : HR or BG column object
!             CDVAR (character*2) : NOMVAR of the state variable
!             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
!             KNLEV (integer)     : number of levels of PVAR
!             KNOBS (integer)     : number of observation profiles in variable PVAR
!
    use MathPhysConstants_mod
    implicit none

    type(struct_columnData) :: lcolumnghr
    integer knlev,knobs
    real*8 pvar(knlev,knobs)
    character*2 cdvar,cdlev

    integer jobs,jlev

      if (cdvar.eq.'PP') then
        if(cdlev.eq.'TH') then
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs_T(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        elseif(cdlev.eq.'MM') then
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs_M(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        else
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        endif
      elseif(cdvar.eq.'HY') then
        if(cdlev.eq.'TH') then
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb_T(jlev) = pvar(jlev,1)
          enddo
        elseif(cdlev.eq.'MM') then
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb_M(jlev) = pvar(jlev,1)
          enddo
        else
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb(jlev) = pvar(jlev,1)
          enddo
        endif
      elseif(cdvar.eq.'UU') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%uu(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'VV') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%vv(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'GZ') then
        if(cdlev.eq.'TH') then
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz_T(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        elseif(cdlev.eq.'MM') then
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz_M(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        else
          do jobs = 1,lcolumnghr%nobtot
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        endif
      elseif(cdvar.eq.'HU') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=log(max(pvar(jlev,jobs),rhumin))
          enddo
        enddo
      elseif(cdvar.eq.'LQ') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'TT') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tt(jlev,jobs)=pvar(jlev,jobs) + tcdk
          enddo
        enddo
      elseif(cdvar.eq.'TR') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tr(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'P0') then
        do jobs = 1,lcolumnghr%nobtot
          lcolumnghr%ps(1,jobs)=pvar(1,jobs)*rmbtpa
        enddo
      elseif(cdvar.eq.'TG') then
        do jobs = 1,lcolumnghr%nobtot
          lcolumnghr%tg(1,jobs)=pvar(1,jobs)
        enddo
      endif

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_pointStagToUnstag(lcolumn)
      IMPLICIT NONE
      type(struct_columnData) :: lcolumn

      deallocate(lcolumn%gz_T)
      deallocate(lcolumn%gz_M)
      deallocate(lcolumn%rppobs_T)
      deallocate(lcolumn%rppobs_M)
      deallocate(lcolumn%vhyb_T)
      deallocate(lcolumn%vhyb_M)

      lcolumn%gz_T => lcolumn%gz
      lcolumn%gz_M => lcolumn%gz
      lcolumn%rppobs_T => lcolumn%rppobs
      lcolumn%rppobs_M => lcolumn%rppobs
      lcolumn%vhyb_T => lcolumn%vhyb
      lcolumn%vhyb_M => lcolumn%vhyb

      lcolumn%nlev_T=lcolumn%nlev
      lcolumn%nlev_M=lcolumn%nlev

    END SUBROUTINE col_pointStagToUnstag


    SUBROUTINE col_expandToMpiGlobal(lcolumng,nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r col_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global column object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

    USE obsSpaceData_mod, only: locObsTag
    IMPLICIT NONE
    type(struct_columnData) :: lcolumng
    integer, intent(in) :: nulout       ! standard output unit
    integer, intent(in) :: nobtot       ! Actual number of observations
    integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot

!   Declare Local Variables. 
    REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
    
    INTEGER :: i,iobs,ierr,sizeRMTMOBS  
!!---------------------------------------------------------------

!!  1.  Release some memory. 
    print*,'Entering col_expandToMpiGlobal'  

!!  1.2 Added restore global array RMTMOBS
    ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
    IF(ierr /= 0)CALL ABORT3D(nulout,'Cant allocate Mem. to RMTMOBS_tmp,Abort!') 
    RMTMOBS_TMP=0.0D0 

!!  1.3 Retore global RMTMOBS
    DO i=1,NOBTOT
       iobs=locObsTag(i)
       RMTMOBS_tmp(iobs)=lcolumng%RMTMOBS(i)
    ENDDO  
    sizeRMTMOBS=NOBTOTP
    CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS, &
                            "mpi_double_precision","mpi_sum","GRID",ierr)

!!  DEALLOCATE(RMTMOBS)
    deallocate(lcolumng%rmtmobs)
    allocate(lcolumng%rmtmobs(nobtotp))
    lcolumng%RMTMOBS=RMTMOBS_tmp
    DEALLOCATE(RMTMOBS_tmp)

    print*,'Leaving col_expandToMpiGlobal' 
    RETURN
  END SUBROUTINE col_expandToMpiGlobal


    SUBROUTINE col_expandToMpiGlobal3(column_local,column_global)
      USE obsSpaceData_mod, only: locObsTag
      IMPLICIT NONE

      type(struct_columnData) :: column_local,column_global

      INTEGER :: i,iobs,ierr,nsize

      print*,'Entering col_expandToMpiGlobal3:',  &
             column_local%nobtot,column_global%nobtot  
      call flush(6)

      column_global%all(:,:)=0.0d0
      DO i=1,column_local%nobtot
        iobs=locObsTag(i)
        column_global%all(:,iobs)  =column_local%all(:,i)
      ENDDO

      write(*,*) 'starting allreduce'
      call flush(6)
      nsize=column_global%nkgdimo*column_global%nobtot
      CALL RPN_COMM_ALLReduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving col_expandToMpiGlobal3' 
      call flush(6)
      RETURN

    END SUBROUTINE col_expandToMpiGlobal3

end module columnData_mod
