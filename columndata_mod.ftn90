module columnData_mod
  use verticalCoord_mod
  implicit none
  save
!  private

  type struct_columnData
    integer :: nlev,nlev_T,nlev_M
    integer :: nkgdimo,numObsHeader
    logical :: allocated=.false.
    real*8,pointer :: all(:,:)
    real*8,pointer :: uu(:,:)
    real*8,pointer :: vv(:,:)
    real*8,pointer :: tt(:,:)
    real*8,pointer :: hu(:,:)
    real*8,pointer :: gz(:,:),gz_T(:,:),gz_M(:,:)
    real*8,pointer :: tr(:,:)
    real*8,pointer :: ps(:,:)
    real*8,pointer :: tg(:,:)
    real*8,pointer :: rppobs(:,:),rppobs_T(:,:),rppobs_M(:,:)
    real*8,pointer :: vhyb(:),vhyb_T(:),vhyb_M(:)
    real*8,pointer :: rmtmobs(:)
    real*8,pointer :: timeInterpWeight(:,:)  ! weights for linear temporal interpolation of increment to obs times
    real*8,pointer :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi transformation
  end type struct_columnData


    INTEGER,parameter :: JPNVARMAX=10
    INTEGER NMVOEXIST(JPNVARMAX)
    INTEGER nouu,novv,noq,nogz,nott,notr,nops,notg
    integer :: nvo3d,nvo2d
    real*8 :: rhumin
    integer, parameter :: mxstepobs=9 ! temporarily specify max number of step obs for allocation

  contains

    SUBROUTINE col_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER*2 CMVONEED(JPNVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED,rhumin

!     Model state at the observation locations
      nouu = 1
      novv = 2
      nogz = 3
      nott = 4
      noq  = 5
      notr = 6
      nops = 7
      notg = 8

      DO JVAR = 1, JPNVARMAX
         NMVOEXIST(JVAR) = 0
      END DO

!    2. Read NAMELIST NAMSTATE to find which fields are needed

      DO JVAR = 1, JPNVARMAX
        cmvoneed(jvar) = ' '
      enddo

      CMVONEED(1)   ='UU'
      CMVONEED(2)   ='VV'
      CMVONEED(3)   ='TT'
      CMVONEED(4)   ='HU'
      CMVONEED(5)   ='GZ'
      CMVONEED(6)   ='P0'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'col_setup: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      NVO3D  = 0
      NVO2D  = 0

      IPOS = 1
      DO JVAR = 1, JPNVARMAX
        IF (NOUU .EQ. JVAR) THEN
          IF (VARNEED('UU')) THEN
            NOUU = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOUU = -9
          ENDIF
        ELSEIF(NOVV .EQ. JVAR) THEN
          IF (VARNEED('VV')) THEN
            NOVV = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOVV = -9
          ENDIF
        ELSEIF(NOQ .EQ. JVAR) THEN
          IF (VARNEED('HU')) THEN
            NOQ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOQ = -9
          ENDIF
        ELSEIF(NOGZ .EQ. JVAR) THEN
          IF (VARNEED('GZ')) THEN
            NOGZ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOGZ = -9
          ENDIF
        ELSEIF(NOTT .EQ. JVAR) THEN
          IF (VARNEED('TT')) THEN
            NOTT = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTT = -9
          ENDIF
        ELSEIF(NOTR .EQ. JVAR) THEN
          IF (VARNEED('XT')) THEN
            NOTR = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTR = -9
          ENDIF
        ELSEIF(NOPS .EQ. JVAR) THEN
          IF (VARNEED('P0')) THEN
            NOPS = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO2D = NVO2D + 1
          ELSE
            NOPS = -9
          ENDIF
        elseif(notg .eq. jvar) then
          if (VARNEED('TG')) then
            notg = ipos
            nmvoexist(ipos) = 1
            ipos = ipos + 1
            NVO2D = NVO2D + 1
          else
            notg = -9
          endif
        ENDIF
      ENDDO
!
      IF(NOUU .EQ. -9) THEN
        NOUU = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOVV .EQ. -9) THEN
        NOVV = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOQ .EQ. -9) THEN
        NOQ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOGZ .EQ. -9) THEN
        NOGZ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTT .EQ. -9) THEN
        NOTT = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTR .EQ. -9) THEN
        NOTR = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOPS .EQ. -9) THEN
        NOPS = IPOS
        IPOS = IPOS + 1
      ENDIF
      if(notg .eq. -9) then
        notg = ipos
        ipos = ipos + 1
      endif

      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6)


      CONTAINS

        LOGICAL FUNCTION VARNEED(VARCHAR)
          character*2 :: varchar
          integer :: jvar
 
          varneed=.false.
          do jvar=1,JPNVARMAX
            if (varchar.eq.cmvoneed(jvar)) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
      column%rmtmobs(:)=0.0d0      
    END SUBROUTINE col_zero


    SUBROUTINE col_allocate(column,kstep,numObsHeader)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer :: kstep,numObsHeader
      integer :: ier

      integer iloc,jvar

      column%allocated=.true.
      column%nkgdimo = nvo3d*kstep + nvo2d
      column%numObsHeader = numObsHeader
      column%nlev = kstep
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo

      allocate(column%all(column%nkgdimo,column%numObsHeader))
      column%all(:,:)=0.0d0

      allocate(column%gz_T(column%nlev,column%numObsHeader))
      allocate(column%gz_M(column%nlev,column%numObsHeader))
      column%gz_T(:,:)=0.0d0
      column%gz_M(:,:)=0.0d0

      allocate(column%rppobs(column%nlev,column%numObsHeader))
      allocate(column%rppobs_T(column%nlev,column%numObsHeader))
      allocate(column%rppobs_M(column%nlev,column%numObsHeader))
      column%rppobs(:,:)=0.0d0
      column%rppobs_T(:,:)=0.0d0
      column%rppobs_M(:,:)=0.0d0

      allocate(column%vhyb(column%nlev))
      allocate(column%vhyb_T(column%nlev))
      allocate(column%vhyb_M(column%nlev))

      allocate(column%rmtmobs(column%numObsHeader))
      column%rmtmobs(:)=0.0d0      
      allocate(column%oltv(2,column%nlev,numObsHeader))
      column%oltv(:,:,:)=0.0d0
      allocate(column%rtapfac(column%nlev,numObsHeader))
      column%rtapfac(:,:)=0.0d0

      allocate(column%timeInterpWeight(column%numObsHeader,mxstepobs))
      column%timeInterpWeight(:,:)=0.0d0

      iloc = 1
      do jvar = 1, jpnvarmax
        if(jvar.eq.nouu) then
          if(nmvoexist(nouu).eq.1) then
            column%uu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.novv) then
          if(nmvoexist(novv).eq.1) then
            column%vv => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nogz) then
          if(nmvoexist(nogz).eq.1) then
            column%gz => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noq) then
          if(nmvoexist(noq).eq.1) then
            column%hu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nott) then
          if(nmvoexist(nott).eq.1) then
            column%tt => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.notr) then
          if(nmvoexist(notr).eq.1) then
            column%tr => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nops) then
          if(nmvoexist(nops).eq.1) then
            column%ps => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
        if(jvar.eq.notg) then
          if(nmvoexist(notg).eq.1) then
            column%tg => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
      enddo

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%all)
      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)
      deallocate(column%vhyb)
      deallocate(column%vhyb_T)
      deallocate(column%vhyb_M)
      deallocate(column%timeInterpWeight)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_setTimeInterpWeight(column,weight_in,headerIndex,stepObs)
      implicit none
      type(struct_columnData), intent(inout) :: column
      integer, intent(in)    :: headerIndex,stepObs
      real(kind=8),intent(in):: weight_in

      column%timeInterpWeight(headerIndex,stepObs)=weight_in

    end SUBROUTINE col_setTimeInterpWeight


    FUNCTION col_getTimeInterpWeight(column,headerIndex,stepObs) result(weight_out)
      implicit none
      real(kind=8) weight_out
      type(struct_columnData),intent(in) :: column
      integer,intent(in)          :: headerIndex,stepObs

      weight_out=column%timeInterpWeight(headerIndex,stepObs)

    end FUNCTION col_getTimeInterpWeight


    SUBROUTINE col_copy2d(column_in,column_out)
      IMPLICIT NONE

      type(struct_columnData) :: column_in,column_out
      integer :: jobs,jv,jv_in,jv_out
 
      do jobs = 1, column_in%numObsHeader
        do jv = 1, nvo2d
          jv_in   = jv + nvo3d*column_in%nlev
          jv_out  = jv + nvo3d*column_out%nlev
          column_out%all(jv_out,jobs) =  column_in%all(jv_in,jobs)
        enddo
      enddo
      column_out%rmtmobs(:) =  column_in%rmtmobs(:)

    END SUBROUTINE col_copy2d


    SUBROUTINE col_fillmvo(lcolumnghr,cdvar,cdlev,pvar,knlev,knobs)
!
!**s/r fillmvo - Fill in COMMVOG and/or COMMVOHR
!
!     Author  : S. Pellerin ARMA/AES SEPT. 2000
!     Revision:
!
!*    Purpose: Fill in COMMVOG/COMMVOHR with trial profiles
!
!Arguments
!
!       input:
!            lcolumnghr          : HR or BG column object
!             CDVAR (character*2) : NOMVAR of the state variable
!             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
!             KNLEV (integer)     : number of levels of PVAR
!             KNOBS (integer)     : number of observation profiles in variable PVAR
!
    use MathPhysConstants_mod
    implicit none

    type(struct_columnData) :: lcolumnghr
    integer knlev,knobs
    real*8 pvar(knlev,knobs)
    character*2 cdvar,cdlev

    integer jobs,jlev

      if (cdvar.eq.'PP') then
        if(cdlev.eq.'TH') then
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs_T(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        elseif(cdlev.eq.'MM') then
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs_M(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        else
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1,lcolumnghr%nlev
              lcolumnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
            enddo
          enddo
        endif
      elseif(cdvar.eq.'HY') then
        if(cdlev.eq.'TH') then
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb_T(jlev) = pvar(jlev,1)
          enddo
        elseif(cdlev.eq.'MM') then
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb_M(jlev) = pvar(jlev,1)
          enddo
        else
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%vhyb(jlev) = pvar(jlev,1)
          enddo
        endif
      elseif(cdvar.eq.'UU') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%uu(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'VV') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%vv(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'GZ') then
        if(cdlev.eq.'TH') then
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz_T(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        elseif(cdlev.eq.'MM') then
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz_M(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        else
          do jobs = 1,lcolumnghr%numObsHeader
            do jlev = 1, lcolumnghr%nlev
              lcolumnghr%gz(jlev,jobs)=pvar(jlev,jobs)*10.*rg
            enddo
          enddo
        endif
      elseif(cdvar.eq.'HU') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=log(max(pvar(jlev,jobs),rhumin))
          enddo
        enddo
      elseif(cdvar.eq.'LQ') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'TT') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tt(jlev,jobs)=pvar(jlev,jobs) + tcdk
          enddo
        enddo
      elseif(cdvar.eq.'TR') then
        do jobs = 1,lcolumnghr%numObsHeader
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tr(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'P0') then
        do jobs = 1,lcolumnghr%numObsHeader
          lcolumnghr%ps(1,jobs)=pvar(1,jobs)*rmbtpa
        enddo
      elseif(cdvar.eq.'TG') then
        do jobs = 1,lcolumnghr%numObsHeader
          lcolumnghr%tg(1,jobs)=pvar(1,jobs)
        enddo
      endif

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_pointStagToUnstag(lcolumn)
      IMPLICIT NONE
      type(struct_columnData) :: lcolumn

      deallocate(lcolumn%gz_T)
      deallocate(lcolumn%gz_M)
      deallocate(lcolumn%rppobs_T)
      deallocate(lcolumn%rppobs_M)
      deallocate(lcolumn%vhyb_T)
      deallocate(lcolumn%vhyb_M)

      lcolumn%gz_T => lcolumn%gz
      lcolumn%gz_M => lcolumn%gz
      lcolumn%rppobs_T => lcolumn%rppobs
      lcolumn%rppobs_M => lcolumn%rppobs
      lcolumn%vhyb_T => lcolumn%vhyb
      lcolumn%vhyb_M => lcolumn%vhyb

      lcolumn%nlev_T=lcolumn%nlev
      lcolumn%nlev_M=lcolumn%nlev

    END SUBROUTINE col_pointStagToUnstag


    SUBROUTINE col_expandToMpiGlobal(column_local,column_global,lobsSpaceData)
      use obsSpaceData_mod
      implicit none

      type(struct_columnData) :: column_local,column_global
      type(struct_obs) :: lobsSpaceData

      integer :: iobs_local,iobs_global,ierr,nsize

      print*,'Entering col_expandToMpiGlobal:',  &
             column_local%numObsHeader,column_global%numObsHeader  
      call flush(6)

      do iobs_local=1,column_local%numObsHeader
        iobs_global=lobsSpaceData%locObsTag(iobs_local)
        column_global%all(:,iobs_global)              = column_local%all(:,iobs_local)
        column_global%rmtmobs(iobs_global)            = column_local%rmtmobs(iobs_local)
        column_global%timeInterpWeight(iobs_global,:) = column_local%timeInterpWeight(iobs_local,:)
      enddo

      write(*,*) 'starting allreduce'
      call flush(6)
      nsize=column_global%nkgdimo*column_global%numObsHeader
      call rpn_comm_allreduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      nsize=column_global%numObsHeader
      call rpn_comm_allreduce(column_global%rmtmobs,column_global%rmtmobs,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)
      nsize=column_global%numObsHeader*mxStepObs
      call rpn_comm_allreduce(column_global%timeInterpWeight,column_global%timeInterpWeight,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving col_expandToMpiGlobal' 
      call flush(6)
      return

    END SUBROUTINE col_expandToMpiGlobal

end module columnData_mod
