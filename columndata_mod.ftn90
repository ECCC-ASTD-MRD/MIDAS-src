module columnData_mod
  implicit none
  save
!  private

  type struct_columnData
    integer nlev,nkgdimo,nobtot
    logical :: allocated=.false.
    real*8,pointer :: all(:,:)
    real*8,pointer :: uu(:,:)
    real*8,pointer :: vv(:,:)
    real*8,pointer :: tt(:,:)
    real*8,pointer :: hu(:,:)
    real*8,pointer :: gz(:,:)
    real*8,pointer :: tr(:,:)
    real*8,pointer :: es(:,:)
    real*8,pointer :: ps(:,:)
    real*8,pointer :: tg(:,:)
    real*8,pointer :: rppobs(:,:)
    real*8,pointer :: vlev(:)
    real*8,pointer :: vhyb(:)
    real*8,pointer :: rmtmobs(:)
  end type struct_columnData

    real*8,pointer :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi transformation
    real*8,pointer :: ollq2es(:,:,:) ! Tangent linear operator of lnq to dewpoint conversion

    INTEGER,parameter :: JPNVARMAX=10
    INTEGER NMVOEXIST(JPNVARMAX), NMVOPOSIT(JPNVARMAX)
    INTEGER nouu,novv,noq,nogz,nott,notr,noes,nops,notg
    integer :: nvo3d,nvo2d

  contains

    SUBROUTINE col_setup(nflev)
      implicit none
      INTEGER JVAR, IPOS,NFLEV,nkgdimo
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER*2 CMVONEED(JPNVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED

!     Model state at the observation locations
      nouu = 1
      novv = 2
      nogz = 3
      nott = 4
      noq  = 5
      notr = 6
      noes = 7
      nops = 8
      notg = 9

      DO JVAR = 1, JPNVARMAX
         NMVOEXIST(JVAR) = 0
      END DO

!    2. Read NAMELIST NAMSTATE to find which fields are needed

      DO JVAR = 1, JPNVARMAX
        cmvoneed(jvar) = ' '
      enddo

      CMVONEED(1)   ='UU'
      CMVONEED(2)   ='VV'
      CMVONEED(3)   ='TT'
      CMVONEED(4)   ='HU'
      CMVONEED(5)   ='ES'
      CMVONEED(6)   ='GZ'
      CMVONEED(7)   ='P0'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'minimization: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      NVO3D  = 0
      NVO2D  = 0

      IPOS = 1
      DO JVAR = 1, JPNVARMAX
        IF (NOUU .EQ. JVAR) THEN
          IF (VARNEED('UU')) THEN
            NOUU = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOUU = -9
          ENDIF
        ELSEIF(NOVV .EQ. JVAR) THEN
          IF (VARNEED('VV')) THEN
            NOVV = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOVV = -9
          ENDIF
        ELSEIF(NOQ .EQ. JVAR) THEN
          IF (VARNEED('HU')) THEN
            NOQ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOQ = -9
          ENDIF
        ELSEIF(NOGZ .EQ. JVAR) THEN
          IF (VARNEED('GZ')) THEN
            NOGZ = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOGZ = -9
          ENDIF
        ELSEIF(NOTT .EQ. JVAR) THEN
          IF (VARNEED('TT')) THEN
            NOTT = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTT = -9
          ENDIF
        ELSEIF(NOTR .EQ. JVAR) THEN
          IF (VARNEED('XT')) THEN
            NOTR = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOTR = -9
          ENDIF
        ELSEIF(NOES .EQ. JVAR) THEN
          IF (VARNEED('ES')) THEN
            NOES = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO3D = NVO3D + 1
          ELSE
            NOES = -9
          ENDIF
        ELSEIF(NOPS .EQ. JVAR) THEN
          IF (VARNEED('P0')) THEN
            NOPS = IPOS
            NMVOEXIST(IPOS) = 1
            IPOS = IPOS + 1
            NVO2D = NVO2D + 1
          ELSE
            NOPS = -9
          ENDIF
        elseif(notg .eq. jvar) then
          if (VARNEED('TG')) then
            notg = ipos
            nmvoexist(ipos) = 1
            ipos = ipos + 1
            NVO2D = NVO2D + 1
          else
            notg = -9
          endif
        ENDIF
      ENDDO
!
      IF(NOUU .EQ. -9) THEN
        NOUU = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOVV .EQ. -9) THEN
        NOVV = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOQ .EQ. -9) THEN
        NOQ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOGZ .EQ. -9) THEN
        NOGZ = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTT .EQ. -9) THEN
        NOTT = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOTR .EQ. -9) THEN
        NOTR = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOES .EQ. -9) THEN
        NOES = IPOS
        IPOS = IPOS + 1
      ENDIF
      IF(NOPS .EQ. -9) THEN
        NOPS = IPOS
        IPOS = IPOS + 1
      ENDIF
      if(notg .eq. -9) then
        notg = ipos
        ipos = ipos + 1
      endif

      NKGDIMO = NVO3D*NFLEV + NVO2D
      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D,NKGDIMO
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6,' NKGDIMO = ',I6)


      CONTAINS

        LOGICAL FUNCTION VARNEED(VARCHAR)
          character*2 :: varchar
          integer :: jvar
 
          varneed=.false.
          do jvar=1,JPNVARMAX
            if (varchar.eq.cmvoneed(jvar)) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_SUALOBSB(nflev,nobtot) 
      IMPLICIT NONE

      INTEGER nflev,nobtot
      INTEGER IERR

      WRITE(*,FMT='(//,6(" ***********"))')
      WRITE(*,*)'     SUALOBSB:  Memory allocation of the observation arrays'
      WRITE(*,FMT='(6(" ***********"))')

      allocate(oltv(2,nflev,nobtot))
      oltv(:,:,:)=0.0d0
      allocate(rtapfac(nflev,nobtot))
      allocate(ollq2es(3,nflev,nobtot))

      RETURN
    END SUBROUTINE col_sualobsb

    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
      column%rmtmobs(:)=0.0d0      
    END SUBROUTINE col_zero

    SUBROUTINE col_allocate(column,kstep,nobtot)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer :: kstep,nobtot
      integer :: ier

      integer iloc,jvar

      column%allocated=.true.
      column%nkgdimo = nvo3d*kstep + nvo2d
      column%nobtot = nobtot
      column%nlev = kstep
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo

      allocate(column%all(column%nkgdimo,column%nobtot))
      allocate(column%rppobs(column%nlev,column%nobtot))
      allocate(column%vlev(column%nlev))
      allocate(column%vhyb(column%nlev))
      allocate(column%rmtmobs(column%nobtot))
      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
      column%rmtmobs(:)=0.0d0      

      iloc = 1
      do jvar = 1, jpnvarmax
        if(jvar.eq.nouu) then
          if(nmvoexist(nouu).eq.1) then
            column%uu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.novv) then
          if(nmvoexist(novv).eq.1) then
            column%vv => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nogz) then
          if(nmvoexist(nogz).eq.1) then
            column%gz => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noq) then
          if(nmvoexist(noq).eq.1) then
            column%hu => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nott) then
          if(nmvoexist(nott).eq.1) then
            column%tt => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.notr) then
          if(nmvoexist(notr).eq.1) then
            column%tr => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.noes) then
          if(nmvoexist(noes).eq.1) then
            column%es => column%all(iloc:(iloc+kstep-1),:)
            iloc = iloc + kstep
          endif
        endif
        if(jvar.eq.nops) then
          if(nmvoexist(nops).eq.1) then
            column%ps => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
        if(jvar.eq.notg) then
          if(nmvoexist(notg).eq.1) then
            column%tg => column%all(iloc:iloc,:)
            iloc = iloc + 1
          endif
        endif
      enddo

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%all)
      deallocate(column%rppobs)
      deallocate(column%vlev)
      deallocate(column%vhyb)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_copy2d(column_in,column_out)
      IMPLICIT NONE

      type(struct_columnData) :: column_in,column_out
      integer :: jobs,jv,jv_in,jv_out
 
      do jobs = 1, column_in%nobtot
        do jv = 1, nvo2d
          jv_in   = jv + nvo3d*column_in%nlev
          jv_out  = jv + nvo3d*column_out%nlev
          column_out%all(jv_out,jobs) =  column_in%all(jv_in,jobs)
        enddo
      enddo
      column_out%rmtmobs(:) =  column_in%rmtmobs(:)

    END SUBROUTINE col_copy2d


    SUBROUTINE col_fillmvo(lcolumnghr,cdvar,pvar,knlev,knobs)
!
!**s/r fillmvo - Fill in COMMVOG and/or COMMVOHR
!
!     Author  : S. Pellerin ARMA/AES SEPT. 2000
!     Revision:
!
!*    Purpose: Fill in COMMVOG/COMMVOHR with trial profiles
!
!Arguments
!
!       input:
!            lcolumnghr          : HR or BG column object
!             CDVAR (character*2) : NOMVAR of the state variable
!             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
!             KNLEV (integer)     : number of levels of PVAR
!             KNOBS (integer)     : number of observation profiles in variable PVAR
!
    use MathPhysConstants_mod
    implicit none
    #include "pardim.cdk"
    #include "comdim.cdk"
    #include "comgem.cdk"

    type(struct_columnData) :: lcolumnghr
    integer knlev,knobs
    real*8 pvar(knlev,knobs)
    character*2 cdvar

    integer jobs,jlev

      if (cdvar.eq.'PP') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1,lcolumnghr%nlev
            lcolumnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'LV') then
        do jlev = 1,lcolumnghr%nlev
          lcolumnghr%vlev(jlev) = pvar(jlev,1)
        enddo
      elseif(cdvar.eq.'HY') then
        do jlev = 1,lcolumnghr%nlev
          lcolumnghr%vhyb(jlev) = pvar(jlev,1)
        enddo
      elseif(cdvar.eq.'UU') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%uu(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'VV') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%vv(jlev,jobs)=pvar(jlev,jobs)*rmsknt
          enddo
        enddo
      elseif(cdvar.eq.'GZ') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%gz(jlev,jobs)=pvar(jlev,jobs)*10.*rg
          enddo
        enddo
      elseif(cdvar.eq.'HU') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=log(max(pvar(jlev,jobs),rhumin))
          enddo
        enddo
      elseif(cdvar.eq.'LQ') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%hu(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'ES') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%es(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'TT') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tt(jlev,jobs)=pvar(jlev,jobs) + tcdk
          enddo
        enddo
      elseif(cdvar.eq.'TR') then
        do jobs = 1,lcolumnghr%nobtot
          do jlev = 1, lcolumnghr%nlev
            lcolumnghr%tr(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdvar.eq.'P0') then
        do jobs = 1,lcolumnghr%nobtot
          lcolumnghr%ps(1,jobs)=pvar(1,jobs)*rmbtpa
        enddo
      elseif(cdvar.eq.'TG') then
        do jobs = 1,lcolumnghr%nobtot
          lcolumnghr%tg(1,jobs)=pvar(1,jobs)
        enddo
      endif

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_expandToMpiGlobal(lcolumng,nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r col_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Original Author    . Bin He (ARMA/MRB )
!          extracted from Bin's obs_expandToMpiGlobal()
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global column object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

    USE obsSpaceData_mod, only: locObsTag
    IMPLICIT NONE
    type(struct_columnData) :: lcolumng
    integer, intent(in) :: nulout       ! standard output unit
    integer, intent(in) :: nobtot       ! Actual number of observations
    integer, intent(in) :: nobtotp      ! Actual no. of obs. in POST FILE=nobtot

!   Declare Local Variables. 
    REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
    
    INTEGER :: i,iobs,ierr,sizeRMTMOBS  
!!---------------------------------------------------------------

!!  1.  Release some memory. 
    print*,'Entering col_expandToMpiGlobal'  

!!  1.2 Added restore global array RMTMOBS
    ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
    IF(ierr /= 0)CALL ABORT3D(nulout,'Cant allocate Mem. to RMTMOBS_tmp,Abort!') 
    RMTMOBS_TMP=0.0D0 

!!  1.3 Retore global RMTMOBS
    DO i=1,NOBTOT
       iobs=locObsTag(i)
       RMTMOBS_tmp(iobs)=lcolumng%RMTMOBS(i)
    ENDDO  
    sizeRMTMOBS=NOBTOTP
    CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS, &
                            "mpi_double_precision","mpi_sum","GRID",ierr)

!!  DEALLOCATE(RMTMOBS)
    deallocate(lcolumng%rmtmobs)
    allocate(lcolumng%rmtmobs(nobtotp))
    lcolumng%RMTMOBS=RMTMOBS_tmp
    DEALLOCATE(RMTMOBS_tmp)

    print*,'Leaving col_expandToMpiGlobal' 
    RETURN
  END SUBROUTINE col_expandToMpiGlobal


    SUBROUTINE col_expandToMpiGlobal3(column_local,column_global)
      USE obsSpaceData_mod, only: locObsTag
      IMPLICIT NONE

      type(struct_columnData) :: column_local,column_global

      INTEGER :: i,iobs,ierr,nsize

      print*,'Entering col_expandToMpiGlobal3:',  &
             column_local%nobtot,column_global%nobtot  
      call flush(6)

      column_global%all(:,:)=0.0d0
      DO i=1,column_local%nobtot
        iobs=locObsTag(i)
        column_global%all(:,iobs)  =column_local%all(:,i)
      ENDDO

      write(*,*) 'starting allreduce'
      call flush(6)
      nsize=column_global%nkgdimo*column_global%nobtot
      CALL RPN_COMM_ALLReduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      write(*,*) 'Leaving col_expandToMpiGlobal3' 
      call flush(6)
      RETURN

    END SUBROUTINE col_expandToMpiGlobal3

end module columnData_mod
