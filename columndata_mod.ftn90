module columnData_mod
  use varNameList_mod
  use verticalCoord_mod
  use MathPhysConstants_mod
  implicit none
  save
!  private

  type struct_columnData
    integer           :: nlev,nlev_T,nlev_M
    integer           :: nkgdimo,numObsHeader,nStepObs
    logical           :: allocated=.false.
    real*8,pointer    :: all(:,:)
    real*8,pointer    :: gz_T(:,:),gz_M(:,:)
    real*8,pointer    :: rppobs(:,:),rppobs_T(:,:),rppobs_M(:,:)
    real*8,pointer    :: timeInterpWeight(:,:)  ! weights for linear temporal interpolation of increment to obs times
    real*8,pointer    :: oltv(:,:,:)    ! Tangent linear operator of virtual temperature
    real*8,pointer    :: rtapfac(:,:)   ! Background surface pressure dependant factor used for Temperature to Phi calc.
    type(vco)         :: vco
    integer,pointer   :: varOffset(:),varNumLev(:)
  end type struct_columnData

  logical nmvoexist(jpnvarmax)
  integer :: nvo3d,nvo2d
  real*8 :: rhumin
  integer, parameter :: mxstepobs=9 

  contains


    function col_varExist(varName) result(varExist)
      implicit none
      character(len=2), intent(in) :: varName
      logical                      :: varExist 

      if(nmvoexist(vnl_varListIndex(varName))) then
        varExist = .true.
      else
        varExist = .false.
      endif

    end function col_varExist


    function col_varnoOffset(column,varnum) result(offset)
      implicit none
      type(struct_columnData) :: column
      integer, intent(in)     :: varnum
      integer                 :: offset

      offset=column%varOffset(vnl_varListIndex(vnl_varnameFromVarnum(varnum)))

    end function col_varnoOffset


    function col_getVarNumLev(column,varName) result(nlev)
      implicit none
      type(struct_columnData) :: column
      character(len=2), intent(in) :: varName
      integer                      :: nlev

      if(varTypeList(vnl_varListIndex(varName)).eq.'MM') then
        nlev=column%nlev_M
      elseif(varTypeList(vnl_varListIndex(varName)).eq.'TH') then
        nlev=column%nlev_T
      elseif(varTypeList(vnl_varListIndex(varName)).eq.'SF') then
        nlev=1
      else
        write(*,*) 'col_getVarNumLev: Unknown number of levels! ',varTypeList(vnl_varListIndex(varName))
        call flush(6)
        call qqexit(1)
      endif

    end function col_getVarNumLev


    function col_varnoNumLev(column,varNumber) result(nlev)
      implicit none
      type(struct_columnData) :: column
      integer, intent(in)     :: varNumber
      integer                 :: nlev

      nlev=col_getVarNumLev(column,vnl_varnameFromVarnum(varNumber))

    end function col_varnoNumLev


    SUBROUTINE col_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER(len=2) :: CMVONEED(JPNVARMAX)
      NAMELIST /NAMSTATEO/CMVONEED,rhumin

      write(*,*) 'col_setup: List of known (valid) variable names'
      write(*,*) 'col_setup: varNameList3D=',varNameList3D
      write(*,*) 'col_setup: varNameList2D=',varNameList2D
      write(*,*) 'col_setup: varNameList  =',varNameList

!     Read NAMELIST NAMSTATEO to find which fields are needed

      DO JVAR = 1, JPNVARMAX
        cmvoneed(jvar) = '  '
      enddo
      rhumin = rminhu

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstateo,iostat=ierr)
      write(*,*) 'col_setup: reading namelist, ierr=',ierr
      write(*,nml=namstateo)
      ierr=fclos(nulnam)

      nvo3d  = 0
      nvo2d  = 0

      do jvar = 1, jpnvarmax3D
        if (varneed(varNameList3D(jvar))) then
          nmvoexist(jvar) = .true.
          nvo3d = nvo3d + 1
        else
          nmvoexist(jvar) = .false.
        endif
      enddo

      do jvar = 1, jpnvarmax2D
        if (varneed(varNameList2D(jvar))) then
          nmvoexist(jvar+jpnvarmax3D) = .true.
          nvo2d = nvo2d + 1
        else
          nmvoexist(jvar+jpnvarmax3D) = .false.
        endif
      enddo

      write(*,*) 'col_setup: nvo3d,nvo2d=',nvo3d,nvo2d
      write(*,*) 'col_setup: nmvoexist =',nmvoexist

      WRITE(*,*)' DIMENSIONS OF MODEL STATE ARRAYS:'
      WRITE(*,FMT=9120) NVO3D,NVO2D
 9120 FORMAT(4X,'  NVO3D =',I6,' NVO2D    =',I6)

      CONTAINS

        LOGICAL FUNCTION VARNEED(VARCHAR)
          character*2 :: varchar
          integer :: jvar
 
          varneed=.false.
          do jvar=1,JPNVARMAX
            if (varchar.eq.cmvoneed(jvar)) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

    END SUBROUTINE col_setup


    SUBROUTINE col_zero(column)
      IMPLICIT NONE
      type(struct_columnData) :: column

      column%all(:,:)=0.0d0
      column%rppobs(:,:)=0.0d0
    END SUBROUTINE col_zero


    SUBROUTINE col_allocate(column,numObsHeader,nlev_M,nlev_T)
      IMPLICIT NONE

      type(struct_columnData) :: column
      integer, intent(in)           :: numObsHeader
      integer, intent(in), optional :: nlev_M,nlev_T
      integer :: ier

      integer iloc,jvar,jvar2

      column%numObsHeader = numObsHeader

      if( (.not.present(nlev_M)) .and. (.not.present(nlev_T)) ) then
        if(column%vco%initialized) then
          column%nlev = max(column%vco%nlev_M,column%vco%nlev_T)
          column%nlev_M = column%vco%nlev_M
          column%nlev_T = column%vco%nlev_T
        else
          write(*,*) 'col_allocate: VerticalCoord has not been initialized!'
          call flush(6)
          call qqexit(1)
        endif
      else
        column%nlev = max(nlev_M,nlev_T)
        column%nlev_M = nlev_M
        column%nlev_T = nlev_T
      endif

      allocate(column%varOffset(jpnvarmax))
      column%varOffset(:)=0
      allocate(column%varNumLev(jpnvarmax))
      column%varNumLev(:)=0

      iloc=0
      do jvar = 1, jpnvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=col_getVarNumLev(column,varNameList(jvar))
          iloc = iloc + col_getVarNumLev(column,varNameList(jvar))
        endif
      enddo
      do jvar2 = 1, jpnvarmax2d
        jvar=jvar2+jpnvarmax3d
        if(nmvoexist(jvar)) then
          column%varOffset(jvar)=iloc
          column%varNumLev(jvar)=1
          iloc = iloc + 1
        endif
      enddo
      column%nkgdimo=iloc

      allocate(column%all(column%nkgdimo,column%numObsHeader))
      column%all(:,:)=0.0d0

      allocate(column%gz_T(column%nlev_T,column%numObsHeader))
      allocate(column%gz_M(column%nlev_M,column%numObsHeader))
      column%gz_T(:,:)=0.0d0
      column%gz_M(:,:)=0.0d0

      allocate(column%rppobs  (column%nlev  ,column%numObsHeader))
      allocate(column%rppobs_T(column%nlev_T,column%numObsHeader))
      allocate(column%rppobs_M(column%nlev_M,column%numObsHeader))
      column%rppobs(:,:)=0.0d0
      column%rppobs_T(:,:)=0.0d0
      column%rppobs_M(:,:)=0.0d0

      allocate(column%oltv(2,column%nlev,numObsHeader))
      column%oltv(:,:,:)=0.0d0
      allocate(column%rtapfac(column%nlev,numObsHeader))
      column%rtapfac(:,:)=0.0d0

      allocate(column%timeInterpWeight(column%numObsHeader,mxstepobs))
      column%timeInterpWeight(:,:)=0.0d0
 
      write(*,*) 'col_allocate: nkgdimo = ',column%nkgdimo
      write(*,*) 'col_allocate: varOffset=',column%varOffset
      write(*,*) 'col_allocate: varNumLev=',column%varNumLev

      column%allocated=.true.

      RETURN
    END SUBROUTINE col_allocate


    SUBROUTINE col_deallocate(column)
      IMPLICIT NONE

      type(struct_columnData) :: column

      deallocate(column%varOffset)
      deallocate(column%varNumLev)
      deallocate(column%all)
      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)
      deallocate(column%oltv)
      deallocate(column%rtapfac)
      deallocate(column%timeInterpWeight)
      column%allocated=.false.

      RETURN
    END SUBROUTINE col_deallocate


    SUBROUTINE col_setTimeInterpWeight(column,weight_in,headerIndex,stepObs)
      implicit none
      type(struct_columnData), intent(inout) :: column
      integer, intent(in)    :: headerIndex,stepObs
      real(kind=8),intent(in):: weight_in

      column%timeInterpWeight(headerIndex,stepObs)=weight_in

    end SUBROUTINE col_setTimeInterpWeight


    FUNCTION col_getTimeInterpWeight(column,headerIndex,stepObs) result(weight_out)
      implicit none
      real(kind=8) weight_out
      type(struct_columnData),intent(in) :: column
      integer,intent(in)          :: headerIndex,stepObs

      weight_out=column%timeInterpWeight(headerIndex,stepObs)

    end FUNCTION col_getTimeInterpWeight


    SUBROUTINE col_fillmvo(columnghr,cdvar,cdlev,pvar)
    !
    !**s/r fillmvo - Fill in values for a complete set of columns at once
    !
    !Arguments
    !
    !       input:
    !            columnghr          : HR or BG column object
    !             CDVAR (character*2) : NOMVAR of the state variable
    !             PVAR(knlev,knobs)   : Variable to transfer in COMMVO(G)(HR)
    !             KNLEV (integer)     : number of levels of PVAR
    !             KNOBS (integer)     : number of observation profiles in variable PVAR
    use MathPhysConstants_mod
    implicit none

    type(struct_columnData) :: columnghr
    real*8 pvar(:,:)
    character*2 cdvar,cdlev

    integer jobs,jlev,nlev
    real*8, pointer :: column_ptr(:)

    ! Pressure
    if (cdvar.eq.'PP') then
      if(cdlev.eq.'TH') then
        do jobs = 1,columnghr%numObsHeader
          do jlev = 1,columnghr%nlev_T
            columnghr%rppobs_T(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdlev.eq.'MM') then
        do jobs = 1,columnghr%numObsHeader
          do jlev = 1,columnghr%nlev_M
            columnghr%rppobs_M(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      else
        do jobs = 1,columnghr%numObsHeader
          do jlev = 1,columnghr%nlev
            columnghr%rppobs(jlev,jobs) = pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! Height
    elseif(cdvar.eq.'GZ') then
      if(cdlev.eq.'TH') then
        do jobs = 1,columnghr%numObsHeader
          do jlev = 1, columnghr%nlev_T
            columnghr%gz_T(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      elseif(cdlev.eq.'MM') then
        do jobs = 1,columnghr%numObsHeader
          do jlev = 1, columnghr%nlev_M
            columnghr%gz_M(jlev,jobs)=pvar(jlev,jobs)
          enddo
        enddo
      else
        nlev = col_getVarNumLev(columnghr,cdvar)
        do jobs = 1,columnghr%numObsHeader
          column_ptr => col_getColumn(columnghr,jobs,cdvar)
          do jlev = 1, nlev
            column_ptr(jlev)=pvar(jlev,jobs)
          enddo
        enddo
      endif

    ! All the other variables that are stored in column%all
    elseif(col_varExist(cdvar)) then
      nlev = col_getVarNumLev(columnghr,cdvar)
      do jobs = 1,columnghr%numObsHeader
        column_ptr => col_getColumn(columnghr,jobs,cdvar)
        do jlev = 1, nlev
          column_ptr(jlev)=pvar(jlev,jobs)
        enddo
      enddo

    ! Unknown variable name
    else
      write(*,*) 'col_fillmvo: Unknown variable name: ',cdvar
      call flush(6)
      call qqexit(1)
    endif

    return
    END SUBROUTINE col_fillmvo


    SUBROUTINE col_pointStagToUnstag(column)
      IMPLICIT NONE
      type(struct_columnData) :: column
      integer                 :: ilev1,ilev2

      deallocate(column%gz_T)
      deallocate(column%gz_M)
      deallocate(column%rppobs_T)
      deallocate(column%rppobs_M)

      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+1
      ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex('GZ')) 
      column%gz_T => column%all(ilev1:ilev2,:)
      column%gz_M => column%all(ilev1:ilev2,:)

      column%rppobs_T => column%rppobs
      column%rppobs_M => column%rppobs

      column%nlev_T=column%nlev
      column%nlev_M=column%nlev

    END SUBROUTINE col_pointStagToUnstag


    SUBROUTINE col_expandToMpiGlobal(column_local,column_global,lobsSpaceData)
      use obsSpaceData_mod
      implicit none

      type(struct_columnData) :: column_local,column_global
      type(struct_obs) :: lobsSpaceData

      integer :: iobs_local,iobs_global,ierr,nsize
      real*8  :: mountain(column_global%numObsHeader)

      print*,'Entering col_expandToMpiGlobal:',  &
             column_local%numObsHeader,column_global%numObsHeader  
      call flush(6)

      column_global%nStepObs     = column_local%nStepObs
      column_global%varOffset(:) = column_local%varOffset(:)
      column_global%varNumLev(:) = column_local%varNumLev(:)

      mountain(:)=0.0d0
      do iobs_local=1,column_local%numObsHeader
        iobs_global=obs_elem_i(lobsSpaceData,'GHI ',iobs_local)
        column_global%all(:,iobs_global)              = column_local%all(:,iobs_local)
        column_global%timeInterpWeight(iobs_global,:) = column_local%timeInterpWeight(iobs_local,:)
        mountain(iobs_global)                         = column_local%gz_t(column_local%nlev_t,iobs_local)
      enddo

      write(*,*) 'starting allreduce'
      call flush(6)

      nsize=column_global%nkgdimo*column_global%numObsHeader
      call rpn_comm_allreduce(column_global%all,column_global%all,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=column_global%numObsHeader
      call rpn_comm_allreduce(mountain,mountain,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      nsize=column_global%numObsHeader*mxStepObs
      call rpn_comm_allreduce(column_global%timeInterpWeight,column_global%timeInterpWeight,nsize, &
                              "mpi_double_precision","mpi_sum","GRID",ierr)

      do iobs_global=1,column_global%numObsHeader
        column_global%gz_t(column_global%nlev_t,iobs_global) = mountain(iobs_global)
      enddo

      write(*,*) 'Leaving col_expandToMpiGlobal' 
      call flush(6)
      return

    END SUBROUTINE col_expandToMpiGlobal


  function col_getPressure(column,ilev,headerIndex,cvar) result(pressure)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character*2, intent(in)             :: cvar
    real*8                              :: pressure

    if (cvar .eq. 'NA') then
      pressure = column%rppobs(ilev,headerIndex)
    elseif (cvar .eq. 'TH') then
      pressure = column%rppobs_t(ilev,headerIndex)
    elseif (cvar .eq. 'MM' ) then
      pressure = column%rppobs_m(ilev,headerIndex)
    elseif (cvar .eq. 'SF' ) then
      pressure = column%rppobs_t(column%nlev_t,headerIndex)
    else
      write(*,*) 'col_getPressure: Unknown variable type: ',cvar
      call flush(6)
      call qqexit(1)
    endif

  end function col_getPressure
 

  function col_getHeight(column,ilev,headerIndex,cvar) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev,headerIndex
    character*2, intent(in)             :: cvar
    real*8                              :: height
    integer                             :: ilev1

    if (cvar .eq. 'NA') then
      ilev1 = column%varOffset(vnl_varListIndex('GZ'))+ilev
      height = column%all(ilev1,headerIndex)
    elseif (cvar .eq. 'TH') then
      height = column%gz_t(ilev,headerIndex)
    elseif (cvar .eq. 'MM' ) then
      height = column%gz_m(ilev,headerIndex)
    elseif (cvar .eq. 'SF' ) then
      height = column%gz_t(column%nlev_t,headerIndex)
    endif

  end function col_getHeight


  function col_getMountain(column,headerIndex) result(height)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: headerIndex
    real*8                              :: height

    height = column%gz_t(column%nlev_t,headerIndex)

  end function col_getMountain


  subroutine col_setMountain(column,headerIndex,height)
    implicit none
    type(struct_columnData)             :: column
    integer, intent(in)                 :: headerIndex
    real*8, intent(in)                  :: height

    column%gz_t(column%nlev_t,headerIndex) = height

  end subroutine col_setMountain


  function col_getColumn(column,headerIndex,cvar) result(onecolumn)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: headerIndex
    character*2, intent(in), optional   :: cvar
    real*8,pointer                      :: onecolumn(:)
    integer                             :: ilev1,ilev2

    if(present(cvar)) then
      if(col_varExist(cvar)) then
        ilev1 = column%varOffset(vnl_varListIndex(cvar))+1
        ilev2 = ilev1 - 1 + column%varNumLev(vnl_varListIndex(cvar))
        onecolumn => column%all(ilev1:ilev2,headerIndex)
      else
        write(*,*) 'col_getColumn: Unknown variable name! ',cvar
        call flush(6)
        call qqexit(1)
      endif
    else
      onecolumn => column%all(:,headerIndex)
    endif

  end function col_getColumn


  function col_getElem(column,ilev,headerIndex,cvar) result(value)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer, intent(in)                 :: ilev
    integer, intent(in)                 :: headerIndex
    character*2, intent(in), optional   :: cvar
    real*8                              :: value

    if(present(cvar)) then
      value = column%all(column%varOffset(vnl_varListIndex(cvar))+ilev,headerIndex)
    else
      value = column%all(ilev,headerIndex)
    endif

  end function col_getElem


  function col_getNumLev(column,cvar) result(nlev)
    implicit none
    type(struct_columnData), intent(in) :: column
    character*2, intent(in), optional   :: cvar
    integer                             :: nlev

    if(present(cvar)) then
      if(cvar.eq.'MM') then
        nlev = column%nlev_m
      elseif(cvar.eq.'TH') then
        nlev = column%nlev_t
      elseif(cvar.eq.'SF') then
        nlev = 1
      else
        write(*,*) 'col_getNumLev: Unknown variable type! ',cvar
        call flush(6)
        call qqexit(1)
      endif
    else
      nlev = column%nlev
    endif

  end function col_getNumLev

  function col_getNumCol(column) result(numColumn)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer                             :: numColumn

    numColumn = column%numObsHeader

  end function col_getNumCol


  function col_getNumStep(column) result(numStep)
    implicit none
    type(struct_columnData), intent(in) :: column
    integer                             :: numStep

    numStep = column%nStepObs

  end function col_getNumStep


  subroutine col_setNumStep(column,numStep)
    implicit none
    type(struct_columnData), intent(inout) :: column
    integer, intent(in)                    :: numStep

    column%nStepObs = numStep

  end subroutine col_setNumStep

end module columnData_mod
