!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

module calcbmatrix_glb_mod
  use gridStateVector_mod
  use globalSpectralTransform
  use MathPhysConstants_mod
  use HorizontalCoord_mod
  use varNameList_mod
  use EarthConstants_mod, only: RA
  implicit none
  save
  private

  ! Public Subroutines
  public :: calcb_glb_setup, calcb_glb_computeStats, calcb_glb_stddev
  public :: calcb_glb_toolbox, calcb_glb_powerspec

  type(struct_hco), pointer :: hco_ens ! Ensemble horizontal grid parameters

  integer :: nens,ntrunc,ni,nj,nLevEns_M,nLevEns_T,nLevPtoT,nkgdimEns,varLevOffset(6),nla
  character(len=256), allocatable :: cflensin(:)
  integer :: gstID
  integer, allocatable :: nip1_M(:),nip1_T(:)
  real(8), pointer :: pressureProfile_M(:), pressureProfile_T(:)
  integer,external    :: get_max_rss

  integer,parameter  :: nvar3d=4,nvar2d=1
  character*4 :: nomvar3d(nvar3d,3),nomvar2d(nvar2d,3)
  integer, parameter :: modelSpace   = 1
  integer, parameter :: cvSpace      = 2
  integer, parameter :: cvUnbalSpace = 3
  integer :: variableType

  real(8) :: gridSpacingInKm

  ! For wave band decomposition
  integer, parameter  :: maxNumLocalLength = 20
  integer             :: waveBandPeaks(maxNumLocalLength)
  integer             :: nWaveBand

  logical :: initialized = .false.

  contains

!--------------------------------------------------------------------------
! CALCB_GLB_SETUP
!--------------------------------------------------------------------------
  subroutine calcb_glb_setup( nens_in, cflens_in, hco_in, vco_in)
    implicit none

    integer, intent(in)            :: nens_in

    character(len=*), intent(in)   :: cflens_in(nens_in)

    type(struct_vco), pointer, intent(in)   :: vco_in
    type(struct_hco), pointer, intent(in)   :: hco_in

    integer :: nulnam,ierr,mpiMode,status, waveBandIndex
    integer :: fclos,fnom,fstouv,fstfrm

    real(8) :: zps

    NAMELIST /NAMCALCB_GLB/ntrunc,waveBandPeaks

    write(6,*)
    write(6,*) 'calcb_glb_setup: Starting...'

    nens=nens_in
    allocate(cflensin(nens))
    cflensin(:)=cflens_in(:)
    call mpc_printConstants(6)

    ! parameters from namelist (date in filename should come directly from sequencer?)
    ntrunc=108
    waveBandPeaks(:) = -1.0d0

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namcalcb_glb)
    write(*,nml=namcalcb_glb)
    ierr=fclos(nulnam)

    !- Setup horizontal grid
    hco_ens => hco_in
    ni=hco_in%ni
    nj=hco_in%nj
    gridSpacingInKm = ra * hco_in%dlon / 1000.d0
    
    write(6,*) 'Grid Spacing in Km = ', gridSpacingInKm

    !- Setup vertical levels
    nLevEns_M=vco_in%nlev_M
    nLevEns_T=vco_in%nlev_T
    nLevPtot=nLevEns_M-1 ! ignore streamfunction at hyb=1, since highly correlated with next level
    varLevOffset(1) = 0
    varLevOffset(2) = 1*nLevEns_M
    varLevOffset(3) = 2*nLevEns_M
    varLevOffset(4) = 2*nLevEns_M+1*nLevEns_T
    varLevOffset(5) = 2*nLevEns_M+2*nLevEns_T
    nkgdimEns=nLevEns_M*2+nLevEns_T*2+1 ! NO TG !!!
    nla=(ntrunc+1)*(ntrunc+2)/2
    
    !- Setup the global spectral transform
    mpiMode=2
    gstID = gst_setup(ni,nj,ntrunc,mpiMode)

    !- Setup ip1s
    allocate(nip1_M(nLevEns_M))
    nip1_M(:)=vco_in%ip1_M(:)
    allocate(nip1_T(nLevEns_T))
    nip1_T(:)=vco_in%ip1_T(:)

    !- Estimate the pressure profile for each vertical grid    
    zps = 101000.D0
    status = vgd_levels( vco_in%vgrid, ip1_list=vco_in%ip1_M, levels=pressureProfile_M, &
                         sfc_field=zps, in_log=.false.)

    status = vgd_levels( vco_in%vgrid, ip1_list=vco_in%ip1_T, levels=pressureProfile_T, &
                         sfc_field=zps, in_log=.false.)

    !
    !- Setup variable names
    !
    nomvar3d(1,modelSpace)='UU'
    nomvar3d(2,modelSpace)='VV'
    nomvar3d(3,modelSpace)='TT'
    nomvar3d(4,modelSpace)='LQ'
    nomvar2d(1,modelSpace)='P0'
    
    nomvar3d(1,cvSpace)='PP'
    nomvar3d(2,cvSpace)='CC'
    nomvar3d(3,cvSpace)='TT'
    nomvar3d(4,cvSpace)='LQ'
    nomvar2d(1,cvSpace)='P0'
    
    nomvar3d(1,cvUnbalSpace)='PP'
    nomvar3d(2,cvUnbalSpace)='UC'
    nomvar3d(3,cvUnbalSpace)='UT'
    nomvar3d(4,cvUnbalSpace)='LQ'
    nomvar2d(1,cvUnbalSpace)='UP'

    !
    !- Wave band decomposition option (available in )
    !
    nWaveBand = count(waveBandPeaks .ge. 0)
    if ( nWaveBand < 1 ) then
       nWaveBand = 1
    else if (nWaveBand == 1) then
       write(6,*) 'You have specified only ONE waveBandPeaks'
       call abort3d('calbmatrix_glb')
    else
       write(6,*)
       write(6,*) 'WaveBand decomposition is ACTIVATED'
    end if
    
    ! Make sure that the wavenumbers are in the correct (decreasing) order
    do waveBandIndex = 1, nWaveBand-1
       if ( waveBandPeaks(waveBandIndex)-waveBandPeaks(waveBandIndex+1) <= 0 ) then
          write(6,*) 'calcb_glb_setup: waveBandPeaks are not in decreasing wavenumber order'
          call abort3d('calbmatrix_glb')
       end if
    end do

    ! Make sure the truncation is compatible with the waveBandPeaks
    if ( ntrunc < nj-1 ) then
       write(6,*) 'calcb_glb_setup: The truncation is not compatible with wave band decomposition'
       write(6,*) '                 ntrunc should = ', nj-1
       call abort3d('calbmatrix_glb')
    end if

    !
    !- Ending
    !
    initialized = .true.

    write(6,*)
    write(6,*) 'calcb_glb_setup: Done!'

  end subroutine calcb_glb_setup

!--------------------------------------------------------------------------
! CALCB_GLB_COMPUTESTATS
!--------------------------------------------------------------------------
  subroutine calcb_glb_computeStats
    implicit none
    integer :: ierr
    real*4,pointer  :: ensPerturbations(:,:,:,:)
    real*4,pointer  :: ensBalPerturbations(:,:,:,:)
    real*8,allocatable :: stddev3d(:,:,:),stddev3dBal(:,:,:),stddev3dUnbal(:,:,:)
    real*8,allocatable :: stddevZonAvg(:,:),stddevZonAvgBal(:,:),stddevZonAvgUnbal(:,:)
    real*8,allocatable :: PtoT(:,:,:),theta1(:,:),theta2(:,:)
    real*8,allocatable :: corns(:,:,:),rstddev(:,:)

    allocate(ensPerturbations(ni,nkgdimEns,nj,nens),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(ensBalPerturbations(ni,nLevEns_T+1,nj,nens),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(theta1(nlevEns_M,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddev3d(ni,nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddevZonAvg(nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(PtoT(nlevEns_T+1,nlevEns_M,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(theta2(nlevEns_M,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddev3dBal(ni,nLevEns_T+1,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddev3dUnbal(ni,nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddevZonAvgBal(nLevEns_T+1,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddevZonAvgUnbal(nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(corns(nkgdimEns,nkgdimEns,0:ntrunc),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(rstddev(nkgdimEns,0:ntrunc),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif

    call readEnsemble(ensPerturbations)
    write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    call removeMean(ensPerturbations)

    call uv_to_psichi(ensPerturbations)

    call calcStddev3d(ensPerturbations,stddev3d,nkgdimens)

    call calcZonAvg(stddevZonAvg,stddev3d,nkgdimens)

    call calcTheta(ensPerturbations,theta1) ! theta1 is put in glbcov and used for analysis!
    write(301,*) theta1

    call removeBalancedChi(ensPerturbations,theta1)

    call normalize3d(ensPerturbations,stddev3d)

    call calcPtoT(ensPerturbations,PtoT)
    write(303,*) PTOT(:,:,1)
    call flush(303)

!    call calcTheta(ensPerturbations,theta2) ! theta2 is used previously for computing unbalanced Chi!
!    write(302,*) theta2

    call removeBalancedT_Ps(ensPerturbations,ensBalPerturbations,PtoT)

!    call removeBalancedChi(ensPerturbations,theta2)

    call multiply3d(ensPerturbations,stddev3d,nkgdimens)

    call multiply3d(ensBalPerturbations(:,1:nLevEns_T,:,:),   &
                    stddev3d(:,(2*nLevEns_M+1):(2*nLevEns_M+nLevEns_T),:),nLevEns_T)

    call multiply3d(ensBalPerturbations(:,(nLevEns_T+1):(nLevEns_T+1),:,:),  &
                    stddev3d(:,(2*nLevEns_M+2*nLevEns_T+1):(2*nLevEns_M+2*nLevEns_T+1),:),1)

    call spectralFilter(ensPerturbations,nkgdimens)

    call spectralFilter(ensBalPerturbations,nLevEns_T+1)

    call calcStddev3d(ensPerturbations,stddev3dUnbal,nkgdimens)

    call calcStddev3d(ensBalPerturbations,stddev3dBal,nLevEns_T+1)

    call calcZonAvg(stddevZonAvgUnbal,stddev3dUnbal,nkgdimens)

    call calcZonAvg(stddevZonAvgBal,stddev3dBal,nLevEns_T+1)

    call normalize3d(ensPerturbations,stddev3dUnbal)

    call removeGlobalMean(ensPerturbations)

    call calcCorrelations(ensPerturbations,corns,rstddev)

    call writeStats(corns,rstddev,ptot,theta1)

    call writeStddev(stddevZonAvg,stddevZonAvgUnbal,stddev3d,stddev3dUnbal)

    call writeStddevBal(stddevZonAvgBal,stddev3dBal)

    call writeSpStats(ptot,theta1)

    write(200,*) stddevZonAvg(1:nlevEns_M,:)
    write(201,*) stddevZonAvg((1+1*nlevEns_M):(2*nlevEns_M),:)
    write(202,*) stddevZonAvg((1+2*nlevEns_M):(3*nlevEns_T),:)
    write(203,*) stddevZonAvg((1+2*nlevEns_M+1*nlevEns_T):(2*nlevEns_M+2*nlevEns_T),:)
    write(204,*) stddevZonAvg((1+2*nlevEns_M+2*nlevEns_T),:)/1.0d2

    write(400,*) stddevZonAvgUnbal(1:nlevEns_M,:)
    write(401,*) stddevZonAvgUnbal((1+1*nlevEns_M):(2*nlevEns_M),:)
    write(402,*) stddevZonAvgUnbal((1+2*nlevEns_M):(3*nlevEns_T),:)
    write(403,*) stddevZonAvgUnbal((1+2*nlevEns_M+1*nlevEns_T):(2*nlevEns_M+2*nlevEns_T),:)
    write(404,*) stddevZonAvgUnbal((1+2*nlevEns_M+2*nlevEns_T),:)/1.0d2

  end subroutine calcb_glb_computeStats

!--------------------------------------------------------------------------
! CALCB_GLB_TOOLBOOX
!--------------------------------------------------------------------------
  subroutine calcb_glb_toolbox
    implicit none

    ! NOTE: The diagnostic computed here are in model variable space 
    !       (no variable transform!!!)

    integer :: waveBandIndex
    integer :: nulnam, ierr, fclos, fnom

    real(4),pointer     :: ensPerturbations(:,:,:,:)
    real(8),allocatable :: stddev3d(:,:,:)
    real(8),allocatable :: corns(:,:,:), rstddev(:,:)

    character(len=60) :: tool

    NAMELIST /NAMTOOLBOX/tool

    write(6,*)
    write(6,*) 'calcb_glb_toolbox'
    write(6,*)

    variableType = modelSpace

    !
    !- Tool selection
    !
    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=NAMTOOLBOX)
    write(*,nml=NAMTOOLBOX)
    ierr = fclos(nulnam)

    select case(trim(tool))
    case ('HVCORREL_HI')
       write(6,*)
       write(6,*) 'Computing Homogeneous and Isotropic Correlation'
    case ('HVCORREL_LOCAL')
       write(6,*)
       write(6,*) 'Computing Local Correlation'
    case ('LOCALIZATIONRADII')
       write(6,*)
       write(6,*) 'Estimating the optimal covariance localization radii'
    case default
       write(6,*)
       write(6,*) 'Unknown TOOL in calcb_glb_toolbox : ', trim(tool)
       call abort3d('calbmatrix_glb')
    end select

    !
    !- Horizontal and vertical correlation diagnostics
    !
    allocate(ensPerturbations(ni,nkgdimEns,nj,nens))
    allocate(stddev3d(ni,nkgdimEns,nj))
    if (trim(tool) == 'HVCORREL_HI') then
       allocate(corns(nkgdimEns,nkgdimEns,0:ntrunc))
       allocate(rstddev(nkgdimEns,0:ntrunc))
    end if

    do waveBandIndex = 1, nWaveBand

       if ( nWaveBand /= 1 ) then
          write(6,*)
          write(6,*) ' ********* Processing WaveBand #',waveBandIndex
          write(6,*)
       end if

       call readEnsemble(ensPerturbations,windImages=.false.) ! OUT
       write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

       call removeMean(ensPerturbations) ! INOUT
       
       if (trim(tool) /= 'HVCORREL_HI') then
          call removeGlobalMean(ensPerturbations) ! INOUT
       end if

       call spectralFilter(ensPerturbations,nkgdimens,waveBandIndex=waveBandIndex) ! INOUT, IN, IN

       call calcStddev3d(ensPerturbations,stddev3d,nkgdimens) ! IN, OUT, IN

       if (trim(tool) == 'HVCORREL_HI') then
          call normalize3d(ensPerturbations,stddev3d) ! INOUT, IN

          call removeGlobalMean(ensPerturbations) ! INOUT

          call calcCorrelations(ensPerturbations, & ! IN
                                corns,            & ! OUT (vertical correlation in spectral space)
                                rstddev)            ! OUT ( sqrt(normalized power spectrum) )

          call writeStats(corns,rstddev,waveBandIndex=waveBandIndex) ! IN

          call calcHorizScale(rstddev,waveBandIndex=waveBandIndex) ! IN

          call horizCorrelFunction(rstddev,waveBandIndex=waveBandIndex) ! IN
       else if (trim(tool) == 'HVCORREL_LOCAL') then
          call normalize3d(ensPerturbations,stddev3d) ! INOUT, IN
          call calcLocalCorrelations(ensPerturbations, waveBandIndex=waveBandIndex) ! IN
       else
          call calcLocalizationRadii(ensPerturbations, stddev3d, waveBandIndex=waveBandIndex) ! IN
       end if

    end do

    !
    !- Write the estimated pressure profiles
    !
    call writePressureProfiles

  end subroutine calcb_glb_toolbox

!--------------------------------------------------------------------------
! CALCB_GLB_POWERSPEC
!--------------------------------------------------------------------------
  subroutine calcb_glb_powerspec
    implicit none

    ! NOTE: The diagnostic computed here are in model variable space 
    !       (no variable transform!!!)

    integer :: ierr,  waveBandIndex

    real*4,pointer     :: ensPerturbations(:,:,:,:)
    real*8,allocatable :: powerSpec(:,:)

    write(6,*)
    write(6,*) 'calcb_glb_powerspec'
    write(6,*)
    
    allocate(ensPerturbations(ni,nkgdimEns,nj,nens))
    allocate(powerspec(nkgdimEns,0:ntrunc))

    call readEnsemble(ensPerturbations,windImages=.false.) ! OUT, IN
    write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    call removeMean(ensPerturbations) ! INOUT

    call calcPowerSpec(ensPerturbations, & ! IN
                       powerSpec)          ! OUT

    call writePowerSpec(powerSpec) ! IN

  end subroutine calcb_glb_powerspec

!--------------------------------------------------------------------------
! CALCB_GLB_STDDEV
!--------------------------------------------------------------------------
  subroutine calcb_glb_stddev
    implicit none
    integer :: ierr
    real*4,pointer  :: ensPerturbations(:,:,:,:)
    real*8,allocatable :: stddev3d(:,:,:),stddevZonAvg(:,:)

    allocate(ensPerturbations(ni,nkgdimEns,nj,nens),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddev3d(ni,nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif
    allocate(stddevZonAvg(nkgdimEns,nj),stat=ierr)
    if(ierr.ne.0) then
      write(6,*) 'Problem allocating memory!',ierr
      call flush(6)
    endif

    call readEnsemble(ensPerturbations)

    call removeMean(ensPerturbations)

    call uv_to_psichi(ensPerturbations)

    call calcStddev3d(ensPerturbations,stddev3d,nkgdimens)

    call calcZonAvg(stddevZonAvg,stddev3d,nkgdimens)

    call writeStddev(stddevZonAvg,stddevZonAvg,stddev3d,stddev3d)

    write(200,*) stddevZonAvg(1:nlevEns_M,:)
    write(201,*) stddevZonAvg((1+1*nlevEns_M):(2*nlevEns_M),:)
    write(202,*) stddevZonAvg((1+2*nlevEns_M):(3*nlevEns_T),:)
    write(203,*) stddevZonAvg((1+2*nlevEns_M+1*nlevEns_T):(2*nlevEns_M+2*nlevEns_T),:)
    write(204,*) stddevZonAvg((1+2*nlevEns_M+2*nlevEns_T),:)/1.0d2

  end subroutine calcb_glb_stddev

!--------------------------------------------------------------------------
! WRITESPSTATS
!--------------------------------------------------------------------------
  subroutine writeSpStats(ptot,theta)
    implicit none
    real*8 :: PtoT(:,:,:),theta(:,:)
    integer jn,ierr,ipak,jlat,jlev1,jlev2,nlev
    integer vfstecr,fstouv,fnom,fstfrm,fclos
    integer ip1,ip2,ip3,kni,knj,idatyp,idateo
    integer :: nulstats
    real*8 :: bufz(nLevEns_M),bufyz(nj,nLevEns_M),zsp(0:ntrunc,nLevEns_M)
    real*8 :: bufptot(nj,(nLevEns_T+1)*nLevEns_M),spptot(0:ntrunc,(nLevEns_T+1)*nLevEns_M)
    real*8 :: zspptot(nLevEns_T+1,nLevEns_M)

    nulstats=0
    ierr =  fnom  (nulstats,'./stats_sp.fst','RND',0)
    ierr =  fstouv(nulstats,'RND')

    ipak = -32
    idatyp = 5
    ip1 = 0
    ip3 = nens
    idateo = 0

    ! write out SP_THETA

    do jlat = 1, nj
      do jlev1 = 1, nLevEns_M
        bufyz(jlat,jlev1) = theta(jlev1,jlat)
      enddo
    enddo

    call gst_zlegdir(gstID,bufyz,zsp,nLevEns_M)

    do jn = 0, ntrunc
      do jlev1=1, nLevEns_M
        bufz(jlev1) = zsp(jn,jlev1)
      enddo

      ierr = vfstecr(bufz,bufz,ipak,nulstats,idateo,0,0,nlevEns_M,1,1,   &
                     ip1,jn,ip3,'X','ZZ','SP_THETA','X',0,0,0,0,idatyp,.true.)

    enddo

    ! write out SP_PTOT

    do jlat = 1, nj
      do jlev1 = 1, (nLevEns_T+1)
        do jlev2 = 1, nLevEns_M
          bufptot(jlat,(jlev2-1)*(nLevEns_T+1)+jlev1) = PtoT(jlev1,jlev2,jlat)
        enddo
      enddo
    enddo

    nlev=(nLevEns_T+1)*nLevEns_M
    call gst_zlegdir(gstID,bufptot,spptot,nLev)

    do jn = 0, ntrunc
      do jlev1 = 1, (nLevEns_T+1)
        do jlev2 = 1, nLevEns_M
          zspptot(jlev1,jlev2) = spptot(jn,(jlev2-1)*(nLevEns_T+1)+jlev1)
        enddo
      enddo

      kni=nLevEns_T+1
      knj=nLevEns_M
      ierr = vfstecr(zspptot,zspptot,ipak,nulstats,idateo,0,0,kni,knj,1,  &
                     ip1,jn,ip3,'X','ZZ','SP_PTOT ','X',0,0,0,0,idatyp,.true.)
    enddo




    ierr =  fstfrm(nulstats)
    ierr =  fclos (nulstats)

    write(6,*) 'finished writing statistics...'
    call flush(6)

  end subroutine writeSpStats

!--------------------------------------------------------------------------
! REMOVEBALANCEDCHI
!--------------------------------------------------------------------------
  subroutine removeBalancedChi(ensPerturbations,theta)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    real*8 :: theta(:,:)
    real*4,pointer :: psi_ptr(:,:,:),chi_ptr(:,:,:)
    integer :: jens,jlat,jlev,jlon

    do jens = 1,nens
      psi_ptr => ensPerturbations(:,1:nlevEns_M,:,jens)
      chi_ptr => ensPerturbations(:,(nlevEns_M+1):(2*nlevEns_M),:,jens)

      do jlat = 1, nj
        do jlev = 1, nLevEns_M
          do jlon = 1, ni
            chi_ptr(jlon,jlev,jlat) = chi_ptr(jlon,jlev,jlat) + tan(theta(jlev,jlat))*psi_ptr(jlon,jlev,jlat)
          enddo
        enddo
      enddo

    enddo

    write(6,*) 'finished removing balanced chi...'
    call flush(6)

  end subroutine removeBalancedChi

!--------------------------------------------------------------------------
! REMOVEBALANCEDT_PS
!--------------------------------------------------------------------------
  subroutine removeBalancedT_Ps(ensPerturbations,ensBalPerturbations,PtoT)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    real*4,pointer :: ensBalPerturbations(:,:,:,:)
    real*8 :: PtoT(:,:,:)

    real*4,pointer :: tt_ptr(:,:,:),ps_ptr(:,:,:),ttb_ptr(:,:,:),psb_ptr(:,:,:)
    real*8  :: spectralState(nla,2,nLevEns_M),spBalancedP(nla,2,nlevEns_M),balancedP(ni,nlevEns_M,nj),psi(ni,nLevEns_M,nj)
    integer :: jens,jlat,jlon,jk1,jk2

    do jens=1,nens

      psi(:,:,:)=ensPerturbations(:,1:nlevEns_M,:,jens)
      call gst_reespe(spectralState,psi,nLevEns_M,nLevEns_M)
      call calcBalancedP(spectralState,spBalancedP)
      call gst_speree(spBalancedP,balancedP,nlevEns_M,nlevEns_M)

      tt_ptr => ensPerturbations(:,(1+2*nLevEns_M):(2*nLevEns_M+1*nLevEns_T),:,jens)
      ps_ptr => ensPerturbations(:,(1+2*nLevEns_M+2*nLevEns_T):(1+2*nLevEns_M+2*nLevEns_T),:,jens)
      ttb_ptr => ensBalPerturbations(:,1:nLevEns_T,:,jens)
      psb_ptr => ensBalPerturbations(:,(1+nLevEns_T):(1+nLevEns_T),:,jens)

      ttb_ptr(:,:,:)=0.0d0
      psb_ptr(:,:,:)=0.0d0

!$OMP PARALLEL
!$OMP DO PRIVATE (jlat,jlon,jk1,jk2)
      do jlat = 1, nj
        do jlon = 1, ni
          do jk1 = 1, nLevEns_T
            do jk2 = 1, nlevptot
              ttb_ptr(jlon,jk1,jlat) = ttb_ptr(jlon,jk1,jlat) + PtoT(jk1,jk2,jlat)*balancedP(jlon,jk2,jlat)
            enddo
            tt_ptr(jlon,jk1,jlat) = tt_ptr(jlon,jk1,jlat) - ttb_ptr(jlon,jk1,jlat)
          enddo
          do jk2 = 1, nlevptot
            psb_ptr(jlon,1,jlat) = psb_ptr(jlon,1,jlat) + PtoT(nLevEns_T+1,jk2,jlat)*balancedP(jlon,jk2,jlat)
          enddo
          ps_ptr(jlon,1,jlat) = ps_ptr(jlon,1,jlat) - psb_ptr(jlon,1,jlat)
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    enddo

    write(6,*) 'finished removing balanced T and Ps...'
    call flush(6)

  end subroutine removeBalancedT_Ps

!--------------------------------------------------------------------------
! CALCCORRELATIONS
!--------------------------------------------------------------------------
  subroutine calcCorrelations(ensPerturbations,corns,rstddev)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    real*8 :: corns(nkgdimEns,nkgdimEns,0:ntrunc),rstddev(nkgdimEns,0:ntrunc)

    real*8  :: spectralState(nla,2,nkgdimEns),gridState(ni,nkgdimEns,nj)
    real*8  :: dfact,dfact2,dsummed
    integer :: jens,ila,jn,jm,jk1,jk2

    corns(:,:,:)=0.0d0
    do jens=1,nens

      write(6,*) 'calcCorrelations: processing member ',jens
      call flush(6)

      gridState(:,:,:)=ensPerturbations(:,:,:,jens)
      call gst_reespe(spectralState,gridState,nkgdimEns,nkgdimEns)

!$OMP PARALLEL
!$OMP DO PRIVATE (jn,jm,dfact,ila,jk1,jk2)
      do jn = 0, ntrunc
        do jm = 0, jn
          dfact = 2.0d0
          if (jm.eq.0) dfact = 1.0d0
          ila = gst_getNind(jm) + jn - jm
          do jk1 = 1, nkgdimEns
            do jk2 = 1, nkgdimEns
              corns(jk1,jk2,jn) = corns(jk1,jk2,jn) +     &
                 dfact*( spectralState(ila,1,jk1)*spectralState(ila,1,jk2) +   &
                         spectralState(ila,2,jk1)*spectralState(ila,2,jk2)  )
            enddo
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    enddo

    do jn = 0, ntrunc
      do jk1 = 1, nkgdimEns
        if(abs(corns(jk1,jk1,jn)).gt.0.0d0) then
          rstddev(jk1,jn) = dsqrt(abs(corns(jk1,jk1,jn)))
        else
          rstddev(jk1,jn) = 0.0d0
        endif
      enddo
    enddo

    do jn = 0, ntrunc
      do jk1 = 1, nkgdimEns
        do jk2 = 1, nkgdimEns
          if(rstddev(jk1,jn).ne.0..and.rstddev(jk2,jn).ne.0.) then
            corns(jk1,jk2,jn) =  corns(jk1,jk2,jn)/(rstddev(jk1,jn)*rstddev(jk2,jn))
          else
            corns(jk1,jk2,jn) = 0.0d0
          endif
        enddo
      enddo
    enddo

    dfact2 = 1.0d0/sqrt(dble(nens-1))
    do jn = 0, ntrunc
      dfact = 1.0d0/sqrt(2.0d0*dble(jn) + 1.0d0)
      do jk1 = 1, nkgdimEns
        rstddev(jk1,jn) = rstddev(jk1,jn)*dfact2*dfact
      enddo
    enddo

    ! Normalize to ensure correlations in horizontal and Multiply by sqrt(0.5) to make valid for m.ne.0
    do jk1 = 1, nkgdimEns
      dsummed=0.0d0
      do jn = 0, ntrunc
        dsummed=dsummed + (rstddev(jk1,jn)**2)*((2.0d0*dble(jn))+1.0d0)/2.0d0
      enddo
      do jn = 0, ntrunc
        if(dsummed.gt.0.0d0) rstddev(jk1,jn)=rstddev(jk1,jn)*sqrt(0.5d0/dsummed)
      enddo
    enddo

    write(6,*) 'finished computing correlations...'
    call flush(6)

  end subroutine calcCorrelations

!--------------------------------------------------------------------------
! CALCPOWERSPEC
!--------------------------------------------------------------------------
  subroutine calcPowerSpec(ensPerturbations,powerSpec)
    implicit none
    real*4,pointer, intent(in)  :: ensPerturbations(:,:,:,:)
    real*8,         intent(out) :: powerSpec(nkgdimEns,0:ntrunc)

    real*8  :: spectralState(nla,2,nkgdimEns),gridState(ni,nkgdimEns,nj)
    real*8  :: dfact,dfact2,dsummed

    integer :: jens,ila,jn,jm,jk

    powerSpec(:,:)=0.0d0

    do jens = 1, nens

      write(6,*) 'calcPowerSpec: processing member ',jens
      call flush(6)

      gridState(:,:,:)=ensPerturbations(:,:,:,jens)
      call gst_reespe(spectralState,gridState,nkgdimEns,nkgdimEns)

!$OMP PARALLEL
!$OMP DO PRIVATE (jn,jm,dfact,ila,jk)
      do jn = 0, ntrunc
        do jm = 0, jn
          dfact = 2.0d0
          if (jm.eq.0) dfact = 1.0d0
          ila = gst_getNind(jm) + jn - jm
          do jk = 1, nkgdimEns
              powerSpec(jk,jn) = powerSpec(jk,jn) +     &
                 dfact*( spectralState(ila,1,jk)**2 + spectralState(ila,2,jk)**2 )
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    enddo

    dfact2 = 1.0d0/sqrt(dble(nens-1))
    do jn = 0, ntrunc
      dfact = 1.0d0/sqrt(2.0d0*dble(jn) + 1.0d0)
      do jk = 1, nkgdimEns
        powerSpec(jk,jn) = powerSpec(jk,jn)*dfact2*dfact
      enddo
    enddo

    write(6,*) 'finished computing power spectrum...'
    call flush(6)

  end subroutine calcPowerSpec

!--------------------------------------------------------------------------
! WRITESTATS
!--------------------------------------------------------------------------
  subroutine writeStats(corns,rstddev,ptot,theta,waveBandIndex)
    implicit none

    real*8 :: corns(nkgdimEns,nkgdimEns,0:ntrunc),rstddev(nkgdimEns,0:ntrunc)
    real*8, optional :: PtoT(:,:,:),theta(:,:)
    integer, optional :: waveBandIndex

    real*8 prcor(nkgdimEns,nkgdimEns)

    integer :: jn,ierr,ipak,jk,jl
    integer :: vfstecr,fstouv,fnom,fstfrm,fclos
    integer :: ip1,ip2,ip3,idatyp,idateo
    integer :: nulstats
    integer :: jvar1, jvar2
    integer :: nLevEns1, nLevEns2, nlevstart1, nlevend1, nlevstart2, nlevend2

    character(len=128) :: outfilename
    character(len=2) :: wbnum

    nulstats=0
    if ( nWaveBand == 1 ) then
       outfilename='./bgcov.fst'
    else
       if (.not. present(waveBandIndex)) then
          write(6,*) 'writeStats: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
       outfilename='./bgcov_'//trim(wbnum)//'.fst'
    end if
    ierr =  fnom  (nulstats,trim(outfilename),'RND',0)
    ierr =  fstouv(nulstats,'RND')

    ipak = -32
    idatyp = 5
    ip1 = 0
    ip2 = 0
    ip3 = nens
    idateo = 0

    if (present(ptot)) then
       ierr = vfstecr(ptot(1,1,1),ptot(1,1,1),ipak,nulstats,idateo,0,0,nlevEns_T+1,nlevEns_M,nj,  &
                      ip1,ip2,ip3,'X','ZZ','P_to_T  ','X',0,0,0,0,idatyp,.true.)
    end if
    if (present(theta)) then
       ierr = vfstecr(theta(1,1),theta(1,1),ipak,nulstats,idateo,0,0,nlevEns_M,nj,1,   &
                      ip1,ip2,ip3,'X','ZZ','THETA   ','X',0,0,0,0,idatyp,.true.)
    end if

    do jn = 0, ntrunc
      ip2 = jn
      ierr = vfstecr(corns(1,1,jn),corns(1,1,jn),ipak,nulstats,idateo,0,0,nkgdimEns,nkgdimEns,1,  &
                     ip1,ip2,ip3,'X','ZZ','CORRNS  ','X',0,0,0,0,idatyp,.true.)
    enddo

    do jn = 0, ntrunc
      ip2 = jn
      ierr = vfstecr(rstddev(1,jn),rstddev(1,jn),ipak,nulstats,idateo,0,0,nkgdimEns,1,1,   &
                     ip1,ip2,ip3,'X','SS','RSTDDEV ','X',0,0,0,0,idatyp,.true.)
    enddo

    
    ! Computing the total vertical correlation matrix
    do jk = 1, nkgdimEns
      do jl = 1, nkgdimEns
        prcor(jk,jl) = 0
        do jn = 0, ntrunc
          prcor(jk,jl) = prcor(jk,jl) + ((2*jn+1)*rstddev(jk,jn)*rstddev(jl,jn)*corns(jk,jl,jn))
        enddo
      enddo
    enddo

    do jk = 1, nkgdimEns
      do jl = 1, nkgdimEns
        if(prcor(jk,jk)*prcor(jl,jl) .gt. 0.0d0) then
          prcor(jk,jl) = prcor(jk,jl) / (sqrt(prcor(jk,jk)*prcor(jl,jl)))
        else
          prcor(jk,jl) = 0.0d0
        endif
      enddo
    enddo
    ip2 =0
    ierr = vfstecr(prcor(1,1),prcor(1,1),ipak,nulstats,idateo,0,0,nkgdimEns,nkgdimEns,1,   &
                   ip1,ip2,ip3,'X','ZV','CORVERT ','X',0,0,0,0,idatyp,.true.)

    ierr =  fstfrm(nulstats)
    ierr =  fclos (nulstats)

    !- For plotting purposes...
    do jvar1 = 1, nvar3d
       do jvar2 = jvar1, nvar3d

          if ( nWaveBand == 1 ) then
             outfilename = "./vertCorrel_"//trim(nomvar3d(jvar1,variableType))//"_"//trim(nomvar3d(jvar2,variableType))//".txt"
          else
             outfilename = "./vertCorrel_"//trim(nomvar3d(jvar1,variableType))//"_"//trim(nomvar3d(jvar2,variableType))//"_"//wbnum//".txt"
          end if
          open (unit=99,file=outfilename,action="write",status="new")

          if (vnl_varLevelFromVarName(nomvar3d(jvar1,variableType)).eq.'MM') then
             nLevEns1 = nLevEns_M
          else
             nLevEns1 = nLevEns_T
          endif
          nLevStart1 = varLevOffset(jvar1)+ 1 
          nLevEnd1   = varLevOffset(jvar1)+ nLevEns1

          if (vnl_varLevelFromVarName(nomvar3d(jvar2,variableType)).eq.'MM') then
             nLevEns2 = nLevEns_M
          else
             nLevEns2 = nLevEns_T
          endif
          nLevStart2 = varLevOffset(jvar2)+ 1 
          nLevEnd2   = varLevOffset(jvar2)+ nLevEns2

          do jk = nLevStart1, nLevEnd1
             do jl = nLevStart2, nLevEnd2
                if ( jl == nLevEnd2 ) then 
                   write(99,'(2X,F6.4)')    prcor(jk,jl) ! Saut de ligne
                else
                   write(99,'(2X,F6.4,$)')  prcor(jk,jl)
                end if
             end do
          end do

          close(unit=99)
          
       end do
    end do

    write(6,*) 'finished writing statistics...'
    call flush(6)

  end subroutine writeStats

!--------------------------------------------------------------------------
! WRITEPRESSUREPROFILES
!--------------------------------------------------------------------------
  subroutine writePressureProfiles
    implicit none

    character(len=128) :: outfilename

    integer :: jk

    outfilename = "./pressureProfile_M.txt"
    open (unit=99,file=outfilename,action="write",status="new")
    do jk = 1, nLevEns_M
       write(99,'(I3,2X,F6.1)') jk, pressureProfile_M(jk)/100.d0
    end do
    close(unit=99)
       
    outfilename = "./pressureProfile_T.txt"
    open (unit=99,file=outfilename,action="write",status="new")
    do jk = 1, nLevEns_T
       write(99,'(I3,2X,F6.1)') jk, pressureProfile_T(jk)/100.d0
    end do
    close(unit=99)

    write(6,*) 'finished writing pressure profiles...'
    call flush(6)

  end subroutine writePressureProfiles

!--------------------------------------------------------------------------
! WRITESTDDEV
!--------------------------------------------------------------------------
  subroutine writeStddev(stddevZonAvg,stddevZonAvgUnbal,stddev3d,stddev3dUnbal)
    implicit none
    real*8 :: stddevZonAvg(:,:),stddevZonAvgUnbal(:,:),stddev3d(:,:,:),stddev3dUnbal(:,:,:)
    real*8 :: dfact,zbuf(ni,nj),zbufyz(nj,max(nLevEns_M,nLevens_T)),zbufy(nj)
    integer jlat,jlon,jlev,ierr,jvar,nLevEns
    integer vfstecr,fstouv,fnom,fstfrm,fclos
    integer ip1,ip2,ip3,idatyp,idateo,ipak,nip1_l(max(nLevEns_M,nLevens_T))
    integer :: nulstats

    nulstats=0
    ierr =  fnom  (nulstats,'./stddev.fst','RND',0)
    ierr =  fstouv(nulstats,'RND')

    ipak = -32
    idatyp = 5
    ip1 = 0
    ip2 = 0
    ip3 = nens
    idateo = 0

    ! do 3d variables
    do jvar=1,nvar3d
      if(vnl_varLevelFromVarName(nomvar3d(jvar,cvSpace)).eq.'MM') then
        nLevEns = nLevEns_M
        nip1_l(1:nLevEns_M)=nip1_M(1:nLevEns_M)
      else
        nLevEns = nLevEns_T
        nip1_l(1:nLevEns_T)=nip1_T(1:nLevEns_T)
      endif
      dfact=1.0d0

      do jlev=1,nlevEns
        do jlat=1,nj
          do jlon=1,ni
            zbuf(jlon,jlat)=dfact*stddev3d(jlon,varLevOffset(jvar)+jlev,jlat)
          enddo
        enddo
        ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,nip1_l(jlev),ip2,ip3,   &
                       'E',nomvar3d(jvar,cvSpace),'STDDEV3D','G',0,0,0,0,idatyp,.true.)
      enddo

      do jlev=1,nlevEns
        do jlat=1,nj
          zbufyz(jlat,jlev)=dfact*stddevZonAvg(varLevOffset(jvar)+jlev,jlat)
        enddo
      enddo
      ierr = vfstecr(zbufyz(:,1:nLevEns),zbufyz(:,1:nLevEns),ipak,nulstats,idateo,0,0,1,nj,nlevEns,ip1,ip2,ip3,   &
                     'E',nomvar3d(jvar,cvSpace),'STDDEV  ','X',0,0,0,0,idatyp,.true.)

      if(nomvar3d(jvar,cvSpace).ne.nomvar3d(jvar,cvUnbalSpace)) then
        dfact=1.0d0

        do jlev=1,nlevEns
          do jlat=1,nj
            do jlon=1,ni
              zbuf(jlon,jlat)=dfact*stddev3dUnbal(jlon,varLevOffset(jvar)+jlev,jlat)
            enddo 
          enddo
          ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,nip1_l(jlev),ip2,ip3,   &
                         'E',nomvar3d(jvar,cvUnbalSpace),'STDDEV3D','G',0,0,0,0,idatyp,.true.)
        enddo

        do jlev=1,nlevEns
          do jlat=1,nj
            zbufyz(jlat,jlev)=dfact*stddevZonAvgUnbal(varLevOffset(jvar)+jlev,jlat)
          enddo
        enddo
        ierr = vfstecr(zbufyz(:,1:nLevEns),zbufyz(:,1:nLevEns),ipak,nulstats,idateo,0,0,1,nj,nlevEns,ip1,ip2,ip3,   &
                       'E',nomvar3d(jvar,cvUnbalSpace),'STDDEV  ','X',0,0,0,0,idatyp,.true.)
      endif

    enddo

    ! now do 2D variables
    do jvar=1,nvar2d
      if(nomvar2d(jvar,cvSpace).eq.'P0') then
        dfact=1.0d0/1.0d2
      else
        dfact=1.0d0
      endif

      do jlat=1,nj
        do jlon=1,ni
          zbuf(jlon,jlat)=dfact*stddev3d(jlon,varLevOffset(nvar3d+1)+jvar,jlat)
        enddo
      enddo
      ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,0,ip2,ip3,   &
                     'E',nomvar2d(jvar,cvSpace),'STDDEV3D','G',0,0,0,0,idatyp,.true.)

      do jlat=1,nj
        zbufy(jlat)=dfact*stddevZonAvg(varLevOffset(nvar3d+1)+jvar,jlat)
      enddo
      ierr = vfstecr(zbufy,zbufy,ipak,nulstats,idateo,0,0,1,nj,1,ip1,ip2,ip3,   &
                     'E',nomvar2d(jvar,cvSpace),'STDDEV  ','X',0,0,0,0,idatyp,.true.)

      if(nomvar2d(jvar,cvSpace).ne.nomvar2d(jvar,cvUnbalSpace)) then
        if(nomvar2d(jvar,cvUnbalSpace).eq.'UP') then
          dfact=1.0d0/1.0d2
        else
          dfact=1.0d0
        endif

        do jlat=1,nj
          do jlon=1,ni
            zbuf(jlon,jlat)=dfact*stddev3dUnbal(jlon,varLevOffset(nvar3d+1)+jvar,jlat)
          enddo 
        enddo
        ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,0,ip2,ip3,   &
                       'E',nomvar2d(jvar,cvUnbalSpace),'STDDEV3D','G',0,0,0,0,idatyp,.true.)

        do jlat=1,nj
          zbufy(jlat)=dfact*stddevZonAvgUnbal(varLevOffset(nvar3d+1)+jvar,jlat)
        enddo
        ierr = vfstecr(zbufyz,zbufyz,ipak,nulstats,idateo,0,0,1,nj,1,ip1,ip2,ip3,   &
                       'E',nomvar2d(jvar,cvUnbalSpace),'STDDEV  ','X',0,0,0,0,idatyp,.true.)
      endif

    enddo

    ierr =  fstfrm(nulstats)
    ierr =  fclos (nulstats)

    write(6,*) 'finished writing stddev...'
    call flush(6)

  end subroutine writeStddev

!--------------------------------------------------------------------------
! WRITESTDDEVBAL
!--------------------------------------------------------------------------
  subroutine writeStddevBal(stddevZonAvgBal,stddev3dBal)
    implicit none
    real*8 :: stddevZonAvgBal(:,:),stddev3dBal(:,:,:)
    real*8 :: dfact,zbuf(ni,nj),zbufyz(nj,max(nLevEns_M,nLevens_T)),zbufy(nj)
    integer jlat,jlon,jlev,ierr,jvar,nLevEns
    integer vfstecr,fstouv,fnom,fstfrm,fclos
    integer ip1,ip2,ip3,idatyp,idateo,ipak,nip1_l(max(nLevEns_M,nLevens_T))
    integer :: nulstats
    integer,parameter :: nvar3d=1,nvar2d=1
    character*4 :: nomvar3dBal(nvar3d),nomvar2dBal(nvar2d)

    nomvar3dBal(1)='TB'
    nomvar2dBal(1)='PB'

    nulstats=0
    ierr =  fnom  (nulstats,'./stddev_balanced.fst','RND',0)
    ierr =  fstouv(nulstats,'RND')

    ipak = -32
    idatyp = 5
    ip1 = 0
    ip2 = 0
    ip3 = nens
    idateo = 0

    ! do 3d variables
    do jvar=1,nvar3d
      nLevEns = nLevEns_T
      nip1_l(1:nLevEns_T)=nip1_T(1:nLevEns_T)
      dfact=1.0d0

      do jlev=1,nlevEns
        do jlat=1,nj
          do jlon=1,ni
            zbuf(jlon,jlat)=dfact*stddev3dBal(jlon,varLevOffset(jvar)+jlev,jlat)
          enddo
        enddo
        ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,nip1_l(jlev),ip2,ip3,   &
                       'E',nomvar3dBal(jvar),'STDDEV3D','G',0,0,0,0,idatyp,.true.)
      enddo

      do jlev=1,nlevEns
        do jlat=1,nj
          zbufyz(jlat,jlev)=dfact*stddevZonAvgBal(varLevOffset(jvar)+jlev,jlat)
        enddo
      enddo
      ierr = vfstecr(zbufyz(:,1:nLevEns),zbufyz(:,1:nLevEns),ipak,nulstats,idateo,0,0,1,nj,nlevEns,ip1,ip2,ip3,   &
                     'E',nomvar3dBal(jvar),'STDDEV  ','X',0,0,0,0,idatyp,.true.)

    enddo

    ! now do 2D variables
    do jvar=1,nvar2d
      dfact=1.0d0/1.0d2

      do jlat=1,nj
        do jlon=1,ni
          zbuf(jlon,jlat)=dfact*stddev3dBal(jlon,varLevOffset(nvar3d+1)+jvar,jlat)
        enddo
      enddo
      ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,0,ip2,ip3,   &
                     'E',nomvar2dBal(jvar),'STDDEV3D','G',0,0,0,0,idatyp,.true.)

      do jlat=1,nj
        zbufy(jlat)=dfact*stddevZonAvgBal(varLevOffset(nvar3d+1)+jvar,jlat)
      enddo
      ierr = vfstecr(zbufy,zbufy,ipak,nulstats,idateo,0,0,1,nj,1,ip1,ip2,ip3,   &
                     'E',nomvar2dBal(jvar),'STDDEV  ','X',0,0,0,0,idatyp,.true.)

    enddo

    ierr =  fstfrm(nulstats)
    ierr =  fclos (nulstats)

    write(6,*) 'finished writing stddev...'
    call flush(6)

  end subroutine writeStddevBal

!--------------------------------------------------------------------------
! SPECTRALFILTER
!--------------------------------------------------------------------------
  subroutine spectralFilter(ensPerturbations,nlev,waveBandIndex)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    integer, intent(in) :: nlev
    integer, optional, intent(in) :: waveBandIndex

    real*8  :: spectralState(nla,2,nlev)
    real*8  :: member(ni,nlev,nj)
    integer :: jens, jk, jn, jm, ila

    real(8), allocatable :: ResponseFunction(:)
    real(8) :: waveLength, FilterResponseFunction

    character(len=128) :: outfilename
    character(len=2) :: wbnum

    if ( nWaveBand /= 1 ) then
       write(6,*) 'Bandpass filtering step'
       if (.not. present(waveBandIndex)) then
          write(6,*) 'Error: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       allocate(ResponseFunction(0:ntrunc))
       write(wbnum,'(I2.2)') waveBandIndex
       outfilename = "./ResponseFunction_"//wbnum//".txt"
       open (unit=99,file=outfilename,action="write",status="new")
       do jn = 0, ntrunc
          ResponseFunction(jn) = FilterResponseFunction(dble(jn),waveBandIndex, waveBandPeaks, nWaveBand)
          if ( jn /= 0) then
             waveLength=4.d0*asin(1.d0)*ra/dble(jn)
          else
             waveLength=0.d0
          end if
          write(* ,'(I4,2X,F7.1,2X,F5.3)') jn, waveLength/1000.d0, ResponseFunction(jn)
          write(99,'(I4,2X,F7.1,2X,F5.3)') jn, waveLength/1000.d0, ResponseFunction(jn)
       end do
       close(unit=99)
    end if

    do jens=1,nens
      member(:,:,:)=dble(ensPerturbations(:,:,:,jens))     
      call gst_reespe(spectralState,member,nlev,nlev)
      if ( nWaveBand /= 1 ) then
!$OMP PARALLEL
!$OMP DO PRIVATE (jk,jn,jm,ila)
         do jk = 1, nlev
            do jn = 0, ntrunc
               do jm = 0, jn
                  ila = gst_getnind(jm,gstID)+jn-jm
                  spectralState(ila,1,jk) = spectralState(ila,1,jk) * ResponseFunction(jn)
                  spectralState(ila,2,jk) = spectralState(ila,2,jk) * ResponseFunction(jn)
               end do
            end do
         end do
!$OMP END DO
!$OMP END PARALLEL
      end if
      call gst_speree(spectralState,member,nlev,nlev)
      ensPerturbations(:,:,:,jens)=sngl(member(:,:,:))
    enddo

    if ( nWaveBand /= 1 ) then
       deallocate(ResponseFunction)
    end if

    write(6,*) 'finished applying spectral filter...'
    call flush(6)

  end subroutine spectralFilter

!--------------------------------------------------------------------------
! CALCTHETA
!--------------------------------------------------------------------------
  subroutine calcTheta(ensPerturbations,theta)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    real*8  :: theta(:,:)
    real*8 zchipsi(nLevEns_M,nj), zpsipsi(nLevEns_M,nj)
    real*4, pointer :: psi_ptr(:,:,:),chi_ptr(:,:,:)
    integer :: jlat,jlon,jlev,jens

    theta(:,:) = 0.0d0
    zchipsi(:,:) = 0.0d0
    zpsipsi(:,:) = 0.0d0

    do jens = 1,nens
      psi_ptr => ensPerturbations(:,1:nlevEns_M,:,jens)
      chi_ptr => ensPerturbations(:,(nlevEns_M+1):(2*nlevEns_M),:,jens)

      ! update zchipsi and zpsipsi covariances
      do jlat = 1, nj
        do jlon = 1, ni
          do jlev = 1, nLevEns_M
            zpsipsi(jlev,jlat) = zpsipsi(jlev,jlat) + psi_ptr(jlon,jlev,jlat) * psi_ptr(jlon,jlev,jlat)
            zchipsi(jlev,jlat) = zchipsi(jlev,jlat) + chi_ptr(jlon,jlev,jlat) * psi_ptr(jlon,jlev,jlat)
          enddo
        enddo
      enddo
    enddo

    !  calculate THETA
    do jlat = 1, nj
      do jlev = 1, nLevEns_M
        theta(jlev,jlat) = atan(-zchipsi(jlev,jlat) / zpsipsi(jlev,jlat))
      enddo
    enddo

    write(6,*) 'finished computing theta...'
    call flush(6)

  end subroutine calcTheta

!--------------------------------------------------------------------------
! CALCPTOT
!--------------------------------------------------------------------------
  subroutine calcPtoT(ensPerturbations,PtoT)
    implicit none
    real*4,pointer :: ensPerturbations(:,:,:,:)
    real*8  :: PtoT(:,:,:)

    real*8  :: spectralState(nla,2,nLevEns_M),spBalancedP(nla,2,nlevEns_M),balancedP(ni,nlevEns_M,nj),psi(ni,nLevEns_M,nj)
    real*4, pointer :: tt_ptr(:,:,:),ps_ptr(:,:)
    INTEGER JENS, IENS, JK1, JK2, JLA, JN, JM, ILA, JLEV
    INTEGER IERR, JFILE, JK, JLAT, ILON, JLON, JB, NLATBAND
    INTEGER IBND1,IBND2,JPNLATBND,ILAT
    PARAMETER (JPNLATBND = 3)
    REAL*8 ZFACT,ZMAXI,ZWT,ZPS,zlat(nj)
    REAL*8 ZFACT2,ZFACTTOT
    REAL*8 ZM1(NLEVENS_T+1,NLEVENS_M,JPNLATBND), ZM2(NLEVPTOT,NLEVPTOT,JPNLATBND)
    REAL*8 ZPTOTBND(NLEVENS_T+1,NLEVENS_M)
    REAL*8 ZM2INV(NLEVPTOT,NLEVPTOT,JPNLATBND),ZWORK(NLEVPTOT*NLEVPTOT),ZDET,ZEPS
    REAL*8  DLA2, DL1SA2
    REAL*8  DLLATMIN(JPNLATBND), DLLATMAX(JPNLATBND)
    REAL*8  DLLATMID(JPNLATBND)
    REAL*8  ZLC,ZTLEN,ZR,ZCORR,ZPRES1,ZPRES2
    real*8 zeigwrk(4*nlevPtoT),zeigen(nlevPtoT,nlevPtoT),zeigenv(nlevPtoT)
    real*8 zeigenvi(nlevPtoT)
    real   zfix
    integer iwork,info

    DATA DLLATMIN / -60.0D0, -30.0D0, 30.0D0 /
    DATA DLLATMAX / -30.0D0,  30.0D0, 60.0D0 /
    DATA DLLATMID / -45.0D0,  00.0D0, 45.0D0 /

    DLA2 = DBLE(RA)*DBLE(RA)
    DL1SA2 = 1.D0/DLA2

!   1. Initialize P_to_T, ZM1, ZM2

    ZFACTTOT = 0.0D0
    DO JLAT = 1, NJ
      ZFACTTOT = ZFACTTOT + cos(GST_GETRLATI(JLAT))
    ENDDO
    ZFACTTOT = NJ/ZFACTTOT

    PtoT(:,:,:) = 0.0d0
    ZM1(:,:,:) = 0.0d0
    ZPTOTBND(:,:) = 0.0d0
    ZM2(:,:,:) = 0.0d0

    do jens = 1,nens

      write(6,*) 'calcPtoT: processing member ',jens
      call flush(6)

      psi(:,:,:)=ensPerturbations(:,1:nlevEns_M,:,jens)
      call gst_reespe(spectralState,psi,nlevEns_M,nlevEns_M)
      CALL calcBalancedP(spectralState,spBalancedP)
      call gst_speree(spBalancedP,balancedP,nlevEns_M,nlevEns_M)

      tt_ptr  => ensPerturbations(:,(2*nLevEns_M+1):(2*nLevEns_M+nLevEns_T),:,jens)
      ps_ptr  => ensPerturbations(:,2*nLevEns_M+2*nLevEns_T+1,:,jens)

      DO JLAT = 1, NJ
        zlat(jlat)=GST_GETRLATI(JLAT)
      enddo

!$OMP PARALLEL
!$OMP DO PRIVATE (JK1,JB,JLAT,ZFACT,JLON,JK2)
      DO JK1 = 1, (nLevEns_T+1)
        DO JB=1,JPNLATBND
          DO JLAT = 1, NJ
            if ((ZLAT(JLAT) .gt. 2.D0*MPC_PI_R8*DLLATMIN(JB)/360.D0)   &
          .and. (ZLAT(JLAT) .le. 2.D0*MPC_PI_R8*DLLATMAX(JB)/360.D0)) then
              ZFACT = cos(ZLAT(JLAT))*ZFACTTOT
              DO JLON = 1, NI

                ! update ZM1 = sum_over_t_x_y[vec(T lnPs) vec(P_b)^T]
                DO JK2 = 1, nLevEns_M
                  IF(JK1.LE.nLevEns_T) THEN
                    ZM1(JK1,JK2,JB) = ZM1(JK1,JK2,JB) + ZFACT * tt_ptr(JLON,JK1,JLAT) * balancedP(JLON,JK2,JLAT)
                  ELSE
                    ZM1(JK1,JK2,JB) = ZM1(JK1,JK2,JB) + ZFACT * ps_ptr(JLON,JLAT) * balancedP(JLON,JK2,JLAT)
                  ENDIF
                ENDDO

                ! update ZM2 = sum_over_t_x_y[vec(P_b) vec(P_b)^T]
                IF(JK1.LE.NLEVPTOT) THEN
                  DO JK2 = 1, NLEVPTOT
                    ZM2(JK1,JK2,JB) = ZM2(JK1,JK2,JB) + ZFACT * balancedP(JLON,JK1,JLAT) * balancedP(JLON,JK2,JLAT)
                  ENDDO
                ENDIF

              ENDDO
            endif
          ENDDO
        ENDDO ! Loop on JPNLATBND
      END DO  ! Loop on JK1
!$OMP END DO
!$OMP END PARALLEL

    ENDDO

! SET ZM1,ZM2 EQUAL FOR ALL THREE REGIONS
    DO JK1 = 1, NLEVPTOT
      DO JK2 = 1, NLEVPTOT
        ZM2(JK1,JK2,1)=ZM2(JK1,JK2,1)+ZM2(JK1,JK2,3)
        ZM2(JK1,JK2,2)=ZM2(JK1,JK2,1)
        ZM2(JK1,JK2,3)=ZM2(JK1,JK2,1)
      ENDDO
    ENDDO
    DO JK1 = 1, (nLevEns_T+1)
      DO JK2 = 1, NLEVPTOT
        ZM1(JK1,JK2,1)=ZM1(JK1,JK2,1)+ZM1(JK1,JK2,3)
        ZM1(JK1,JK2,2)=ZM1(JK1,JK2,1)
        ZM1(JK1,JK2,3)=ZM1(JK1,JK2,1)
      ENDDO
    ENDDO

    DO JK1=1,NLEVPTOT
      DO JK2=1,NLEVPTOT
        ZEIGEN(JK1,JK2)=ZM2(JK1,JK2,1)
      ENDDO
    ENDDO
    IWORK=4*NLEVPTOT
    CALL DSYEV('V','U',NLEVPTOT,ZEIGEN,NLEVPTOT,ZEIGENV,ZEIGWRK,IWORK,INFO)

    write(6,*) 'calcPtot: info=',info
    write(6,*) 'calcPtot: eigen values=',zeigenv(:)

    do JK1=1,NLEVPTOT
      if (ZEIGENV(JK1).gt.0.0d0) then
        ZEIGENVI(JK1)=1.0d0/ZEIGENV(JK1)
      else
        ZEIGENVI(JK1)=0.0d0
      endif
    enddo

    DO JK1=1,NLEVPTOT
      DO JK2=1,NLEVPTOT
        ZM2INV(JK1,JK2,1)=0.0d0
        DO JK=1,NLEVPTOT
          ZM2INV(JK1,JK2,1)=ZM2INV(JK1,JK2,1)+ZEIGEN(JK1,JK)*ZEIGENVI(JK)*ZEIGEN(JK2,JK)
        ENDDO
      ENDDO
    ENDDO

!    write(6,*) 'zm1=',zm1(:,:,1)
!    write(6,*) 'zm2=',zm2(:,:,1)
!    write(6,*) 'zm2inv=',zm2inv(:,:,1)

! Calculate A = ZM1*inv(ZM2)
!
    DO JK1 = 1, (nLevEns_T+1)
      DO JK2 = 1, NLEVPTOT
        DO JK = 1, NLEVPTOT
          ZPTOTBND(JK1,JK2) = ZPTOTBND(JK1,JK2) + ZM1(JK1,JK,1) * ZM2INV(JK,JK2,1)
        ENDDO
      ENDDO
    ENDDO
!
    DO JK1 = 1, nLevEns_T+1
      DO JK2 = 1, NLEVPTOT
        DO JLAT = 1,NJ
          PTOT(JK1,JK2,JLAT) = ZPTOTBND(JK1,JK2)
        ENDDO
      ENDDO
    ENDDO

    write(6,*) 'finished computing PtoT...'
    call flush(6)

  end subroutine calcPtoT

!--------------------------------------------------------------------------
! REMOVEGLOBALMEAN
!--------------------------------------------------------------------------
  subroutine removeGlobalMean(ensPerturbations)
    implicit none
    integer :: jlon,jlat,jlev,jens
    real*4  :: ensPerturbations(:,:,:,:)
    real*8  :: dmean

!$OMP PARALLEL
!$OMP DO PRIVATE (JENS,JLEV,JLAT,JLON,DMEAN)
    do jens=1,nens
      do jlev=1,nkgdimEns
        dmean=0.0d0
        do jlat=1,nj
          do jlon=1,ni
            dmean=dmean+ensPerturbations(jlon,jlev,jlat,jens)
          enddo
        enddo
        dmean=dmean/(dble(ni)*dble(nj))
        do jlat=1,nj
          do jlon=1,ni
            ensPerturbations(jlon,jlev,jlat,jens)=ensPerturbations(jlon,jlev,jlat,jens)-dmean
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished removing global mean...'
    call flush(6)

  end subroutine removeGlobalMean

!--------------------------------------------------------------------------
! CALCZONAVG
!--------------------------------------------------------------------------
  subroutine calcZonAvg(fieldsZonAvg,fields3D,nlev)
    implicit none

    integer :: jlon,jlat,jlev,nlev
    real*8  :: fieldsZonAvg(:,:),fields3D(:,:,:),dfact

    fieldsZonAvg(:,:)=0.0d0
    dfact=1.0d0/dble(ni)
!$OMP PARALLEL
!$OMP DO PRIVATE (JLEV,JLAT,JLON)
      do jlat=1,nj
        do jlev=1,nlev
          do jlon=1,ni
            fieldsZonAvg(jlev,jlat)=fieldsZonAvg(jlev,jlat)+dfact*fields3D(jlon,jlev,jlat)
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished computing the zonal average...'
    call flush(6)

  end subroutine calcZonAvg

!--------------------------------------------------------------------------
! CALCSTDDEV3D
!--------------------------------------------------------------------------
  subroutine calcStddev3d(ensPerturbations,stddev3d,nlev)
    implicit none

    integer :: jlon,jlat,jlev,jens,nlev
    real*8  :: dnens,stddev3d(:,:,:)
    real*4  :: ensPerturbations(:,:,:,:)

    write(6,*) 'started computing the stddev...'
    write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    call flush(6)

    stddev3d(:,:,:)=0.0d0
    dnens=1.0d0/dble(nens-1)
!$OMP PARALLEL
!$OMP DO PRIVATE (JLEV,JENS,JLAT,JLON)
      do jlev=1,nlev
        do jens=1,nens
          do jlat=1,nj
            do jlon=1,ni
              stddev3d(jlon,jlev,jlat)=stddev3d(jlon,jlev,jlat)+ensPerturbations(jlon,jlev,jlat,jens)**2
            enddo
          enddo
        enddo
        do jlat=1,nj
          do jlon=1,ni
            if(stddev3d(jlon,jlev,jlat).gt.0.0d0) then
              stddev3d(jlon,jlev,jlat)=sqrt(stddev3d(jlon,jlev,jlat)*dnens)
            else
              stddev3d(jlon,jlev,jlat)=0.0d0
            endif
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished computing the stddev...'
    call flush(6)
  
  end subroutine calcStddev3d

!--------------------------------------------------------------------------
! CALCBALANCEDP
!--------------------------------------------------------------------------
  subroutine calcBalancedP(sppsi,spgz)
    implicit none

    real*8 :: sppsi(:,:,:),spgz(:,:,:)
    real*8 :: spvor(nla,2,nlevEns_M)
    integer  ia, ib, ji, jm, jlev,jlat
    real*8 :: zn,zm,zenm,zenmp1,zcon,dl1sa2
    ! constants
    real*8             :: rday
    real*8             :: rsiyea
    real*8             :: rsiday
    real*8             :: romega

    ! some constants
    RDAY=86400.D0
    RSIYEA=365.25D0*RDAY*2.*MPC_PI_R8/6.283076D0
    RSIDAY=RDAY/(1.D0+RDAY/RSIYEA)
    ROMEGA=2.D0*MPC_PI_R8/RSIDAY

    ! convert PSI to vorticity 
    dl1sa2   = 1.0d0/(dble(ra)*dble(ra))
    do jlev = 1, nlevEns_M
      do jlat = 1, nla
        spvor(jlat,1,jlev) = sppsi(jlat,1,jlev)*dl1sa2*gst_getRnnp1(jlat)
        spvor(jlat,2,jlev) = sppsi(jlat,2,jlev)*dl1sa2*gst_getRnnp1(jlat)
      enddo
    enddo

    ! ensure input field is zero for spectral component (0,0)
    do jlev = 1, nlevEns_M
      if(spvor(1,1,jlev).ne.0.D0) then
        spvor(1,1,jlev) = 0.0D0
      endif
      if(spvor(1,2,jlev).ne.0.D0) then
        spvor(1,2,jlev) = 0.0D0
      endif
    enddo

    ! initialize outout field to zero
    spgz(:,:,:)=0.0d0

    ! loop over levels and zonal wavenumbers
    ! n.b.: at the tip of the triangle, no contributions
    
    zcon = -2.D0*romega*ra**2
    do jlev = 1, nlevEns_M

      ! the base address ia will point to the spherical harmonic
      ! coefficient (m,m), in the input field
      ia = 1
      do jm = 0, ntrunc-1
        ib = ia + ntrunc - jm
        zm = dble(jm)

        ! at the base, contributions from n+1 coeff only
        zn = zm
        zenmp1 = sqrt ( ((zn+1)**2-zm**2)/(4.D0*(zn+1)**2-1.D0) )
        spgz(ia,1,jlev)=zcon*spvor(ia+1,1,jlev)*zenmp1/((zn+1.0D0)**2)
        spgz(ia,2,jlev)=zcon*spvor(ia+1,2,jlev)*zenmp1/((zn+1.0D0)**2)

        zn = zn+1
        do ji = ia+1, ib-1
          zenm = sqrt ( (zn**2-zm**2)/(4.D0*zn**2-1.D0) )
          zenmp1 = sqrt ( ((zn+1)**2-zm**2)/(4.D0*(zn+1)**2-1.D0) )
          spgz(ji,1,jlev)=spvor(ji-1,1,jlev)*zenm/(zn**2)
          spgz(ji,2,jlev)=spvor(ji-1,2,jlev)*zenm/(zn**2)
          spgz(ji,1,jlev)=zcon*(spgz(ji,1,jlev)+spvor(ji+1,1,jlev)*zenmp1/((zn+1.0D0)**2))
          spgz(ji,2,jlev)=zcon*(spgz(ji,2,jlev)+spvor(ji+1,2,jlev)*zenmp1/((zn+1.0D0)**2))
          zn = zn + 1.0D0
        enddo

        ! at the top, contributions from n-1 coeff only
        zenm = sqrt ( (zn**2-zm**2)/(4.D0*zn**2-1.D0) )
        spgz(ib,1,jlev) = zcon*spvor(ib-1,1,jlev)*zenm/(zn**2)
        spgz(ib,2,jlev) = zcon*spvor(ib-1,2,jlev)*zenm/(zn**2)
        ia = ib + 1
      enddo
    enddo

    ! ensure correct value for mass spectral-coefficient for m=n=0
    do jlev = 1, nlevens_M
      spgz(1,1,jlev) = 0.0D0
      spgz(1,2,jlev) = 0.0D0
    enddo

  end subroutine calcBalancedP

!--------------------------------------------------------------------------
! NORMALIZED3D
!--------------------------------------------------------------------------
  subroutine normalize3d(ensPerturbations,stddev3d)
    implicit none

    integer :: jlon,jlat,jlev,jens
    real*8  :: dfact,stddev3d(:,:,:)
    real*4  :: ensPerturbations(:,:,:,:)

!$OMP PARALLEL
!$OMP DO PRIVATE (JLEV,JENS,JLAT,JLON,DFACT)
      do jlat=1,nj
        do jlev=1,nkgdimEns
          do jlon=1,ni
            if(stddev3d(jlon,jlev,jlat).gt.0.0d0) then
              dfact=1.0d0/stddev3d(jlon,jlev,jlat)
            else
              dfact=0.0d0
            endif
            do jens=1,nens
              ensPerturbations(jlon,jlev,jlat,jens)=ensPerturbations(jlon,jlev,jlat,jens)*dfact
            enddo
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished normalizing by stddev3D...'
    call flush(6)
  
  end subroutine normalize3d

!--------------------------------------------------------------------------
! MULTIPLY3D
!--------------------------------------------------------------------------
  subroutine multiply3d(ensPerturbations,stddev3d,nlev)
    implicit none

    integer :: jlon,jlat,jlev,jens,nlev
    real*8  :: stddev3d(:,:,:)
    real*4  :: ensPerturbations(:,:,:,:)

!$OMP PARALLEL
!$OMP DO PRIVATE (JLEV,JENS,JLAT,JLON)
      do jlat=1,nj
        do jlev=1,nlev
          do jlon=1,ni
            do jens=1,nens
              ensPerturbations(jlon,jlev,jlat,jens)=ensPerturbations(jlon,jlev,jlat,jens)*stddev3d(jlon,jlev,jlat)
            enddo
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished multiplying by stddev3D...'
    call flush(6)
  
  end subroutine multiply3d

!--------------------------------------------------------------------------
! READENSEMBLE
!--------------------------------------------------------------------------
  subroutine readEnsemble1(ensPerturbations,windImages)
    implicit none

    logical, optional, intent(in) :: windImages

    integer :: stamp_in
    real*8 :: gd2d(ni,nj)
    real*4 :: ensPerturbations(:,:,:,:)
    real*8 :: rmsknt,rmbtpa,r1sa,conima
    real*8 :: rhumin = 2.5d-6
    integer :: jlon,jlat,jlev,jens
    integer :: nulens
    integer :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg

    logical :: convertToWindImages

    ! standard file variables
    integer ini,inj,ink,ip1,ip2,ip3,ierr,idateo,ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket
    integer :: vfstlir,fstfrm,fclos,fnom,fstouv


    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nLevEns_M
    ngposittt=1+2*nLevEns_M
    ngpositq =1+2*nLevEns_M+1*nLevEns_T
    ngpositps=1+2*nLevEns_M+2*nLevEns_T
    ngposittg=2+2*nLevEns_M+2*nLevEns_T

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    if ( present(windImages)) then
       convertToWindImages = windImages
    else
       convertToWindImages = .true. ! default value
    end if

    if ( convertToWindImages ) then
       write(6,*) 'WIND components will be converted to WIND IMAGES'
    end if

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)
    ip2 = 6
!    ip2 = -1
    ip3=-1
    idateo = -1
    cltypvar = ' '
    cletiket = ' '

    do jens=1,nens
        write(6,*) 'Reading ensemble member:',trim(cflensin(jens))
        write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
        call flush(6)

        nulens=0
        ierr = fnom(nulens,cflensin(jens),'RND+OLD+R/O',0)
        ierr = fstouv(nulens,'RND+OLD')
        write(6,*) 'reading member:',jens
        call flush(6)

          clnomvar = 'P0' 
          ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,-1,ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
            write(6,*) 'SUENS: Problem with P0 ENS'
            call flush(6)
            call qqexit(1)
          endif
          do jlat=1,nj
            do jlon=1,ni
              ensPerturbations(jlon,ngpositps,jlat,jens)= gd2d(jlon,jlat)*rmbtpa
            enddo
          enddo

          do jlev=1,nLevEns_T
            clnomvar = 'TT'
            ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(6,*) idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar
              write(6,*) 'SUENS: Problem with TT ENS'
              call flush(6)
              call qqexit(1)
            endif
            call flush(6)
            do jlat=1,nj
              do jlon=1,ni
                ensPerturbations(jlon,jlev-1+ngposittt,jlat,jens)= gd2d(jlon,jlat)
              enddo
            enddo
          enddo

          do jlev=1,nLevEns_T
            clnomvar = 'HU' 
            ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              clnomvar = 'LQ' 
              ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
              if(ikey.lt.0) then
                write(6,*) idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar
                write(6,*) 'SUENS: Problem with HU and LQ ENS'
                call flush(6)
                call qqexit(1)
              else
                do jlat=1,nj
                  do jlon=1,ni
                    ensPerturbations(jlon,jlev-1+ngpositq,jlat,jens)= gd2d(jlon,jlat)
                  enddo
                enddo
              endif
            else
              do jlat=1,nj
                do jlon=1,ni
                  ensPerturbations(jlon,jlev-1+ngpositq,jlat,jens)= log(max(gd2d(jlon,jlat),rhumin))
                enddo
              enddo
            endif
          enddo

          do jlev=1,nLevEns_M
            clnomvar = 'UU' 
            ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(6,*) idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar
              write(6,*) 'SUENS: Problem with UU ENS'
              call flush(6)
              call qqexit(1)
            endif
            do jlat=1,nj
              if ( convertToWindImages ) then
                 conima=r1sa*gst_getRSQM2(jlat,gstID)
              else
                 conima=1.d0
              end if
              do jlon=1,ni
                ensPerturbations(jlon,jlev-1+ngposituu,jlat,jens)= gd2d(jlon,jlat)*rmsknt*conima
              enddo
            enddo
          enddo

          do jlev=1,nLevEns_M
            clnomvar = 'VV' 
            ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar)
            if(ikey.lt.0) then
              write(6,*) idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar
              write(6,*) 'SUENS: Problem with VV ENS'
              call flush(6)
              call qqexit(1)
            endif
            do jlat=1,nj
              if ( convertToWindImages ) then
                 conima=r1sa*gst_getRSQM2(jlat,gstID)
              else
                 conima=1.d0
              end if
              do jlon=1,ni
                ensPerturbations(jlon,jlev-1+ngpositvv,jlat,jens)= gd2d(jlon,jlat)*rmsknt*conima
              enddo
            enddo
          enddo

!          clnomvar = 'TG' 
!          ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,-1,ip2,ip3,cltypvar,clnomvar)
!          if(ikey.lt.0)  then
!            write(6,*) idateo,cletiket,ip2,ip3,cltypvar,clnomvar
!            write(6,*) 'SUENS: Problem with TG ENS'
!            call flush(6)
!            call qqexit(1)
!          else
!            do jlat=1,nj
!              do jlon=1,ni
!                ensPerturbations(jlon,ngposittg,jlat,jens)= gd2d(jlon,jlat)
!              enddo
!            enddo
!          endif

        ierr =  fstfrm(nulens)
        ierr =  fclos (nulens)

        write(6,*) 'done reading member ',jens
        call flush(6)

    enddo

    write(6,*) 'finished reading ensemble members...'
    call flush(6)

  end subroutine readEnsemble1

!--------------------------------------------------------------------------
! READENSEMBLE
!--------------------------------------------------------------------------
  subroutine readEnsemble(ensPerturbations,windImages)
    implicit none

    logical, optional, intent(in) :: windImages

    real*4 :: ensPerturbations(:,:,:,:)

    integer :: jens, fclos, fnom, fstfrm, fstouv, ierr
    integer :: nulens(nens)

    nulens(:)=0
    do jens = 1, nens
       ierr = fnom(nulens(jens),cflensin(jens),'RND+OLD+R/O',0)
       ierr = fstouv(nulens(jens),'RND+OLD')
    end do

    write(6,*) 'Before reading the ensemble:'
    write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    call flush(6)

!$OMP PARALLEL
!$OMP DO PRIVATE (jens)
    do jens = 1, nens
        write(6,*) 'Reading ensemble member:',trim(cflensin(jens))
        call flush(6)
        call readEnsembleMember(ensPerturbations,nulens,jens,windImages)
        write(6,*) 'done reading member ',jens
        call flush(6)
    end do
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'After reading the ensemble:'
    write(6,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    call flush(6)

    do jens = 1, nens
       ierr =  fstfrm(nulens(jens))
       ierr =  fclos (nulens(jens))
    end do

    write(6,*) 'finished reading ensemble members...'
    call flush(6)

  end subroutine readEnsemble

!--------------------------------------------------------------------------
! READENSEMBLEMEMBER
!--------------------------------------------------------------------------
  subroutine readEnsembleMember(ensPerturbations,nulens,jens,windImages)
    implicit none

    real*4 :: ensPerturbations(:,:,:,:)
    integer, intent(in) :: jens
    integer, intent(in) :: nulens(nens)
    logical, optional, intent(in) :: windImages
    
    
    integer :: stamp_in
    real*4 :: gd2d(ni,nj)
    real*8 :: rmsknt,rmbtpa,r1sa,conima
    real*8 :: rhumin = 2.5d-6
    integer :: jlon,jlat,jlev
    integer :: fstlir
    integer :: ngposituu,ngpositvv,ngposittt,ngpositq,ngpositps,ngposittg

    logical :: convertToWindImages

    ! standard file variables
    integer ini,inj,ink,ip1,ip2,ip3,ierr,idateo,ikey
    character(len=2)   :: cltypvar
    character(len=1)   :: clgrtyp
    character(len=4)   :: clnomvar
    character(len=12)  :: cletiket

    ! this should come from state vector object
    ngposituu=1
    ngpositvv=1+1*nLevEns_M
    ngposittt=1+2*nLevEns_M
    ngpositq =1+2*nLevEns_M+1*nLevEns_T
    ngpositps=1+2*nLevEns_M+2*nLevEns_T
    ngposittg=2+2*nLevEns_M+2*nLevEns_T

    ! some physical constants
    rmsknt = 1.d0/1.94246d0
    rmbtpa = 1.0d2
    r1sa=1.d0/6371229.d0

    if ( present(windImages)) then
       convertToWindImages = windImages
    else
       convertToWindImages = .true. ! default value
    end if

    if ( convertToWindImages ) then
       write(6,*) 'WIND components will be converted to WIND IMAGES'
    end if

    ! read in raw ensemble (UU,VV,TT,P0,LQ (convert HU to LQ) - covariances)
    ip2 = 6
!    ip2 = -1
    ip3=-1
    idateo = -1
    cltypvar = ' '
    cletiket = ' '

    clnomvar = 'P0' 
    ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,-1,ip2,ip3, cltypvar,clnomvar)
    if(ikey.lt.0) then
       write(6,*) 'SUENS: Problem with P0 ENS'
       call flush(6)
       call qqexit(1)
    endif
    do jlat=1,nj
       do jlon=1,ni
          ensPerturbations(jlon,ngpositps,jlat,jens)= gd2d(jlon,jlat)*rmbtpa
       enddo
    enddo
    
    do jlev=1,nLevEns_T
       clnomvar = 'TT'
       ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
       if(ikey.lt.0) then
          write(6,*) idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar
          write(6,*) 'SUENS: Problem with TT ENS'
          call flush(6)
          call qqexit(1)
       endif
       call flush(6)
       do jlat=1,nj
          do jlon=1,ni
             ensPerturbations(jlon,jlev-1+ngposittt,jlat,jens)= gd2d(jlon,jlat)
          enddo
       enddo
    enddo
    
    do jlev=1,nLevEns_T
       clnomvar = 'HU' 
       ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
       if(ikey.lt.0) then
          clnomvar = 'LQ' 
          ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar)
          if(ikey.lt.0) then
             write(6,*) idateo,cletiket,nip1_T(jlev),ip2,ip3,cltypvar,clnomvar
             write(6,*) 'SUENS: Problem with HU and LQ ENS'
             call flush(6)
             call qqexit(1)
          else
             do jlat=1,nj
                do jlon=1,ni
                   ensPerturbations(jlon,jlev-1+ngpositq,jlat,jens)= gd2d(jlon,jlat)
                enddo
             enddo
          endif
       else
          do jlat=1,nj
             do jlon=1,ni
                ensPerturbations(jlon,jlev-1+ngpositq,jlat,jens)= log(max(gd2d(jlon,jlat),real(rhumin,4)))
             enddo
          enddo
       endif
    enddo
    
    do jlev=1,nLevEns_M
       clnomvar = 'UU' 
       ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar)
       if(ikey.lt.0) then
          write(6,*) idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar
          write(6,*) 'SUENS: Problem with UU ENS'
          call flush(6)
          call qqexit(1)
       endif
       do jlat=1,nj
          if ( convertToWindImages ) then
             conima=r1sa*gst_getRSQM2(jlat,gstID)
          else
             conima=1.d0
          end if
          do jlon=1,ni
             ensPerturbations(jlon,jlev-1+ngposituu,jlat,jens)= gd2d(jlon,jlat)*rmsknt*conima
          enddo
       enddo
    enddo
    
    do jlev=1,nLevEns_M
       clnomvar = 'VV' 
       ikey=fstlir(gd2d,nulens(jens),ini,inj,ink,idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar)
       if(ikey.lt.0) then
          write(6,*) idateo,cletiket,nip1_M(jlev),ip2,ip3,cltypvar,clnomvar
          write(6,*) 'SUENS: Problem with VV ENS'
          call flush(6)
          call qqexit(1)
       endif
       do jlat=1,nj
          if ( convertToWindImages ) then
             conima=r1sa*gst_getRSQM2(jlat,gstID)
          else
             conima=1.d0
          end if
          do jlon=1,ni
             ensPerturbations(jlon,jlev-1+ngpositvv,jlat,jens)= gd2d(jlon,jlat)*rmsknt*conima
          enddo
       enddo
    enddo

!          clnomvar = 'TG' 
!          ikey = vfstlir(gd2d,nulens,ini,inj,ink,idateo,cletiket,-1,ip2,ip3,cltypvar,clnomvar)
!          if(ikey.lt.0)  then
!            write(6,*) idateo,cletiket,ip2,ip3,cltypvar,clnomvar
!            write(6,*) 'SUENS: Problem with TG ENS'
!            call flush(6)
!            call qqexit(1)
!          else
!            do jlat=1,nj
!              do jlon=1,ni
!                ensPerturbations(jlon,ngposittg,jlat,jens)= gd2d(jlon,jlat)
!              enddo
!            enddo
!          endif

    
  end subroutine readEnsembleMember

!--------------------------------------------------------------------------
! UV_TO_PSICHI
!--------------------------------------------------------------------------
  subroutine uv_to_psichi(ensPerturbations)
    implicit none

    integer :: jens,jlev,jla
    real*8  :: dla2
    real*8  :: spectralState(nla,2,nkgdimEns)
    real*4  :: ensPerturbations(:,:,:,:)
    real*8  :: member(ni,nkgdimens,nj)
!
! Convert from U/V to PSI/CHI and spectrally filter all fields
!
    dla2   = dble(ra)*dble(ra)
    do jens=1,nens
      member(:,:,:)=dble(ensPerturbations(:,:,:,jens))
      call gst_gdsp(spectralState,member,nkgdimEns,nlevEns_M,nkgdimEns)
      do jlev = 1, nlevEns_M
        do jla = 1, nla
          spectralState(jla,1,jlev)           = spectralState(jla,1,jlev)           * dla2*gst_getR1snp1(jla)
          spectralState(jla,2,jlev)           = spectralState(jla,2,jlev)           * dla2*gst_getR1snp1(jla)
          spectralState(jla,1,jlev+nlevEns_M) = spectralState(jla,1,jlev+nlevEns_M) * dla2*gst_getR1snp1(jla)
          spectralState(jla,2,jlev+nlevEns_M) = spectralState(jla,2,jlev+nlevEns_M) * dla2*gst_getR1snp1(jla)
        enddo
      enddo
      call gst_speree(spectralState,member,nkgdimEns,nkgdimEns)
      ensPerturbations(:,:,:,jens)=sngl(member(:,:,:))
    enddo

    write(6,*) 'finished doing u/v -> psi/chi and spectral filter...'
    call flush(6)
    
  end subroutine uv_to_psichi

!--------------------------------------------------------------------------
! REMOVEMEAN
!--------------------------------------------------------------------------
  subroutine removeMean(ensPerturbations)
    implicit none

    integer :: jens,jlev,jlat,jlon
    real*8  :: dnens,gd2d(ni,nj)
    real*4  :: ensPerturbations(:,:,:,:)

    ! remove mean and divide by sqrt(2*(NENS-1)) - extra 2 is needed?
    dnens=1.0d0/dble(nens)
!$OMP PARALLEL
!$OMP DO PRIVATE (JLEV,GD2D,JENS,JLAT,JLON)
      do jlev=1,nkgdimEns
        gd2d(:,:)=0.0d0
        do jens=1,nens
          do jlat=1,nj
            do jlon=1,ni
              gd2d(jlon,jlat)=gd2d(jlon,jlat)+ensPerturbations(jlon,jlev,jlat,jens)
            enddo
          enddo
        enddo
        do jlat=1,nj
          do jlon=1,ni
            gd2d(jlon,jlat)=gd2d(jlon,jlat)*dnens
          enddo
        enddo
        do jens=1,nens
          do jlat=1,nj
            do jlon=1,ni
              ensPerturbations(jlon,jlev,jlat,jens)=     &
                ensPerturbations(jlon,jlev,jlat,jens)-gd2d(jlon,jlat)
            enddo
          enddo
        enddo
      enddo
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished removing the ensemble mean...'
    call flush(6)

  end subroutine removeMean


!--------------------------------------------------------------------------
! HORIZCORRELFUNCTION
!--------------------------------------------------------------------------
  subroutine horizCorrelFunction(rstddev,waveBandIndex)
    implicit none

    real*8,intent(in) :: rstddev(nkgdimEns,0:ntrunc)
    integer,optional, intent(in) :: waveBandIndex

    real*8  :: spectralState(nla,2,nkgdimEns)
    real*8  :: gridState(ni,nkgdimEns,nj)

    integer :: ji, jj, jk, jn, jm, ila, iref, jref
    integer :: nLevEns, nLevStart, nLevEnd, jvar, iStart, iEnd

    character(len=128) :: outfilename
    character(len=2) :: wbnum

    write(6,*)
    write(6,*) 'Computing horizontal correlation functions'

    !
    !- 1.  Spectral transform of a delta function (at the center of the domain)
    !

    !- 1.1 Create the delta function
    iref = ni/2
    jref = nj/2

    GridState(:,:,:)       = 0.d0
    GridState(iref,:,jref) = 1.d0

    !- 1.2 Adjoint of the identity (change of norm)
    GridState(iref,:,jref) = GridState(iref,:,jref) * real(ni,8) / gst_getRWT(jref)

    !- 1.3 Move to spectral space
    call gst_reespe(spectralState,                & ! OUT
                    GridState,nkgdimEns,nkgdimEns)  ! IN

    !
    !- 2.  Apply the horizontal correlation function
    !
!$OMP PARALLEL
!$OMP DO PRIVATE (jk,jn,jm,ila)
    do jk = 1, nkgdimEns
       do jn = 0, ntrunc
          do jm = 0, jn
             ila = gst_getNind(jm) + jn - jm
             if (jm.eq.0) then
                spectralState(ila,1,jk) = spectralState(ila,1,jk) * rstddev(jk,jn)**2 * 2.0d0
                spectralState(ila,2,jk) = 0.d0
             else
                spectralState(ila,1,jk) = spectralState(ila,1,jk) * rstddev(jk,jn)**2 * 2.0d0
                spectralState(ila,2,jk) = spectralState(ila,2,jk) * rstddev(jk,jn)**2 * 2.0d0
             endif
          end do
       end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    !
    !- 3.  Move back to grid point space
    !
    call gst_speree(spectralState,     & ! IN
                    GridState,         & ! OUT
                    nkgdimEns,nkgdimEns) ! IN

    !
    !- 4.  Write to file
    !
    if ( nWaveBand /= 1 ) then
       if (.not. present(waveBandIndex)) then
          write(6,*) 'horizCorrelFunction: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
    end if

    !- 4.1 2D correlation function in fst format
    if ( nWaveBand == 1 ) then
       outfilename = "./horizCorrel.fst"
    else
       outfilename = "./horizCorrel_"//wbnum//".fst"
    end if
    call write3d(GridState,outfilename,'HORIZCORFUNC')

    !- 4.2 1D correlation function in txt format (for plotting purposes)
    iStart=iref
    iEnd=3*ni/4 ! About 10 000 km away from the center of the domain

    do jvar = 1, nvar3d
       if ( nWaveBand == 1 ) then
          outfilename = "./horizCorrel_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./horizCorrel_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
       else
          nLevEns = nLevEns_T
       endif
       nLevStart = varLevOffset(jvar)+ 1 
       nLevEnd   = varLevOffset(jvar)+ nLevEns

       do ji=iStart,iEnd
          do jk = nLevStart,nLevEnd
             if ( jk == nLevStart  ) then
                write(99,'(I7,2X,F7.1,2X,F6.4,$)')  ji-iStart, (ji-iStart)*gridSpacingInKm, GridState(ji,jk,jref)
             else if ( jk == nLevEnd ) then 
                write(99,'(2X,F6.4)')  GridState(ji,jk,jref) ! Saut de ligne
             else
                write(99,'(2X,F6.4,$)')  GridState(ji,jk,jref)
             end if
          end do
       end do
       close(unit=99)
    end do

    do jvar = 1, nvar2d
       if ( nWaveBand == 1 ) then
          outfilename = "./horizCorrel_"//trim(nomvar2d(jvar,variableType))//".txt"
       else
          outfilename = "./horizCorrel_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")
       do ji=iStart,iEnd
          write(99,'(I7,2X,F7.1,2X,F6.4)')  ji-iStart, (ji-iStart)*gridSpacingInKm, GridState(ji,varLevOffset(nvar3d+1)+jvar,jref)
       end do
       close(unit=99)
    end do

  end subroutine horizCorrelFunction

!--------------------------------------------------------------------------
! WRITE3D
!--------------------------------------------------------------------------
  subroutine write3d(gridpoint3d,filename,etiket_in)
    implicit none

    real*8, intent(in) :: gridpoint3d(:,:,:)
    character(len=*), intent(in) :: filename,etiket_in
    
    real*8 :: dfact,zbuf(ni,nj)
    integer jlat,jlon,jlev,ierr,jvar,nLevEns
    integer vfstecr,fstouv,fnom,fstfrm,fclos
    integer ip1,ip2,ip3,idatyp,idateo,ipak,nip1_l(max(nLevEns_M,nLevens_T))
    integer :: nulstats
    character(len=12) :: etiket

    etiket=trim(etiket_in)

    nulstats=0
    ierr =  fnom  (nulstats,filename,'RND',0)
    ierr =  fstouv(nulstats,'RND')

    ipak = -32
    idatyp = 5
    ip1 = 0
    ip2 = 0
    ip3 = nens
    idateo = 0

    ! do 3d variables
    do jvar = 1, nvar3d

      if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
        nLevEns = nLevEns_M
        nip1_l(1:nLevEns_M)=nip1_M(1:nLevEns_M)
      else
        nLevEns = nLevEns_T
        nip1_l(1:nLevEns_T)=nip1_T(1:nLevEns_T)
      endif
      dfact=1.0d0

      do jlev=1,nlevEns
        do jlat=1,nj
          do jlon=1,ni
            zbuf(jlon,jlat)=dfact*gridpoint3d(jlon,varLevOffset(jvar)+jlev,jlat)
          enddo
        enddo
        ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,nip1_l(jlev),ip2,ip3,   &
                       'E',nomvar3d(jvar,variableType),etiket,'G',0,0,0,0,idatyp,.true.)
      enddo

    enddo

    ! now do 2D variables
    do jvar = 1, nvar2d
      !if(nomvar2d(jvar,variableType).eq.'P0') then
      !  dfact=1.0d0/1.0d2
      !else
        dfact=1.0d0
      !endif

      do jlat=1,nj
        do jlon=1,ni
          zbuf(jlon,jlat)=dfact*gridpoint3d(jlon,varLevOffset(nvar3d+1)+jvar,jlat)
        enddo
      enddo
      ierr = vfstecr(zbuf,zbuf,ipak,nulstats,idateo,0,0,ni,nj,1,0,ip2,ip3,   &
                     'E',nomvar2d(jvar,variableType),etiket,'G',0,0,0,0,idatyp,.true.)

    enddo

    ierr =  fstfrm(nulstats)
    ierr =  fclos (nulstats)

    write(6,*) 'finished writing 3d array...'
    call flush(6)

  end subroutine write3d

!--------------------------------------------------------------------------
! CALCHORIZSCALE
!--------------------------------------------------------------------------
  subroutine CalcHorizScale(rstddev,waveBandIndex)
    implicit none
    
    ! Based on subroutine corrlength.ftn in the "old" var code
    real(8),intent(in) :: rstddev(nkgdimEns,0:ntrunc)
    integer,optional, intent(in) :: waveBandIndex

    real(8) :: HorizScale(nkgdimEns)
    real(8), pointer :: PressureProfile(:)

    integer :: jk, jn, nLevEns, jvar
    real(8) :: rjn, fact, temp, a, b

    character(len=128) :: outfilename
    character(len=2) :: wbnum

    write(6,*)
    write(6,*) 'Computing horizontal correlation lengthscales'

    !
    !- 1.  Compute the horizontal correlation lengthscales
    !
    do jk = 1, nkgdimEns
       a = 0.d0
       b = 0.d0   
       do jn = 0, ntrunc
          rjn = dble(jn)
          fact = (2.0d0*rjn + 1.0d0)/2.0d0
          temp  = (rstddev(jk,jn)**2) * fact
          a = a + temp
          if (jn /= 0) then
             b = b - temp*rjn*(rjn+1.d0)
          end if
       end do
       if ( a > 0.d0 .and. b /= 0.d0 ) then
          HorizScale(jk) = ra * sqrt(-2.0d0*a/b)
       else
          HorizScale(jk) = 0.d0
       end if
    end do

    !
    !- 2. Write the results
    !
    if ( nWaveBand /= 1 ) then
       if (.not. present(waveBandIndex)) then
          write(6,*) 'CalcHorizScale: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
    end if

    do jvar = 1, nvar3d
       write(6,*)
       write(6,*) nomvar3d(jvar,variableType)

       if ( nWaveBand == 1 ) then
          outfilename = "./horizScale_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./horizScale_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
          PressureProfile => pressureProfile_M
       else
          nLevEns = nLevEns_T
          PressureProfile => pressureProfile_T
       endif
       do jk=1,nlevEns
          write(* ,'(I3,2X,F6.1,2X,F6.1)')  jk, PressureProfile(jk)/100.d0, HorizScale(varLevOffset(jvar)+jk)/1000.d0
          write(99,'(I3,2X,F6.1,2X,F6.1)')  jk, PressureProfile(jk)/100.d0, HorizScale(varLevOffset(jvar)+jk)/1000.d0
       end do

       close(unit=99)
    end do

    do jvar = 1, nvar2d
       write(6,*)
       write(6,*) nomvar2d(jvar,variableType)
       
       if ( nWaveBand == 1 ) then
          outfilename = "./horizScale_"//trim(nomvar2d(jvar,variableType))//".txt"
       else
          outfilename = "./horizScale_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       write(* ,'(I3,2X,F6.1,2X,F6.1)') 1, 1010.0, HorizScale(varLevOffset(nvar3d+1)+jvar)/1000.d0
       write(99,'(I3,2X,F6.1,2X,F6.1)') 1, 1010.0, HorizScale(varLevOffset(nvar3d+1)+jvar)/1000.d0

       close(unit=99)
    end do

  end subroutine CalcHorizScale

!--------------------------------------------------------------------------
! WRITEPOWERSPEC
!--------------------------------------------------------------------------
  subroutine writePowerSpec(powerSpec)
    implicit none

    real*8,intent(in) :: powerSpec(nkgdimEns,0:ntrunc)

    integer :: jk, nLevEns, nLevStart, nLevEnd, jvar, jn

    real(8) :: waveLength 

    character(len=128) :: outfilename

    !- Write to txt files
    do jvar = 1, nvar3d

       outfilename = "./PowerSpec_"//trim(nomvar3d(jvar,variableType))//".txt"
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
       else
          nLevEns = nLevEns_T
       endif
       nLevStart = varLevOffset(jvar)+ 1 
       nLevEnd   = varLevOffset(jvar)+ nLevEns

       do jn = 0, ntrunc
          if ( jn /= 0) then
             waveLength=4.d0*asin(1.d0)*ra/dble(jn)
          else
             waveLength=0.d0
          end if
          do jk = nLevStart,nLevEnd
             if ( jk == nLevStart  ) then
                write(99,'(I4,2X,F7.1,2X,e10.3,$)')  jn, waveLength/1000.d0, sngl(powerSpec(jk,jn))
             else if ( jk == nLevEnd ) then 
                write(99,'(2X,e10.3)')  sngl(powerSpec(jk,jn)) ! Saut de ligne
             else
                write(99,'(2X,e10.3,$)')  sngl(powerSpec(jk,jn))
             end if
          end do
       end do
       close(unit=99)
    end do

    do jvar = 1, nvar2d

       outfilename = "./PowerSpec_"//trim(nomvar2d(jvar,variableType))//".txt"
       open (unit=99,file=outfilename,action="write",status="new")
       do jn = 0, ntrunc
          if ( jn /= 0) then
             waveLength=4.d0*asin(1.d0)*ra/dble(jn)
          else
             waveLength=0.d0
          end if
          write(99,'(I4,2X,F7.1,2X,e10.3)')  jn, waveLength/1000.d0, sngl(powerSpec(varLevOffset(nvar3d+1)+jvar,jn))
       end do
       close(unit=99)
    end do

  end subroutine writePowerSpec

  !--------------------------------------------------------------------------
  ! CALCLOCALCORRELATIONS
  !--------------------------------------------------------------------------
  subroutine calcLocalCorrelations(ensPerturbations,waveBandIndex)
    implicit none

    real(4), intent(in) :: ensPerturbations(:,:,:,:)
    integer,optional, intent(in) :: waveBandIndex

    real(8), allocatable :: localHorizCorrel(:,:,:)

    real(8) :: dnens

    integer :: i, j, k, ens
    integer :: blocklength, blockpadding, nirefpoint, njrefpoint
    integer :: iref_id, jref_id, iref, jref
    integer :: imin, imax, jmin, jmax

    integer :: nulnam, ierr, fclos, fnom
    
    character(len=128) :: outfilename
    character(len=2)   :: wbnum

    NAMELIST /NAMHVCORREL_LOCAL/blocklength, blockpadding

    !
    ! To compute the local horizontal correlation for some 'reference' grid point
    ! ... we assume that the ensemble grid point mean was removed and that
    !     the ensemble values were divided by the grid point std dev.
    !

    blocklength = 100 ! Horizontal correlation will be compute blocklength x blocklength gridpoint
                      ! around each reference point
    blockpadding = 4  ! Number of grid point padding between blocks (to set correlation to 0 between each block)

    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=NAMHVCORREL_LOCAL)
    write(*,nml=NAMHVCORREL_LOCAL)
    ierr = fclos(nulnam)

    nirefpoint = ni/blocklength ! Number of reference grid point in x
    njrefpoint = nj/blocklength ! Number of reference grid point in y

    allocate(localHorizCorrel(ni,nkgdimEns,nj))

    localHorizCorrel(:,:,:)=0.0d0

    dnens = 1.0d0/dble(nens-1)

!$OMP PARALLEL
!$OMP DO PRIVATE (k,jref_id,iref_id,iref,jref,jmin,jmax,imin,imax,j,i,ens)
    do k = 1, nkgdimEns

       do ens = 1, nens
          do jref_id = 1, njrefpoint
             do iref_id = 1, nirefpoint
                iref = (2*iref_id-1)*blocklength/2
                jref = (2*jref_id-1)*blocklength/2
                jmin = max(jref-(blocklength-blockpadding)/2,1)
                jmax = min(jref+(blocklength-blockpadding)/2,nj)
                imin = max(iref-(blocklength-blockpadding)/2,1)
                imax = min(iref+(blocklength-blockpadding)/2,ni)
                do j = jmin, jmax
                   do i = imin, imax
                      localHorizCorrel(i,k,j)=localHorizCorrel(i,k,j) + &
                           ensPerturbations(i,k,j,ens) * ensPerturbations(iref,k,jref,ens)
                   end do
                end do
             end do
          end do
       end do

       do j = 1, nj
          do i = 1, ni
             localHorizCorrel(i,k,j) = localHorizCorrel(i,k,j)*dnens
          end do
       end do

    end do
!$OMP END DO
!$OMP END PARALLEL

    write(6,*) 'finished computing the local horizontal correlations...'
    call flush(6)

    !
    !- 4.  Write to file
    !
    if ( nWaveBand /= 1 ) then
       if (.not. present(waveBandIndex)) then
          write(6,*) 'calcLocalCorrelations: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
    end if

    !- 4.1 2D correlation function in fst format
    if ( nWaveBand == 1 ) then
       outfilename = "./horizCorrelLocal.fst"
    else
       outfilename = "./horizCorrelLocal_"//wbnum//".fst"
    end if
    call write3d(localHorizCorrel,outfilename,'HCORREL_LOC')

    localHorizCorrel(:,:,:) = localHorizCorrel(:,:,:)**2
    call write3d(localHorizCorrel,outfilename,'HCORREL2_LOC')

    deallocate(localHorizCorrel)

  end subroutine calcLocalCorrelations

  !--------------------------------------------------------------------------
  ! CALCHORIZLOCALIZATIONRADII
  !--------------------------------------------------------------------------
  subroutine calcLocalizationRadii(ensPerturbations,ensStdDev,waveBandIndex)
    implicit none

    real(4), intent(in) :: ensPerturbations(:,:,:,:)
    real(8), intent(in) :: ensStdDev(:,:,:)
    integer,optional, intent(in) :: waveBandIndex

    integer :: nulnam, ierr, fclos, fnom, strideForHLoc,strideForVloc
    
    logical :: hLoc, vLoc

    NAMELIST /NAMLOCALIZATIONRADII/strideForHLoc,strideForVloc,hLoc,vLoc

    !
    !- 1.  Setup
    !

    ! Parameters from namelist
    hLoc          = .true.
    vLoc          = .true.
    strideForHLoc = 100 ! Horizontal correlations will be computed every "stride" gridpoint in x and y
    strideForVLoc = 50  ! Vertical   correlations will be computed every "stride" gridpoint in x and y

    nulnam = 0
    ierr = fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=NAMLOCALIZATIONRADII)
    write(*,nml=NAMLOCALIZATIONRADII)
    ierr = fclos(nulnam)

    !
    !- 2. Estimate the horionzontal and vertical localization radii
    !
    if ( hLoc ) then
       call calcHorizLocalizationRadii(ensPerturbations, ensStdDev, strideForHLoc, waveBandIndex=waveBandIndex) ! IN
    end if
    if ( vLoc ) then
       call calcVertLocalizationRadii(ensPerturbations, ensStdDev, strideForVloc, waveBandIndex=waveBandIndex) ! IN
    end if

  end subroutine calcLocalizationRadii

  !--------------------------------------------------------------------------
  ! CALCHORIZLOCALIZATIONRADII
  !--------------------------------------------------------------------------
  subroutine calcHorizLocalizationRadii(ensPerturbations,ensStdDev,stride,waveBandIndex)
    use localizationFunction_mod
    implicit none

    real(4), intent(in) :: ensPerturbations(:,:,:,:)
    real(8), intent(in) :: ensStdDev(:,:,:)
    integer, intent(in) :: stride
    integer,optional, intent(in) :: waveBandIndex

    real*4, allocatable :: ensPert_local(:,:,:)

    real(8), allocatable :: meanCorrel(:,:)
    real(8), allocatable :: meanCorrelSquare(:,:)
    real(8), allocatable :: meanVarianceProduct(:,:)
    real(8), allocatable :: meanCovarianceSquare(:,:)
    real(8), allocatable :: meanFourthMoment(:,:)

    real(8), allocatable :: localizationFunctions(:,:,:) ! Eq. 19-21 in MMMB 2015 Part 2

    real(8), allocatable :: localizationRadii(:,:)

    real(8), allocatable :: distanceBinThresholds(:) ! Maximum distance for each distance-bin
    real(8), allocatable :: distanceBinMean(:)       ! Mean distance for each distance-bin
    real(8), allocatable :: distanceBinWeight(:)     ! Weight given to each bin in the curve fitting step

    real(8), allocatable :: gridPointWeight(:,:,:)   ! Weight given to grid point in the statistic computation

    real(8), allocatable :: sumWeight(:,:)    ! Sample size for each distance-bin
    
    real(8), pointer :: PressureProfile(:)

    real(8) :: dnens, correlation, covariance, fourthMoment, distance, maxDistance, weight
    real(8) :: t1, t2, t3, rmse

    integer :: i, j, k, f, ens, bin, numbins, numFunctions
    integer :: nirefpoint, njrefpoint
    integer :: iref_id, jref_id, iref, jref
    integer :: nLevEns, nLevStart, nLevEnd, jvar

    character(len=128) :: outfilename
    character(len=2)   :: wbnum

    !
    !- 1.  Setup
    !

    numFunctions = 3
    
    nirefpoint = ni/stride ! Number of reference grid point in x
    njrefpoint = nj/stride ! Number of reference grid point in y

    numBins=ni/4 !2

    allocate(localizationFunctions(numFunctions,numBins,nkgdimEns))

    allocate(meanCorrelSquare(numBins,nkgdimEns))
    allocate(meanCorrel(numBins,nkgdimEns))
    allocate(meanVarianceProduct(numBins,nkgdimEns))
    allocate(meanCovarianceSquare(numBins,nkgdimEns))
    allocate(meanFourthMoment(numBins,nkgdimEns))
    allocate(sumWeight(numBins,nkgdimEns))

    allocate(gridPointWeight(ni,nkgdimEns,nj))

    allocate(distanceBinThresholds(numBins))

    ! Assign the (upper) threshold to each separation-distance-bin
    write(6,*)
    write(6,*) 'Separation distance bin'
    do bin = 1, numbins
       distanceBinThresholds(bin) = calcDistance(hco_ens%lat(nj/2),hco_ens%lon(1),hco_ens%lat(nj/2),hco_ens%lon(bin))
       write(6,*) bin, hco_ens%lat(nj/2),hco_ens%lon(1),hco_ens%lat(nj/2),hco_ens%lon(bin), distanceBinThresholds(bin)/1000.d0
    end do

    maxDistance=distanceBinThresholds(numBins)

    dnens = 1.0d0/dble(nens-1)

    ! Grid point Weight
    write(6,*)
    write(6,*) 'Grid point Weight'
    do j = 1, nj
       gridPointWeight(:,:,j) = cos(hco_ens%lat(j))
       write(6,*) j, hco_ens%lat(j), cos(hco_ens%lat(j))
    end do

    !
    !- 2.  Estimation of localization functions
    !

    !- 2.1  Computation of various statistics for different separation distances
    meanCorrelSquare(:,:)     = 0.d0
    meanCorrel(:,:)           = 0.d0
    meanCovarianceSquare(:,:) = 0.d0
    meanVarianceProduct(:,:)  = 0.d0
    meanFourthMoment(:,:)     = 0.d0
    sumWeight(:,:) = 0.d0

    allocate(ensPert_local(nens,ni,nj))

!$OMP PARALLEL
!$OMP DO PRIVATE (k,iref,jref,j,i,ens,correlation,covariance,fourthMoment,distance,bin,weight,ensPert_local)
    do k = 1, nkgdimEns
       write(6,*) 'Computing distance-bin statistics for ensemble level: ', k
       call flush(6)

       !- Select data needed to speed up the process (ensemble member index must come first in ensPert_Local 
       !  because ensemble member is the last loop index below)
       do ens = 1, nens
          do j = 1, nj
             do i = 1, ni
                ensPert_local(ens,i,j) = ensPerturbations(i,k,j,ens)
             end do
          end do
       end do
       
       do jref = nint(stride/2.0), nj, stride     ! Pick every stride point to save cost.
          do iref = nint(stride/2.0), ni, stride  ! Pick every stride point to save cost.

             if (k == 1) then
                write(6,*) 'grid point info', iref, jref
                call flush(6)
             end if

             do j = 1, nj
                do i = 1, ni
                   distance=calcDistance(hco_ens%lat(jref),hco_ens%lon(iref),hco_ens%lat(j),hco_ens%lon(i))
                   if (distance <= maxDistance .and. gridPointWeight(i,k,j) > 0.d0) then
                      covariance = 0.d0
                      fourthMoment = 0.d0
                      do ens = 1, nens
                          covariance = covariance + &
                               ensPert_local(ens,i,j) * ensPert_local(ens,iref,jref)
                          fourthMoment = fourthMoment + &
                               (ensPert_local(ens,i,j) * ensPert_local(ens,iref,jref))**2
                      end do
                      covariance   = covariance * dnens
                      fourthMoment = fourthMoment / real(nens,8)
                      correlation  = covariance / (ensStdDev(i,k,j)*ensStdDev(iref,k,jref))

                      bin=findBinIndex(distance,distanceBinThresholds,numBins)
                      
                      weight = sqrt(gridPointWeight(iref,k,jref)) * sqrt(gridPointWeight(i,k,j))

                      sumWeight(bin,k) = sumWeight(bin,k) + weight

                      meanCorrel(bin,k)           = meanCorrel(bin,k)           + correlation    * weight
                      meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     + correlation**2 * weight
                      meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) + covariance**2  * weight
                      meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  + ensStdDev(i,k,j)**2 * ensStdDev(iref,k,jref)**2 * weight
                      meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     + fourthMoment   * weight
                  end if
                end do
             end do

             ! From now on, omit the current reference point
             gridPointWeight(iref,k,jref) = 0.d0

          end do ! iref
       end do    ! jref

    end do ! nkgdimEns
!$OMP END DO
!$OMP END PARALLEL

    deallocate(ensPert_local)
    

    !- 2.2  Computation of the localization functions
    t1=dble((nens-1)**2)/dble(nens*(nens-3))
    t2=dble(nens)/dble((nens-2)*(nens-3))
    t3=dble(nens-1)/dble(nens*(nens-2)*(nens-3))
!$OMP PARALLEL
!$OMP DO PRIVATE (k,bin)
    do k = 1, nkgdimEns
       do bin = 1, numbins

          meanCorrel(bin,k)           = meanCorrel(bin,k)           / sumWeight(bin,k)
          meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     / sumWeight(bin,k)
          meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) / sumWeight(bin,k)
          meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  / sumWeight(bin,k)
          meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     / sumWeight(bin,k)

          if ( meanCovarianceSquare(bin,k) /= 0.d0 ) then
             ! Form 1: General formulation (Eq. 19 in MMMB 2015 Part 2)
             localizationFunctions(1,bin,k) = t1 - t2*meanFourthMoment(bin,k)/meanCovarianceSquare(bin,k) + &
                  t3*meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k)
             ! Form 2: Gaussian sample distribution (Eq. 20 in MMMB 2015 Part 2)
             localizationFunctions(2,bin,k) = dble(nens-1)/dble((nens+1)*(nens-2)) * &
                  (dble(nens-1)-meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k))
          else
             write(6,*) ' !!! Warning !!! meanCovarianceSquare = 0 in bin, level = ', bin, k
             localizationFunctions(1,bin,k) = 0.d0
             localizationFunctions(2,bin,k) = 0.d0
          end if
          ! Form 3: Gaussian sample distribution and correlation-based formulation (Eq. 21 in MMMB 2015 Part 2)
          if ( meanCorrelSquare(bin,k) /= 0.d0 ) then
             localizationFunctions(3,bin,k) = dble(nens-1)/dble((nens+1)*(nens-2)) * &
                  (dble(nens-1)-1.d0/meanCorrelSquare(bin,k))
          else
             write(6,*) ' !!! Warning !!! meanCorrelSquare = 0 in bin, level = ', bin, k
             localizationFunctions(3,bin,k) = 0.d0
          end if
       end do
    end do
!$OMP END DO
!$OMP END PARALLEL

    !
    !- 3.  Estimation of localization radii (curve fitting)
    !
    allocate(localizationRadii(numFunctions,nkgdimEns))
    allocate(distanceBinMean(numBins))
    allocate(distanceBinWeight(numBins))

    call loc_setup('FifthOrder') ! IN

    localizationRadii(:,:) = 2000.d0*1000.d0 ! First Guess (meter)
    distanceBinWeight(:)   = 1.d0            ! Even weight
    do bin = 1, numBins
       if (bin == 1) then
          distanceBinMean(bin) = distanceBinThresholds(bin) ! = 0 m
       else
          distanceBinMean(bin) = 0.5d0*(distanceBinThresholds(bin)+distanceBinThresholds(bin-1))
       end if
    end do

    do f = 1, numFunctions
       write(6,*)
       write(6,*) 'Localization Function : ', f
!$OMP PARALLEL
!$OMP DO PRIVATE (k,rmse)
       do k =  1, nkgdimEns
          write(6,*) '         ----- EnsLev : ', k
          call loc_lengthscale( localizationRadii(f,k),       & ! INOUT
                                rmse,                         & ! OUT
                                localizationFunctions(f,:,k), & ! IN
                                distanceBinMean,              & ! IN
                                distanceBinWeight,            & ! IN
                                numbins )                       ! IN
          !write(6,*) 'localizationRadii = ', localizationRadii(f,k), rmse
       end do
!$OMP END DO
!$OMP END PARALLEL
    end do

    !
    !- 4.  Write to file
    !
    if ( nWaveBand /= 1 ) then
       if (.not. present(waveBandIndex)) then
          write(6,*) 'calcLocalizationRadii: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
    end if

    !- 4.1 Localization functions in txt format (for plotting purposes)
    do jvar = 1, nvar3d
       if ( nWaveBand == 1 ) then
          outfilename = "./horizLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./horizLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
       else
          nLevEns = nLevEns_T
       endif
       do k=1,nlevEns
          do bin = 1, numbins
             write(99,'(I3,2X,I3,2X,F7.1,2X,I7,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,E10.3,2X,E10.3,2X,E10.3)') k, bin, &
                  distanceBinThresholds(bin)/1000.d0, nint(sumWeight(bin,varLevOffset(jvar)+k)), &
                  meanCorrel(bin,varLevOffset(jvar)+k), &
                  localizationFunctions(3,bin,varLevOffset(jvar)+k), &
                  localizationFunctions(2,bin,varLevOffset(jvar)+k), &
                  localizationFunctions(1,bin,varLevOffset(jvar)+k), &
                  meanCorrelSquare(bin,varLevOffset(jvar)+k), &
                  meanCovarianceSquare(bin,varLevOffset(jvar)+k), &
                  meanVarianceProduct(bin,varLevOffset(jvar)+k), &
                  meanFourthMoment(bin,varLevOffset(jvar)+k)
          end do
       end do
       close(unit=99)
    end do

    do jvar = 1, nvar2d
       k = varLevOffset(nvar3d+1)+jvar
       if ( nWaveBand == 1 ) then
          outfilename = "./horizLocalizationFunctions_"//trim(nomvar2d(jvar,variableType))//".txt"
       else
          outfilename = "./horizLocalizationFunctions_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")
       do bin = 1, numbins
          write(99,'(I3,2X,I3,2X,F7.1,2X,I7,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,E10.3,2X,E10.3,2X,E10.3)') 1, bin, &
               distanceBinThresholds(bin)/1000.d0, nint(sumWeight(bin,k)), &
               meanCorrel(bin,k), &
               localizationFunctions(3, bin,k), &
               localizationFunctions(2, bin,k), &
               localizationFunctions(1, bin,k), &
               meanCorrelSquare(bin,k), &
               meanCovarianceSquare(bin,k), &
               meanVarianceProduct(bin,k), &
               meanFourthMoment(bin,k)
       end do
       close(unit=99)
    end do

    !- 4.2 Localization radii in txt format (for plotting purposes)
    do jvar = 1, nvar3d
       if ( nWaveBand == 1 ) then
          outfilename = "./horizLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./horizLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
          PressureProfile => pressureProfile_M
       else
          nLevEns = nLevEns_T
          PressureProfile => pressureProfile_T
       endif
       do k=1,nlevEns
          write(99,'(I3,2X,F6.1,2X,F7.1,2X,F7.1,2X,F7.1)') k, PressureProfile(k)/100.d0, &
               localizationRadii(3,varLevOffset(jvar)+k)/1000.d0, &
               localizationRadii(2,varLevOffset(jvar)+k)/1000.d0, &
               localizationRadii(1,varLevOffset(jvar)+k)/1000.d0
       end do
       close(unit=99)
    end do

    do jvar = 1, nvar2d
       k = varLevOffset(nvar3d+1)+jvar
       if ( nWaveBand == 1 ) then
          outfilename = "./horizLocalizationRadii_"//trim(nomvar2d(jvar,variableType))//".txt"
       else
          outfilename = "./horizLocalizationRadii_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")
       write(99,'(I3,2X,F6.1,2X,F7.1,2X,F7.1,2X,F7.1)') 1, 1010.0, &
               localizationRadii(3,k)/1000.d0, localizationRadii(2,k)/1000.d0, localizationRadii(1,k)/1000.d0
       close(unit=99)
    end do

    deallocate(meanCorrelSquare)
    deallocate(meanCorrel)
    deallocate(meanCovarianceSquare)
    deallocate(meanVarianceProduct)
    deallocate(meanFourthMoment)
    deallocate(distanceBinThresholds)
    deallocate(sumWeight)
    deallocate(localizationFunctions)
    deallocate(localizationRadii)
    deallocate(distanceBinMean)
    deallocate(distanceBinWeight)
    deallocate(gridPointWeight)

    write(6,*) 'finished estimating the horizontal localization radii...'
    call flush(6)

  end subroutine calcHorizLocalizationRadii

!!$  !--------------------------------------------------------------------------
!!$  ! CALCLOCALIZATIONRADII2
!!$  !--------------------------------------------------------------------------
!!$  subroutine calcHorizLocalizationRadii2(ensPerturbations,ensStdDev,stride,waveBandIndex)
!!$    use localizationFunction_mod
!!$    implicit none
!!$
!!$    real(4), intent(in) :: ensPerturbations(:,:,:,:)
!!$    real(8), intent(in) :: ensStdDev(:,:,:)
!!$    integer, intent(in) :: stride
!!$    integer,optional, intent(in) :: waveBandIndex
!!$
!!$    real*4, allocatable :: ensPert_local(:,:,:)
!!$
!!$    real(8), allocatable :: meanCorrel(:,:)
!!$    real(8), allocatable :: meanCorrelSquare(:,:)
!!$    real(8), allocatable :: meanVarianceProduct(:,:)
!!$    real(8), allocatable :: meanCovarianceSquare(:,:)
!!$    real(8), allocatable :: meanFourthMoment(:,:)
!!$
!!$    real(8), allocatable :: localizationFunctions(:,:,:) ! Eq. 19-21 in MMMB 2015 Part 2
!!$
!!$    real(8), allocatable :: localizationRadii(:,:)
!!$
!!$    real(8), allocatable :: distanceBinThresholds(:) ! Maximum distance for each distance-bin
!!$    real(8), allocatable :: distanceBinMean(:)       ! Mean distance for each distance-bin
!!$    real(8), allocatable :: distanceBinWeight(:)     ! Weight given to each bin in the curve fitting step
!!$
!!$    real(8), allocatable :: gridPointWeight(:,:,:)   ! Weight given to grid point in the statistic computation
!!$
!!$    real(8), allocatable :: sumWeight(:,:)    ! Sample size for each distance-bin
!!$    
!!$    real(8), pointer :: PressureProfile(:)
!!$
!!$    real(8), allocatable :: covariance(:,:), fourthMoment(:,:)
!!$
!!$    integer, allocatable :: binVector(:,:)
!!$
!!$    real(8) :: dnens, correlation, distance, maxDistance, weight
!!$    real(8) :: t1, t2, t3, rmse
!!$
!!$    integer :: i, j, k, f, ens, bin, numbins, numFunctions
!!$    integer :: nirefpoint, njrefpoint
!!$    integer :: iref_id, jref_id, iref, jref
!!$    integer :: nLevEns, nLevStart, nLevEnd, jvar
!!$
!!$    character(len=128) :: outfilename
!!$    character(len=2)   :: wbnum
!!$
!!$    !
!!$    !- 1.  Setup
!!$    !
!!$    numFunctions = 3
!!$    
!!$    nirefpoint = ni/stride ! Number of reference grid point in x
!!$    njrefpoint = nj/stride ! Number of reference grid point in y
!!$
!!$    numBins=ni/4 !2
!!$
!!$    allocate(localizationFunctions(numFunctions,numBins,nkgdimEns))
!!$
!!$    allocate(meanCorrelSquare(numBins,nkgdimEns))
!!$    allocate(meanCorrel(numBins,nkgdimEns))
!!$    allocate(meanVarianceProduct(numBins,nkgdimEns))
!!$    allocate(meanCovarianceSquare(numBins,nkgdimEns))
!!$    allocate(meanFourthMoment(numBins,nkgdimEns))
!!$    allocate(sumWeight(numBins,nkgdimEns))
!!$
!!$    allocate(gridPointWeight(ni,nkgdimEns,nj))
!!$
!!$    allocate(distanceBinThresholds(numBins))
!!$
!!$    
!!$    ! Assign the (upper) threshold to each separation-distance-bin
!!$    write(6,*)
!!$    write(6,*) 'Separation distance bin'
!!$    do bin = 1, numbins
!!$       distanceBinThresholds(bin) = calcDistance(hco_ens%lat(nj/2),hco_ens%lon(1),hco_ens%lat(nj/2),hco_ens%lon(bin))
!!$       write(6,*) bin, hco_ens%lat(nj/2),hco_ens%lon(1),hco_ens%lat(nj/2),hco_ens%lon(bin), distanceBinThresholds(bin)/1000.d0
!!$    end do
!!$
!!$    maxDistance=distanceBinThresholds(numBins)
!!$
!!$    dnens = 1.0d0/dble(nens-1)
!!$
!!$    ! Grid point Weight
!!$    write(6,*)
!!$    write(6,*) 'Grid point Weight'
!!$    do j = 1, nj
!!$       gridPointWeight(:,:,j) = cos(hco_ens%lat(j))
!!$       write(6,*) j, hco_ens%lat(j), cos(hco_ens%lat(j))
!!$    end do
!!$
!!$    !
!!$    !- 2.  Estimation of localization functions
!!$    !
!!$
!!$    !- 2.1  Computation of various statistics for different separation distances
!!$    allocate(covariance(ni,nj))
!!$    allocate(fourthMoment(ni,nj))
!!$    allocate(binVector(ni,nj))
!!$
!!$    meanCorrelSquare(:,:)     = 0.d0
!!$    meanCorrel(:,:)           = 0.d0
!!$    meanCovarianceSquare(:,:) = 0.d0
!!$    meanVarianceProduct(:,:)  = 0.d0
!!$    meanFourthMoment(:,:)     = 0.d0
!!$    sumWeight(:,:) = 0.d0
!!$
!!$!$OMP PARALLEL
!!$!$OMP DO PRIVATE (k,iref,jref,j,i,ens,correlation,covariance,fourthMoment,distance,bin,weight,binVector)
!!$    do k = 1, nkgdimEns
!!$       write(6,*) 'Computing distance-bin statistics for ensemble level: ', k
!!$       call flush(6)
!!$
!!$       do jref = nint(stride/2.0), nj, stride     ! Pick every stride point to save cost.
!!$          do iref = nint(stride/2.0), ni, stride  ! Pick every stride point to save cost.
!!$
!!$             if (k == 1) then
!!$                write(6,*) 'grid point info', iref, jref
!!$                call flush(6)
!!$             end if
!!$
!!$             covariance(:,:) = 0.d0
!!$             fourthMoment(:,:) = 0.d0
!!$             binVector(:,:) = -1
!!$             do ens = 1, nens
!!$                do j = 1, nj
!!$                   do i = 1, ni
!!$                      if (ens == 1) then
!!$                         distance=calcDistance(hco_ens%lat(jref),hco_ens%lon(iref),hco_ens%lat(j),hco_ens%lon(i))
!!$                         if (distance <= maxDistance .and. gridPointWeight(i,k,j) > 0.d0) then
!!$                            binVector(i,j)=findBinIndex(distance,distanceBinThresholds,numBins)                            
!!$                         end if
!!$                      end if
!!$
!!$                      if ( binVector(i,j) > 0 ) then
!!$                         covariance(i,j) = covariance(i,j) + &
!!$                               ensPerturbations(i,k,j,ens) * ensPerturbations(iref,k,jref,ens)
!!$                         fourthMoment(i,j) = fourthMoment(i,j) + &
!!$                               (ensPerturbations(i,k,j,ens) * ensPerturbations(iref,k,jref,ens))**2
!!$                     end if
!!$                   end do
!!$                end do
!!$             end do
!!$
!!$             do j = 1, nj
!!$                do i = 1, ni
!!$                   if ( binVector(i,j) > 0 ) then
!!$                      covariance(i,j) = covariance(i,j) * dnens
!!$                      fourthMoment(i,j) = fourthMoment(i,j) / real(nens,8)
!!$                      correlation  = covariance(i,j) / (ensStdDev(i,k,j)*ensStdDev(iref,k,jref))
!!$
!!$                      bin=binVector(i,j)
!!$                      
!!$                      weight = sqrt(gridPointWeight(iref,k,jref)) * sqrt(gridPointWeight(i,k,j))
!!$                
!!$                      sumWeight(bin,k) = sumWeight(bin,k) + weight
!!$
!!$                      meanCorrel(bin,k)           = meanCorrel(bin,k)           + correlation    * weight
!!$                      meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     + correlation**2 * weight
!!$                      meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) + covariance(i,j)**2  * weight
!!$                      meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  + ensStdDev(i,k,j)**2 * ensStdDev(iref,k,jref)**2 * weight
!!$                      meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     + fourthMoment(i,j) * weight
!!$                   end if
!!$                end do
!!$             end do
!!$
!!$             ! From now on, omit the current reference point
!!$             gridPointWeight(iref,k,jref) = 0.d0
!!$
!!$          end do ! iref
!!$       end do    ! jref
!!$
!!$    end do ! nkgdimEns
!!$!$OMP END DO
!!$!$OMP END PARALLEL
!!$
!!$    deallocate(covariance)
!!$    deallocate(fourthMoment)
!!$    deallocate(binVector)
!!$
!!$    !- 2.2  Computation of the localization functions
!!$    t1=dble((nens-1)**2)/dble(nens*(nens-3))
!!$    t2=dble(nens)/dble((nens-2)*(nens-3))
!!$    t3=dble(nens-1)/dble(nens*(nens-2)*(nens-3))
!!$!$OMP PARALLEL
!!$!$OMP DO PRIVATE (k,bin)
!!$    do k = 1, nkgdimEns
!!$       do bin = 1, numbins
!!$
!!$          meanCorrel(bin,k)           = meanCorrel(bin,k)           / sumWeight(bin,k)
!!$          meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     / sumWeight(bin,k)
!!$          meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) / sumWeight(bin,k)
!!$          meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  / sumWeight(bin,k)
!!$          meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     / sumWeight(bin,k)
!!$
!!$          if ( meanCovarianceSquare(bin,k) /= 0.d0 ) then
!!$             ! Form 1: General formulation (Eq. 19 in MMMB 2015 Part 2)
!!$             localizationFunctions(1,bin,k) = t1 - t2*meanFourthMoment(bin,k)/meanCovarianceSquare(bin,k) + &
!!$                  t3*meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k)
!!$             ! Form 2: Gaussian sample distribution (Eq. 20 in MMMB 2015 Part 2)
!!$             localizationFunctions(2,bin,k) = real(nens-1,8)/real((nens+1)*(nens-2),8) * &
!!$                  (real(nens-1,8)-meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k))
!!$          else
!!$             write(6,*) ' !!! Warning !!! meanCovarianceSquare = 0 in bin, level = ', bin, k
!!$             localizationFunctions(1,bin,k) = 0.d0
!!$             localizationFunctions(2,bin,k) = 0.d0
!!$          end if
!!$          ! Form 3: Gaussian sample distribution and correlation-based formulation (Eq. 21 in MMMB 2015 Part 2)
!!$          if ( meanCorrelSquare(bin,k) /= 0.d0 ) then
!!$             localizationFunctions(3,bin,k) = real(nens-1,8)/real((nens+1)*(nens-2),8) * &
!!$                  (real(nens-1,8)-1.d0/meanCorrelSquare(bin,k))
!!$          else
!!$             write(6,*) ' !!! Warning !!! meanCorrelSquare = 0 in bin, level = ', bin, k
!!$             localizationFunctions(3,bin,k) = 0.d0
!!$          end if
!!$       end do
!!$    end do
!!$!$OMP END DO
!!$!$OMP END PARALLEL
!!$
!!$    !
!!$    !- 3.  Estimation of localization radii (curve fitting)
!!$    !
!!$    allocate(localizationRadii(numFunctions,nkgdimEns))
!!$    allocate(distanceBinMean(numBins))
!!$    allocate(distanceBinWeight(numBins))
!!$
!!$    call loc_setup('FifthOrder') ! IN
!!$
!!$    localizationRadii(:,:) = 2000.d0*1000.d0 ! First Guess (meter)
!!$    distanceBinWeight(:)   = 1.d0            ! Even weight
!!$    do bin = 1, numBins
!!$       if (bin == 1) then
!!$          distanceBinMean(bin) = distanceBinThresholds(bin) ! = 0 m
!!$       else
!!$          distanceBinMean(bin) = 0.5d0*(distanceBinThresholds(bin)+distanceBinThresholds(bin-1))
!!$       end if
!!$    end do
!!$
!!$    do f = 1, numFunctions
!!$       write(6,*)
!!$       write(6,*) 'Localization Function : ', f
!!$!$OMP PARALLEL
!!$!$OMP DO PRIVATE (k,rmse)
!!$       do k =  1, nkgdimEns
!!$          write(6,*) '         ----- EnsLev : ', k
!!$          call loc_lengthscale( localizationRadii(f,k),       & ! INOUT
!!$                                rmse,                         & ! OUT
!!$                                localizationFunctions(f,:,k), & ! IN
!!$                                distanceBinMean,              & ! IN
!!$                                distanceBinWeight,            & ! IN
!!$                                numbins )                       ! IN
!!$          !write(6,*) 'localizationRadii = ', localizationRadii(f,k), rmse
!!$       end do
!!$!$OMP END DO
!!$!$OMP END PARALLEL
!!$    end do
!!$
!!$    !
!!$    !- 4.  Write to file
!!$    !
!!$    if ( nWaveBand /= 1 ) then
!!$       if (.not. present(waveBandIndex)) then
!!$          write(6,*) 'calcLocalizationRadii: No waveBandIndex was supplied!!!'
!!$          call abort3d('calbmatrix_glb')
!!$       end if
!!$       write(wbnum,'(I2.2)') waveBandIndex
!!$    end if
!!$
!!$    !- 4.1 Localization functions in txt format (for plotting purposes)
!!$    do jvar = 1, nvar3d
!!$       if ( nWaveBand == 1 ) then
!!$          outfilename = "./horizLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//".txt"
!!$       else
!!$          outfilename = "./horizLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
!!$       end if
!!$       open (unit=99,file=outfilename,action="write",status="new")
!!$
!!$       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
!!$          nLevEns = nLevEns_M
!!$       else
!!$          nLevEns = nLevEns_T
!!$       endif
!!$       do k=1,nlevEns
!!$          do bin = 1, numbins
!!$             write(99,'(I3,2X,I3,2X,F7.1,2X,I7,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4)') k, bin, &
!!$                  distanceBinThresholds(bin)/1000.d0, nint(sumWeight(bin,varLevOffset(jvar)+k)), &
!!$                  meanCorrel(bin,varLevOffset(jvar)+k), &
!!$                  localizationFunctions(3,bin,varLevOffset(jvar)+k), &
!!$                  localizationFunctions(2,bin,varLevOffset(jvar)+k), &
!!$                  localizationFunctions(1,bin,varLevOffset(jvar)+k)
!!$          end do
!!$       end do
!!$       close(unit=99)
!!$    end do
!!$
!!$    do jvar = 1, nvar2d
!!$       k = varLevOffset(nvar3d+1)+jvar
!!$       if ( nWaveBand == 1 ) then
!!$          outfilename = "./horizLocalizationFunctions_"//trim(nomvar2d(jvar,variableType))//".txt"
!!$       else
!!$          outfilename = "./horizLocalizationFunctions_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
!!$       end if
!!$       open (unit=99,file=outfilename,action="write",status="new")
!!$       do bin = 1, numbins
!!$          write(99,'(I3,2X,I3,2X,F7.1,2X,I7,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4)') 1, bin, &
!!$               distanceBinThresholds(bin)/1000.d0, nint(sumWeight(bin,k)), &
!!$               meanCorrel(bin,k), &
!!$               localizationFunctions(3, bin,k), &
!!$               localizationFunctions(2, bin,k), &
!!$               localizationFunctions(1, bin,k)
!!$       end do
!!$       close(unit=99)
!!$    end do
!!$
!!$    !- 4.2 Localization radii in txt format (for plotting purposes)
!!$    do jvar = 1, nvar3d
!!$       if ( nWaveBand == 1 ) then
!!$          outfilename = "./horizLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//".txt"
!!$       else
!!$          outfilename = "./horizLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
!!$       end if
!!$       open (unit=99,file=outfilename,action="write",status="new")
!!$
!!$       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
!!$          nLevEns = nLevEns_M
!!$          PressureProfile => pressureProfile_M
!!$       else
!!$          nLevEns = nLevEns_T
!!$          PressureProfile => pressureProfile_T
!!$       endif
!!$       do k=1,nlevEns
!!$          write(99,'(I3,2X,F6.1,2X,F7.1,2X,F7.1,2X,F7.1)') k, PressureProfile(k)/100.d0, &
!!$               localizationRadii(3,varLevOffset(jvar)+k)/1000.d0, &
!!$               localizationRadii(2,varLevOffset(jvar)+k)/1000.d0, &
!!$               localizationRadii(1,varLevOffset(jvar)+k)/1000.d0
!!$       end do
!!$       close(unit=99)
!!$    end do
!!$
!!$    do jvar = 1, nvar2d
!!$       k = varLevOffset(nvar3d+1)+jvar
!!$       if ( nWaveBand == 1 ) then
!!$          outfilename = "./horizLocalizationRadii_"//trim(nomvar2d(jvar,variableType))//".txt"
!!$       else
!!$          outfilename = "./horizLocalizationRadii_"//trim(nomvar2d(jvar,variableType))//"_"//wbnum//".txt"
!!$       end if
!!$       open (unit=99,file=outfilename,action="write",status="new")
!!$       write(99,'(I3,2X,F6.1,2X,F7.1,2X,F7.1,2X,F7.1)') 1, 1010.0, &
!!$               localizationRadii(3,k)/1000.d0, localizationRadii(2,k)/1000.d0, localizationRadii(1,k)/1000.d0
!!$       close(unit=99)
!!$    end do
!!$
!!$    deallocate(meanCorrelSquare)
!!$    deallocate(meanCorrel)
!!$    deallocate(meanCovarianceSquare)
!!$    deallocate(meanVarianceProduct)
!!$    deallocate(meanFourthMoment)
!!$    deallocate(distanceBinThresholds)
!!$    deallocate(sumWeight)
!!$    deallocate(localizationFunctions)
!!$    deallocate(localizationRadii)
!!$    deallocate(distanceBinMean)
!!$    deallocate(distanceBinWeight)
!!$    deallocate(gridPointWeight)
!!$
!!$    write(6,*) 'finished estimating the horizontal localization radii...'
!!$    call flush(6)
!!$
!!$  end subroutine calcHorizLocalizationRadii2

  !--------------------------------------------------------------------------
  ! FINDBININDEX
  !--------------------------------------------------------------------------
  function findBinIndex(distance,distanceBinThresholds,numBins) result(binIndex)
      implicit none

      integer :: numBins, binIndex
      real(8) :: distance
      real(8) :: distanceBinThresholds(numBins)

      integer :: bin

      binIndex = -1
      do bin = 1, numbins
         if ( distance <= distanceBinThresholds(bin) ) then
            binIndex = bin
            exit
         end if
      end do

      if (binIndex == -1) then
         write(6,*) 'findBinIndex: No match found! ABORTING'
         call abort3d('findBinIndex')
      end if

    end function findBinIndex

  !--------------------------------------------------------------------------
  ! DISTANCE
  !--------------------------------------------------------------------------
  function calcDistance(lat2, lon2, lat1, lon1) result(distanceInM)
      implicit none

      ! Compute the distance between two point on earth: (lat1,lon1) and (lat2,lon2)
      !     Calcul utilisant la Formule d'Haversine
      !     Reference: R.W. Sinnott,'Virtues of Haversine',Sky and Telescope,
      !     vol.68, no.2, 1984, p.159)

      real(8) :: lat1, lon1, lat2, lon2
      real(8) :: dlat, dlon, a, c

      real(8) :: distanceInM

      dlon = lon2 - lon1
      dlat = lat2 - lat1

      a = (sin(dlat/2.d0))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2.d0))**2
      c = 2.d0 * atan2(sqrt(a),sqrt(1.d0-a))
      distanceInM = RA * c

    end function calcDistance

 !--------------------------------------------------------------------------
  ! CALCVERTLOCALIZATIONRADII
  !--------------------------------------------------------------------------
  subroutine calcVertLocalizationRadii(ensPerturbations,ensStdDev,stride,waveBandIndex)
    use localizationFunction_mod
    implicit none

    real(4), intent(in) :: ensPerturbations(:,:,:,:)
    real(8), intent(in) :: ensStdDev(:,:,:)
    integer, intent(in) :: stride
    integer,optional, intent(in) :: waveBandIndex

    real*4, allocatable :: ensPert_local(:,:)

    real(8), allocatable :: meanCorrel(:,:)
    real(8), allocatable :: meanCorrelSquare(:,:)
    real(8), allocatable :: meanVarianceProduct(:,:)
    real(8), allocatable :: meanCovarianceSquare(:,:)
    real(8), allocatable :: meanFourthMoment(:,:)

    real(8), allocatable :: localizationFunctions(:,:,:) ! Eq. 19-21 in MMMB 2015 Part 2

    real(8), allocatable :: localizationRadii(:,:)

    real(8), allocatable, target :: distanceBinInLnP_T(:,:) ! Distance between each pair of thermo vertical levels in ln(Pressure)
    real(8), allocatable, target :: distanceBinInLnP_M(:,:) ! Distance between each pair of momentum vertical levels in ln(Pressure)
    real(8), allocatable :: distanceBinWeight(:)    ! Weight given to each bin in the curve fitting step

    real(8), allocatable :: gridPointWeight(:,:)   ! Weight given to grid point in the statistic computation

    real(8), allocatable :: sumWeight(:,:)    ! Sample size for each distance-bin
    
    real(8), pointer :: PressureProfile(:)
    real(8), pointer :: distanceBinInLnP(:,:)

    real(8) :: dnens, correlation, covariance, fourthMoment, distance, maxDistance, weight
    real(8) :: t1, t2, t3, rmse

    integer :: k, k2, kens, f, ens, bin, numbins, numFunctions
    integer :: nirefpoint, njrefpoint
    integer :: iref, jref
    integer :: nLevEns, nLevStart, nLevEnd, jvar

    character(len=128) :: outfilename
    character(len=2)   :: wbnum

    !
    !- 1.  Setup
    !

    numFunctions = 3
    
    nirefpoint = ni/stride ! Number of reference grid point in x
    njrefpoint = nj/stride ! Number of reference grid point in y

    numBins=max(nLevEns_M,nLevEns_T) !ni/4 !2

    allocate(localizationFunctions(numFunctions,numBins,nkgdimEns))

    allocate(meanCorrelSquare(numBins,nkgdimEns))
    allocate(meanCorrel(numBins,nkgdimEns))
    allocate(meanVarianceProduct(numBins,nkgdimEns))
    allocate(meanCovarianceSquare(numBins,nkgdimEns))
    allocate(meanFourthMoment(numBins,nkgdimEns))
    allocate(sumWeight(numBins,nkgdimEns))

    allocate(gridPointWeight(ni,nj))

    allocate(distanceBinInLnP_M(nLevEns_M,nLevEns_M))
    allocate(distanceBinInLnP_T(nLevEns_T,nLevEns_T))

    ! Compute the separation-distance in ln(p) between vertical levels
    !write(6,*)
    !write(6,*) 'Separation distance bin'
    do k = 1, nLevEns_M
       do k2 = 1, nLevEns_M
          distanceBinInLnP_M(k,k2) = abs(log(pressureProfile_M(k))-log(pressureProfile_M(k2)))
       end do
    end do
    do k = 1, nLevEns_T
       do k2 = 1, nLevEns_T
          distanceBinInLnP_T(k,k2) = abs(log(pressureProfile_T(k))-log(pressureProfile_T(k2)))
       end do
    end do

    dnens = 1.0d0/dble(nens-1)

    ! Grid point Weight
    write(6,*)
    write(6,*) 'Grid point Weight'
    do jref = 1, nj
       gridPointWeight(:,jref) = cos(hco_ens%lat(jref))
       write(6,*) jref, hco_ens%lat(jref), cos(hco_ens%lat(jref))
    end do

    !
    !- 2.  Estimation of localization functions
    !

    !- 2.1  Computation of various statistics for different separation distances
    meanCorrelSquare(:,:)     = 0.d0
    meanCorrel(:,:)           = 0.d0
    meanCovarianceSquare(:,:) = 0.d0
    meanVarianceProduct(:,:)  = 0.d0
    meanFourthMoment(:,:)     = 0.d0
    sumWeight(:,:) = 0.d0

    allocate(ensPert_local(nens,nkgdimEns))

    do jref = nint(stride/2.0), nj, stride     ! Pick every stride point to save cost.
       do iref = nint(stride/2.0), ni, stride  ! Pick every stride point to save cost.

          !- Select data needed to speed up the process (ensemble member index must come first in ensPert_Local 
          !  because ensemble member is the last loop index below)
          do ens = 1, nens
             do k = 1, nkgdimEns
                ensPert_local(ens,k) = ensPerturbations(iref,k,jref,ens)
             end do
          end do

          ! Loop on all 3D variables
          do jvar = 1, nvar3d

             if (vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
                nLevEns = nLevEns_M
             else
                nLevEns = nLevEns_T
             endif
             nLevStart = varLevOffset(jvar)+ 1
             nLevEnd   = varLevOffset(jvar)+ nLevEns

!$OMP PARALLEL
!$OMP DO PRIVATE (k,k2,ens,correlation,covariance,fourthMoment,bin,weight)
             do k = nLevStart, nLevEnd
                do k2 = nLevStart, nLevEnd

                   covariance = 0.d0
                   fourthMoment = 0.d0
                   do ens = 1, nens
                      covariance = covariance + &
                           ensPert_local(ens,k2) * ensPert_local(ens,k)
                      fourthMoment = fourthMoment + &
                           (ensPert_local(ens,k2) * ensPert_local(ens,k))**2
                   end do
                   covariance   = covariance * dnens
                   fourthMoment = fourthMoment / real(nens,8)
                   correlation  = covariance / (ensStdDev(iref,k2,jref)*ensStdDev(iref,k,jref))
                   
                   bin=k2-nLevStart+1

                   weight = gridPointWeight(iref,jref)

                   sumWeight(bin,k) = sumWeight(bin,k) + weight
                   
                   meanCorrel(bin,k)           = meanCorrel(bin,k)           + correlation    * weight
                   meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     + correlation**2 * weight
                   meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) + covariance**2  * weight
                   meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  + ensStdDev(iref,k2,jref)**2 * ensStdDev(iref,k,jref)**2 * weight
                   meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     + fourthMoment   * weight
                end do
             end do
!$OMP END DO
!$OMP END PARALLEL
          end do ! var3D

       end do ! iref
    end do    ! jref

    deallocate(ensPert_local)
    

    !- 2.2  Computation of the localization functions
    t1=dble((nens-1)**2)/dble(nens*(nens-3))
    t2=dble(nens)/dble((nens-2)*(nens-3))
    t3=dble(nens-1)/dble(nens*(nens-2)*(nens-3))

    do jvar = 1, nvar3d
       if (vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
       else
          nLevEns = nLevEns_T
       endif
       nLevStart = varLevOffset(jvar)+ 1
       nLevEnd   = varLevOffset(jvar)+ nLevEns
!$OMP PARALLEL
!$OMP DO PRIVATE (k,bin)       
       do k = nLevStart, nLevEnd
          do bin = 1, nLevEns
             meanCorrel(bin,k)           = meanCorrel(bin,k)           / sumWeight(bin,k)
             meanCorrelSquare(bin,k)     = meanCorrelSquare(bin,k)     / sumWeight(bin,k)
             meanCovarianceSquare(bin,k) = meanCovarianceSquare(bin,k) / sumWeight(bin,k)
             meanVarianceProduct(bin,k)  = meanVarianceProduct(bin,k)  / sumWeight(bin,k)
             meanFourthMoment(bin,k)     = meanFourthMoment(bin,k)     / sumWeight(bin,k)

             if ( meanCovarianceSquare(bin,k) /= 0.d0 ) then
                ! Form 1: General formulation (Eq. 19 in MMMB 2015 Part 2)
                localizationFunctions(1,bin,k) = t1 - t2*meanFourthMoment(bin,k)/meanCovarianceSquare(bin,k) + &
                     t3*meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k)
                ! Form 2: Gaussian sample distribution (Eq. 20 in MMMB 2015 Part 2)
                localizationFunctions(2,bin,k) = dble(nens-1)/dble((nens+1)*(nens-2)) * &
                     (dble(nens-1)-meanVarianceProduct(bin,k)/meanCovarianceSquare(bin,k))
             else
                write(6,*) ' !!! Warning !!! meanCovarianceSquare = 0 in bin, level = ', bin, k
                localizationFunctions(1,bin,k) = 0.d0
                localizationFunctions(2,bin,k) = 0.d0
             end if
             ! Form 3: Gaussian sample distribution and correlation-based formulation (Eq. 21 in MMMB 2015 Part 2)
             if ( meanCorrelSquare(bin,k) /= 0.d0 ) then
                localizationFunctions(3,bin,k) = dble(nens-1)/dble((nens+1)*(nens-2)) * &
                     (dble(nens-1)-1.d0/meanCorrelSquare(bin,k))
             else
                write(6,*) ' !!! Warning !!! meanCorrelSquare = 0 in bin, level = ', bin, k
                localizationFunctions(3,bin,k) = 0.d0
             end if
          end do
       end do
!$OMP END DO
!$OMP END PARALLEL
    end do

    !
    !- 3.  Estimation of localization radii (curve fitting)
    !
    allocate(localizationRadii(numFunctions,nkgdimEns))
    allocate(distanceBinWeight(numBins))

    call loc_setup('FifthOrder') ! IN

    localizationRadii(:,:) = 2.d0 ! First Guess (in ln(p) distance)
    distanceBinWeight(:)   = 1.d0 ! Even weight

    do jvar = 1, nvar3d
       if (vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
          distanceBinInLnP => distanceBinInLnP_M
       else
          nLevEns = nLevEns_T
          distanceBinInLnP => distanceBinInLnP_T
       endif
       nLevStart = varLevOffset(jvar)+ 1
       nLevEnd   = varLevOffset(jvar)+ nLevEns

       write(6,*)
       write(6,*) nomvar3d(jvar,variableType)

       do f = 1, numFunctions

          write(6,*)
          write(6,*) 'Localization Function : ', f
!!$OMP PARALLEL
!!$OMP DO PRIVATE (k,kens,rmse)
          do k =  nLevStart, nLevEnd
             kens = k-nLevStart+1
             write(6,*) '         ----- EnsLev : ', k
             call loc_lengthscale( localizationRadii(f,k),       & ! INOUT
                                   rmse,                         & ! OUT
                                   localizationFunctions(f,1:nLevEns,k), & ! IN
                                   distanceBinInLnP(kens,:),        & ! IN
                                   distanceBinWeight(1:nLevEns), & ! IN
                                   nLevEns )                       ! IN
          end do
!!$OMP END DO
!!$OMP END PARALLEL
       end do
    end do

    !
    !- 4.  Write to file
    !
    if ( nWaveBand /= 1 ) then
       if (.not. present(waveBandIndex)) then
          write(6,*) 'calcLocalizationRadii: No waveBandIndex was supplied!!!'
          call abort3d('calbmatrix_glb')
       end if
       write(wbnum,'(I2.2)') waveBandIndex
    end if

    !- 4.1 Localization functions in txt format (for plotting purposes)
    do jvar = 1, nvar3d
       if ( nWaveBand == 1 ) then
          outfilename = "./vertLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./vertLocalizationFunctions_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
          PressureProfile => pressureProfile_M
          distanceBinInLnP => distanceBinInLnP_M 
       else
          nLevEns = nLevEns_T
          PressureProfile => pressureProfile_T
          distanceBinInLnP => distanceBinInLnP_T
       endif

       do k=1,nlevEns
          do bin = 1, nlevEns
             write(99,'(I3,2X,I3,2X,F6.1,2X,F7.3,2X,I7,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,F6.4,2X,E10.3,2X,E10.3,2X,E10.3)') k, bin, &
                  PressureProfile(bin)/100.d0, distanceBinInLnP(k,bin), nint(sumWeight(bin,varLevOffset(jvar)+k)), &
                  meanCorrel(bin,varLevOffset(jvar)+k), &
                  localizationFunctions(3,bin,varLevOffset(jvar)+k), &
                  localizationFunctions(2,bin,varLevOffset(jvar)+k), &
                  localizationFunctions(1,bin,varLevOffset(jvar)+k), &
                  meanCorrelSquare(bin,varLevOffset(jvar)+k), &
                  meanCovarianceSquare(bin,varLevOffset(jvar)+k), &
                  meanVarianceProduct(bin,varLevOffset(jvar)+k), &
                  meanFourthMoment(bin,varLevOffset(jvar)+k)
          end do
       end do
       close(unit=99)
    end do

    !- 4.2 Localization radii in txt format (for plotting purposes)
    do jvar = 1, nvar3d
       if ( nWaveBand == 1 ) then
          outfilename = "./vertLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//".txt"
       else
          outfilename = "./vertLocalizationRadii_"//trim(nomvar3d(jvar,variableType))//"_"//wbnum//".txt"
       end if
       open (unit=99,file=outfilename,action="write",status="new")

       if(vnl_varLevelFromVarName(nomvar3d(jvar,variableType)).eq.'MM') then
          nLevEns = nLevEns_M
          PressureProfile => pressureProfile_M
       else
          nLevEns = nLevEns_T
          PressureProfile => pressureProfile_T
       endif
       do k=1,nlevEns
          write(99,'(I3,2X,F6.1,2X,F7.2,2X,F7.2,2X,F7.2)') k, PressureProfile(k)/100.d0, &
               localizationRadii(3,varLevOffset(jvar)+k), &
               localizationRadii(2,varLevOffset(jvar)+k), &
               localizationRadii(1,varLevOffset(jvar)+k)
       end do
       close(unit=99)
    end do

    deallocate(meanCorrelSquare)
    deallocate(meanCorrel)
    deallocate(meanCovarianceSquare)
    deallocate(meanVarianceProduct)
    deallocate(meanFourthMoment)
    deallocate(distanceBinInLnP_M)
    deallocate(distanceBinInLnP_T)
    deallocate(sumWeight)
    deallocate(localizationFunctions)
    deallocate(localizationRadii)
    deallocate(distanceBinWeight)
    deallocate(gridPointWeight)

    write(6,*) 'finished estimating the vertical localization radii...'
    call flush(6)

  end subroutine calcVertLocalizationRadii

end module calcbmatrix_glb_mod
