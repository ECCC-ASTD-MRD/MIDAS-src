!--------------------------------------------------------------------------
! MODULE glbspec_mod (Global Spectral Transform: prefix="gst")
!
! Purpose: Perform global spectral transform. Uses the fft_mod module for
!          the FFT part of the transform.
!
! Subroutines:
!    gst_setup (public)
!    gst_speree    (public)
!    gst_reespe    (public)
!    gst_spgd      (public)
!    gst_spgda     (public)
!    spereepar
!    reespepar
!    sppar
!    spgdapar
!    legdir3
!    leginv3
!    allocate_comleg
!    suleg
!    gauss8
!    ordleg8
!    sualp
!    getalp
!    allp
!    allp2
!
! Public variables:
!    gst_rmu
!    gst_rwt
!    gst_nind
!    gst_rlati
!    gst_r1qm2
!    gst_rsqm2
!
! Dependencies:
!    fft_mod
!--------------------------------------------------------------------------
MODULE GLBSPEC_MOD

  implicit none
  save
  private

  ! public variables
  public :: gst_rmu,gst_rwt,gst_nind,gst_rlati,gst_r1qm2,gst_rsqm2
  ! public procedures
  public :: gst_speree,gst_reespe,gst_setup,gst_spgd,gst_spgda

  real*8,allocatable   :: gst_rmu(:),gst_rwt(:),gst_rsqm2(:),gst_r1qm2(:),gst_rlati(:)
  integer,allocatable  :: gst_nind(:)

  real*8,allocatable   :: dalp(:,:), dealp(:,:)
  real*8,allocatable   :: rwocs(:)
  real*8,allocatable   :: r1mu2(:),rcolat(:),r1mui(:),r1mua(:)
  real*8,allocatable   :: gaus(:,:)
  integer,allocatable  :: nindrh(:), nclm(:)
  integer              :: nlatbd = 8
  integer              :: ni_l,nibeg_l,niend_l,nisur_l,nj_l,njbeg_l,njend_l,njsur_l
  integer              :: njlath_l
  integer              :: ntrunc_l, nla_l, nlarh_l
  real*8               :: rinfini,rpi,r1sa
  real*8,allocatable   :: r1snp1(:)

CONTAINS

  SUBROUTINE GST_SETUP(KULOUT,NI_IN,NJ_IN,NTRUNC_IN)
    use fft_mod
    implicit none
    integer kulout,ni_in,nj_in,ntrunc_in
    integer jn,jm,ila
    real*8   :: ra,znnp1,z1snp1

    nisur_l=2
    njsur_l=2
    ni_l=ni_in
    nj_l=nj_in
    nibeg_l=0
    niend_l=ni_l+nisur_l
    njbeg_l=1-njsur_l
    njend_l=nj_l+njsur_l
    njlath_l = (nj_l + 1)/2

    ntrunc_l=ntrunc_in
    nla_l=(ntrunc_l + 1)*(ntrunc_l +2)/2
    nlarh_l = (ntrunc_l+1)*(ntrunc_l+1)
    write(*,*) 'ntrunc_l=',ntrunc_l
    write(*,*) 'nibeg,niend,njbeg,njend=',nibeg_l,niend_l,njbeg_l,njend_l


    rpi=2.0d0*asin(1.0d0)
    ra=6371229.d0
    r1sa=1.d0/dble(ra)
    rinfini = 1.d+35

    write(*,*) 'allocating comleg...'
    call allocate_comleg
    write(*,*) 'calling suleg...'
    call suleg(kulout)
    write(*,*) 'calling sualp...'
    call sualp
    write(*,*) 'calling sufft...'
    call fft_sufft(6,ni_l,nj_l)

    allocate(r1snp1(nla_l))
    r1snp1(1) = 0.
    do jn = 1, ntrunc_l
       znnp1  = -float(jn)*float(jn+1)
       z1snp1 =  1./znnp1
       do jm = 0, jn
          ila = gst_nind(jm) + jn - jm
          r1snp1(ila) = z1snp1
       enddo
    enddo
   
  END SUBROUTINE GST_SETUP

  SUBROUTINE GST_SPGD(SP,GD,KFIELD,NFLEV,KDIM)
    use fft_mod
    implicit none

    integer kfield,nflev,kdim
    real*8 sp(nla_l,2,kdim), gd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)
    integer  ji,jj,jla,jgl, jk, jlon, ilonmax
    real*8 zfmla(ni_l,kfield,nj_l), zsp(nla_l,2)
    real*8 zgdxy(ni_l,nj_l)

!*  1. Inverse Legendre transform
!      --------------------------
      call sppar(sp,gd,kfield,nflev,kdim)

!   2.1 Reset to zero the modes that are not part of the truncation
!       -----------------------------------------------------------
      ilonmax = niend_l
      do jgl = 1, nj_l
         do jlon = 2*(ntrunc_l+1)+1, ilonmax
            do  jk = 1, kfield
               gd(jlon,jk,jgl) = 0.
            enddo
         enddo
      enddo

      do jgl =1,nj_l
         do jk = 1, kfield
            gd(0,jk,jgl) = 0.
         enddo
      enddo

!     2.2 Apply the FFT 
!         -------------
      call fft_fft3dvar(gd,nibeg_l,niend_l,kfield,njbeg_l,njend_l,kfield,+1)

  END SUBROUTINE GST_SPGD


  SUBROUTINE SPPAR(SP,GD,KFIELD,NFLEV,KDIM)
!**s/r SPPAR  - Inverse spectral transform(PARALLEL LOOP)

    implicit none

    integer kfield,nflev,kdim
    real*8 sp(nla_l,2,kdim), gd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)

    ! local variables
    integer isiz
    integer ilen, jj, jlatn, jlats ,jm, ilonr,ilonim
    integer jk ,jn, ila, inm, jm0, jns, ins, jk2
    integer :: i_njlath, i_nj

    real*8 zjm
    real*8 dlalp(0:ntrunc_l,njlath_l), dldalp(0:ntrunc_l,njlath_l)
    real*8 zfms(njlath_l+1,2,kfield), zfma(njlath_l+1,2,kfield)
    real*8 dlsp(0:ntrunc_l,2,kfield)

    integer  thdid,numthd,omp_get_thread_num,omp_get_num_threads

    ! 1. Set up according to the desired grid (staggered or not)
    !    ---------------------
    i_nj = nj_l
    i_njlath = njlath_l

    ! 2. Inverse Legendre transform
    !    --------------------------

    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,ZFMS,ZFMA,JLATN,JLATS) &
    !$OMP  PRIVATE(INM,ILA,JM,JN,JK,JJ,ZJM,JNS,INS,ILONR,ILONIM) &
    !$OMP  PRIVATE(thdid,numthd)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, ntrunc_l/2,numthd
       ins=1
       if(jm0.eq.ntrunc_l-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(ntrunc_l - jm0)

          ! 2.1 Copy global spectral state into local spectral state
          do jn = jm, ntrunc_l
             ila = gst_nind(jm) + jn - jm
             inm = jn - jm
             do jk = 2*nflev+1, kfield
                dlsp(inm,1,jk) = sp(ila,1,jk)
                dlsp(inm,2,jk) = sp(ila,2,jk)
             enddo
             do jk = 1, 2*nflev
                dlsp(inm,1,jk) = sp(ila,1,jk)*r1snp1(ila)
                dlsp(inm,2,jk) = sp(ila,2,jk)*r1snp1(ila)
             enddo
          enddo

          ! 2.2  Get Legendre polynomial (and its derivative) for all latitudes
          !      but for the chosen value of "m" from the global array
          call getalp (dlalp,dldalp,i_njlath,ntrunc_l,ntrunc_l,jm)

          ! 2.3  Perform the inverse Legendre transform for all fields
          call leginv3(jm,zfms,zfma,dlsp,dlalp,kfield,i_njlath,ntrunc_l,ntrunc_l)

          ! 2.4 Passage to Fourier space
          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          zjm = float(jm)
          do jj = 1, i_njlath
             jlatn = jj
             jlats = i_nj - jlatn + 1
             do  jk = 2*nflev+1, kfield
                gd(ilonr,jk,jlatn) = zfms(jj,1,jk) + zfma(jj,1,jk)
                gd(ilonim,jk,jlatn) = zfms(jj,2,jk) + zfma(jj,2,jk)
                gd(ilonr,jk,jlats) = zfms(jj,1,jk) - zfma(jj,1,jk)
                gd(ilonim,jk,jlats) = zfms(jj,2,jk) - zfma(jj,2,jk)
             enddo

             do jk = 1, nflev
                jk2= jk + nflev
                gd(ilonr,jk,jlatn)  = -zjm*(zfms(jj,2,jk+nflev) + zfma(jj,2,jk+nflev))
                gd(ilonim,jk,jlatn) = zjm*(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                gd(ilonr,jk,jlats)  = -zjm*(zfms(jj,2,jk+nflev) - zfma(jj,2,jk+nflev))
                gd(ilonim,jk,jlats) = zjm*(zfms(jj,1,jk+nflev) - zfma(jj,1,jk+nflev))

                gd(ilonr,jk2,jlatn)  = -zjm*(zfms(jj,2,jk) + zfma(jj,2,jk))
                gd(ilonim,jk2,jlatn) = zjm*(zfms(jj,1,jk) + zfma(jj,1,jk))
                gd(ilonr,jk2,jlats)  = -zjm*(zfms(jj,2,jk) - zfma(jj,2,jk))
                gd(ilonim,jk2,jlats) = zjm*(zfms(jj,1,jk) - zfma(jj,1,jk))
             enddo
          enddo

          ! 2.5 Completion of the computation of the winds in Fourier space
          !     -----------------------------------------------------------

          call leginv3 (jm, zfma,zfms,dlsp,dldalp,2*nflev, i_njlath, ntrunc_l, ntrunc_l)

          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          zjm    = float(jm)
          do jj = 1, i_njlath
             jlatn = jj
             jlats = i_nj - jlatn + 1

             if(jlatn.ne.jlats) then
                do jk = 1,nflev
                   jk2= jk + nflev
                   ! northern latitudes
                   gd(ilonr,jk,jlatn)  = gd(ilonr,jk,jlatn)  -(zfms(jj,1,jk) + zfma(jj,1,jk))
                   gd(ilonim,jk,jlatn) = gd(ilonim,jk,jlatn) -(zfms(jj,2,jk) + zfma(jj,2,jk))

                   gd(ilonr,jk2,jlatn) = gd(ilonr,jk2,jlatn) +(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlatn)= gd(ilonim,jk2,jlatn)+(zfms(jj,2,jk+nflev) + zfma(jj,2,jk+nflev))
                   ! southern latitudes
                   gd(ilonr,jk,jlats) = gd(ilonr,jk,jlats)   -(zfms(jj,1,jk) - zfma(jj,1,jk))
                   gd(ilonim,jk,jlats)= gd(ilonim,jk,jlats)  -(zfms(jj,2,jk) - zfma(jj,2,jk))
                   gd(ilonr,jk2,jlats) = gd(ilonr,jk2,jlats) +(zfms(jj,1,jk+nflev) - zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlats)= gd(ilonim,jk2,jlats)+(zfms(jj,2,jk+nflev) - zfma(jj,2,jk+nflev))
                enddo
             else
                ! Special case for the equator
                do jk = 1, nflev
                   jk2= jk + nflev
                   gd(ilonr,jk,jlatn)  = gd(ilonr,jk,jlatn)  -(zfms(jj,1,jk) + zfma(jj,1,jk))
                   gd(ilonim,jk,jlatn) = gd(ilonim,jk,jlatn) -(zfms(jj,2,jk)+ zfma(jj,2,jk))
                   gd(ilonr,jk2,jlatn) = gd(ilonr,jk2,jlatn) +(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlatn)= gd(ilonim,jk2,jlatn)+(zfms(jj,2,jk+nflev)+ zfma(jj,2,jk+nflev))
                enddo
             end if
          enddo

       enddo
!     end loop on m
    enddo
    !$OMP END PARALLEL

  END SUBROUTINE SPPAR


  SUBROUTINE GST_SPGDA(SP,GD,KFIELD,NFLEV,KDIM)
    use fft_mod
    implicit none

    integer kfield,nflev,kdim
    real*8 sp(nla_l,2,kdim), gd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)

    integer :: ilen, jk, jlon, jlat, incpu, isiz, i_nj
    integer ji,jj,jla

    integer idum1,idum2,idum3,idum4
    real*8 zmin,zmax
    real*8 :: zfm(ni_l+2,kfield,nj_l)
    real*8 zfmla(ni_l,kfield,nj_l), zsp(nla_l,2)
    real*8 zgdxy(ni_l,nj_l)

!   1. Fourier transform all fields for all latitudes
!      ----------------------------------------------
    zfm(:,:,:) = 0.d0
    i_nj = nj_l
                                !
    do jk = 1, kfield
       do jlat = 1, i_nj
          do jlon = 1, ni_l
             zfm(jlon,jk,jlat) = gd(jlon,jk,jlat)
          enddo
       enddo
    enddo
!
    call fft_fft3dvar(zfm,1,ni_l+2,kfield,1,i_nj,kfield,-1)

!   2. Direct Legendre transform including wind transformations
!      --------------------------------------------------------
    call spgdapar(sp,zfm,kfield,nflev,kdim)

  END SUBROUTINE GST_SPGDA


  SUBROUTINE SPGDAPAR(SP,ZFM,KFIELD,NFLEV,KDIM)
    use procs_topo
    implicit none

    integer :: kfield,nflev,kdim
    real*8  :: sp(nla_l,2,kdim),zfm(ni_l+2,kdim, nj_l)

    integer isiz
    integer ilen, jj, jk, ilonr, iloni, jm ,ila, inm, jn, jm0, ins, jns
    real*8 :: zjm,dlrwt(njbeg_l:njend_l)
    real*8 ::  dlalp(0:ntrunc_l,njlath_l), dldalp(0:ntrunc_l, njlath_l)
    real*8 :: dlsp(0:ntrunc_l,2,kfield),dlsp2(0:ntrunc_l,2,2*nflev)
    real*8 ::  zfms( njlath_l+1,2,kfield), zfma( njlath_l+1,2,kfield)
    integer :: i_njlath, i_nj

    integer thdid,numthd,omp_get_thread_num,omp_get_num_threads

    !    1. Set up according to the desired grid (staggered or not)
    !       ---------------------
    if(myid == 0) then
      write(*,fmt='(/,4x,A)')'SPGDAPAR- Adjoint of the inverse Legendre transform'
    endif
                                !
    i_nj = nj_l
    i_njlath = njlath_l
    dlrwt(:) = gst_rwt(:)
    if (mod(i_nj,2).ne.0) then
       dlrwt(i_njlath) = dlrwt(i_njlath)/2.d0
    end if

    ! 2. Fourier transform all fields for all latitudes
    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,DLSP2,ZFMS,ZFMA) &
    !$OMP  PRIVATE(INM,ILA,JM,JN,JK,JJ,ZJM,JNS,INS,ILONR,ILONI) &
    !$OMP  PRIVATE(thdid,numthd)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, ntrunc_l/2,numthd
       ins=1
       if(jm0.eq.ntrunc_l-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(ntrunc_l - jm0)
          ilonr = 2 * jm + 1
          iloni = ilonr + 1
          zjm   = float(jm)

          ! 2.1 Fetch the Legendre functions and their derivatives for this choice of "m"

!     CRITICAL
             call getalp(dlalp,dldalp,i_njlath,ntrunc_l,ntrunc_l,jm)
!     END CRITICAL

          ! 2.2  Build the symmetric and anti-symmetric Fourier coefficients including
          !      the appropriate quadrature weights (see scientific notes)
          do jj = 1, i_njlath

             ! 2.2.1  Coefficients for scalar fields
             do jk = 2*nflev+1, kfield
                ! symmetric coefficients
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj-jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo

             ! 2.2.2 Coefficients associated with the wind fields
             do jk = 1, nflev
                ! vorticity: symmetric coefficients
                zfms(jj,1,jk) = -zjm*dlrwt(jj)*(zfm(iloni,jk+nflev,jj)+zfm(iloni,jk+nflev,1+i_nj-jj))
                zfms(jj,2,jk) = zjm*dlrwt(jj) *(zfm(ilonr,jk+nflev,jj)+zfm(ilonr,jk+nflev,1+i_nj-jj))
                ! vorticity: antisymmetric coefficients
                zfma(jj,1,jk) = -zjm*dlrwt(jj) *(zfm(iloni,jk+nflev,jj)- zfm(iloni,jk+nflev,1+i_nj-jj))
                zfma(jj,2,jk) = zjm*dlrwt(jj)*(zfm(ilonr,jk+nflev,jj)- zfm(ilonr,jk+nflev,1+i_nj-jj))
                ! divergence: symmetric coefficients
                zfms(jj,1,jk+nflev) = -zjm*dlrwt(jj)*(zfm(iloni,jk,jj)+ zfm(iloni,jk,1+i_nj-jj))
                zfms(jj,2,jk+nflev) = zjm*dlrwt(jj)*(zfm(ilonr,jk,jj)+ zfm(ilonr,jk,1+i_nj-jj))
                ! divergence: antisymmetric coefficients
                zfma(jj,1,jk+nflev) = -zjm*dlrwt(jj)*(zfm(iloni,jk,jj)- zfm(iloni,jk,1+i_nj-jj))
                zfma(jj,2,jk+nflev) = zjm*dlrwt(jj)*(zfm(ilonr,jk,jj)- zfm(ilonr,jk,1+i_nj-jj))
             enddo
          enddo

          ! 2.3 First one with ALP for all scalar fields and for half the terms
          !     required to define the divergence and vorticity
!      CRITICAL
          call legdir3 (jm,zfms,zfma,dlsp,dlalp,kfield,i_njlath,ntrunc_l,ntrunc_l)
!     END CRITICAL
                                !
          ! 2.4  Second transform with DALP to complete the construction of the
          !      vorticity and divergence fields
          do jj = 1, i_njlath
             do jk = 1, nflev
                ! symmetric coefficients for zonal wind
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj - jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients for zonal wind
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo
             do jk = nflev+1, 2*nflev
                ! symmetric coefficients for meridional wind
                zfms(jj,1,jk) = -dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj-jj))
                zfms(jj,2,jk) = -dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients for meridional wind
                zfma(jj,1,jk) = -dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = -dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo
          enddo
!      CRITICAL
          call legdir3(jm,zfma,zfms,dlsp2,dldalp,2*nflev,i_njlath,ntrunc_l,ntrunc_l)
!     END CRITICAL

          ! 2.5  Transfer the result in the global state
          do jn = jm, ntrunc_l
             ila = gst_nind(jm) + jn - jm
             inm = jn - jm
             do jk = 1, 2*nflev
                sp(ila,1,jk) = -r1snp1(ila)*(dlsp(inm,1,jk) + dlsp2(inm,1,jk))
                sp(ila,2,jk) = -r1snp1(ila)*(dlsp(inm,2,jk) + dlsp2(inm,2,jk))
             enddo
             do jk = 2*nflev+1,kfield
                sp(ila,1,jk) = dlsp(inm,1,jk)
                sp(ila,2,jk) = dlsp(inm,2,jk)
             enddo
          enddo
       ! End of loop on zonal wavenumbers
       enddo
    enddo
    !$OMP END PARALLEL
  END SUBROUTINE SPGDAPAR


  SUBROUTINE GST_SPEREE(PSP,PGD,KFIELD,KDIM)
    use fft_mod
    implicit none

    integer kfield,kdim,itemp,ijump,ilot,julot,infft
    real*8 psp(nla_l,2,kdim), pgd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)
    integer ilen, jgl, jk, jlon, ilonmax

    !    1. Inverse Legendre transform
    !    --------------------------
    call spereepar(psp,pgd,kfield,kdim)

    !     2. Inverse Fourier transform
    !        -------------------------
    !     2.1 Reset to zero the modes that are not part of the truncation
    !         -----------------------------------------------------------
    ilonmax = niend_l
    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JGL,JLON,JK)
    do jgl = 1,nj_l
       do jlon = 2*(ntrunc_l+1)+1, ilonmax
          do  jk = 1, kfield
             pgd(jlon,jk,jgl) = 0.
          enddo
       enddo

       do jk = 1, kfield
          pgd(0,jk,jgl) = 0.
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

    !     2.2 Apply the FFT 
    !         -------------
    !*    . INVERSE FOURIER TRANSFORM
    !     .  -------------------------
    call fft_fft3dvar(pgd,nibeg_l,niend_l,kfield,njbeg_l,njend_l,kfield,+1)

    return
  END SUBROUTINE GST_SPEREE


  SUBROUTINE GST_REESPE(PSP,PGD,KFIELD,KDIM)
    use fft_mod
    implicit none

    integer :: kfield,kdim
    real*8 psp(nla_l,2,kdim), pgd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)
    !
    integer :: ilen, ji,jj,jk, jlon, jlat,incpu, isiz
    real*8,pointer  :: zfm(:,:,:)
    integer value(8)
    real*8 seconds1,seconds2,seconds3

    allocate(zfm(ni_l+2,kfield,nj_l))

    !     1. Transfer global fields to local array
    call  date_and_time(values=value)
    seconds1=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JJ,JK,JI)
    do jj=1,nj_l
       do jk=1,kfield
          do ji=1,ni_l
             zfm(ji,jk,jj) = pgd(ji,jk,jj)
          enddo
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL
    call  date_and_time(values=value)
    seconds2=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)
    !  write(*,*) 'in reespe, transfer=',seconds2-seconds1

    !     2. Apply the FFT
    call  date_and_time(values=value)
    seconds1=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)
    call fft_fft3dvar(zfm,1,ni_l+2,kfield,1,nj_l,kfield,-1)
    call  date_and_time(values=value)
    seconds2=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    ! 3. Direct Legendre transform
    call reespepar(psp,zfm,kfield,kdim)
    call  date_and_time(values=value)
    seconds3=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    !  write(*,*) 'in reespe, fft=',seconds2-seconds1
    !  write(*,*) 'in reespe, leg=',seconds3-seconds2

    deallocate(zfm)

  END SUBROUTINE GST_REESPE


  SUBROUTINE SPEREEPAR(PSP,PGD,KFIELD,KDIM)
    implicit none

    integer kfield,kdim
    real*8 psp(nla_l,2,kdim), pgd(nibeg_l:niend_l,kdim,njbeg_l:njend_l)

    integer isiz
    integer ilen,jj,jlatn, jlats,jm
    integer ilonr,ilonim,jk,jn,ila,inm,jm0,jns,ins

    real*8 dlalp(0:ntrunc_l,njlath_l), dldalp(0:ntrunc_l,njlath_l)
    real*8 zfms(njlath_l+1,2,kfield), zfma(njlath_l+1,2,kfield)
    real*8 dlsp(0:ntrunc_l,2,kfield)

    integer  thdid,numthd,omp_get_thread_num,omp_get_num_threads


    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,DLSP,ZFMS,ZFMA,JLATN,JLATS, &
    !$OMP INM,ILA,JM,JN,JK,JJ,JNS,INS,ILONR,ILONIM,JM0)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, ntrunc_l/2,numthd
       ins=1
       if(jm0.eq.ntrunc_l-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(ntrunc_l - jm0)

          !**   .   2.1 Copy global spectral state into local spectral state

          do jn = jm, ntrunc_l
             ila = gst_nind(jm) + jn - jm
             inm = jn - jm
             do jk =1,kfield
                dlsp(inm,1,jk) = psp(ila,1,jk)
                dlsp(inm,2,jk) = psp(ila,2,jk)
             enddo
          enddo

          !     .   2.2  Get Legendre polynomial (and its derivative) for all latitudes
          !     .        but for the chosen value of "m" from the global array

          call getalp(dlalp,dldalp,njlath_l,ntrunc_l,ntrunc_l,jm)

          !     .   2.3  Perform the inverse Legendre transform for all fields

          call leginv3(jm, zfms,zfma,dlsp,dlalp,kfield,njlath_l,ntrunc_l,ntrunc_l)

          !     .   2.4 Passage to Fourier space

          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          do jj = 1, njlath_l
             jlatn = jj
             jlats = nj_l - jj + 1
             do  jk = 1,kfield
                pgd(ilonr,jk,jlatn)  = zfms(jj,1,jk) + zfma(jj,1,jk)
                pgd(ilonim,jk,jlatn) = zfms(jj,2,jk) + zfma(jj,2,jk)
                pgd(ilonr,jk,jlats)  = zfms(jj,1,jk) - zfma(jj,1,jk)
                pgd(ilonim,jk,jlats) = zfms(jj,2,jk) - zfma(jj,2,jk)
             enddo
          enddo
       enddo
    enddo
    !$OMP END PARALLEL

    return
  END SUBROUTINE SPEREEPAR


  SUBROUTINE REESPEPAR(PSP,ZFM,KFIELD,KDIM)
    implicit none

    integer :: kfield,kdim
    real*8  :: psp(nla_l,2,kdim)
    real*8  :: zfm(ni_l+2,kdim, nj_l)

    integer :: ilen, jj, jk,jk2,ilonr, iloni
    integer :: jm, ila, inm, jn, jm0, ins, jns
    real*8  ::  dlalp(0:ntrunc_l,njlath_l)
    real*8  :: dldalp(0:ntrunc_l, njlath_l)
    real*8  ::  dlsp(0:ntrunc_l,2,kfield)
    real*8  ::  zfms( njlath_l+1,2,kfield), zfma( njlath_l+1,2,kfield)
    real*8  :: dlrwt(njbeg_l:njend_l)

    integer :: thdid,numthd,omp_get_thread_num,omp_get_num_threads

    !     1. Adjustment needed when an odd number of latitudes is considered
    !     --------------------------------------------------------------------
    dlrwt(:)   = gst_rwt(:)
    if (mod(nj_l,2).ne.0) then
       dlrwt(njlath_l)   = dlrwt(njlath_l)/2.d0
    end if

    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,ZFMS,ZFMA,thdid,numthd, &
    !$OMP   INM,ILA,JM,JN,JK,JK2,JJ,JNS,INS,ILONR,ILONI)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, ntrunc_l/2,numthd
       ins=1
       if(jm0.eq.ntrunc_l-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(ntrunc_l - jm0)
          ilonr = 2 * jm + 1
          iloni = ilonr + 1

          !**  .  2.1 Fetch the Legendre functions and their derivatives for this choice of "m"

          call getalp(dlalp,dldalp,njlath_l,ntrunc_l,ntrunc_l,jm)

          !    .  2.2  Build the symmetric and anti-symmetric Fourier coefficients including
          !    .       the appropriate quadrature weights (see scientific notes)

          do jj = 1, njlath_l
             do jk = 1,kfield
                !     .                       Symmetric coefficients
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+nj_l-jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+nj_l-jj))
                !     .                       Antisymmetric coefficients
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) -  zfm(ilonr,jk,1+nj_l-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) -  zfm(iloni,jk,1+nj_l-jj))
             enddo
          enddo

          !     .   2.3 First one with ALP for all scalar fields and for half the terms
          !     .        required to define the divergence and vorticity

          call legdir3 (jm,zfms,zfma,dlsp,dlalp,kfield,njlath_l,ntrunc_l,ntrunc_l)

          !     .    2.5  Transfer the result in the global state

          do jn = jm, ntrunc_l
             ila = gst_nind(jm) + jn - jm
             inm = jn - jm
             do jk2 = 1,kfield
                psp(ila,1,jk2) = dlsp(inm,1,jk2)
                psp(ila,2,jk2) = dlsp(inm,2,jk2)
             enddo
          enddo

          !     End of loop on zonal wavenumbers

       enddo
    enddo
    !$OMP END PARALLEL

    return
  END SUBROUTINE REESPEPAR


  SUBROUTINE LEGDIR3 (KM,PFMS,PFMA,DDSP,DDALP,KDIM,KLATH,KTRUNC,KTRUNCDIM)
    implicit none

    integer km, kdim, ktrunc, ktruncdim, klath
    real*8    pfms(njlath_l+1,2*kdim),pfma(njlath_l+1,2*kdim)
    real*8 ddalp(0:ktruncdim,klath)
    real*8  ddsp(0:ktruncdim,2*kdim)

    integer jk, jlat, jn, inm, itrunc, inmp1, jind, ink

    itrunc = ktrunc
    if(mod(ktrunc-km+1,2).eq.1) itrunc = ktrunc-1

    if(km.ne.ktrunc)then
       ddsp(0:ktrunc,1:2*kdim)=0.d0
       do jlat = 1,klath
          do jk = 1,2*kdim
             do jn = km, itrunc, 2
                inm = jn - km
                inmp1 = inm + 1
                ddsp(inm,jk)   = ddsp(inm,jk) +  ddalp(inm  ,jlat)*pfms(jlat,jk)
                ddsp(inmp1,jk) = ddsp(inmp1,jk)+ ddalp(inmp1,jlat)*pfma(jlat,jk)
             enddo
          enddo
       enddo
    end if

    if(mod(ktrunc-km+1,2).eq.1) then
       jn = ktrunc
       inm = jn - km
       ddsp(inm,1:2*kdim)=0.d0

       do jlat = 1,klath
          do jk = 1,2*kdim
             ddsp(inm,jk) = ddsp(inm,jk) + ddalp(inm,jlat)*pfms(jlat,jk )
          enddo
       enddo
    end if

    return
  END SUBROUTINE LEGDIR3


  SUBROUTINE LEGINV3 (KM,PFMS,PFMA,DDSP,DDALP,KDIM, KLATH ,KTRUNC,KTRUNCDIM)
    implicit none

    integer km, kdim, ktrunc, ktruncdim, klath
    real*8 pfms(njlath_l+1,2*kdim),pfma(njlath_l+1,2*kdim)
    real*8 ddalp(0:ktruncdim,klath)
    real*8  ddsp(0:ktruncdim,2*kdim)

    integer jk, jlat, jn, inm, ilen ,itrunc, inmp1, jind, ink
    integer i,j

    ilen=(klath+1)*2*kdim
    pfms(:,:) = 0.d0
    pfma(:,:) = 0.d0

    itrunc = ktrunc
    if(mod(ktrunc-km+1,2).eq.1) itrunc = ktrunc-1

    if(km.ne.ktrunc)then
       do jlat = 1,klath
          do jk = 1,2*kdim
             do jn = km, itrunc, 2
                inm = jn - km
                inmp1  = inm + 1
                pfms(jlat,jk) = pfms(jlat,jk) + ddalp(inm,jlat) * ddsp(inm,jk)
                pfma(jlat,jk) = pfma(jlat,jk) + ddalp(inmp1,jlat) * ddsp(inmp1,jk)
             enddo
          enddo
       enddo
    end if

    if(mod(ktrunc-km+1,2).eq.1) then
       jn = ktrunc
       if ( km .ne. ktrunc) then
          inm = jn - km
          do jlat = 1,klath
             do jk = 1,2*kdim
                pfms(jlat,jk) = pfms(jlat,jk) + ddalp(inm,jlat) * ddsp(inm,jk)
             enddo
          enddo
       else
          inm = jn - km
          do jlat = 1,klath
             do jk = 1,2*kdim
                pfms(jlat,jk) = ddalp(inm,jlat) * ddsp(inm,jk)
             enddo
          enddo
       end if
    end if

    return
  END SUBROUTINE LEGINV3


  SUBROUTINE ALLOCATE_COMLEG
    implicit none

    allocate(gst_rmu(njbeg_l:njend_l))  
    allocate(gst_rwt(njbeg_l:njend_l))
    allocate(rwocs(njbeg_l:njend_l))
    allocate(r1mu2(njbeg_l:njend_l))
    allocate(gst_rsqm2(njbeg_l:njend_l))
    allocate(rcolat(njbeg_l:njend_l))
    allocate(gst_r1qm2(njbeg_l:njend_l))
    allocate(r1mui(njbeg_l:njend_l))
    allocate(r1mua(njbeg_l:njend_l))
    allocate(gst_rlati(njbeg_l:njend_l))
    allocate(gaus(njbeg_l:njend_l,10))
    allocate(gst_nind(0:ntrunc_l))
    allocate(nindrh(0:ntrunc_l))
    allocate(nclm(0:ntrunc_l))

  END SUBROUTINE ALLOCATE_COMLEG


  SUBROUTINE SULEG(KULOUT)
    !
    !**s/r SULEG  - Initialisation of Gaussian latitudes, weights and related
    !     .         quantities
    implicit none

    integer kulout, jlat, jm
    real*8 zpisu2
    external gauss

    write(*,fmt='(//,6(" ***********"))')
    write(*,*)'     SULEG: initialisation of Gaussian', &
         ' latitudes, weights, etc...'
    write(*,fmt='(6(" ***********"))')

    !     1. GAUSSIAN LATITUDES AND WEIGHTS OVER AN HEMISPHERE
    !     -------------------------------------------------

    call gauss8(njlath_l,gst_rmu(1),gst_rwt(1),gst_rsqm2(1),rcolat(1),rwocs(1) &
         ,gst_r1qm2(1),r1mui(1),r1mu2(1))

    do jlat = 1, njlath_l
       gst_rlati(jlat) = asin(gst_rmu(jlat))
       r1mua(jlat) = r1sa*r1mui(jlat)
    enddo

    !     2. COMPLETION FOR THE SOUTHERN HEMISPHERE
    !     --------------------------------------

    do jlat = njlath_l +1, nj_l
       gst_rmu(jlat)   =  -gst_rmu(2*njlath_l +1 - jlat)
       rwocs(jlat) =   rwocs(2*njlath_l +1 - jlat)
       r1mu2(jlat) =   r1mu2(2*njlath_l +1 - jlat)
       gst_rsqm2(jlat) =   gst_rsqm2(2*njlath_l +1 - jlat)
       gst_r1qm2(jlat) =   gst_r1qm2(2*njlath_l +1 - jlat)
       r1mui(jlat) =   r1mui(2*njlath_l +1 - jlat)
       r1mua(jlat) =   r1mua(2*njlath_l +1 - jlat)
       gst_rwt(jlat)   =   gst_rwt(2*njlath_l +1 - jlat)
       gst_rlati(jlat) = - gst_rlati (2*njlath_l +1 - jlat)
    enddo

    zpisu2 = rpi/2.
    do jlat = 1, nj_l
       rcolat(jlat) = zpisu2 - gst_rlati(jlat)
    enddo

    !*    3. Overdimensioning for interpolation

    if(njsur_l.ge.2) then
       gst_rmu  (-1) =   gst_rmu  (1)
       r1mu2(-1) =   r1mu2(1)
       gst_rsqm2(-1) =   gst_rsqm2(1)
       gst_r1qm2(-1) =   gst_r1qm2(1)
       r1mui(-1) =   r1mui(1)
       r1mua(-1) =   r1mua(1)
       gst_rlati(-1) =   rpi-gst_rlati(1)

       gst_rmu  (0) =   1.
       r1mu2(0) =   0.
       gst_rsqm2(0) =   0.
       gst_r1qm2(0) =   rinfini
       r1mui(0) =   rinfini
       r1mua(0) =   rinfini
       gst_rlati(0) =   rpi*.5

       gst_rmu  (nj_l+1) =  -1.
       r1mu2(nj_l+1) =   0.
       gst_rsqm2(nj_l+1) =   0.
       gst_r1qm2(nj_l+1) =   rinfini
       r1mui(nj_l+1) =   rinfini
       r1mua(nj_l+1) =   rinfini
       gst_rlati(nj_l+1) =  -rpi*.5

       gst_rmu  (nj_l+2) =   gst_rmu  (nj_l)
       r1mu2(nj_l+2) =   r1mu2(nj_l)
       gst_rsqm2(nj_l+2) =   gst_rsqm2(nj_l)
       gst_r1qm2(nj_l+2) =   gst_r1qm2(nj_l)
       r1mui(nj_l+2) =   r1mui(nj_l)
       r1mua(nj_l+2) =   r1mua(nj_l)
       gst_rlati(nj_l+2) =   -rpi-gst_rlati(nj_l)
    end if

    !*    4. Print the content of GAUS

    write(*,fmt='(" JLAT:",4X," RLATI",8X,"RCOLAT",8X,"RMU",10X ,"RWT",12X,"RW0CS")')
    do jlat = 1, nj_l
       write(*,fmt='(2X,I4,5(2X,G23.16))')  &
            jlat,gst_rlati(jlat),rcolat(jlat), gst_rmu(jlat)  &
            ,gst_rwt(jlat),rwocs(jlat)
    enddo

    write(kulout,fmt='(//," JLAT:",4X,"R1MU2",8X,"RSQM2",9X,"R1QM2",10X,"R1MUI",10X,"R1MUA")')

    do jlat = 1, nj_l
       write(kulout,fmt='(2X,I4,5(2X,G23.16))') jlat,r1mu2(jlat),gst_rsqm2(jlat),gst_r1qm2(jlat)  &
            ,r1mui(jlat),r1mua(jlat)
    enddo

    !*    5.  Positioning within spectral arrays

    do jm = 0, ntrunc_l
       gst_nind(jm)   = jm*(ntrunc_l+1) - (jm*(jm-1))/2 + 1
       nindrh(jm) = jm*(ntrunc_l+1) + 1
       nclm(jm)   = ntrunc_l - jm + 1
    enddo

    write(*,fmt='(/," NIND(0:NTRUNC_L):",/,10(2X,I8))')  &
         (gst_nind(jm),jm=0,ntrunc_l)
    write(*,fmt='(" NINDRH(0:NTRUNC_L):",/,10(2X,I8))')  &
         (nindrh(jm),jm=0,ntrunc_l)
    write(*,fmt='("   NCLM(0:NTRUNC_L):",/,10(2X,I8))')  &
         (nclm(jm),jm=0,ntrunc_l)

  END SUBROUTINE SULEG

  SUBROUTINE GAUSS8(NRACP,RACP,PG,SIA,RAD,PGSSIN2,SINM1,SINM2,SIN2)
    implicit none

    integer nracp
    real*8 racp(*),pg(*),rad(*),pgssin2(*),sinm2(*),sin2(*),sia(*),sinm1(*)
!    real*8, pointer :: sia(:),sinm1(:)
    real*8 xlim,pi,fi,fi1,fn,dot,dn,dn1,a,b,c,g,gm,gp,gt,ractemp,gtemp
    integer i,ir,irm,irp

    xlim=1.d-13
    pi = 4.d0*atan(1.d0)
    ir = 2*nracp
    fi=dble(ir)
    fi1=fi+1.d0
    fn=dble(nracp)

    do i=1,nracp
       dot=dble(i-1)
       racp(i)=-pi*.5d0*(dot+.5d0)/fn + pi*.5d0
       racp(i) =  sin(racp(i))
    enddo

    dn = fi/sqrt(4.d0*fi*fi-1.d0)
    dn1=fi1/sqrt(4.d0*fi1*fi1-1.d0)
    a = dn1*fi
    b = dn*fi1
    irp = ir + 1
    irm = ir -1

    do i=1,nracp
42     call ordleg8(g,racp(i),ir)
       call ordleg8(gm,racp(i),irm)
       call ordleg8(gp,racp(i),irp)
       gt = (a*gp-b*gm)/(racp(i)*racp(i)-1.d0)
       ractemp = racp(i) - g/gt
       gtemp = racp(i) - ractemp
       racp(i) = ractemp
       if( abs(gtemp).gt.xlim) go to 42
    enddo

    do i=1,nracp
       a=2.d0*(1.-racp(i)**2)
       call ordleg8(b,racp(i),irm)
       b = b*b*fi*fi
       pg(i)=a*(fi-.5d0)/b
       rad(i) =   acos(racp(i))
       sia(i) =  sin(rad(i))
       c=(sia(i))**2
       sinm1(i) = 1.d0/sia(i)
       sinm2(i) = 1.d0/c
       pgssin2(i) =pg(i)/c
       sin2(i)=c
    enddo

    return
  END SUBROUTINE GAUSS8

  SUBROUTINE ORDLEG8(SX,COA,IR)
    implicit none

    real*8 sx,coa
    integer ir
    integer n,kk,k,n1,irpp,irppm
    real*8 pi,sqr2,delta,sia,theta,c1,c4,s1,ang,fk,fn,fn2,fn2sq,a,b

    pi    = 4.d0*atan(1.d0)
    sqr2  = sqrt(2.d0)
    irpp  = ir   + 1
    irppm = irpp - 1
    delta = acos(coa)
    sia   = sin(delta)

    theta = delta
    c1    = sqr2

    do n=1,irppm
       fn2   = dble(2*n)
       fn2sq = fn2*fn2
       c1    =  c1*sqrt(1.d0 - 1.d0/fn2sq)
    enddo

    n   = irppm
    fn  = dble(n)
    ang = fn*theta
    s1  = 0.d0
    c4  = 1.d0
    a   =-1.d0
    b   = 0.d0
    n1  = n+1

    do kk=1,n1,2
       k   = kk-1
       if (k.eq.n) c4 = 0.5d0*c4
       s1  = s1+c4* cos(ang)
       a   =  a+2.d0
       b   =  b+1.d0
       fk  = dble(k)
       ang = theta*(fn-fk-2.d0)
       c4  = ( a * (fn-b+1.d0) / (b*(fn2-a)) )*c4
    enddo

    sx = s1*c1

    return
  END SUBROUTINE ORDLEG8


  SUBROUTINE SUALP
    implicit none

    integer jj,jgl,jm,jn,ilat
    integer ilen,ilarh,ila,ilatbd,ierr
    real*8  dlalp(nlarh_l,nlatbd), dldalp(nlarh_l,nlatbd)
    real*8  dldelalp(nlarh_l,nlatbd)
    !     
    !     Memory allocation for Legendre polynomials
    !     
    write(*,*) 'allocating dalp:',nla_l,njlath_l,nla_l*njlath_l
    allocate( dalp(nla_l,njlath_l), dealp(nla_l,njlath_l))
    write(*,*) 'succeeded'

    latitudes: do jgl = 1, njlath_l, nlatbd
       ilatbd = min(nlatbd,njlath_l - jgl + 1)

       if(ilatbd.eq.8) then
          call allp(dlalp,dldalp,gst_rmu(jgl),nclm(0),0,ntrunc_l,ilatbd)
       else
          call allp2(dlalp,dldalp,gst_rmu(jgl),nclm(0),0,ntrunc_l,ilatbd)
       endif

       do jm=0,ntrunc_l
          do jn=jm,ntrunc_l
             ila=gst_nind(jm) + jn -jm
             ilarh=nindrh(jm) + jn-jm
             do jj=1,ilatbd
                ilat = jgl+jj-1
                dalp (ila,jgl+jj-1)=dlalp (ilarh,jj)
                dealp(ila,jgl+jj-1)=dldalp(ilarh,jj)
             enddo
          enddo
       enddo
    enddo latitudes

  END SUBROUTINE SUALP


  SUBROUTINE GETALP(DDALP,DDDALP,KLATH,KTRUNC,KTRUNCDIM ,KM)
    implicit none

    integer km,klath,ktrunc, ktruncdim
    integer ila,ind
    integer jlat,jn, jlen
    real*8  ddalp(0:ktruncdim,klath), dddalp(0:ktruncdim,klath)

    do jlat = 1,klath
       do jlen = 0, ktrunc
          ddalp(jlen,jlat) = 0.d0
          dddalp(jlen,jlat)= 0.d0
       end do
    end do

    do jlat = 1, klath
       do jn = km, ktrunc
          ila = gst_nind(km) + jn-km
          ind=jn-km
          ddalp(ind,jlat) =  dalp(ila,jlat)
          dddalp(ind,jlat) = dealp(ila,jlat)
       end do
    end do

    return
  END SUBROUTINE GETALP


  SUBROUTINE ALLP( P , G , X , LR , HEM , R , NLATP) 

    implicit none 
    integer r, nlatp, lr(0:r), hem 
    real *8 p(0:r,0:r,nlatp) , g(0:r,0:r,nlatp) 
    real *8 x(nlatp) 

    real*8 onehalf   
    real*8 xp , xp2,  p0, enm, fnm
    integer ilat , m , l , n

    data onehalf /0.5/

    do ilat=1,nlatp
       xp2 = sqrt( 1.0 - x(ilat) ** 2 ) 
       p(0,0,ilat) = sqrt(onehalf) 
       do m=1,r 
          xp = float(m)
          p(0,m,ilat) = sqrt( (2.0*xp+1.0)/(2.0*xp) ) * xp2 * p(0,m-1,ilat)
       enddo
    enddo

    do ilat=1,nlatp
       do m=0,r 
          xp = float(m)
          g(0,m,ilat) = - x(ilat)*xp * p(0,m,ilat) 
       enddo
    enddo
    do n=1,r
       do m=0,lr(n)-1
          l =  1
          p0 = float(m+n)
          xp = float(m)
          enm = sqrt( ((p0*p0-xp*xp)*(2.0*p0+1.0))/(2.0*p0-1.0) )
          fnm = sqrt( (2.0*p0+1.0)/((p0*p0-xp*xp)*(2.0*p0-1.0)) )

          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
       enddo
    enddo

    return
  END SUBROUTINE ALLP


  SUBROUTINE ALLP2( P , G , X , LR , HEM , R , NLATP)

    implicit none
    integer r, nlatp, lr(0:r), hem, jlat
    real*8 p(0:r,0:r,nlatp) , g(0:r,0:r,nlatp) 
    real*8 x(nlatp)

    real*8 onehalf   
    real*8 xp , xp2,  p0, enm, fnm
    integer ilat , m , l , n

    data onehalf /0.5/

    do ilat=1,nlatp
       xp2 = sqrt( 1.0 - x(ilat) ** 2 )
       p(0,0,ilat) = sqrt(onehalf)
       do m=1,r
          xp = float(m)
          p(0,m,ilat) = sqrt( (2.0*xp+1.0)/(2.0*xp) ) * xp2 * p(0,m-1,ilat)
       enddo
    enddo

    do ilat=1,nlatp
       do m=0,r
          xp = float(m)
          g(0,m,ilat) = - x(ilat)*xp * p(0,m,ilat)
       enddo
    enddo

    do n=1,r
       do m=0, r
          p0 = float(m+n)
          xp = float(m)
          enm = sqrt( ((p0*p0-xp*xp)*(2.0*p0+1.0))/(2.0*p0-1.0) )
          fnm = sqrt( (2.0*p0+1.0)/((p0*p0-xp*xp)*(2.0*p0-1.0)) )

          do jlat = 1, nlatp
             l = jlat
             p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) - g(n-1,m,l) ) * fnm
             g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l)
          enddo
       enddo
    enddo

    return
  END SUBROUTINE ALLP2


END MODULE GLBSPEC_MOD
