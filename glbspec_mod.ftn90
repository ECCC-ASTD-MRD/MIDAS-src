!--------------------------------------------------------------------------
! MODULE glbspec_mod (Global Spectral Transform: prefix="gst")
!
! Purpose: Perform global spectral transform. Uses the fft_mod module for
!          the FFT part of the transform.
!
! Subroutines:
!    gst_setup (public)
!    gst_speree    (public)
!    gst_reespe    (public)
!    gst_spgd      (public)
!    gst_spgda     (public)
!    spereepar
!    reespepar
!    sppar
!    spgdapar
!    legdir3
!    leginv3
!    allocate_comleg
!    suleg
!    gauss8
!    ordleg8
!    sualp
!    getalp
!    allp
!    allp2
!
! Public variables:
!    gst_rmu
!    gst_rwt
!    gst_nind
!    gst_rlati
!    gst_r1qm2
!    gst_rsqm2
!
! Dependencies:
!    fft_mod
!--------------------------------------------------------------------------
MODULE GLBSPEC_MOD

  implicit none
  save
  private

  ! public subroutines
  public :: gst_speree,gst_reespe,gst_setup,gst_spgd,gst_spgda,gst_zlegpol,gst_setID,gst_setToDefaultID
  ! public functions
  public :: gst_getRmu,gst_getRwt,gst_getnind,gst_getrlati,gst_getr1qm2,gst_getrsqm2,gst_getrnnp1

  type  :: T_gst
    real*8,allocatable   :: rmu(:)
    real*8,allocatable   :: rwt(:)
    real*8,allocatable   :: rsqm2(:)
    real*8,allocatable   :: r1qm2(:)
    real*8,allocatable   :: rlati(:)
    integer,allocatable  :: nind(:)
    integer,allocatable  :: nindrh(:)
    real*8,allocatable   :: dalp(:,:)
    real*8,allocatable   :: dealp(:,:)
    real*8,allocatable   :: rwocs(:)
    real*8,allocatable   :: r1mu2(:)
    real*8,allocatable   :: rcolat(:)
    real*8,allocatable   :: r1mui(:)
    real*8,allocatable   :: r1mua(:)
    integer,allocatable  :: nclm(:)
    real*8,allocatable   :: r1snp1(:)
    real*8,allocatable   :: rnnp1(:)
    integer              :: ntrunc
    integer              :: nla
    integer              :: nlarh
    integer              :: njlath
    integer              :: ni
    integer              :: nibeg
    integer              :: niend
    integer              :: nisur
    integer              :: nj
    integer              :: njbeg
    integer              :: njend
    integer              :: njsur
  end type T_gst

  integer,parameter :: nMaxGst = 10
  integer,parameter :: gstIdDefault = 1
  integer      :: nGstAlreadyAllocated = 0
  integer      :: gstID = 0
  type(T_gst)  :: gst(nmaxgst)

  real*8               :: rinfini,rpi,r1sa
  integer              :: nlatbd = 8

CONTAINS

  SUBROUTINE GST_setID(gstID_in)
    implicit none

    integer :: gstID_in
  
    gstID = gstID_in

  END SUBROUTINE GST_setID


  SUBROUTINE GST_setToDefaultID
    implicit none

    gstID = gstIdDefault

  END SUBROUTINE GST_setToDefaultID


  real*8 FUNCTION GST_getRmu(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in

    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getRmu=gst(gstID_l)%rmu(latIndex)

  END FUNCTION GST_getRmu


  real*8 FUNCTION GST_getRnnp1(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in

    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getRnnp1=gst(gstID_l)%rnnp1(latIndex)

  END FUNCTION GST_getRnnp1


  real*8 FUNCTION GST_getRwt(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in
  
    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getRwt=gst(gstID_l)%rwt(latIndex)

  END FUNCTION GST_getRwt


  real*8 FUNCTION GST_getNind(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in
  
    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getNind=gst(gstID_l)%nind(latIndex)

  END FUNCTION GST_getNind


  real*8 FUNCTION GST_getRlati(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in
 
    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getRlati=gst(gstID_l)%rlati(latIndex)

  END FUNCTION GST_getRlati


  real*8 FUNCTION GST_getR1qm2(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in
  
    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getR1qm2=gst(gstID_l)%r1qm2(latIndex)

  END FUNCTION GST_getR1qm2


  real*8 FUNCTION GST_getRsqm2(latIndex,gstID_in)
    implicit none

    integer :: latIndex,gstID_l
    integer,optional :: gstID_in

    if(present(gstID_in)) then
      gstID_l=gstID_in
    else
      gstID_l=gstIdDefault
    endif

    gst_getRsqm2=gst(gstID_l)%rsqm2(latIndex)

  END FUNCTION GST_getRsqm2


  integer FUNCTION GST_SETUP(KULOUT,NI_IN,NJ_IN,NTRUNC_IN)
    use fft_mod
    implicit none
    integer kulout,ni_in,nj_in,ntrunc_in
    integer jn,jm,ila
    real*8   :: ra,znnp1,z1snp1

    if(nGstAlreadyAllocated.eq.nMaxGst) then
      write(*,*) 'The maxmimum number of spectral transform have already been allocated! ',nMaxGst
      call abort3d(6,'Aborted in gst_setup')
    endif

    nGstAlreadyAllocated=nGstAlreadyAllocated+1
    gstID=nGstAlreadyAllocated
    write(*,*) 'Now setting up spectral transform #',gstID

    gst(gstID)%nisur=2
    gst(gstID)%njsur=2
    gst(gstID)%ni=ni_in
    gst(gstID)%nj=nj_in
    gst(gstID)%nibeg=0
    gst(gstID)%niend=gst(gstID)%ni+gst(gstID)%nisur
    gst(gstID)%njbeg=1-gst(gstID)%njsur
    gst(gstID)%njend=gst(gstID)%nj+gst(gstID)%njsur
    gst(gstID)%njlath = (gst(gstID)%nj + 1)/2

    gst(gstID)%ntrunc=ntrunc_in
    gst(gstID)%nla=(gst(gstID)%ntrunc + 1)*(gst(gstID)%ntrunc +2)/2
    gst(gstID)%nlarh = (gst(gstID)%ntrunc+1)*(gst(gstID)%ntrunc+1)
    write(*,*) 'ntrunc=',gst(gstID)%ntrunc
    write(*,*) 'nibeg,niend,njbeg,njend=',gst(gstID)%nibeg,gst(gstID)%niend,gst(gstID)%njbeg,gst(gstID)%njend


    rpi=2.0d0*asin(1.0d0)
    ra=6371229.d0
    r1sa=1.d0/dble(ra)
    rinfini = 1.d+35

    write(*,*) 'allocating comleg...'
    call allocate_comleg
    write(*,*) 'calling suleg...'
    call suleg(kulout)
    write(*,*) 'calling sualp...'
    call sualp
    write(*,*) 'calling sufft...'
    call fft_sufft(6,gst(gstID)%ni,gst(gstID)%nj)

    allocate(gst(gstID)%r1snp1(gst(gstID)%nla))
    allocate(gst(gstID)%rnnp1(gst(gstID)%nla))
    gst(gstID)%r1snp1(1) = 0.
    gst(gstID)%rnnp1(1) = 0.
    do jn = 1, gst(gstID)%ntrunc
       znnp1  = -float(jn)*float(jn+1)
       z1snp1 =  1./znnp1
       do jm = 0, jn
          ila = gst(gstID)%nind(jm) + jn - jm
          gst(gstID)%r1snp1(ila) = z1snp1
          gst(gstID)%rnnp1(ila) = znnp1
       enddo
    enddo
    gst_setup=gstID
  
  END FUNCTION GST_SETUP

  SUBROUTINE GST_SPGD(SP,GD,KFIELD,NFLEV,KDIM)
    use fft_mod
    implicit none

    integer kfield,nflev,kdim
    real*8 sp(gst(gstID)%nla,2,kdim), gd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)
    integer  ji,jj,jla,jgl, jk, jlon, ilonmax
    real*8 zfmla(gst(gstID)%ni,kfield,gst(gstID)%nj), zsp(gst(gstID)%nla,2)
    real*8 zgdxy(gst(gstID)%ni,gst(gstID)%nj)

!*  1. Inverse Legendre transform
!      --------------------------
      call sppar(sp,gd,kfield,nflev,kdim)

!   2.1 Reset to zero the modes that are not part of the truncation
!       -----------------------------------------------------------
      ilonmax = gst(gstID)%niend
      do jgl = 1, gst(gstID)%nj
         do jlon = 2*(gst(gstID)%ntrunc+1)+1, ilonmax
            do  jk = 1, kfield
               gd(jlon,jk,jgl) = 0.
            enddo
         enddo
      enddo

      do jgl =1,gst(gstID)%nj
         do jk = 1, kfield
            gd(0,jk,jgl) = 0.
         enddo
      enddo

!     2.2 Apply the FFT 
!         -------------
      call fft_fft3dvar(gd,gst(gstID)%nibeg,gst(gstID)%niend,kfield,gst(gstID)%njbeg,gst(gstID)%njend,kfield,+1)

  END SUBROUTINE GST_SPGD


  SUBROUTINE SPPAR(SP,GD,KFIELD,NFLEV,KDIM)
!**s/r SPPAR  - Inverse spectral transform(PARALLEL LOOP)

    implicit none

    integer kfield,nflev,kdim
    real*8 sp(gst(gstID)%nla,2,kdim), gd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)

    ! local variables
    integer isiz
    integer ilen, jj, jlatn, jlats ,jm, ilonr,ilonim
    integer jk ,jn, ila, inm, jm0, jns, ins, jk2
    integer :: i_njlath, i_nj

    real*8 zjm
    real*8 dlalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath), dldalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath)
    real*8 zfms(gst(gstID)%njlath+1,2,kfield), zfma(gst(gstID)%njlath+1,2,kfield)
    real*8 dlsp(0:gst(gstID)%ntrunc,2,kfield)

    integer  thdid,numthd,omp_get_thread_num,omp_get_num_threads

    ! 1. Set up according to the desired grid (staggered or not)
    !    ---------------------
    i_nj = gst(gstID)%nj
    i_njlath = gst(gstID)%njlath

    ! 2. Inverse Legendre transform
    !    --------------------------

    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,ZFMS,ZFMA,JLATN,JLATS) &
    !$OMP  PRIVATE(INM,ILA,JM,JN,JK,JJ,ZJM,JNS,INS,ILONR,ILONIM) &
    !$OMP  PRIVATE(thdid,numthd)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, gst(gstID)%ntrunc/2,numthd
       ins=1
       if(jm0.eq.gst(gstID)%ntrunc-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(gst(gstID)%ntrunc - jm0)

          ! 2.1 Copy global spectral state into local spectral state
          do jn = jm, gst(gstID)%ntrunc
             ila = gst(gstID)%nind(jm) + jn - jm
             inm = jn - jm
             do jk = 2*nflev+1, kfield
                dlsp(inm,1,jk) = sp(ila,1,jk)
                dlsp(inm,2,jk) = sp(ila,2,jk)
             enddo
             do jk = 1, 2*nflev
                dlsp(inm,1,jk) = sp(ila,1,jk)*gst(gstID)%r1snp1(ila)
                dlsp(inm,2,jk) = sp(ila,2,jk)*gst(gstID)%r1snp1(ila)
             enddo
          enddo

          ! 2.2  Get Legendre polynomial (and its derivative) for all latitudes
          !      but for the chosen value of "m" from the global array
          call getalp (dlalp,dldalp,i_njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc,jm)

          ! 2.3  Perform the inverse Legendre transform for all fields
          call leginv3(jm,zfms,zfma,dlsp,dlalp,kfield,i_njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc)

          ! 2.4 Passage to Fourier space
          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          zjm = float(jm)
          do jj = 1, i_njlath
             jlatn = jj
             jlats = i_nj - jlatn + 1
             do  jk = 2*nflev+1, kfield
                gd(ilonr,jk,jlatn) = zfms(jj,1,jk) + zfma(jj,1,jk)
                gd(ilonim,jk,jlatn) = zfms(jj,2,jk) + zfma(jj,2,jk)
                gd(ilonr,jk,jlats) = zfms(jj,1,jk) - zfma(jj,1,jk)
                gd(ilonim,jk,jlats) = zfms(jj,2,jk) - zfma(jj,2,jk)
             enddo

             do jk = 1, nflev
                jk2= jk + nflev
                gd(ilonr,jk,jlatn)  = -zjm*(zfms(jj,2,jk+nflev) + zfma(jj,2,jk+nflev))
                gd(ilonim,jk,jlatn) = zjm*(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                gd(ilonr,jk,jlats)  = -zjm*(zfms(jj,2,jk+nflev) - zfma(jj,2,jk+nflev))
                gd(ilonim,jk,jlats) = zjm*(zfms(jj,1,jk+nflev) - zfma(jj,1,jk+nflev))

                gd(ilonr,jk2,jlatn)  = -zjm*(zfms(jj,2,jk) + zfma(jj,2,jk))
                gd(ilonim,jk2,jlatn) = zjm*(zfms(jj,1,jk) + zfma(jj,1,jk))
                gd(ilonr,jk2,jlats)  = -zjm*(zfms(jj,2,jk) - zfma(jj,2,jk))
                gd(ilonim,jk2,jlats) = zjm*(zfms(jj,1,jk) - zfma(jj,1,jk))
             enddo
          enddo

          ! 2.5 Completion of the computation of the winds in Fourier space
          !     -----------------------------------------------------------

          call leginv3 (jm, zfma,zfms,dlsp,dldalp,2*nflev, i_njlath, gst(gstID)%ntrunc, gst(gstID)%ntrunc)

          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          zjm    = float(jm)
          do jj = 1, i_njlath
             jlatn = jj
             jlats = i_nj - jlatn + 1

             if(jlatn.ne.jlats) then
                do jk = 1,nflev
                   jk2= jk + nflev
                   ! northern latitudes
                   gd(ilonr,jk,jlatn)  = gd(ilonr,jk,jlatn)  -(zfms(jj,1,jk) + zfma(jj,1,jk))
                   gd(ilonim,jk,jlatn) = gd(ilonim,jk,jlatn) -(zfms(jj,2,jk) + zfma(jj,2,jk))

                   gd(ilonr,jk2,jlatn) = gd(ilonr,jk2,jlatn) +(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlatn)= gd(ilonim,jk2,jlatn)+(zfms(jj,2,jk+nflev) + zfma(jj,2,jk+nflev))
                   ! southern latitudes
                   gd(ilonr,jk,jlats) = gd(ilonr,jk,jlats)   -(zfms(jj,1,jk) - zfma(jj,1,jk))
                   gd(ilonim,jk,jlats)= gd(ilonim,jk,jlats)  -(zfms(jj,2,jk) - zfma(jj,2,jk))
                   gd(ilonr,jk2,jlats) = gd(ilonr,jk2,jlats) +(zfms(jj,1,jk+nflev) - zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlats)= gd(ilonim,jk2,jlats)+(zfms(jj,2,jk+nflev) - zfma(jj,2,jk+nflev))
                enddo
             else
                ! Special case for the equator
                do jk = 1, nflev
                   jk2= jk + nflev
                   gd(ilonr,jk,jlatn)  = gd(ilonr,jk,jlatn)  -(zfms(jj,1,jk) + zfma(jj,1,jk))
                   gd(ilonim,jk,jlatn) = gd(ilonim,jk,jlatn) -(zfms(jj,2,jk)+ zfma(jj,2,jk))
                   gd(ilonr,jk2,jlatn) = gd(ilonr,jk2,jlatn) +(zfms(jj,1,jk+nflev) + zfma(jj,1,jk+nflev))
                   gd(ilonim,jk2,jlatn)= gd(ilonim,jk2,jlatn)+(zfms(jj,2,jk+nflev)+ zfma(jj,2,jk+nflev))
                enddo
             end if
          enddo

       enddo
!     end loop on m
    enddo
    !$OMP END PARALLEL

  END SUBROUTINE SPPAR


  SUBROUTINE GST_SPGDA(SP,GD,KFIELD,NFLEV,KDIM)
    use fft_mod
    implicit none

    integer kfield,nflev,kdim
    real*8 sp(gst(gstID)%nla,2,kdim), gd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)

    integer :: ilen, jk, jlon, jlat, incpu, isiz, i_nj
    integer ji,jj,jla

    integer idum1,idum2,idum3,idum4
    real*8 zmin,zmax
    real*8 :: zfm(gst(gstID)%ni+2,kfield,gst(gstID)%nj)
    real*8 zfmla(gst(gstID)%ni,kfield,gst(gstID)%nj), zsp(gst(gstID)%nla,2)
    real*8 zgdxy(gst(gstID)%ni,gst(gstID)%nj)

!   1. Fourier transform all fields for all latitudes
!      ----------------------------------------------
    zfm(:,:,:) = 0.d0
    i_nj = gst(gstID)%nj
                                !
    do jk = 1, kfield
       do jlat = 1, i_nj
          do jlon = 1, gst(gstID)%ni
             zfm(jlon,jk,jlat) = gd(jlon,jk,jlat)
          enddo
       enddo
    enddo
!
    call fft_fft3dvar(zfm,1,gst(gstID)%ni+2,kfield,1,i_nj,kfield,-1)

!   2. Direct Legendre transform including wind transformations
!      --------------------------------------------------------
    call spgdapar(sp,zfm,kfield,nflev,kdim)

  END SUBROUTINE GST_SPGDA


  SUBROUTINE SPGDAPAR(SP,ZFM,KFIELD,NFLEV,KDIM)
    use procs_topo
    implicit none

    integer :: kfield,nflev,kdim
    real*8  :: sp(gst(gstID)%nla,2,kdim),zfm(gst(gstID)%ni+2,kdim, gst(gstID)%nj)

    integer isiz
    integer ilen, jj, jk, ilonr, iloni, jm ,ila, inm, jn, jm0, ins, jns
    real*8 :: zjm,dlrwt(gst(gstID)%njbeg:gst(gstID)%njend)
    real*8 ::  dlalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath), dldalp(0:gst(gstID)%ntrunc, gst(gstID)%njlath)
    real*8 :: dlsp(0:gst(gstID)%ntrunc,2,kfield),dlsp2(0:gst(gstID)%ntrunc,2,2*nflev)
    real*8 ::  zfms( gst(gstID)%njlath+1,2,kfield), zfma( gst(gstID)%njlath+1,2,kfield)
    integer :: i_njlath, i_nj

    integer thdid,numthd,omp_get_thread_num,omp_get_num_threads

    !    1. Set up according to the desired grid (staggered or not)
    !       ---------------------
    if(myid == 0) then
      write(*,fmt='(/,4x,A)')'SPGDAPAR- Adjoint of the inverse Legendre transform'
    endif
                                !
    i_nj = gst(gstID)%nj
    i_njlath = gst(gstID)%njlath
    dlrwt(:) = gst(gstID)%rwt(:)
    if (mod(i_nj,2).ne.0) then
       dlrwt(i_njlath) = dlrwt(i_njlath)/2.d0
    end if

    ! 2. Fourier transform all fields for all latitudes
    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,DLSP2,ZFMS,ZFMA) &
    !$OMP  PRIVATE(INM,ILA,JM,JN,JK,JJ,ZJM,JNS,INS,ILONR,ILONI) &
    !$OMP  PRIVATE(thdid,numthd)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, gst(gstID)%ntrunc/2,numthd
       ins=1
       if(jm0.eq.gst(gstID)%ntrunc-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(gst(gstID)%ntrunc - jm0)
          ilonr = 2 * jm + 1
          iloni = ilonr + 1
          zjm   = float(jm)

          ! 2.1 Fetch the Legendre functions and their derivatives for this choice of "m"

!     CRITICAL
             call getalp(dlalp,dldalp,i_njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc,jm)
!     END CRITICAL

          ! 2.2  Build the symmetric and anti-symmetric Fourier coefficients including
          !      the appropriate quadrature weights (see scientific notes)
          do jj = 1, i_njlath

             ! 2.2.1  Coefficients for scalar fields
             do jk = 2*nflev+1, kfield
                ! symmetric coefficients
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj-jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo

             ! 2.2.2 Coefficients associated with the wind fields
             do jk = 1, nflev
                ! vorticity: symmetric coefficients
                zfms(jj,1,jk) = -zjm*dlrwt(jj)*(zfm(iloni,jk+nflev,jj)+zfm(iloni,jk+nflev,1+i_nj-jj))
                zfms(jj,2,jk) = zjm*dlrwt(jj) *(zfm(ilonr,jk+nflev,jj)+zfm(ilonr,jk+nflev,1+i_nj-jj))
                ! vorticity: antisymmetric coefficients
                zfma(jj,1,jk) = -zjm*dlrwt(jj) *(zfm(iloni,jk+nflev,jj)- zfm(iloni,jk+nflev,1+i_nj-jj))
                zfma(jj,2,jk) = zjm*dlrwt(jj)*(zfm(ilonr,jk+nflev,jj)- zfm(ilonr,jk+nflev,1+i_nj-jj))
                ! divergence: symmetric coefficients
                zfms(jj,1,jk+nflev) = -zjm*dlrwt(jj)*(zfm(iloni,jk,jj)+ zfm(iloni,jk,1+i_nj-jj))
                zfms(jj,2,jk+nflev) = zjm*dlrwt(jj)*(zfm(ilonr,jk,jj)+ zfm(ilonr,jk,1+i_nj-jj))
                ! divergence: antisymmetric coefficients
                zfma(jj,1,jk+nflev) = -zjm*dlrwt(jj)*(zfm(iloni,jk,jj)- zfm(iloni,jk,1+i_nj-jj))
                zfma(jj,2,jk+nflev) = zjm*dlrwt(jj)*(zfm(ilonr,jk,jj)- zfm(ilonr,jk,1+i_nj-jj))
             enddo
          enddo

          ! 2.3 First one with ALP for all scalar fields and for half the terms
          !     required to define the divergence and vorticity
!      CRITICAL
          call legdir3 (jm,zfms,zfma,dlsp,dlalp,kfield,i_njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc)
!     END CRITICAL
                                !
          ! 2.4  Second transform with DALP to complete the construction of the
          !      vorticity and divergence fields
          do jj = 1, i_njlath
             do jk = 1, nflev
                ! symmetric coefficients for zonal wind
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj - jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients for zonal wind
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo
             do jk = nflev+1, 2*nflev
                ! symmetric coefficients for meridional wind
                zfms(jj,1,jk) = -dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+i_nj-jj))
                zfms(jj,2,jk) = -dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+i_nj-jj))
                ! antisymmetric coefficients for meridional wind
                zfma(jj,1,jk) = -dlrwt(jj)*(zfm(ilonr,jk,jj) - zfm(ilonr,jk,1+i_nj-jj))
                zfma(jj,2,jk) = -dlrwt(jj)*(zfm(iloni,jk,jj) - zfm(iloni,jk,1+i_nj-jj))
             enddo
          enddo
!      CRITICAL
          call legdir3(jm,zfma,zfms,dlsp2,dldalp,2*nflev,i_njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc)
!     END CRITICAL

          ! 2.5  Transfer the result in the global state
          do jn = jm, gst(gstID)%ntrunc
             ila = gst(gstID)%nind(jm) + jn - jm
             inm = jn - jm
             do jk = 1, 2*nflev
                sp(ila,1,jk) = -gst(gstID)%r1snp1(ila)*(dlsp(inm,1,jk) + dlsp2(inm,1,jk))
                sp(ila,2,jk) = -gst(gstID)%r1snp1(ila)*(dlsp(inm,2,jk) + dlsp2(inm,2,jk))
             enddo
             do jk = 2*nflev+1,kfield
                sp(ila,1,jk) = dlsp(inm,1,jk)
                sp(ila,2,jk) = dlsp(inm,2,jk)
             enddo
          enddo
       ! End of loop on zonal wavenumbers
       enddo
    enddo
    !$OMP END PARALLEL
  END SUBROUTINE SPGDAPAR


  SUBROUTINE GST_SPEREE(PSP,PGD,KFIELD,KDIM)
    use fft_mod
    implicit none

    integer kfield,kdim,itemp,ijump,ilot,julot,infft
    real*8 psp(gst(gstID)%nla,2,kdim), pgd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)
    integer ilen, jgl, jk, jlon, ilonmax

    !    1. Inverse Legendre transform
    !    --------------------------
    call spereepar(psp,pgd,kfield,kdim)

    !     2. Inverse Fourier transform
    !        -------------------------
    !     2.1 Reset to zero the modes that are not part of the truncation
    !         -----------------------------------------------------------
    ilonmax = gst(gstID)%niend
    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JGL,JLON,JK)
    do jgl = 1,gst(gstID)%nj
       do jlon = 2*(gst(gstID)%ntrunc+1)+1, ilonmax
          do  jk = 1, kfield
             pgd(jlon,jk,jgl) = 0.
          enddo
       enddo

       do jk = 1, kfield
          pgd(0,jk,jgl) = 0.
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL

    !     2.2 Apply the FFT 
    !         -------------
    !*    . INVERSE FOURIER TRANSFORM
    !     .  -------------------------
    call fft_fft3dvar(pgd,gst(gstID)%nibeg,gst(gstID)%niend,kfield,gst(gstID)%njbeg,gst(gstID)%njend,kfield,+1)

    return
  END SUBROUTINE GST_SPEREE


  SUBROUTINE GST_REESPE(PSP,PGD,KFIELD,KDIM)
    use fft_mod
    implicit none

    integer :: kfield,kdim
    real*8 psp(gst(gstID)%nla,2,kdim), pgd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)
    !
    integer :: ilen, ji,jj,jk, jlon, jlat,incpu, isiz
    real*8,pointer  :: zfm(:,:,:)
    integer value(8)
    real*8 seconds1,seconds2,seconds3

    allocate(zfm(gst(gstID)%ni+2,kfield,gst(gstID)%nj))

    !     1. Transfer global fields to local array
    call  date_and_time(values=value)
    seconds1=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    !$OMP PARALLEL 
    !$OMP DO PRIVATE (JJ,JK,JI)
    do jj=1,gst(gstID)%nj
       do jk=1,kfield
          do ji=1,gst(gstID)%ni
             zfm(ji,jk,jj) = pgd(ji,jk,jj)
          enddo
       enddo
    enddo
    !$OMP END DO
    !$OMP END PARALLEL
    call  date_and_time(values=value)
    seconds2=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)
    !  write(*,*) 'in reespe, transfer=',seconds2-seconds1

    !     2. Apply the FFT
    call  date_and_time(values=value)
    seconds1=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)
    call fft_fft3dvar(zfm,1,gst(gstID)%ni+2,kfield,1,gst(gstID)%nj,kfield,-1)
    call  date_and_time(values=value)
    seconds2=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    ! 3. Direct Legendre transform
    call reespepar(psp,zfm,kfield,kdim)
    call  date_and_time(values=value)
    seconds3=0.001d0*value(8)+value(7)+60.0d0*value(6)+3600.0d0*value(5)

    !  write(*,*) 'in reespe, fft=',seconds2-seconds1
    !  write(*,*) 'in reespe, leg=',seconds3-seconds2

    deallocate(zfm)

  END SUBROUTINE GST_REESPE


  SUBROUTINE SPEREEPAR(PSP,PGD,KFIELD,KDIM)
    implicit none

    integer kfield,kdim
    real*8 psp(gst(gstID)%nla,2,kdim), pgd(gst(gstID)%nibeg:gst(gstID)%niend,kdim,gst(gstID)%njbeg:gst(gstID)%njend)

    integer isiz
    integer ilen,jj,jlatn, jlats,jm
    integer ilonr,ilonim,jk,jn,ila,inm,jm0,jns,ins

    real*8 dlalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath), dldalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath)
    real*8 zfms(gst(gstID)%njlath+1,2,kfield), zfma(gst(gstID)%njlath+1,2,kfield)
    real*8 dlsp(0:gst(gstID)%ntrunc,2,kfield)

    integer  thdid,numthd,omp_get_thread_num,omp_get_num_threads


    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,DLSP,ZFMS,ZFMA,JLATN,JLATS, &
    !$OMP INM,ILA,JM,JN,JK,JJ,JNS,INS,ILONR,ILONIM,JM0)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, gst(gstID)%ntrunc/2,numthd
       ins=1
       if(jm0.eq.gst(gstID)%ntrunc-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(gst(gstID)%ntrunc - jm0)

          !**   .   2.1 Copy global spectral state into local spectral state

          do jn = jm, gst(gstID)%ntrunc
             ila = gst(gstID)%nind(jm) + jn - jm
             inm = jn - jm
             do jk =1,kfield
                dlsp(inm,1,jk) = psp(ila,1,jk)
                dlsp(inm,2,jk) = psp(ila,2,jk)
             enddo
          enddo

          !     .   2.2  Get Legendre polynomial (and its derivative) for all latitudes
          !     .        but for the chosen value of "m" from the global array

          call getalp(dlalp,dldalp,gst(gstID)%njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc,jm)

          !     .   2.3  Perform the inverse Legendre transform for all fields

          call leginv3(jm, zfms,zfma,dlsp,dlalp,kfield,gst(gstID)%njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc)

          !     .   2.4 Passage to Fourier space

          ilonr  = 2*jm + 1
          ilonim = 2*jm + 2
          do jj = 1, gst(gstID)%njlath
             jlatn = jj
             jlats = gst(gstID)%nj - jj + 1
             do  jk = 1,kfield
                pgd(ilonr,jk,jlatn)  = zfms(jj,1,jk) + zfma(jj,1,jk)
                pgd(ilonim,jk,jlatn) = zfms(jj,2,jk) + zfma(jj,2,jk)
                pgd(ilonr,jk,jlats)  = zfms(jj,1,jk) - zfma(jj,1,jk)
                pgd(ilonim,jk,jlats) = zfms(jj,2,jk) - zfma(jj,2,jk)
             enddo
          enddo
       enddo
    enddo
    !$OMP END PARALLEL

    return
  END SUBROUTINE SPEREEPAR


  SUBROUTINE REESPEPAR(PSP,ZFM,KFIELD,KDIM)
    implicit none

    integer :: kfield,kdim
    real*8  :: psp(gst(gstID)%nla,2,kdim)
    real*8  :: zfm(gst(gstID)%ni+2,kdim, gst(gstID)%nj)

    integer :: ilen, jj, jk,jk2,ilonr, iloni
    integer :: jm, ila, inm, jn, jm0, ins, jns
    real*8  ::  dlalp(0:gst(gstID)%ntrunc,gst(gstID)%njlath)
    real*8  :: dldalp(0:gst(gstID)%ntrunc, gst(gstID)%njlath)
    real*8  ::  dlsp(0:gst(gstID)%ntrunc,2,kfield)
    real*8  ::  zfms( gst(gstID)%njlath+1,2,kfield), zfma( gst(gstID)%njlath+1,2,kfield)
    real*8  :: dlrwt(gst(gstID)%njbeg:gst(gstID)%njend)

    integer :: thdid,numthd,omp_get_thread_num,omp_get_num_threads

    !     1. Adjustment needed when an odd number of latitudes is considered
    !     --------------------------------------------------------------------
    dlrwt(:)   = gst(gstID)%rwt(:)
    if (mod(gst(gstID)%nj,2).ne.0) then
       dlrwt(gst(gstID)%njlath)   = dlrwt(gst(gstID)%njlath)/2.d0
    end if

    !$OMP PARALLEL PRIVATE(DLALP,DLDALP,JM0,DLSP,ZFMS,ZFMA,thdid,numthd, &
    !$OMP   INM,ILA,JM,JN,JK,JK2,JJ,JNS,INS,ILONR,ILONI)
    thdid = omp_get_thread_num()
    numthd= omp_get_num_threads()
    do jm0 = thdid, gst(gstID)%ntrunc/2,numthd
       ins=1
       if(jm0.eq.gst(gstID)%ntrunc-jm0) ins = 0
       do jns = 0,ins
          jm = (1-jns)*jm0 + jns*(gst(gstID)%ntrunc - jm0)
          ilonr = 2 * jm + 1
          iloni = ilonr + 1

          !**  .  2.1 Fetch the Legendre functions and their derivatives for this choice of "m"

          call getalp(dlalp,dldalp,gst(gstID)%njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc,jm)

          !    .  2.2  Build the symmetric and anti-symmetric Fourier coefficients including
          !    .       the appropriate quadrature weights (see scientific notes)

          do jj = 1, gst(gstID)%njlath
             do jk = 1,kfield
                !     .                       Symmetric coefficients
                zfms(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) + zfm(ilonr,jk,1+gst(gstID)%nj-jj))
                zfms(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) + zfm(iloni,jk,1+gst(gstID)%nj-jj))
                !     .                       Antisymmetric coefficients
                zfma(jj,1,jk) = dlrwt(jj)*(zfm(ilonr,jk,jj) -  zfm(ilonr,jk,1+gst(gstID)%nj-jj))
                zfma(jj,2,jk) = dlrwt(jj)*(zfm(iloni,jk,jj) -  zfm(iloni,jk,1+gst(gstID)%nj-jj))
             enddo
          enddo

          !     .   2.3 First one with ALP for all scalar fields and for half the terms
          !     .        required to define the divergence and vorticity

          call legdir3 (jm,zfms,zfma,dlsp,dlalp,kfield,gst(gstID)%njlath,gst(gstID)%ntrunc,gst(gstID)%ntrunc)

          !     .    2.5  Transfer the result in the global state

          do jn = jm, gst(gstID)%ntrunc
             ila = gst(gstID)%nind(jm) + jn - jm
             inm = jn - jm
             do jk2 = 1,kfield
                psp(ila,1,jk2) = dlsp(inm,1,jk2)
                psp(ila,2,jk2) = dlsp(inm,2,jk2)
             enddo
          enddo

          !     End of loop on zonal wavenumbers

       enddo
    enddo
    !$OMP END PARALLEL

    return
  END SUBROUTINE REESPEPAR


  SUBROUTINE LEGDIR3 (KM,PFMS,PFMA,DDSP,DDALP,KDIM,KLATH,KTRUNC,KTRUNCDIM)
    implicit none

    integer km, kdim, ktrunc, ktruncdim, klath
    real*8    pfms(gst(gstID)%njlath+1,2*kdim),pfma(gst(gstID)%njlath+1,2*kdim)
    real*8 ddalp(0:ktruncdim,klath)
    real*8  ddsp(0:ktruncdim,2*kdim)

    integer jk, jlat, jn, inm, itrunc, inmp1, jind, ink

    itrunc = ktrunc
    if(mod(ktrunc-km+1,2).eq.1) itrunc = ktrunc-1

    if(km.ne.ktrunc)then
       ddsp(0:ktrunc,1:2*kdim)=0.d0
       do jlat = 1,klath
          do jk = 1,2*kdim
             do jn = km, itrunc, 2
                inm = jn - km
                inmp1 = inm + 1
                ddsp(inm,jk)   = ddsp(inm,jk) +  ddalp(inm  ,jlat)*pfms(jlat,jk)
                ddsp(inmp1,jk) = ddsp(inmp1,jk)+ ddalp(inmp1,jlat)*pfma(jlat,jk)
             enddo
          enddo
       enddo
    end if

    if(mod(ktrunc-km+1,2).eq.1) then
       jn = ktrunc
       inm = jn - km
       ddsp(inm,1:2*kdim)=0.d0

       do jlat = 1,klath
          do jk = 1,2*kdim
             ddsp(inm,jk) = ddsp(inm,jk) + ddalp(inm,jlat)*pfms(jlat,jk )
          enddo
       enddo
    end if

    return
  END SUBROUTINE LEGDIR3


  SUBROUTINE LEGINV3 (KM,PFMS,PFMA,DDSP,DDALP,KDIM, KLATH ,KTRUNC,KTRUNCDIM)
    implicit none

    integer km, kdim, ktrunc, ktruncdim, klath
    real*8 pfms(gst(gstID)%njlath+1,2*kdim),pfma(gst(gstID)%njlath+1,2*kdim)
    real*8 ddalp(0:ktruncdim,klath)
    real*8  ddsp(0:ktruncdim,2*kdim)

    integer jk, jlat, jn, inm, ilen ,itrunc, inmp1, jind, ink
    integer i,j

    ilen=(klath+1)*2*kdim
    pfms(:,:) = 0.d0
    pfma(:,:) = 0.d0

    itrunc = ktrunc
    if(mod(ktrunc-km+1,2).eq.1) itrunc = ktrunc-1

    if(km.ne.ktrunc)then
       do jlat = 1,klath
          do jk = 1,2*kdim
             do jn = km, itrunc, 2
                inm = jn - km
                inmp1  = inm + 1
                pfms(jlat,jk) = pfms(jlat,jk) + ddalp(inm,jlat) * ddsp(inm,jk)
                pfma(jlat,jk) = pfma(jlat,jk) + ddalp(inmp1,jlat) * ddsp(inmp1,jk)
             enddo
          enddo
       enddo
    end if

    if(mod(ktrunc-km+1,2).eq.1) then
       jn = ktrunc
       if ( km .ne. ktrunc) then
          inm = jn - km
          do jlat = 1,klath
             do jk = 1,2*kdim
                pfms(jlat,jk) = pfms(jlat,jk) + ddalp(inm,jlat) * ddsp(inm,jk)
             enddo
          enddo
       else
          inm = jn - km
          do jlat = 1,klath
             do jk = 1,2*kdim
                pfms(jlat,jk) = ddalp(inm,jlat) * ddsp(inm,jk)
             enddo
          enddo
       end if
    end if

    return
  END SUBROUTINE LEGINV3


  SUBROUTINE ALLOCATE_COMLEG
    implicit none

    allocate(gst(gstID)%rmu(gst(gstID)%njbeg:gst(gstID)%njend))  
    allocate(gst(gstID)%rwt(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%rwocs(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%r1mu2(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%rsqm2(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%rcolat(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%r1qm2(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%r1mui(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%r1mua(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%rlati(gst(gstID)%njbeg:gst(gstID)%njend))
    allocate(gst(gstID)%nind(0:gst(gstID)%ntrunc))
    allocate(gst(gstID)%nindrh(0:gst(gstID)%ntrunc))
    allocate(gst(gstID)%nclm(0:gst(gstID)%ntrunc))

  END SUBROUTINE ALLOCATE_COMLEG


  SUBROUTINE SULEG(KULOUT)
    !
    !**s/r SULEG  - Initialisation of Gaussian latitudes, weights and related
    !     .         quantities
    implicit none

    integer kulout, jlat, jm
    real*8 zpisu2
    external gauss

    write(*,fmt='(//,6(" ***********"))')
    write(*,*)'     SULEG: initialisation of Gaussian', &
         ' latitudes, weights, etc...'
    write(*,fmt='(6(" ***********"))')

    !     1. GAUSSIAN LATITUDES AND WEIGHTS OVER AN HEMISPHERE
    !     -------------------------------------------------

    call gauss8(gst(gstID)%njlath,gst(gstID)%rmu(1),gst(gstID)%rwt(1),gst(gstID)%rsqm2(1),gst(gstID)%rcolat(1),gst(gstID)%rwocs(1) &
         ,gst(gstID)%r1qm2(1),gst(gstID)%r1mui(1),gst(gstID)%r1mu2(1))

    do jlat = 1, gst(gstID)%njlath
       gst(gstID)%rlati(jlat) = asin(gst(gstID)%rmu(jlat))
       gst(gstID)%r1mua(jlat) = r1sa*gst(gstID)%r1mui(jlat)
    enddo

    !     2. COMPLETION FOR THE SOUTHERN HEMISPHERE
    !     --------------------------------------

    do jlat = gst(gstID)%njlath +1, gst(gstID)%nj
       gst(gstID)%rmu(jlat)   =  -gst(gstID)%rmu(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%rwocs(jlat) =   gst(gstID)%rwocs(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%r1mu2(jlat) =   gst(gstID)%r1mu2(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%rsqm2(jlat) =   gst(gstID)%rsqm2(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%r1qm2(jlat) =   gst(gstID)%r1qm2(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%r1mui(jlat) =   gst(gstID)%r1mui(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%r1mua(jlat) =   gst(gstID)%r1mua(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%rwt(jlat)   =   gst(gstID)%rwt(2*gst(gstID)%njlath +1 - jlat)
       gst(gstID)%rlati(jlat) = - gst(gstID)%rlati (2*gst(gstID)%njlath +1 - jlat)
    enddo

    zpisu2 = rpi/2.
    do jlat = 1, gst(gstID)%nj
       gst(gstID)%rcolat(jlat) = zpisu2 - gst(gstID)%rlati(jlat)
    enddo

    !*    3. Overdimensioning for interpolation

    if(gst(gstID)%njsur.ge.2) then
       gst(gstID)%rmu  (-1) =   gst(gstID)%rmu  (1)
       gst(gstID)%r1mu2(-1) =   gst(gstID)%r1mu2(1)
       gst(gstID)%rsqm2(-1) =   gst(gstID)%rsqm2(1)
       gst(gstID)%r1qm2(-1) =   gst(gstID)%r1qm2(1)
       gst(gstID)%r1mui(-1) =   gst(gstID)%r1mui(1)
       gst(gstID)%r1mua(-1) =   gst(gstID)%r1mua(1)
       gst(gstID)%rlati(-1) =   rpi-gst(gstID)%rlati(1)

       gst(gstID)%rmu  (0) =   1.
       gst(gstID)%r1mu2(0) =   0.
       gst(gstID)%rsqm2(0) =   0.
       gst(gstID)%r1qm2(0) =   rinfini
       gst(gstID)%r1mui(0) =   rinfini
       gst(gstID)%r1mua(0) =   rinfini
       gst(gstID)%rlati(0) =   rpi*.5

       gst(gstID)%rmu  (gst(gstID)%nj+1) =  -1.
       gst(gstID)%r1mu2(gst(gstID)%nj+1) =   0.
       gst(gstID)%rsqm2(gst(gstID)%nj+1) =   0.
       gst(gstID)%r1qm2(gst(gstID)%nj+1) =   rinfini
       gst(gstID)%r1mui(gst(gstID)%nj+1) =   rinfini
       gst(gstID)%r1mua(gst(gstID)%nj+1) =   rinfini
       gst(gstID)%rlati(gst(gstID)%nj+1) =  -rpi*.5

       gst(gstID)%rmu  (gst(gstID)%nj+2) =   gst(gstID)%rmu  (gst(gstID)%nj)
       gst(gstID)%r1mu2(gst(gstID)%nj+2) =   gst(gstID)%r1mu2(gst(gstID)%nj)
       gst(gstID)%rsqm2(gst(gstID)%nj+2) =   gst(gstID)%rsqm2(gst(gstID)%nj)
       gst(gstID)%r1qm2(gst(gstID)%nj+2) =   gst(gstID)%r1qm2(gst(gstID)%nj)
       gst(gstID)%r1mui(gst(gstID)%nj+2) =   gst(gstID)%r1mui(gst(gstID)%nj)
       gst(gstID)%r1mua(gst(gstID)%nj+2) =   gst(gstID)%r1mua(gst(gstID)%nj)
       gst(gstID)%rlati(gst(gstID)%nj+2) =   -rpi-gst(gstID)%rlati(gst(gstID)%nj)
    end if

    !*    4. Print the content of GAUS

    write(*,fmt='(" JLAT:",4X," RLATI",8X,"RCOLAT",8X,"RMU",10X ,"RWT",12X,"RW0CS")')
    do jlat = 1, gst(gstID)%nj
       write(*,fmt='(2X,I4,5(2X,G23.16))')  &
            jlat,gst(gstID)%rlati(jlat),gst(gstID)%rcolat(jlat), gst(gstID)%rmu(jlat)  &
            ,gst(gstID)%rwt(jlat),gst(gstID)%rwocs(jlat)
    enddo

    write(kulout,fmt='(//," JLAT:",4X,"R1MU2",8X,"RSQM2",9X,"R1QM2",10X,"R1MUI",10X,"R1MUA")')

    do jlat = 1, gst(gstID)%nj
       write(kulout,fmt='(2X,I4,5(2X,G23.16))') jlat,gst(gstID)%r1mu2(jlat),gst(gstID)%rsqm2(jlat),gst(gstID)%r1qm2(jlat)  &
            ,gst(gstID)%r1mui(jlat),gst(gstID)%r1mua(jlat)
    enddo

    !*    5.  Positioning within spectral arrays

    do jm = 0, gst(gstID)%ntrunc
       gst(gstID)%nind(jm)   = jm*(gst(gstID)%ntrunc+1) - (jm*(jm-1))/2 + 1
       gst(gstID)%nindrh(jm) = jm*(gst(gstID)%ntrunc+1) + 1
       gst(gstID)%nclm(jm)   = gst(gstID)%ntrunc - jm + 1
    enddo

    write(*,fmt='(/," NIND(0:NTRUNC):",/,10(2X,I8))')  &
         (gst(gstID)%nind(jm),jm=0,gst(gstID)%ntrunc)
    write(*,fmt='(" NINDRH(0:NTRUNC):",/,10(2X,I8))')  &
         (gst(gstID)%nindrh(jm),jm=0,gst(gstID)%ntrunc)
    write(*,fmt='("   NCLM(0:NTRUNC):",/,10(2X,I8))')  &
         (gst(gstID)%nclm(jm),jm=0,gst(gstID)%ntrunc)

  END SUBROUTINE SULEG


  SUBROUTINE GAUSS8(NRACP,RACP,PG,SIA,RAD,PGSSIN2,SINM1,SINM2,SIN2)
    implicit none

    integer nracp
    real*8 racp(*),pg(*),rad(*),pgssin2(*),sinm2(*),sin2(*),sia(*),sinm1(*)
!    real*8, pointer :: sia(:),sinm1(:)
    real*8 xlim,pi,fi,fi1,fn,dot,dn,dn1,a,b,c,g,gm,gp,gt,ractemp,gtemp
    integer i,ir,irm,irp

    xlim=1.d-13
    pi = 4.d0*atan(1.d0)
    ir = 2*nracp
    fi=dble(ir)
    fi1=fi+1.d0
    fn=dble(nracp)

    do i=1,nracp
       dot=dble(i-1)
       racp(i)=-pi*.5d0*(dot+.5d0)/fn + pi*.5d0
       racp(i) =  sin(racp(i))
    enddo

    dn = fi/sqrt(4.d0*fi*fi-1.d0)
    dn1=fi1/sqrt(4.d0*fi1*fi1-1.d0)
    a = dn1*fi
    b = dn*fi1
    irp = ir + 1
    irm = ir -1

    do i=1,nracp
42     call ordleg8(g,racp(i),ir)
       call ordleg8(gm,racp(i),irm)
       call ordleg8(gp,racp(i),irp)
       gt = (a*gp-b*gm)/(racp(i)*racp(i)-1.d0)
       ractemp = racp(i) - g/gt
       gtemp = racp(i) - ractemp
       racp(i) = ractemp
       if( abs(gtemp).gt.xlim) go to 42
    enddo

    do i=1,nracp
       a=2.d0*(1.-racp(i)**2)
       call ordleg8(b,racp(i),irm)
       b = b*b*fi*fi
       pg(i)=a*(fi-.5d0)/b
       rad(i) =   acos(racp(i))
       sia(i) =  sin(rad(i))
       c=(sia(i))**2
       sinm1(i) = 1.d0/sia(i)
       sinm2(i) = 1.d0/c
       pgssin2(i) =pg(i)/c
       sin2(i)=c
    enddo

    return
  END SUBROUTINE GAUSS8

  SUBROUTINE ORDLEG8(SX,COA,IR)
    implicit none

    real*8 sx,coa
    integer ir
    integer n,kk,k,n1,irpp,irppm
    real*8 pi,sqr2,delta,sia,theta,c1,c4,s1,ang,fk,fn,fn2,fn2sq,a,b

    pi    = 4.d0*atan(1.d0)
    sqr2  = sqrt(2.d0)
    irpp  = ir   + 1
    irppm = irpp - 1
    delta = acos(coa)
    sia   = sin(delta)

    theta = delta
    c1    = sqr2

    do n=1,irppm
       fn2   = dble(2*n)
       fn2sq = fn2*fn2
       c1    =  c1*sqrt(1.d0 - 1.d0/fn2sq)
    enddo

    n   = irppm
    fn  = dble(n)
    ang = fn*theta
    s1  = 0.d0
    c4  = 1.d0
    a   =-1.d0
    b   = 0.d0
    n1  = n+1

    do kk=1,n1,2
       k   = kk-1
       if (k.eq.n) c4 = 0.5d0*c4
       s1  = s1+c4* cos(ang)
       a   =  a+2.d0
       b   =  b+1.d0
       fk  = dble(k)
       ang = theta*(fn-fk-2.d0)
       c4  = ( a * (fn-b+1.d0) / (b*(fn2-a)) )*c4
    enddo

    sx = s1*c1

    return
  END SUBROUTINE ORDLEG8


  SUBROUTINE SUALP
    implicit none

    integer jj,jgl,jm,jn,ilat
    integer ilen,ilarh,ila,ilatbd,ierr
    real*8  dlalp(gst(gstID)%nlarh,nlatbd), dldalp(gst(gstID)%nlarh,nlatbd)
    real*8  dldelalp(gst(gstID)%nlarh,nlatbd)
    !     
    !     Memory allocation for Legendre polynomials
    !     
    write(*,*) 'allocating dalp:',gst(gstID)%nla,gst(gstID)%njlath,gst(gstID)%nla*gst(gstID)%njlath
    allocate( gst(gstID)%dalp(gst(gstID)%nla,gst(gstID)%njlath), gst(gstID)%dealp(gst(gstID)%nla,gst(gstID)%njlath))
    write(*,*) 'succeeded'

    latitudes: do jgl = 1, gst(gstID)%njlath, nlatbd
       ilatbd = min(nlatbd,gst(gstID)%njlath - jgl + 1)

       if(ilatbd.eq.8) then
          call allp(dlalp,dldalp,gst(gstID)%rmu(jgl),gst(gstID)%nclm(0),0,gst(gstID)%ntrunc,ilatbd)
       else
          call allp2(dlalp,dldalp,gst(gstID)%rmu(jgl),gst(gstID)%nclm(0),0,gst(gstID)%ntrunc,ilatbd)
       endif

       do jm=0,gst(gstID)%ntrunc
          do jn=jm,gst(gstID)%ntrunc
             ila=gst(gstID)%nind(jm) + jn -jm
             ilarh=gst(gstID)%nindrh(jm) + jn-jm
             do jj=1,ilatbd
                ilat = jgl+jj-1
                gst(gstID)%dalp (ila,jgl+jj-1)=dlalp (ilarh,jj)
                gst(gstID)%dealp(ila,jgl+jj-1)=dldalp(ilarh,jj)
             enddo
          enddo
       enddo
    enddo latitudes

  END SUBROUTINE SUALP


  SUBROUTINE GETALP(DDALP,DDDALP,KLATH,KTRUNC,KTRUNCDIM ,KM)
    implicit none

    integer km,klath,ktrunc, ktruncdim
    integer ila,ind
    integer jlat,jn, jlen
    real*8  ddalp(0:ktruncdim,klath), dddalp(0:ktruncdim,klath)

    do jlat = 1,klath
       do jlen = 0, ktrunc
          ddalp(jlen,jlat) = 0.d0
          dddalp(jlen,jlat)= 0.d0
       end do
    end do

    do jlat = 1, klath
       do jn = km, ktrunc
          ila = gst(gstID)%nind(km) + jn-km
          ind=jn-km
          ddalp(ind,jlat) =  gst(gstID)%dalp(ila,jlat)
          dddalp(ind,jlat) = gst(gstID)%dealp(ila,jlat)
       end do
    end do

    return
  END SUBROUTINE GETALP


  SUBROUTINE ALLP( P , G , X , LR , HEM , R , NLATP) 

    implicit none 
    integer r, nlatp, lr(0:r), hem 
    real *8 p(0:r,0:r,nlatp) , g(0:r,0:r,nlatp) 
    real *8 x(nlatp) 

    real*8 onehalf   
    real*8 xp , xp2,  p0, enm, fnm
    integer ilat , m , l , n

    data onehalf /0.5/

    do ilat=1,nlatp
       xp2 = sqrt( 1.0 - x(ilat) ** 2 ) 
       p(0,0,ilat) = sqrt(onehalf) 
       do m=1,r 
          xp = float(m)
          p(0,m,ilat) = sqrt( (2.0*xp+1.0)/(2.0*xp) ) * xp2 * p(0,m-1,ilat)
       enddo
    enddo

    do ilat=1,nlatp
       do m=0,r 
          xp = float(m)
          g(0,m,ilat) = - x(ilat)*xp * p(0,m,ilat) 
       enddo
    enddo
    do n=1,r
       do m=0,lr(n)-1
          l =  1
          p0 = float(m+n)
          xp = float(m)
          enm = sqrt( ((p0*p0-xp*xp)*(2.0*p0+1.0))/(2.0*p0-1.0) )
          fnm = sqrt( (2.0*p0+1.0)/((p0*p0-xp*xp)*(2.0*p0-1.0)) )

          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
          p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) -  g(n-1,m,l) ) * fnm 
          g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l) 
          l = l + 1
       enddo
    enddo

    return
  END SUBROUTINE ALLP


  SUBROUTINE ALLP2( P , G , X , LR , HEM , R , NLATP)

    implicit none
    integer r, nlatp, lr(0:r), hem, jlat
    real*8 p(0:r,0:r,nlatp) , g(0:r,0:r,nlatp) 
    real*8 x(nlatp)

    real*8 onehalf   
    real*8 xp , xp2,  p0, enm, fnm
    integer ilat , m , l , n

    data onehalf /0.5/

    do ilat=1,nlatp
       xp2 = sqrt( 1.0 - x(ilat) ** 2 )
       p(0,0,ilat) = sqrt(onehalf)
       do m=1,r
          xp = float(m)
          p(0,m,ilat) = sqrt( (2.0*xp+1.0)/(2.0*xp) ) * xp2 * p(0,m-1,ilat)
       enddo
    enddo

    do ilat=1,nlatp
       do m=0,r
          xp = float(m)
          g(0,m,ilat) = - x(ilat)*xp * p(0,m,ilat)
       enddo
    enddo

    do n=1,r
       do m=0, r
          p0 = float(m+n)
          xp = float(m)
          enm = sqrt( ((p0*p0-xp*xp)*(2.0*p0+1.0))/(2.0*p0-1.0) )
          fnm = sqrt( (2.0*p0+1.0)/((p0*p0-xp*xp)*(2.0*p0-1.0)) )

          do jlat = 1, nlatp
             l = jlat
             p(n,m,l) = ( x(l) * p0 * p(n-1,m,l) - g(n-1,m,l) ) * fnm
             g(n,m,l) = enm * p(n-1,m,l) - x(l) * p0 * p(n,m,l)
          enddo
       enddo
    enddo

    return
  END SUBROUTINE ALLP2

  SUBROUTINE GST_ZLEGPOL(PLEG)
    !***s/r ZLEGPOL  - Evaluation of Legendre polynomials restricted to
    !*     .           (n,m) = (n,0)
    !*Arguments
    !*     o   PLEG               : Legendre functions evaluated at the KNJ Gaussian latitudes
    implicit none

    real*8    pleg(0:gst(gstID)%ntrunc,gst(gstID)%nj)

    integer jn, jlat, ilen, ierr
    real*8 dlfact1, dlfact2, dln
    real*8 dlnorm(0:gst(gstID)%ntrunc)

    do jlat = 1, gst(gstID)%nj
       pleg(0,jlat) = sqrt(0.5d0)
       pleg(1,jlat) = sqrt(1.5d0)*gst(gstID)%rmu(jlat)
    enddo

    do jn = 0, gst(gstID)%ntrunc
       dln = 1.d0*dfloat(jn)
       dlnorm(jn) = dsqrt((2.*dln + 1.d0)/2.d0)
    enddo

    do jn = 1, gst(gstID)%ntrunc-1
       dln = dfloat(jn)
       dlfact1 = ((2.*dln+1.)/(dln+1.))*(dlnorm(jn+1)/dlnorm(jn))
       dlfact2 = (dln/(dln+1.))*(dlnorm(jn+1)/dlnorm(jn-1))
       do jlat = 1,gst(gstID)%nj
          pleg(jn+1,jlat) = dlfact1*gst(gstID)%rmu(jlat)*dble(pleg(jn,jlat))   &
                - dlfact2*dble(pleg(jn-1,jlat))
       enddo
    enddo

    return
  END SUBROUTINE GST_ZLEGPOL

END MODULE GLBSPEC_MOD
