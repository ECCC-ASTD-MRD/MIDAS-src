!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE ltt2phigd(pgz,ptt,statevectorg)
#if defined (DOC)
*
***s/r ltt2phigd  - Grid-point version of ltt2phi.ftn
*
*Author  : L. Fillion *ARMA/AES  Feb 17, 1999
*     .
*Revision: L. Fillion *ARMA/AES - 4 mar 1999
*              . Changed arguments to lvtapgd.ftn
*          JM Belanger CMDA/SMC  Nov 2000
*              . 32 bits conversion
*           C. Charette - ARMA/SMC - Sep. 2004
*            - Conversion to hybrid vertical coordinate
*
*
**
*Arguments
*     in-
*   ptt    : 3D Temperature Incr. appearing on r.h.s. of TL-eq.
*     out-
*   pgz    : 3D GZ fields computed from TL-Hydrostatic equation
#endif
C
      use gridStateVector_mod
      use vGrid_Descriptors , only:vgrid_descriptor,vgd_levels,VGD_OK
      IMPLICIT NONE
*
      type(struct_gsv) :: statevectorg
      real*8 pgz(statevectorg%ni,statevectorg%nlev,statevectorg%nj)
      real*8 ptt(statevectorg%ni,statevectorg%nlev,statevectorg%nj)
*
      real*8  vma(statevectorg%nlev),vmb(statevectorg%nlev)
      real*8  vmc(statevectorg%nlev),vmd(statevectorg%nlev)
      real*8  vme(statevectorg%nlev),vmf(statevectorg%nlev)
      INTEGER JLEV, JLA, ILA, ILEV, JLAT, JLON
      real*8  zalpha
      real*8 zpress(statevectorg%ni,statevectorg%nlev),zprof(statevectorg%nlev)
      real*8, pointer :: ps3d_ptr(:,:,:), zpres3d_ptr(:,:,:)
      real*8, allocatable :: zps2d(:,:) 
      integer status
*------------------------------------------------------------------
**
C
      WRITE(*,FMT='(/,4X,"Starting LTT2PHIGD",//)')
C
      zalpha=-1.0D0

c
c     Prepare r.h.s. for TL-Hydrostatic equation
c
      ps3d_ptr => gsv_getField3D(statevectorg,'P0')
c
      allocate(zps2d(statevectorg%ni,statevectorg%nj))
      zps2d(:,:) = ps3d_ptr(:,1,:)
c
      status=vgd_levels(statevectorg%vco%vgrid,
     &                  ip1_list=statevectorg%vco%ip1_M,
     &                  levels=zpres3d_ptr,sfc_field=zps2d,in_log=.false.)
      if(status.ne.VGD_OK)then
        write(*,*) 'ERROR with vgd_levels for desired levels '
        call qqexit(1)
      endif
      do jlat = 1, statevectorg%nj
        zpress = zpres3d_ptr(:,jlat,:)
        do jlon = 1, statevectorg%ni
          do jlev = 1,statevectorg%nlev
            ila         = jlev+(jlon-1)*statevectorg%nlev
            zprof(jlev) = zpress(jlon,jlev)
          enddo
          call matapat(zprof,zalpha,statevectorg%nlev,vma,vmb,vmc,vmd,vme,vmf)
          call lvtapgd(pgz,ptt,jlon,jlat) 
        enddo
      enddo
      deallocate(zps2d)
c
      RETURN

      CONTAINS

      subroutine lvtapgd(pgz,ptt,ki,kj)
*S/P LVTAPGD:
*
*         CALCULE Y A PARTIR DE R PAR SOLUTION DE L'EQUATION R*CON=S**E
C *D(Y)
*         AVEC UN SCHEME DU 4EME ORDRE DU A J. COTE.
*         NOTE: CET ALGORITHME EST EXACTEMENT REVERSIBLE (VOIR VPAT).
*
*         ON DOIT FOURNIR LA COND
*         A LA LIMITE INF. Y(N). LA MATRICE MATAP A ETE CALCULEE DANS LA
*         SUBR. MATAPAT.
*
*
* AUTHOR: Luc Fillion - 5 Nov 98 - Grid-Point version of lvtap
C subroutine.
*
* REVISION: C.Charette ARMA/AES 18 nov 1998
*                     - when llprint=.true. calculate grid point
C coordinates
*                       closest to  R1OBSLA and R1OBSLO read from the
*                       namelist.Print debug diagnostics for this point.
* REVISION: L. Fillion ARMA/AES 11 feb 1999
*                     - Remove T factor since r.h.s. must now be
C prepared outside lvtapgd
*           S. Pellerin *ARMA/SMC Nov. 2001
*                     - Reordering dependencies for Linux compilation
      use MathPhysConstants_mod
      IMPLICIT NONE
      integer ki,kj
!
      INTEGER  IKLEVM2, JK, IK
      REAL*8    ZAK, ZBK, ZCK, ZCON

*implicits
*
      real*8    pgz(statevectorg%ni,statevectorg%nlev,statevectorg%nj)
      real*8    ptt(statevectorg%ni,statevectorg%nlev,statevectorg%nj)
c
c ptt : working vector of virtual temperatures.
c
      ZCON = -MPC_RGAS_DRY_AIR_R8
      ZAK = -2.0*ZCON*VMA(statevectorg%nlev)
      ZBK = -2.0*ZCON*VMB(statevectorg%nlev)
      ZCK = -2.0*ZCON*VMC(statevectorg%nlev)
      pgz(ki,statevectorg%nlev,kj) = 0.0
      pgz(ki,statevectorg%nlev-1,kj)=ZAK*ptt(ki,statevectorg%nlev-1,kj)+
     &     ZBK*ptt(ki,statevectorg%nlev,kj)+
     &     ZCK*ptt(ki,statevectorg%nlev-2,kj)+
     &     pgz(ki,statevectorg%nlev,kj)
*
      IKLEVM2 = statevectorg%nlev-2
      do JK = 1, IKLEVM2
        IK = statevectorg%nlev-1-JK
        ZAK = -2.0*ZCON*VMA(IK+1)
        ZBK = -2.0*ZCON*VMB(IK+1)
        ZCK = -2.0*ZCON*VMC(IK+1)
        pgz(ki,ik,kj)= ZAK*ptt(ki,IK,kj)+
     &       ZBK*ptt(ki,IK+1,kj)+
     &       ZCK*ptt(ki,IK+2,kj)+
     &       pgz(ki,IK+2,kj)
      enddo
C
      RETURN
      END SUBROUTINE lvtapgd


      END








