!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
module stateToColumn_mod
  ! Note: this module replaces oda_L and oda_LT, while implementing the
  !       the possibility of having the obs distributing arbitrarily over
  !       the mpi tasks, while the increment is distributed by horizontal tiles
  !
  use MathPhysConstants_mod
  use mpivar_mod 
  use gridstatevector_mod
  use obsSpaceData_mod
  use columnData_mod
  use timeCoord_mod
  use tt2phi_mod
  implicit none
  save
  private
  
  ! public routines
  public :: s2c_tl, s2c_ad

  ! private module variables
  logical :: initialized = .false.
  integer :: numHeaderTile, numHeaderColumn
  integer, allocatable :: PE_sender_mpiglobal(:), PE_receiver_mpiglobal(:)
  integer, allocatable :: myPESourceColumn(:)
  real(8), allocatable :: myYposTile(:), myXposTile(:)
  real(8), allocatable :: myLatTile(:), myLonTile(:)
  real(8), allocatable :: myTimeInterpWeight(:,:)
  real(8), pointer     :: fieldsWithHalo(:,:,:,:)

  integer :: get_max_rss


CONTAINS 

  !---------------------------------------------------------
  ! S2C_SETUP
  !---------------------------------------------------------
  subroutine s2c_setup(statevector,column,obsSpaceData)
    implicit none
    ! Purpose: gather information needed concerning observations that live on
    !          other mpi tasks, but are associated with the horizontal tile
    !          on the local mpi task
    type(struct_gsv)        :: statevector
    type(struct_columnData) :: column
    type(struct_obs)        :: obsSpaceData

    integer :: procIndex, procIndex2, headerIndex, headerIndex2, stepIndex, ierr, nsize, status
    integer :: numToSend, PE_sender, PE_receiver
    integer :: numToSend_mpiglobal(mpi_nprocs), numToSend_tmp(mpi_nprocs)
    real(8), allocatable :: myYposToSend(:)
    real(8), allocatable :: myXposToSend(:)
    real(8), allocatable :: myLatToSend(:)
    real(8), allocatable :: myLonToSend(:)
    real(8), allocatable :: myTimeInterpWeightToSend(:,:)
    real(8) :: Lat, Lon, ypos, xpos, LatRot, LonRot

    if(mpi_myid.eq.0) write(*,*) 's2c_setup: gathering information for load balancing'

    ! Allocate some module arrays
    allocate(PE_sender_mpiglobal(mpi_nprocs))
    allocate(PE_receiver_mpiglobal(mpi_nprocs))

    ! Number of headers on local columns
    numHeaderColumn = col_getNumCol(column)

    write(*,*) ' ' 
    write(*,*) 's2c_setup: Column-related values:'
    write(*,*) 's2c_setup: numHeaderColumn              = ', numHeaderColumn

    ! determine for each receiver TILE which COLUMN is the sender
    PE_sender = -1
    do headerIndex = 1, numHeaderColumn
      if(obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex).ne. &
         obs_headElem_i(obsSpaceData,OBS_IPC,headerIndex)) then
        PE_sender   = obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex)
      endif
    enddo
    call rpn_comm_allgather(PE_sender, 1, "mpi_integer",  &
                            PE_sender_mpiglobal, 1, "mpi_integer", "GRID", ierr)

    ! determine for each sender TILE which COLUMN is the receiver
    do procIndex = 0, mpi_nprocs-1
      PE_receiver_mpiglobal(procIndex+1) = -1
      do procIndex2 = 0, mpi_nprocs-1
        if(PE_sender_mpiglobal(procIndex2+1).eq.procIndex) then
          PE_receiver_mpiglobal(procIndex+1) = procIndex2
        endif
      enddo
    enddo
    PE_receiver = PE_receiver_mpiglobal(mpi_myid+1)

    numToSend_tmp(:) = 0
    do headerIndex = 1, numHeaderColumn
      if(obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex).ne. &
         obs_headElem_i(obsSpaceData,OBS_IPC,headerIndex)) then
        numToSend_tmp(PE_sender+1) = numToSend_tmp(PE_sender+1) + 1
      endif
    enddo

    call rpn_comm_allreduce(numToSend_tmp, numToSend_mpiglobal, mpi_nprocs, &
                            "MPI_INTEGER", "MPI_SUM", "GRID", ierr)
    numToSend = numToSend_mpiglobal(mpi_myid+1)

    ! Number of headers on local TILE
    if(PE_sender.eq.-1) then
      ! I am a sender from TILE to COLUMN
      numHeaderTile = numHeaderColumn + numToSend_mpiglobal(mpi_myid+1)
    else
      ! I am a receiver from TILE to COLUMN
      numHeaderTile = numHeaderColumn - numToSend_mpiglobal(PE_sender+1)
    endif

    write(*,*) 's2c_setup: numToSend_mpiglobal   = ',numToSend_mpiglobal(:)
    write(*,*) 's2c_setup: PE_sender_mpiglobal   = ',PE_sender_mpiglobal(:)
    write(*,*) 's2c_setup: PE_receiver_mpiglobal = ',PE_receiver_mpiglobal(:)

    write(*,*) ' ' 
    write(*,*) 's2c_setup: Tile-related values:'
    write(*,*) 's2c_setup: numHeaderTile              = ', numHeaderTile

    ! Only do the following if this mpi task is either sender or receiver
    if(numHeaderTile.ne.numHeaderColumn) then
      allocate(myPEsourceColumn(numHeaderColumn))
      do headerIndex = 1, numHeaderColumn
        myPEsourceColumn(headerIndex) = obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex)
      enddo

      allocate(myYPosTile(numHeaderTile))
      allocate(myXPosTile(numHeaderTile))
      allocate(myLatTile(numHeaderTile))
      allocate(myLonTile(numHeaderTile))
      allocate(myTimeInterpWeight(numHeaderTile,statevector%numStep))

      if(PE_sender.eq.-1) then
        ! I am a sender from TILE to COLUMN:
      
        ! copy lat-lon that are already on correct mpi task
        headerIndex2 = 0
        do headerIndex = 1, numHeaderColumn
          if(obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex).eq. &
             obs_headElem_i(obsSpaceData,OBS_IPC,headerIndex)) then
            headerIndex2 = headerIndex2 + 1
            call col_getLatLon( column, headerIndex,                 & ! IN
                                Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT
            myYPosTile(headerIndex2)= ypos
            myXPosTile(headerIndex2)= xpos
            myLatTile(headerIndex2) = lat
            myLonTile(headerIndex2) = lon

            if(btest(obs_headElem_i(obsSpaceData,OBS_ST1,headerIndex),5) ) then
              myTimeInterpWeight(headerIndex2,:) = 0.0d0
            else
              do stepIndex = 1, statevector%numStep
                myTimeInterpWeight(headerIndex2,stepIndex) = &
                  tim_getTimeInterpWeight(headerIndex,stepIndex)
              enddo
            endif
          endif
        enddo

        write(*,*) 's2c_setup: headerIndex2, numToSend_mpiglobal(mpi_myid+1)=',headerIndex2, numToSend_mpiglobal(mpi_myid+1)
        call flush(6)

        ! receive lat-lon, etc from receiver
        nsize = numHeaderTile-numHeaderColumn
        if(nsize.gt.0) then
          call rpn_comm_recv(myYPosTile(numHeaderColumn+1:numHeaderTile),nsize, &
                            "mpi_double_precision",PE_receiver,PE_receiver*2000+mpi_myid,  &
                            "GRID",status,ierr)
          call rpn_comm_recv(myXPosTile(numHeaderColumn+1:numHeaderTile),nsize, &
                            "mpi_double_precision",PE_receiver,PE_receiver*2000+mpi_myid,  &
                            "GRID",status,ierr)
          call rpn_comm_recv(myLatTile(numHeaderColumn+1:numHeaderTile),nsize, &
                            "mpi_double_precision",PE_receiver,PE_receiver*2000+mpi_myid,  &
                            "GRID",status,ierr)
          call rpn_comm_recv(myLonTile(numHeaderColumn+1:numHeaderTile),nsize, &
                            "mpi_double_precision",PE_receiver,PE_receiver*2000+mpi_myid,  &
                            "GRID",status,ierr)
          call rpn_comm_recv(myTimeInterpWeight(numHeaderColumn+1:numHeaderTile,:),nsize*statevector%numStep, &
                            "mpi_double_precision",PE_receiver,PE_receiver*2000+mpi_myid,  &
                            "GRID",status,ierr)
        endif
      else
        ! I am a receiver from TILE to COLUMN:

        ! copy lat-lon that are already on correct mpi task
        headerIndex2 = 0
        do headerIndex = 1, numHeaderColumn
          if(obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex).eq. &
             obs_headElem_i(obsSpaceData,OBS_IPC,headerIndex)) then
            headerIndex2 = headerIndex2 + 1

            call col_getLatLon( column, headerIndex,                 & ! IN
                                Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT
            myYPosTile(headerIndex2)= ypos
            myXPosTile(headerIndex2)= xpos
            myLatTile(headerIndex2) = lat
            myLonTile(headerIndex2) = lon

            if(btest(obs_headElem_i(obsSpaceData,OBS_ST1,headerIndex),5) ) then
              myTimeInterpWeight(headerIndex2,:) = 0.0d0
            else
              do stepIndex = 1, statevector%numStep
                myTimeInterpWeight(headerIndex2,stepIndex) = &
                  tim_getTimeInterpWeight(headerIndex,stepIndex)
              enddo
            endif
          endif
        enddo

        ! send lat-lon to sender
        nsize = numHeaderColumn - numHeaderTile
        if(nsize.gt.0) then
          allocate(myYposToSend(nsize))
          allocate(myXposToSend(nsize))
          allocate(myLatToSend(nsize))
          allocate(myLonToSend(nsize))
          allocate(myTimeInterpWeightToSend(nsize,statevector%numStep))
          headerIndex2 = 0
          do headerIndex = 1, numHeaderColumn
            if(obs_headElem_i(obsSpaceData,OBS_IPT,headerIndex).ne. &
               obs_headElem_i(obsSpaceData,OBS_IPC,headerIndex)) then
              headerIndex2 = headerIndex2 + 1

              call col_getLatLon( column, headerIndex,                 & ! IN
                                  Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT
              myYPosToSend(headerIndex2)= ypos
              myXPosToSend(headerIndex2)= xpos
              myLatToSend(headerIndex2) = lat
              myLonToSend(headerIndex2) = lon

              if(btest(obs_headElem_i(obsSpaceData,OBS_ST1,headerIndex),5) ) then
                myTimeInterpWeightToSend(headerIndex2,:) = 0.0d0
              else
                do stepIndex = 1, statevector%numStep
                  myTimeInterpWeightToSend(headerIndex2,stepIndex) = &
                    tim_getTimeInterpWeight(headerIndex,stepIndex)
                enddo
              endif

            endif
          enddo
          write(*,*) 's2c_setup: headerIndex2, nsize=',headerIndex2, nsize
          call flush(6)
          call rpn_comm_send(myYPosToSend,nsize, &
                             "mpi_double_precision",PE_sender,mpi_myid*2000+PE_sender,  &
                             "GRID",ierr)
          call rpn_comm_send(myXPosToSend,nsize, &
                             "mpi_double_precision",PE_sender,mpi_myid*2000+PE_sender,  &
                             "GRID",ierr)
          call rpn_comm_send(myLatToSend,nsize, &
                             "mpi_double_precision",PE_sender,mpi_myid*2000+PE_sender,  &
                             "GRID",ierr)
          call rpn_comm_send(myLonToSend,nsize, &
                             "mpi_double_precision",PE_sender,mpi_myid*2000+PE_sender,  &
                             "GRID",ierr)
          call rpn_comm_send(myTimeInterpWeightToSend,nsize*statevector%numStep, &
                             "mpi_double_precision",PE_sender,mpi_myid*2000+PE_sender,  &
                             "GRID",ierr)

          deallocate(myYposToSend)
          deallocate(myXposToSend)
          deallocate(myLatToSend)
          deallocate(myLonToSend)
          deallocate(myTimeInterpWeightToSend)
        endif

      endif

    else  ! here numHeaderTile .eq. numHeaderColumn, so no sending or receiving

      if (numHeaderTile.gt.0) then

        allocate(myYPosTile(numHeaderTile))
        allocate(myXPosTile(numHeaderTile))
        allocate(myLatTile(numHeaderTile))
        allocate(myLonTile(numHeaderTile))
        allocate(myTimeInterpWeight(numHeaderTile,statevector%numStep))

        ! copy lat-lon that are already on correct mpi task
        do headerIndex = 1, numHeaderTile
          call col_getLatLon( column, headerIndex,                 & ! IN
                              Lat, Lon, ypos, xpos, LatRot, LonRot ) ! OUT
          myYPosTile(headerIndex)= ypos
          myXPosTile(headerIndex)= xpos
          myLatTile(headerIndex) = lat
          myLonTile(headerIndex) = lon

          if(btest(obs_headElem_i(obsSpaceData,OBS_ST1,headerIndex),5) ) then
            myTimeInterpWeight(headerIndex,:) = 0.0d0
          else
            do stepIndex = 1, statevector%numStep
              myTimeInterpWeight(headerIndex,stepIndex) = &
                tim_getTimeInterpWeight(headerIndex,stepIndex)
            enddo
          endif
        enddo
   
      endif ! numHeaderTile .gt. 0

    endif ! numHeaderTile .ne. numHeaderColumn

    ! allocate the 4D array used to store the statevector with a Halo
    allocate(fieldsWithHalo(statevector%myLonBeg:(statevector%myLonEnd+1),statevector%nk,  &
                            statevector%myLatBeg:(statevector%myLatEnd+1),statevector%numStep))

    initialized = .true.

    if(mpi_myid.eq.0) write(*,*) 's2c_setup: END'

  end subroutine s2c_setup

  !---------------------------------------------------------
  ! Tangent linear operator (replaces oda_L)
  !---------------------------------------------------------
  subroutine s2c_tl(statevector,column,columng,obsSpaceData)
    implicit none
    !
    ! Purpose: Horizontal interpolation to transform a 
    !          statevector object into a column object
    !
    type(struct_columnData) :: column, columng
    type(struct_obs)        :: obsSpaceData
    type(struct_gsv)        :: statevector

    integer :: ilev, ierr, myLonEndP1, myLatEndP1, status, Vcode_anl
    type(struct_vco), pointer :: vco_anl

    if(.not.initialized) call s2c_setup(statevector,column,obsSpaceData)

    myLonEndP1 = statevector%myLonEnd + 1
    myLatEndP1 = min(statevector%myLatEnd + 1, statevector%nj)

    !
    !- 1.  Interpolation to obs location
    !
    if(mpi_myid==0) write(*,*) 's2c_tl - Horizontal interpolation StateVector --> ColumnData'

    !- 1.1 Communicate extra latitude needed for interpolation  
    call tmg_start(38,'INTERP_BARR')
    call rpn_comm_barrier("GRID",ierr)
    call tmg_stop(38)
    call tmg_start(39,'INTERP_COMM')
    call commLatLon(statevector)
    call tmg_stop(39)

    call gd2mvo

    !
    !- 2.  Variable conversions
    !

    !- 2.1 Mass fields (TT,PS,HU) to hydrostatic geopotential
    vco_anl => col_getVco(columng)
    status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)
    call tmg_start(36,'INTERP_TT2PHI_TL')
    call tt2phi_tl(column,columng)
    call tmg_stop(36)

    !- 2.2 Rotated wind to Meteorological wind
    if ( gsv_varExist('UU') .and. gsv_varExist('VV') .and. statevector%hco%Rotated ) then
      write(*,*) 'uvrot2uv Active'
      call uvrot2uv('UU', 'VV', col_getNumLev(column,'MM')) ! IN
    end if
  
  CONTAINS

    !--------------------------------------------------------------------------
    ! GD2MVO
    !--------------------------------------------------------------------------
    subroutine gd2mvo
      !
      ! s/r GD2MVO  - Horizontal bilinear interpolation of the model variables
      !               in grid-point space to observation locations.
      !
      !     numLev   : number of levels
      !
      implicit none
    
      integer :: numLev
      integer :: jlev, headerIndex, stepIndex, ilon, ilat
      real(8) :: dldx, dldy, dlw1, dlw2, dlw3, dlw4
      real(8) :: xpos, ypos, lat, lon, latrot, lonrot
      real(8), pointer :: column_ptr(:,:), column_tile(:,:)

      if (numHeaderTile > 0) then
        column_ptr => col_getAllColumns(column)
        column_ptr(:,:) = 0.0d0
        numLev = size(column_ptr,1)
        write(*,*) 'gd2mvo: total number of levels for all variables=',numLev

        allocate(column_tile(numLev,numHeaderTile))
        column_tile(:,:) = 0.0d0
        write(*,*) 'gd2mvo: after allocate of column_tile'
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
        call flush(6)
      else
        write(*,*) 'gd2mvo: numHeaderTile not positive: ',numHeaderTile
      end if

      ! Note: We assume here that all the obs between the poles and the last grid points
      !       (i.e. outside the grid) have been moved within the grid by sugomobs

      do stepIndex = 1, statevector%numStep

        !- Loop over all the observations
        do headerIndex = 1, numHeaderTile

          if ( myTimeInterpWeight(headerIndex,stepIndex) > 0.0d0 ) then

            !- 2.1 Find the obs position within the analysis grid
            ypos = myYposTile(headerIndex)
            xpos = myXposTile(headerIndex)
            Lat  = myLatTile(headerIndex)
            Lon  = myLonTile(headerIndex)

            !- Make sure we are within bounds
            if ( ypos < real(statevector%myLatBeg,8) .or. &
                 ypos > real(myLatEndP1          ,8) .or. &
                 xpos < real(statevector%myLonBeg,8) .or. &
                 xpos > real(myLonEndP1          ,8) ) then
              write(*,*) 's2c_tl: Obs outside local domain for headerIndex = ', headerIndex
              write(*,*) '        obs lat, lon position               = ',  &
                         Lat*MPC_DEGREES_PER_RADIAN_R8, Lon*MPC_DEGREES_PER_RADIAN_R8
              write(*,*) '        obs x, y     position               = ', xpos, ypos
              write(*,*) '        domain x_start, x_end, y_start, y_end bounds = ',  &
                         statevector%myLonBeg, myLonEndP1, statevector%myLatBeg, myLatEndP1

              ! if obs above or below latitude band, move it to the edge of this latitude band
              if( ypos < real(statevector%myLatBeg,8) ) ypos = real(statevector%myLatBeg,8)
              if( ypos > real(myLatEndP1          ,8) ) ypos = real(myLatEndP1          ,8)

              ! if obs left or right longitude band, move it to the edge of this longitude band
              if( xpos < real(statevector%myLonBeg,8) ) xpos = real(statevector%myLonBeg,8)
              if( xpos > real(myLonEndP1          ,8) ) xpos = real(myLonEndP1          ,8)
              write(*,*) ' new   obs x, y     position               = ', xpos, ypos
            end if

            !- 2.2 Find the lower-left grid point next to the observation
            if ( xpos /= real(myLonEndP1,8) ) then
              ilon = floor(xpos)
            else
              ilon = floor(xpos) - 1
            end if

            if ( ypos /= real(myLatEndP1,8) ) then
              ilat = floor(ypos)
            else
              ilat = floor(ypos) - 1
            end if

            !- 2.3 Compute the 4 weights of the bilinear interpolation
            dldx = xpos - real(ilon,8)
            dldy = ypos - real(ilat,8)

            dlw1 = (1.d0-dldx) * (1.d0-dldy)
            dlw2 =       dldx  * (1.d0-dldy)
            dlw3 = (1.d0-dldx) *       dldy
            dlw4 =       dldx  *       dldy

            !- 2.4 Interpolate the model state to the obs point
            do jlev = 1, numLev
              column_tile(jlev,headerIndex) = column_tile(jlev,headerIndex)  +  &
                                  myTimeInterpWeight(headerIndex,stepIndex) * &
                                  ( dlw1 * fieldsWithHalo(ilon  ,jlev,ilat  ,stepIndex) &
                                  + dlw2 * fieldsWithHalo(ilon+1,jlev,ilat  ,stepIndex) &
                                  + dlw3 * fieldsWithHalo(ilon  ,jlev,ilat+1,stepIndex) &
                                  + dlw4 * fieldsWithHalo(ilon+1,jlev,ilat+1,stepIndex) )
            enddo

          end if

        enddo ! headerIndex

      enddo ! stepIndex

      call tmg_start(38,'INTERP_BARR')
      call rpn_comm_barrier("GRID",ierr)
      call tmg_stop(38)
      if (numHeaderTile > 0) then
        call transpose_tileToColumn(column_tile,column_ptr,numLev)
        deallocate(column_tile)
      endif

    end subroutine gd2mvo

    !--------------------------------------------------------------------------
    ! transpose_tileToColumn
    !--------------------------------------------------------------------------
    subroutine transpose_tileToColumn(col_ptr_in,col_ptr_out,numLev)
      implicit none
      real(8), pointer :: col_ptr_in(:,:),col_ptr_out(:,:)
      integer :: numLev

      real(8), allocatable :: col_recv(:,:)
      integer :: headerIndex, headerIndex_local, headerIndex_recv, jlev, nsize, ierr

      write(*,*) 'transpose_tileToColumn: STARTING'
      call flush(6)

      call tmg_start(39,'INTERP_COMM')

      if(PE_receiver_mpiglobal(mpi_myid+1).ne.-1) then
        ! I am a sender from TILE to COLUMN
        col_ptr_out(:,1:numHeaderColumn) = col_ptr_in(:,1:numHeaderColumn)

        nsize = numlev*(numHeaderTile-numHeaderColumn)
        call tmg_start(35,'INTERP_SENDRECV')
        call rpn_comm_send(col_ptr_in(1:numlev,numHeaderColumn+1:numHeaderTile),nsize, &
                           "mpi_double_precision",PE_receiver_mpiglobal(mpi_myid+1), &
                           PE_receiver_mpiglobal(mpi_myid+1)*2000+mpi_myid,  &
                           "GRID",ierr)
        call tmg_stop(35)
      elseif(PE_sender_mpiglobal(mpi_myid+1).ne.-1) then
        ! I am a receiver from TILE to COLUMN:
        nsize = numlev*(numHeaderColumn-numHeaderTile)
        allocate(col_recv(numLev,nsize))
        call tmg_start(35,'INTERP_SENDRECV')
        call rpn_comm_recv(col_recv(:,:),nsize, &
                           "mpi_double_precision",PE_sender_mpiglobal(mpi_myid+1), &
                           mpi_myid*2000+PE_sender_mpiglobal(mpi_myid+1),  &
                           "GRID",status,ierr)
        call tmg_stop(35)
        headerIndex_local = 0
        headerIndex_recv = 0
        do headerIndex = 1, numHeaderColumn
          if(myPEsourceColumn(headerIndex).eq.mpi_myid) then
            headerIndex_local = headerIndex_local + 1
            do jlev = 1, numLev
              col_ptr_out(jlev,headerIndex) = col_ptr_in(jlev,headerIndex_local)
            enddo
          else
            headerIndex_recv = headerIndex_recv + 1
            do jlev = 1, numLev
              col_ptr_out(jlev,headerIndex) = col_recv(jlev,headerIndex_recv)
            enddo
          endif
        enddo
        deallocate(col_recv)
      else
        ! No communication
        col_ptr_out(:,1:numHeaderColumn) = col_ptr_in(:,1:numHeaderColumn)
      endif

      call tmg_stop(39)

    end subroutine transpose_tileToColumn

    !--------------------------------------------------------------------------
    ! UVROT2UV
    !--------------------------------------------------------------------------
    subroutine uvrot2uv (UUvarName,VVvarName,numLev)
      !
      !- uvrot2uv - Transforms tangential (U,V) wind components at observation
      !             locations on GEM rotated frame to the real sphere.
      use WindRotation_mod
      implicit none

      character(len=*), intent(in) :: UUvarName
      character(len=*), intent(in) :: VVvarName
      integer,          intent(in) :: numLev
    
      real(8) :: lat, lon, latrot, lonrot, xpos, ypos
      real(8), pointer :: UUcolumn(:), VVcolumn(:)
      integer :: headerIndex

      !
      !- 1.  Loop over all the observation locations
      !
      do headerIndex = 1, col_getNumCol(column)

        !- 1.1 Extract (rotated) wind profiles
        UUColumn => col_getColumn(column,headerIndex,UUvarName)
        VVColumn => col_getColumn(column,headerIndex,VVvarName)
       
        !- 1.2 Find the latitudes and longitudes
        call col_getLatLon( column, headerIndex,                   & ! IN
                            Lat, Lon, ypos, xpos, LatRot, LonRot )   ! OUT

        !- 1.3 Rotate Winds
        call uvr_RotateWind( UUColumn, VVColumn,       & ! INOUT
                             Lat, Lon, LatRot, LonRot, & ! IN
                             'ToMetWind', numLev )       ! IN

      enddo

    end subroutine uvrot2uv

  end subroutine s2c_tl


  !---------------------------------------------------------
  ! Adjoint operator (replaces oda_LT)
  !---------------------------------------------------------
  subroutine s2c_ad(statevector,column,columng,obsSpaceData)
    implicit none
    !
    ! Purpose: Adjoint of horizontal interpolations
    !          Compute adjoint statevector object from adjoint column object
    !

    type(struct_columnData) :: column,columng
    type(struct_obs)        :: obsSpaceData
    type(struct_gsv)        :: statevector

    integer :: ierr, myLonEndP1, myLatEndP1, status, Vcode_anl
    type(struct_vco), pointer :: vco_anl

    if(.not.initialized) call s2c_setup(statevector,column,obsSpaceData)

    myLonEndP1 = statevector%myLonEnd + 1
    myLatEndP1 = min(statevector%myLatEnd + 1, statevector%nj)

    !
    !- 2.  Variable conversions
    !

    !- 2.2 Rotated wind to Meteorological wind
    if ( gsv_varExist('UU') .and. gsv_varExist('VV') .and. statevector%hco%Rotated ) then
       write(*,*) 'uvrot2uvAdj Active' 
       call uvrot2uvAdj('UU', 'VV', col_getNumLev(column,'MM')) ! IN
    end if
  
    !- 2.1 Mass fields (TT,PS,HU) to hydrostatic geopotential
    vco_anl => col_getVco(columng)
    status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)
    call tmg_start(37,'INTERP_TT2PHI_AD')
    call tt2phi_ad(column,columng)
    call tmg_stop(37)
  
    !
    !- 1.  Interpolation to obs location
    !
    if(mpi_myid==0) write(*,*) 's2c_ad - Adjoint of horizontal interpolation StateVector --> ColumnData'
  
    call gd2mvoad

    !- 1.1 Communicate extra latitude needed for interpolation
    call tmg_start(38,'INTERP_BARR')
    call rpn_comm_barrier("GRID",ierr)
    call tmg_stop(38)
    call tmg_start(39,'INTERP_COMM')
    call commLatLonAd(statevector)
    call tmg_stop(39)

  CONTAINS

    !--------------------------------------------------------------------------
    ! GD2MVOAD
    !--------------------------------------------------------------------------
    subroutine gd2mvoad
      !
      ! s/r GD2MVOAD  - Adjoint of the bilinear horizontal interpolation of the 
      !                 model variables in grid-point space to observation locations.
      !
      !    Purpose:  Update the estimate of GD from the gradient components
      !              at the observation points which have been stored in
      !              column
      !
      implicit none
    
      integer :: numLev    
      integer :: jlev, headerIndex, stepIndex, ilon, ilat
      real(8) :: dldx, dldy, dlw1, dlw2, dlw3, dlw4, DInterpWeight
      real(8) :: xpos, ypos, lat, lon, latrot, lonrot
      real(8), pointer :: column_ptr(:,:), column_tile(:,:)

      if (col_getNumCol(column) > 0) then
        column_ptr => col_getAllColumns(column)
        numLev = size(column_ptr,1)
      endif

      if (numHeaderTile > 0) then
        allocate(column_tile(numLev,numHeaderTile))
        column_tile(:,:) = 0.0d0
      endif

      call tmg_start(38,'INTERP_BARR')
      call rpn_comm_barrier("GRID",ierr)
      call tmg_stop(38)

      if (numHeaderTile > 0) then
        call transpose_columnToTile(column_tile,column_ptr,numLev)
      endif

      ! Note: We assume here the all the obs between the poles and the last grid points
      !       (i.e. outside the grid) have been moved within the grid previously


      do stepIndex = 1, statevector%numStep

        fieldsWithHalo(:,:,:,stepIndex) = 0.0D0
      
        !
        !- 2.  LOOP OVER ALL THE OBSERVATIONS
        !
        do headerIndex = 1, numHeaderTile

          if ( myTimeInterpWeight(headerIndex,stepIndex) > 0.0d0 ) then

            !- 2.1 Find the obs position within the analysis grid
            ypos = myYposTile(headerIndex)
            xpos = myXposTile(headerIndex)
            Lat  = myLatTile(headerIndex)
            Lon  = myLonTile(headerIndex)

            !- Make sure we are within bounds
            if ( ypos < real(statevector%myLatBeg,8) .or. &
                 ypos > real(myLatEndP1          ,8) .or. &
                 xpos < real(statevector%myLonBeg,8) .or. &
                 xpos > real(myLonEndP1          ,8) ) then
              write(*,*) 's2c_ad: Obs outside local domain for job = ', headerIndex
              write(*,*) '  obs x, y position  = ', xpos, ypos
              write(*,*) '  domain x_start, x_end, y_start, y_end bounds = ',  &
                         statevector%myLonBeg, myLonEndP1, statevector%myLatBeg, myLatEndP1

              ! if obs above or below latitude band, move it to the edge of this latitude band
              if( ypos < real(statevector%myLatBeg,8) ) ypos = real(statevector%myLatBeg,8)
              if( ypos > real(myLatEndP1          ,8) ) ypos = real(myLatEndP1          ,8)

              ! abort if obs is to the left or right of the analysis domain
              if( xpos < real(statevector%myLonBeg,8) ) xpos = real(statevector%myLonBeg,8)
              if( xpos > real(myLonEndP1          ,8) ) xpos = real(myLonEndP1          ,8)
            end if

            !- 2.2 Find the lower-left grid point next to the observation
            if ( xpos /= real(myLonEndP1,8) ) then
              ilon = floor(xpos)
            else
              ilon = floor(xpos) - 1
            end if

            if ( ypos /= real(myLatEndP1,8) ) then
              ilat = floor(ypos)
            else
              ilat = floor(ypos) - 1
            end if

            !- 2.3 COMPUTE THE 4 WEIGHTS OF THE BILINEAR INTERPOLATION
            dldx = xpos - real(ilon,8)
            dldy = ypos - real(ilat,8)

            DInterpWeight = myTimeInterpWeight(headerIndex,stepIndex)
          
            dlw1  = DInterpWeight * (1.d0-dldx) * (1.d0-dldy)
            dlw2  = DInterpWeight *       dldx  * (1.d0-dldy)
            dlw3  = DInterpWeight * (1.d0-dldx) *       dldy
            dlw4  = DInterpWeight *       dldx  *       dldy

            !- 2.4 Interpolate the model state to the obs point
            do jlev = 1, numLev
              fieldsWithHalo(ilon  ,jlev,ilat,  stepIndex) = fieldsWithHalo(ilon  ,jlev,ilat,  stepIndex)    &
                                          + dlw1 * column_tile(jlev,headerIndex)
              fieldsWithHalo(ilon+1,jlev,ilat,  stepIndex) = fieldsWithHalo(ilon+1,jlev,ilat,  stepIndex)    &
                                          + dlw2 * column_tile(jlev,headerIndex)
              fieldsWithHalo(ilon  ,jlev,ilat+1,stepIndex) = fieldsWithHalo(ilon  ,jlev,ilat+1,stepIndex)    &
                                          + dlw3 * column_tile(jlev,headerIndex)
              fieldsWithHalo(ilon+1,jlev,ilat+1,stepIndex) = fieldsWithHalo(ilon+1,jlev,ilat+1,stepIndex)    &
                                          + dlw4 * column_tile(jlev,headerIndex)
            enddo

          end if

        enddo ! headerIndex

      enddo ! stepIndex

      if (numHeaderTile > 0) then
        deallocate(column_tile)
      endif

    end subroutine gd2mvoad

    !--------------------------------------------------------------------------
    ! transpose_columnToTile
    !--------------------------------------------------------------------------
    subroutine transpose_columnToTile(col_ptr_out,col_ptr_in,numLev)
      implicit none
      real(8), pointer :: col_ptr_in(:,:),col_ptr_out(:,:)
      integer :: numLev

      real(8), allocatable :: col_send(:,:)
      integer :: headerIndex, headerIndex_local, headerIndex_send, jlev, nsize, ierr

      call tmg_start(39,'INTERP_COMM')

      if(PE_receiver_mpiglobal(mpi_myid+1).ne.-1) then
        ! I am a receiver from COLUMN to TILE
        col_ptr_out(:,1:numHeaderColumn) = col_ptr_in(:,1:numHeaderColumn)

        call tmg_start(35,'INTERP_SENDRECV')
        nsize = numlev*(numHeaderTile-numHeaderColumn)
        call rpn_comm_recv(col_ptr_out(1:numlev,numHeaderColumn+1:numHeaderTile),nsize, &
                           "mpi_double_precision",PE_receiver_mpiglobal(mpi_myid+1), &
                           PE_receiver_mpiglobal(mpi_myid+1)*2000+mpi_myid,  &
                           "GRID",status,ierr)
        call tmg_stop(35)


      elseif(PE_sender_mpiglobal(mpi_myid+1).ne.-1) then
        ! I am a sender from COLUMN to TILE:
        nsize = numlev*(numHeaderColumn-numHeaderTile)
        allocate(col_send(numLev,nsize))
        headerIndex_local = 0
        headerIndex_send = 0
        do headerIndex = 1, numHeaderColumn
          if(myPEsourceColumn(headerIndex).eq.mpi_myid) then
            headerIndex_local = headerIndex_local + 1
            do jlev = 1, numLev
              col_ptr_out(jlev,headerIndex_local) = col_ptr_in(jlev,headerIndex)
            enddo
          else
            headerIndex_send = headerIndex_send + 1
            do jlev = 1, numLev
              col_send(jlev,headerIndex_send) = col_ptr_in(jlev,headerIndex)
            enddo
          endif
        enddo
        call tmg_start(35,'INTERP_SENDRECV')
        call rpn_comm_send(col_send(:,:),nsize, &
                           "mpi_double_precision",PE_sender_mpiglobal(mpi_myid+1), &
                           mpi_myid*2000+PE_sender_mpiglobal(mpi_myid+1),  &
                           "GRID",ierr)
        call tmg_stop(35)
        deallocate(col_send)
      else
        ! No communication
        col_ptr_out(:,1:numHeaderColumn) = col_ptr_in(:,1:numHeaderColumn)
      endif

      call tmg_stop(39)

    end subroutine transpose_columnToTile

    !--------------------------------------------------------------------------
    ! UVROT2UVADJ
    !--------------------------------------------------------------------------
    subroutine uvrot2uvAdj(UUvarName,VVvarName,numLev)
      !
      !- uvrot2uv - Transforms tangential (U,V) wind components at observation
      !             locations on GEM rotated frame to the real sphere.
      use WindRotation_mod
      implicit none

      character(len=*), intent(in) :: UUvarName
      character(len=*), intent(in) :: VVvarName
      integer,          intent(in) :: numLev
    
      real(8) :: lat, lon, latrot, lonrot, xpos, ypos
      real(8), pointer :: UUcolumn(:), VVcolumn(:)
      integer :: headerIndex

      !
      !- 1.  Loop over all the observation locations
      !
      do headerIndex = 1, col_getNumCol(column)

        !- 1.1 Extract (rotated) wind profiles
        UUColumn => col_getColumn(column,headerIndex,UUvarName)
        VVColumn => col_getColumn(column,headerIndex,VVvarName)
       
        !- 1.2 Find the latitudes and longitudes
        call col_getLatLon( column, headerIndex,                   & ! IN
                            Lat, Lon, ypos, xpos, LatRot, LonRot )   ! OUT

        !- 1.3 Rotate Winds
        call uvr_RotateWindAdj( UUColumn, VVColumn,       & ! INOUT
                                Lat, Lon, LatRot, LonRot, & ! IN
                                'ToMetWind', numLev )       ! IN

      enddo

    end subroutine uvrot2uvAdj

  end subroutine s2c_ad


  subroutine commLatLon(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize, ierr, status, latPerPEhalo, myLatEndP1
    integer :: jlat, jstep, jlev, jlon
    real(8), pointer :: field_ptr(:,:,:,:) 

    ! copy statevector into fieldsWithHalo
    field_ptr => gsv_getField(statevector_in)
!$OMP PARALLEL DO PRIVATE (jlat,jstep,jlev,jlon)    
    do jlat = statevector_in%myLatBeg, statevector_in%myLatEnd
      do jstep = 1, statevector_in%numStep
        do jlev = 1, statevector_in%nk
          do jlon = statevector_in%myLonBeg, statevector_in%myLonEnd
            fieldsWithHalo(jlon,jlev,jlat,jstep)= field_ptr(jlon,jlev,jlat,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    ! ******First send latitude halos

    if(mpi_npey.gt.1) then  ! only do exchange when more than one mpi task in Y direction

      nsize=statevector_in%lonPerPE*statevector_in%nk*statevector_in%numStep

      ! northern most latitude band
      if(mpi_myidy.eq.(mpi_npey-1)) then
        call rpn_comm_send(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                                             statevector_in%myLatBeg:statevector_in%myLatBeg,:),nsize, &
                           "mpi_double_precision",mpi_myidy-1,mpi_myidy*500+(mpi_myidy-1),  &
                           "NS",ierr)
      endif

      ! all latitude bands not at the north or south poles
      if(mpi_myidy.ne.0.and.mpi_myidy.ne.(mpi_npey-1)) then
        call rpn_comm_sendrecv(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                                                 statevector_in%myLatBeg:statevector_in%myLatBeg,:), &
                               nsize,"mpi_double_precision",mpi_myidy-1,mpi_myidy*500+(mpi_myidy-1), &
                               fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:, &
                                                 (statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                               nsize,"mpi_double_precision",mpi_myidy+1,(mpi_myidy+1)*500+mpi_myidy, &
                               "NS",status,ierr)
      endif

      ! southern most latitude band
      if(mpi_myidy.eq.0) then
        call rpn_comm_recv(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:, &
                                             (statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:),nsize, &
                          "mpi_double_precision",mpi_myidy+1,(mpi_myidy+1)*500+mpi_myidy,  &
                          "NS",status,ierr)
      endif

    endif ! mpi_npey.gt.1


    ! ******Now send longitude halos

    if(mpi_myidy.eq.(mpi_npey-1)) then
      ! northern most latitude band does not have a latitude halo to the north
      latPerPEhalo = statevector_in%latPerPE
      myLatEndP1 = statevector_in%myLatEnd
    else
      ! all others do
      latPerPEhalo = statevector_in%latPerPE + 1
      myLatEndP1 = statevector_in%myLatEnd + 1
    endif

    if(mpi_npex.gt.1) then  ! only do exchange when more than one mpi task in X direction

      nsize=latPerPEhalo*statevector_in%nk*statevector_in%numStep

      ! eastern most longitude band
      if(mpi_myidx.eq.(mpi_npex-1)) then
        call rpn_comm_send(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonBeg,:,  &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
          "mpi_double_precision",mpi_myidx-1,mpi_myidx*500+(mpi_myidx-1),"EW",ierr)
      endif

      ! all other longitude bands (not first nor last)
      if(mpi_myidx.ne.0.and.mpi_myidx.ne.(mpi_npex-1)) then
        call rpn_comm_sendrecv(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonBeg,:,  &
                                                 statevector_in%myLatBeg:myLatEndP1,:), &
                               nsize,"mpi_double_precision",mpi_myidx-1,mpi_myidx*500+(mpi_myidx-1), &
                               fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                                 statevector_in%myLatBeg:myLatEndP1,:), &
                               nsize,"mpi_double_precision",mpi_myidx+1,(mpi_myidx+1)*500+mpi_myidx, &
                               "EW",status,ierr)
      endif

      ! western most longitude band
      if(mpi_myidx.eq.0) then
        call rpn_comm_recv(fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
          "mpi_double_precision",mpi_myidx+1,(mpi_myidx+1)*500+mpi_myidx,"EW",status,ierr)
      endif

      ! periodic, so also send the first meridian on myidx=0 to the last meridian on myidx=(npex-1)
      if(mpi_myidx.eq.0) then
        call rpn_comm_send(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonBeg,:,  &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
          "mpi_double_precision",mpi_npex-1,mpi_myidx*500+(mpi_npex-1),"EW",ierr)
      endif
      if(mpi_myidx.eq.(mpi_npex-1)) then
        call rpn_comm_recv(fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
          "mpi_double_precision",0,0*500+mpi_myidx,"EW",status,ierr)
      endif

    else ! only one mpi task in X direction, so just copy first meridian to last (plus 1)
      
      fieldsWithHalo(statevector_in%myLonEnd+1,:,statevector_in%myLatBeg:myLatEndP1,:) = &
        fieldsWithHalo(1                      ,:,statevector_in%myLatBeg:myLatEndP1,:)

    endif

  end subroutine commlatlon


  subroutine commLatLonAd(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize, ierr, status, latPerPEhalo, myLatEndP1
    real*8, allocatable :: latHalo(:,:,:,:)
    real*8, allocatable :: lonHalo(:,:,:,:)
    integer :: jlat, jstep, jlev, jlon
    real(8), pointer :: field_ptr(:,:,:,:) 

    ! ******Adjoint of sending longitude halos

    if(mpi_myidy.eq.(mpi_npey-1)) then
      ! northern most latitude band does not have a latitude halo to the north
      latPerPEhalo = statevector_in%latPerPE
      myLatEndP1 = statevector_in%myLatEnd
    else
      ! all others do
      latPerPEhalo = statevector_in%latPerPE + 1
      myLatEndP1 = statevector_in%myLatEnd + 1
    endif

    if(mpi_npex.gt.1) then  ! only do adjoint of exchange when more than one mpi task in X direction

      allocate(lonHalo(1, statevector_in%nk, latPerPEhalo, statevector_in%numStep))

      nsize=latPerPEhalo*statevector_in%nk*statevector_in%numStep

      ! periodic, so also do adjoint of sending the first meridian on myidx=0 to the last meridian on myidx=(npex-1)
      if(mpi_myidx.eq.(mpi_npex-1)) then
        call rpn_comm_send(fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
                           "mpi_double_precision",0,0*500+mpi_myidx,  &
                           "EW",ierr)
      endif
      if(mpi_myidx.eq.0) then
        call rpn_comm_recv(lonHalo,nsize, &
                           "mpi_double_precision",mpi_npex-1,mpi_myidx*500+(mpi_npex-1),"EW",status,ierr)
      endif

      ! western most longitude band
      if(mpi_myidx.eq.0) then
        call rpn_comm_send(fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                             statevector_in%myLatBeg:myLatEndP1,:),nsize, &
                           "mpi_double_precision",mpi_myidx+1,(mpi_myidx+1)*500+mpi_myidx,  &
                           "EW",ierr)
      endif

      ! all other longitude bands (not first nor last)
      if(mpi_myidx.ne.0.and.mpi_myidx.ne.(mpi_npex-1)) then
        call rpn_comm_sendrecv(fieldsWithHalo((statevector_in%myLonEnd+1):(statevector_in%myLonEnd+1),:, &
                                                 statevector_in%myLatBeg:myLatEndP1,:), &
                               nsize,"mpi_double_precision",mpi_myidx+1,(mpi_myidx+1)*500+mpi_myidx, &
                               lonHalo, &
                               nsize,"mpi_double_precision",mpi_myidx-1,mpi_myidx*500+(mpi_myidx-1), &
                               "EW",status,ierr)
      endif

      ! eastern most longitude band
      if(mpi_myidx.eq.(mpi_npex-1)) then
        call rpn_comm_recv(lonHalo,nsize, &
                           "mpi_double_precision",mpi_myidx-1,mpi_myidx*500+(mpi_myidx-1),"EW",status,ierr)
      endif

      ! add the sensitivity from the halo to the in situ sensitivity
      fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonBeg,:,  &
                        statevector_in%myLatBeg:myLatEndP1,:) = &
        fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonBeg,:,  &
                          statevector_in%myLatBeg:myLatEndP1,:) + lonHalo(:,:,:,:)

      ! to make sure sensitivity from the halo is not double counted, set to zero
      fieldsWithHalo(statevector_in%myLonEnd+1,:,statevector_in%myLatBeg:myLatEndP1,:) = 0.0d0

      deallocate(lonHalo)

    else ! only one mpi task in X direction, so just adjoint of copying first meridian to last (plus 1)
      
      fieldsWithHalo(1                          ,:,statevector_in%myLatBeg:myLatEndP1,:) =  &
        fieldsWithHalo(1                        ,:,statevector_in%myLatBeg:myLatEndP1,:) +  &
        fieldsWithHalo(statevector_in%myLonEnd+1,:,statevector_in%myLatBeg:myLatEndP1,:)
        
      ! to make sure sensitivity from the halo is not double counted, set to zero
      fieldsWithHalo(statevector_in%myLonEnd+1,:,statevector_in%myLatBeg:myLatEndP1,:) = 0.0d0

    endif

    ! ******Adjoint of sending latitude halos

    if(mpi_npey.gt.1) then  ! only do exchange when more than one mpi task in Y direction

      allocate(latHalo(statevector_in%lonPerPE, statevector_in%nk, 1, statevector_in%numStep))

      nsize=statevector_in%lonPerPE*statevector_in%nk*statevector_in%numStep

      ! southern most latitude band
      if(mpi_myidy.eq.0) then
        call rpn_comm_send(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                                             (statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                           nsize,"mpi_double_precision",mpi_myidy+1,(mpi_myidy+1)*500+mpi_myidy,"NS",ierr)
      endif

      ! all latitude bands not at the north or south poles
      if(mpi_myidy.ne.0.and.mpi_myidy.ne.(mpi_npey-1)) then
        call rpn_comm_sendrecv(fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                                                 (statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                               nsize,"mpi_double_precision",mpi_myidy+1,(mpi_myidy+1)*500+mpi_myidy, &
                               latHalo, &
                               nsize,"mpi_double_precision",mpi_myidy-1,mpi_myidy*500+(mpi_myidy-1), &
                               "NS",status,ierr)
      endif

      ! northern most latitude band
      if(mpi_myidy.eq.(mpi_npey-1)) then
        call rpn_comm_recv(latHalo,nsize,  &
                           "mpi_double_precision",mpi_myidy-1,mpi_myidy*500+(mpi_myidy-1), &
                           "NS",status,ierr)
      endif

      ! add the sensitivity from the halo to the in situ sensitivity
      if(mpi_myidy.ne.0) then
        fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                       statevector_in%myLatBeg:statevector_in%myLatBeg,:) = &
               fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,  &
                              statevector_in%myLatBeg:statevector_in%myLatBeg,:) + &
               latHalo(:,:,:,:)
      endif

      ! to make sure sensitivity from the halo is not double counted, set to zero
      if(mpi_myidy.ne.(mpi_npey-1)) then
        fieldsWithHalo(statevector_in%myLonBeg:statevector_in%myLonEnd,:,statevector_in%myLatEnd+1,:)=0.0d0
      endif

      deallocate(latHalo)

    endif

    ! copy statevector into fieldsWithHalo
    field_ptr => gsv_getField(statevector_in)
!$OMP PARALLEL DO PRIVATE (jlat,jstep,jlev,jlon)    
    do jlat = statevector_in%myLatBeg, statevector_in%myLatEnd
      do jstep = 1, statevector_in%numStep
        do jlev = 1, statevector_in%nk
          do jlon = statevector_in%myLonBeg, statevector_in%myLonEnd
            field_ptr(jlon,jlev,jlat,jstep) = fieldsWithHalo(jlon,jlev,jlat,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  end subroutine commLatLonAd

end module stateToColumn_mod
