module masks_mod
  use MathPhysConstants_mod
  use obsSpaceData_mod
  use mod_tovs
  use bufr
  use mpi
  implicit none
  #include "comfilt.cdk"
  #include "partov.cdk"
  #include "comtov.cdk"
  save
  !Purpose:
  !Mask of assimilated data for various type of observations
  !
  !Author  : S. Pellerin ARMA, January 2009
  !
  !Revision:
  !          S. Macpherson ARMA, September 2009
  !            -- add mask lmaskgp for ground-based GPS ZTD data
  !
  ! Mask should be set to .true. if data is assimilated
  ! lmaskpp_in       : mask for pressure profile inside the vertical domain
  ! lmaskpp_out      : mask for pressure profile below the surface
  ! lmasksf_in       : mask for surface data
  ! lmasksf_out      : mask for suface data below the model topography
  ! lmaskto/go/ro/zp : mask for tovs/goes/gpsro/profiler data
  ! lmaskgp          : mask for ground based GPS ZTD data
  ! lmask            : global (all obs type) mask of assimilated data
  ! ldiagpp/sf       : mask of diagnostic pressure profile/suface data
  ! ldiag            : global mask of diagnostic data
  !
  logical, pointer, dimension(:) :: lmaskpp_in,lmaskpp_out,lmasksf_in
  logical, pointer, dimension(:) :: lmasksf_out,lmask,lmaskto
  logical, pointer, dimension(:) :: lmaskro,lmaskzp,ldiagpp,ldiagsf,ldiag
  logical, pointer, dimension(:) :: lmaskgp

  logical, pointer,dimension(:) :: lmask_g 
  logical, pointer,dimension(:) :: lmaskpp_inout_g 
  logical, pointer,dimension(:) :: lmasksf_inout_g 
  logical, pointer,dimension(:) :: lmaskto_g
  logical, pointer,dimension(:) :: lmaskro_g
  logical, pointer,dimension(:) :: lmaskzp_g
  logical, pointer,dimension(:) :: lmaskgp_g

  contains

  subroutine oda_mask(lobsSpaceData)
  implicit none

  type(struct_obs) :: lobsSpaceData

  allocate(lmask(obs_numbody_max(lobsSpaceData)))
  lmask = .false.

  allocate(lmaskpp_in(obs_numbody_max(lobsSpaceData)))
  lmaskpp_in = .false.

  allocate(lmaskpp_out(obs_numbody_max(lobsSpaceData)))
  lmaskpp_out = .false.

  allocate(lmasksf_in(obs_numbody_max(lobsSpaceData)))
  lmasksf_in = .false.

  allocate(lmasksf_out(obs_numbody_max(lobsSpaceData)))
  lmasksf_out = .false.

  allocate(lmaskto(obs_numbody_max(lobsSpaceData)))
  lmaskto = .false.

  allocate(lmaskro(obs_numbody_max(lobsSpaceData)))
  lmaskro = .false.

  allocate(lmaskzp(obs_numbody_max(lobsSpaceData)))
  lmaskzp = .false.

  allocate(lmaskgp(obs_numbody_max(lobsSpaceData)))
  lmaskgp = .false.

  allocate(ldiag(obs_numbody_max(lobsSpaceData)))
  ldiag = .false.

  allocate(ldiagpp(obs_numbody_max(lobsSpaceData)))
  ldiagpp = .false.

  allocate(ldiagsf(obs_numbody_max(lobsSpaceData)))
  ldiagsf = .false.

  call oda_masksf(lobsSpaceData,'UA')
  call oda_masksf(lobsSpaceData,'SF')
  call oda_masksf(lobsSpaceData,'SC')
  call oda_masksf(lobsSpaceData,'GP')
  call oda_maskpp(lobsSpaceData,'UA')
  call oda_maskpp(lobsSpaceData,'AI')
  call oda_maskpp(lobsSpaceData,'SW')
  call oda_maskto(lobsSpaceData)
  call oda_maskro(lobsSpaceData)
  call oda_maskzp(lobsSpaceData,'PR')
  call oda_maskgp(lobsSpaceData)

  !restore Global Masks. 
!!  IF(NCONF == 141) CALL restoreMasks(lobsSpaceData) 
!!  IF(mpi_nprocs.gt.1) CALL restoreMasks(lobsSpaceData) 
  CALL restoreMasks(lobsSpaceData) 

  end subroutine oda_mask

      SUBROUTINE oda_masksf(lobsSpaceData,CDFAM)
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          P. Koclas *CMC/AES in September 1994
!
      type(struct_obs) :: lobsSpaceData
      CHARACTER(len=*) :: CDFAM
      INTEGER ITYP
      integer :: index_header, index_body
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C

      ! loop over all header indices of the CDFAM family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,CDFAM)
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
!C
!C     Process all data within the domain of the model
!C
         ! loop over all body indices (still in the CDFAM family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            IF ( obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 1 ) THEN
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',index_body)
                IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NEPS  &
                     .OR.ITYP.EQ.BUFR_NEPN .OR. ITYP.EQ.BUFR_NESS  &
                     .OR.ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS) THEN
                  LMASKSF_IN(index_body)=(obs_elem_i(lobsSpaceData,'ASS ', &
                                                     index_body) &
                                          .EQ. 1)
                ELSE IF (ITYP.EQ.BUFR_NEZD .OR. ITYP.EQ.BUFR_NEFE) THEN
                  LMASKSF_IN(index_body)= .false.
                ELSE
                  LMASKSF_IN(index_body)= &
                       (      obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1&
                        .AND. obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 0)
                ENDIF

               IF(obs_elem_i(lobsSpaceData,'VNM ',index_body) .EQ. BUFR_NEHS)then
                  ldiagsf(index_body) = .true.
                endif
            ENDIF ! VC0 .EQ. 1
         end do BODY

!C
!C     Process all geopotential data below model's orography
!C
         ! loop over all body indices (still in the CDFAM family)
                                        ! Start at the beginning of the list
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY_2: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY_2

            lmasksf_out(index_body)= &
                           (obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1) &
                     .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 2) &
                     .AND. (obs_elem_i(lobsSpaceData,'VNM ',index_body) &
                                                               .EQ. BUFR_NEGZ ) &
                     .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 1)
         enddo BODY_2

      END DO HEADER

      lmask = lmask .or. lmasksf_in
      lmask = lmask .or. lmasksf_out
      ldiag = ldiag .or. ldiagsf
!C--------------------------------------------------------------------
      RETURN
      END subroutine oda_masksf


      SUBROUTINE oda_maskpp(lobsSpaceData,CDFAM)
!* Argument declarations
      type(struct_obs) :: lobsSpaceData
      CHARACTER(len=*) :: CDFAM ! Family code to process (UA,SW,AI)
!*
!*Purpose : Defines a mask of assimilated and diagnosed data inside
!*          and outside the vertical domain
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          P. Koclas *CMC/AES in September 1994
!*
!* Local declarations
      INTEGER IDBURP
      integer :: index_header, index_body
      REAL(8) :: ZLAT,ZLON
      LOGICAL LLNOXTR
      LLNOXTR   = .false.

      ! loop over all header indices of the CDFAM family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,CDFAM)
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
!C
!C     Process all data within the domain of the model
!C
         ! loop over all body indices (still in the CDFAM family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            lmaskpp_in(index_body)= &
                           (obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1) &
                     .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 0) &
                     .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 2)

            IF(      obs_elem_i(lobsSpaceData,'VNM ',index_body) .EQ. BUFR_NEHU &
               .AND. obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 2) THEN
               IF (     NINT(obs_elem_r(lobsSpaceData,'PPP ',index_body)) &
                   .GE. NINT(RLIMLVHU *100) ) THEN
                  ldiagpp(index_body) = .true.
               ENDIF
            endif
         END DO BODY

         ! loop over all body indices (still in the CDFAM family)
                                        ! Start at the beginning of the list
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY_2: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY_2

            lmaskpp_out(index_body)= &
                         (obs_elem_i(lobsSpaceData,'ASS ',index_header) .EQ. 1) &
                   .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_header) .EQ. 2) &
                   .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_header) .EQ. 2)

            if (lmaskpp_out(index_body) .and. &
                obs_elem_i(lobsSpaceData,'VNM ',index_header) .NE.BUFR_NEGZ) then
               lmaskpp_out(index_body) = .false.
              LLNOXTR   = .true.
              ZLAT      = obs_elem_r(lobsSpaceData,'LAT ',index_header) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
              ZLON      = obs_elem_r(lobsSpaceData,'LON ',index_header) &
                                                      * MPC_DEGREES_PER_RADIAN_R8
              IDBURP    = obs_elem_i(lobsSpaceData,'ITY ',index_header)

              WRITE(*,*)' ODA_MASKPP: NO EXTRAPOLATION ALLOWED '  &
                   ,' OBS ',obs_elem_c9(lobsSpaceData,'STID',index_header) &
                   ,' TYPE ',IDBURP, ' ELM ' &
                   , obs_elem_i(lobsSpaceData,'VNM ',index_header),' LAT ' &
                   , ZLAT,  ' LON ', ZLON
            endif
         END DO BODY_2
      END DO HEADER
      lmask = lmask .or. lmaskpp_in
      lmask = lmask .or. lmaskpp_out
      ldiag = ldiag .or. ldiagpp
!C--------------------------------------------------------------------
      IF(LLNOXTR) THEN
        WRITE(*,*)'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        WRITE(*,*)' Warning - ODA_MASKPP: NO EXTRAPOLATION ALLOWED SEE LISTING FOR MORE DETAILS'
        WRITE(*,*)'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
      ENDIF

      RETURN
      END subroutine oda_maskpp


subroutine oda_maskto(lobsSpaceData)
  ! Purpose : Defines a mask of assimilated data
  !
  ! Author  : S. Pellerin, ARMA, January 2009
  !           Based on selection made in observation operator as written by
  !           j. halle *cmda/aes  in december 2005
  !
  !revision :      Sylvain Heilliette:
  !                 add IASI data (codtyp 186)

  type(struct_obs) :: lobsSpaceData
  integer :: isens, indxchn, indxtovs
  integer idatyp
  integer ichn
  integer :: index_header, index_body
  integer  isrcheq
  external isrcheq
  external abort3d

  if(NOBTOV.eq.0) return    ! exit if there are not tovs data

  !     1.  Computation of (hx - z)/sigma for tovs data only
  !     .   ------------------------------------------------

  ! loop over all header indices of the 'TO' family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
  call obs_set_current_header_list(lobsSpaceData,'TO')
  HEADER: do
     index_header = obs_getHeaderIndex(lobsSpaceData)
     if (index_header < 0) exit HEADER
           !     .  1.1  Extract general information for this observation point
           !     .       ------------------------------------------------------

     !       process only radiance data to be assimilated?
     !       (data type=[164,168,180,181,182,183,185,186])

     idatyp = obs_elem_i(lobsSpaceData,'ITY ',index_header)
           if ( idatyp .ne. 164 .and.  &
                idatyp .ne. 168 .and.  &
                idatyp .ne. 180 .and.  &
                idatyp .ne. 181 .and.  &
                idatyp .ne. 182 .and.  &
                idatyp .ne. 183 .and.  &
                idatyp .ne. 185 .and.  &
                idatyp .ne. 186          ) then
        cycle HEADER                    ! Proceed to the next HEADER
     end if

     indxtovs = ltovsno(index_header)
     if ( indxtovs .eq. 0 ) then
        write(*,fmt=9203)
9203    format(' tovs_calc_jo_tl: error with indxtovs')
        call abort3d(6,'tovs_calc_jo_tl ')
     endif

     if (rttov_errorstatus(indxtovs) .lt. 20   ) then
        ! loop over all body indices (still in the 'TO' family)
        isens = lsensor(indxtovs)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
        call obs_set_current_body_list(lobsSpaceData, index_header)
        BODY: do 
           index_body = obs_getBodyIndex(lobsSpaceData)
           if (index_body < 0) exit BODY

           if ( obs_elem_i(lobsSpaceData,'ASS ',index_body).eq.1 ) then
              ichn = nint(obs_elem_r(lobsSpaceData,'PPP ',index_body))
              ichn    = max(0,min(ichn,jpch+1))
              if(idatyp.ne.183 .and. idatyp.ne.186) ichn=ichn-chanoffset(isens)
              indxchn = isrcheq (ichan(:,isens),nchan(isens),ichn)
              if ( indxchn .eq. 0 ) then
                 write(*,fmt=9202)
9202             format(' tovs_calc_jo_tl: error with channel number')
                 call abort3d(6,'tovs_calc_jo_tl  ')
              endif
!              print *,"maskto",index_body!,shape(lmaskto(:))
              lmaskto(index_body) = .true.
           endif
        enddo BODY
!    else
!       kfailtot = kfailtot + 1
     endif
  enddo HEADER
  lmask = lmask .or. lmaskto
end subroutine oda_maskto


      SUBROUTINE oda_maskro(lobsSpaceData)
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          J. M. Aparicio in Jan 2004
!*
      type(struct_obs) :: lobsSpaceData
      INTEGER IDATYP
      LOGICAL  LUSE
      integer :: index_header, index_body

      ! loop over all header indices of the 'RO' family (Radio Occultation)
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,'RO')
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER

         IDATYP = obs_elem_i(lobsSpaceData,'ITY ',index_header)
         IF ( IDATYP .NE. 169 ) THEN
            cycle HEADER                ! Proceed to the next HEADER
         ENDIF

         ! loop over all body indices (still in the 'RO' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            LUSE=( obs_elem_i(lobsSpaceData,'ASS ',index_body).EQ.1 )
            IF ( LUSE ) THEN
              lmaskro(index_body) = .true.
            ENDIF
         ENDDO BODY
      ENDDO HEADER
      lmask = lmask .or. lmaskro
      RETURN
      END subroutine oda_maskro


      SUBROUTINE oda_maskzp(lobsSpaceData,CDFAM)
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          J. St-James, CMDA/SMC in July 2003
!*
      type(struct_obs) :: lobsSpaceData
      CHARACTER(len=*) :: CDFAM

      integer :: index_header, index_body
      LOGICAL LLOK

      ! loop over all header indices of the CDFAM family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,CDFAM)
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER

         ! loop over all body indices (still in the CDFAM family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            LLOK=       (obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1)  &
                  .AND. (obs_elem_i(lobsSpaceData,'XTR ',INDEX_BODY) .EQ. 0) &
                  .AND. (obs_elem_i(lobsSpaceData,'VCO ',INDEX_BODY) .EQ. 1)
              IF ( LLOK ) THEN
               lmaskzp(index_body) = .true.
              ENDIF
         END DO BODY
      END DO HEADER
      lmask = lmask .or. lmaskzp
      RETURN
      END subroutine oda_maskzp


      SUBROUTINE oda_maskgp(lobsSpaceData)
!*
!*Purpose : Defines a mask of assimilated data for GP family ZTD data
!*
!*Author  : S. Macpherson, ARMA, March 2009
!*
      type(struct_obs) :: lobsSpaceData

      INTEGER ITYP,IDATYP
      integer :: index_header, index_body
      LOGICAL LLOK

      ! loop over all header indices of the 'GP' family
                                        ! Set the header list
                                        ! (& start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,'GP')
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER

         IDATYP    = obs_elem_i(lobsSpaceData,'ITY ',INDEX_HEADER)
            IF ( IDATYP .NE. 189 ) THEN
            cycle HEADER                ! Proceed to the next HEADER
         ENDIF

         ! loop over all body indices (still in the 'GP' family)
                                        ! Set the body list
                                        ! (& start at the beginning of the list)
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
                LLOK = ( (ITYP .EQ. BUFR_NEZD) .AND.  &
                     (obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1) )
                IF ( LLOK ) THEN
                   lmaskgp(index_body) = .true.
                ENDIF
          ENDDO BODY
      END DO HEADER
      lmask = lmask .or. lmaskgp
      RETURN
      END subroutine oda_maskgp


      SUBROUTINE restoreMasks(lobsSpaceData)
!
!c Purpose:
!c Compute the global masks such as lmaskpp_inout_g,lmasksf_inout_g,... 
!c
!c Author  : BIN HE  *ARMA/MRB MAY 2009
!c
      type(struct_obs) :: lobsSpaceData
      INTEGER :: ierr
      integer :: mask_dim
      LOGICAL,DIMENSION(:),pointer :: llmask_l  

       mask_dim = obs_numbody_max(lobsSpaceData)
         
       ALLOCATE(lmaskpp_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmaskpp_inout_g')

       ALLOCATE(lmasksf_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmasksf_inout_g')

       ALLOCATE(lmaskto_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmaskto_g')

       ALLOCATE(lmaskro_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmaskro_g')

       ALLOCATE(lmaskzp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmaskzp_g')

       ALLOCATE(lmask_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmask_g')

       ALLOCATE(lmaskgp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cannt Allocate Mem. to lmaskgp_g')

       ALLOCATE(llmask_l(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(6,'Cant Allocate Mem. to llmask_l')

       CALL restore_mask(lobsSpaceData,lmask_g,lmask,mask_dim)  

       llmask_l = lmaskpp_in .or. lmaskpp_out
       CALL restore_mask(lobsSpaceData,lmaskpp_inout_g,llmask_l,mask_dim)  

       llmask_l =  lmasksf_in .or. lmasksf_out
       CALL restore_mask(lobsSpaceData,lmasksf_inout_g,llmask_l,mask_dim)  

       CALL restore_mask(lobsSpaceData,lmaskto_g,lmaskto,mask_dim)  

       CALL restore_mask(lobsSpaceData,lmaskro_g,lmaskro,mask_dim)  

       CALL restore_mask(lobsSpaceData,lmaskzp_g,lmaskzp,mask_dim)  

       CALL restore_mask(lobsSpaceData,lmaskgp_g,lmaskgp,mask_dim)  

       deallocate(llmask_l)

      END SUBROUTINE restoreMasks     


      SUBROUTINE restore_mask(lobsSpaceData,lmask_g,lmask_l,kdata_g)
        type(struct_obs) :: lobsSpaceData
        INTEGER :: kdata_g 
        Logical :: lmask_g(:) 
        Logical :: lmask_l(:) 

       INTEGER :: i,ii,j ,iobs,idata,idataend,ierr  

       lmask_g=.false.
       ii=0
       DO i=1,obs_numheader(lobsSpaceData)
         iobs=obs_elem_i(lobsSpaceData,'GHI ',i)
         idata=obs_elem_mpiglobal_i(lobsSpaceData,'RLN ',iobs)
         idataend=obs_elem_mpiglobal_i(lobsSpaceData,'NLV ',iobs) + idata -1
         DO j=idata,idataend
           ii=ii+1
           lmask_g(j)=lmask_l(ii)
         ENDDO
       ENDDO  
       IF(mpi_nprocs.gt.1) CALL rpn_comm_allreduce(lmask_g,lmask_g,kdata_g,"MPI_LOGICAL","MPI_LOR","GRID",ierr )
      END SUBROUTINE restore_mask
  !
end module masks_mod
