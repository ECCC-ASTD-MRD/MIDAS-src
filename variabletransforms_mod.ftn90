!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
! MODULE variableTransforms,(prefix="vtr")
!
! Purpose: To store various functions for variable transforms using inputs from
!          gridStateVector(s). Outputs are also placed in a GridStateVector
!
! Subroutines:
!    vtr_setup       (public)
!    vtr_Transform   (public)
!
! Dependencies:
!    gridStateVector
!--------------------------------------------------------------------------
MODULE variableTransforms_mod
  use gridStateVector_mod
  implicit none
  save
  private

  ! public procedures
  public :: vtr_Setup, vtr_Transform

  logical             :: initialized = .false.

  integer             :: myLonBeg, myLonEnd, myLatBeg, myLatEnd

CONTAINS

  !--------------------------------------------------------------------------
  ! vtr_Setup
  !--------------------------------------------------------------------------
  subroutine vtr_setup(statevector)
    implicit none

    type(struct_gsv) :: statevector
    
    if (initialized) return

    write(*,*) 'vtr_setup: starting'

    myLonBeg = statevector%myLonBeg
    myLonEnd = statevector%myLonEnd
    myLatBeg = statevector%myLatBeg
    myLatEnd = statevector%myLatEnd

    initialized  = .true.

    write(*,*) 'vtr_setup: done'

  end subroutine vtr_setup

  !--------------------------------------------------------------------------
  ! vtr_transform
  !--------------------------------------------------------------------------
  subroutine vtr_transform(statevector,transform)
    implicit none
   
    type(struct_gsv) :: statevector
 
    character(len=*), intent(in) :: transform

    if ( .not. initialized ) then
      write(*,*)
      write(*,*) 'The variable transforms module was NOT initialized'
      call abort3d('vtr_transform')
    endif

    select case(trim(transform))
    case ('UVtoVortDiv')
       call UVtoVortDiv(statevector)
    case ('VortDivToPsiChi')
       if ( .not. gsv_varExist('QR') .or. .not. gsv_varExist('DD') ) then
         write(*,*)
         write(*,*) 'for VortDivToPsiChi, variables QR and DD must be allocated in gridstatevector'
         call abort3d('vtr_transform')
       end if
       call VortDivToPsiChi(statevector)
    case default
       write(*,*)
       write(*,*) 'Unsupported function : ', trim(transform)
       call abort3d('vtr_transform')
    end select

  end subroutine vtr_transform

!--------------------------------------------------------------------------
! UVtoVortDiv
!--------------------------------------------------------------------------
  subroutine UVtoVortDiv(statevector)
    use lamAnalysisGrid_mod
    implicit none
   
    type(struct_gsv) :: statevector
 
    real(8), pointer :: uu_ptr(:,:,:,:), vv_ptr(:,:,:,:)
    real(8), pointer :: qr_ptr(:,:,:,:), dd_ptr(:,:,:,:)

    real(8), allocatable :: uu3d(:,:,:), vv3d(:,:,:)
    real(8), allocatable :: qr3d(:,:,:), dd3d(:,:,:)

    integer :: nlev_M, tstep

    uu_ptr => gsv_getField(statevector,'UU')
    vv_ptr => gsv_getField(statevector,'VV')
    qr_ptr => gsv_getField(statevector,'QR')
    dd_ptr => gsv_getField(statevector,'DD')
    nlev_M = gsv_getNumLev(statevector,'MM')
    
    if (  statevector%hco%global ) then
       call abort3d('UVtoVortDiv:global mode not available')
    else
       allocate(uu3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))
       allocate(vv3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))
       allocate(qr3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))
       allocate(dd3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))

       do tstep = 1, statevector%numStep
          
          call lamInterface(uu3d,uu_ptr,tstep,nlev_M,'fromGSV')
          call lamInterface(vv3d,vv_ptr,tstep,nlev_M,'fromGSV')
          
          call lag_UVToVortDiv(qr3d, dd3d, & ! OUT
               uu3d, vv3d, & ! IN
               nlev_M )      ! IN
          
          call lamInterface(qr3d,qr_ptr,tstep,nlev_M,'toGSV')
          call lamInterface(dd3d,dd_ptr,tstep,nlev_M,'toGSV')
          
       end do
       
       deallocate(dd3d)
       deallocate(qr3d)
       deallocate(vv3d)
       deallocate(uu3d)
    end if

  end subroutine UVtoVortDiv

!--------------------------------------------------------------------------
! VortDivToPsiChi
!--------------------------------------------------------------------------
  subroutine VortDivToPsiChi(statevector)
    use LamSpectralTransform_mod
    implicit none
   
    type(struct_gsv) :: statevector
 
    real(8), pointer :: qr_ptr(:,:,:,:), dd_ptr(:,:,:,:)
    real(8), pointer :: pp_ptr(:,:,:,:), cc_ptr(:,:,:,:)

    real(8), allocatable :: vortpsi3d(:,:,:), divchi3d(:,:,:)

    type(struct_lst)     :: lst_lapl   ! Spectral transform Parameters for Vort/Div -> Psi/Chi

    integer :: nlev_M, tstep

    integer :: trunc=125

    qr_ptr => gsv_getField(statevector,'QR')
    dd_ptr => gsv_getField(statevector,'DD')
    pp_ptr => gsv_getField(statevector,'PP')
    cc_ptr => gsv_getField(statevector,'CC')
    nlev_M = gsv_getNumLev(statevector,'MM')
    
    if (  statevector%hco%global ) then
       call abort3d('VortDivToPsiChi:global mode not available')
    else
       call lst_Setup( lst_lapl,                                & ! OUT
                       statevector%hco%ni, statevector%hco%nj,  & ! IN
                       statevector%hco%dlon, trunc,             & ! IN
                      'LatLonMN', nlev_M )                        ! IN

       allocate(VortPsi3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))
       allocate(DivChi3d(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nlev_M))

       do tstep = 1, statevector%numStep
          
          call lamInterface(VortPsi3d,qr_ptr,tstep,nlev_M,'fromGSV')
          call lamInterface(DivChi3d,dd_ptr,tstep,nlev_M,'fromGSV')
         
          ! Vort -> Psi
          call lst_Laplacian( lst_lapl%id,       & ! IN
                              VortPsi3d,         & ! INOUT
                              'Inverse', nlev_M )  ! IN    

          ! Div -> Chi
          call lst_Laplacian( lst_lapl%id,       & ! IN
                              DivChi3d,          & ! INOUT
                              'Inverse', nlev_M )  ! IN

          call lamInterface(VortPsi3d,pp_ptr,tstep,nlev_M,'toGSV')
          call lamInterface(DivChi3d,cc_ptr,tstep,nlev_M,'toGSV')

       end do
       
       deallocate(DivChi3d)
       deallocate(VortPsi3d)

    end if

  end subroutine VortDivToPsiChi

!--------------------------------------------------------------------------
! lamInterface
!--------------------------------------------------------------------------
  subroutine lamInterface(array_lonlatlev, array_lonlevlat, tstep, nk, reOrdering)
    implicit none

    integer,          intent(in)  :: tstep, nk 

    real(8),          intent(inout)  :: array_lonlatlev(myLonBeg:myLonEnd,myLatBeg:myLatEnd,nk)
    real(8),          intent(inout)  :: array_lonlevlat(myLonBeg:,:,myLatBeg:,:)

    character(len=*), intent(in) :: reOrdering

    integer :: i,j,k

    if ( .not. initialized ) then
      call abort3d('lag_reOrder: LamAnalysisGrid not initialized')
    endif

    select case(trim(reOrdering))
    case ('fromGSV') 
    do k = 1, nk
       do j = myLatBeg, myLatEnd
          do i = myLonBeg, myLonEnd
            array_lonlatlev(i,j,k) =  array_lonlevlat(i,k,j,tstep)
          end do
       end do
    end do
    case ('toGSV')
    do k = 1, nk
       do j = myLatBeg, myLatEnd
          do i = myLonBeg, myLonEnd
             array_lonlevlat(i,k,j,tstep) = array_lonlatlev(i,j,k)
          end do
       end do
    end do
    case default
       write(*,*)
       write(*,*) 'Unsupported reOrdering : ', trim(reOrdering)
       call abort3d('lamInterface')
    end select

  end subroutine lamInterface

END MODULE variableTransforms_mod
