!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
! MODULE variableTransforms,(prefix="vtr")
!
! Purpose: To store various functions for variable transforms using inputs from
!          gridStateVector(s). Outputs are also placed in a GridStateVector
!
! Subroutines:
!    vtr_setup       (public)
!    vtr_Transform   (public)
!
! Dependencies:
!    gridStateVector
!--------------------------------------------------------------------------
MODULE variableTransforms_mod
  use gridStateVector_mod
  implicit none
  save
  private

  ! public procedures
  public :: vtr_Setup, vtr_Transform

  logical             :: initialized = .false.

  integer             :: myLonBeg, myLonEnd, myLatBeg, myLatEnd

CONTAINS

  !--------------------------------------------------------------------------
  ! vtr_Setup
  !--------------------------------------------------------------------------
  subroutine vtr_setup(statevector)
    implicit none

    type(struct_gsv) :: statevector
    
    if (initialized) return

    write(*,*) 'vtr_setup: starting'

    myLonBeg = statevector%myLonBeg
    myLonEnd = statevector%myLonEnd
    myLatBeg = statevector%myLatBeg
    myLatEnd = statevector%myLatEnd

    initialized  = .true.

    write(*,*) 'vtr_setup: done'

  end subroutine vtr_setup

  !--------------------------------------------------------------------------
  ! vtr_transform
  !--------------------------------------------------------------------------
  subroutine vtr_transform(statevector,transform)
    implicit none
   
    type(struct_gsv) :: statevector
 
    character(len=*), intent(in) :: transform

    if ( .not. initialized ) then
      write(*,*)
      write(*,*) 'The variable transforms module was NOT initialized'
      call abort3d('vtr_transform')
    endif

    select case(trim(transform))
    case ('UVtoVortDiv')
       call UVtoVortDiv(statevector)
    case ('VortDivToPsiChi')
       if ( .not. gsv_varExist(statevector,'QR') .or. .not. gsv_varExist(statevector,'DD') ) then
         write(*,*)
         write(*,*) 'for VortDivToPsiChi, variables QR and DD must be allocated in gridstatevector'
         call abort3d('vtr_transform')
       end if
       call VortDivToPsiChi(statevector)
    case default
       write(*,*)
       write(*,*) 'Unsupported function : ', trim(transform)
       call abort3d('vtr_transform')
    end select

  end subroutine vtr_transform

!--------------------------------------------------------------------------
! UVtoVortDiv
!--------------------------------------------------------------------------
  subroutine UVtoVortDiv(statevector)
    use lamAnalysisGrid_mod
    implicit none
   
    type(struct_gsv) :: statevector
 
    real(8), pointer :: uu_ptr(:,:,:,:), vv_ptr(:,:,:,:)
    real(8), pointer :: qr_ptr(:,:,:,:), dd_ptr(:,:,:,:)

    integer :: nlev_M, tstep

    uu_ptr => gsv_getField_r8(statevector,'UU')
    vv_ptr => gsv_getField_r8(statevector,'VV')
    qr_ptr => gsv_getField_r8(statevector,'QR')
    dd_ptr => gsv_getField_r8(statevector,'DD')
    nlev_M = gsv_getNumLev(statevector,'MM')
    
    if (  statevector%hco%global ) then
       call abort3d('UVtoVortDiv:global mode not available')
    else

       do tstep = 1, statevector%numStep
          
          call lag_UVToVortDiv(qr_ptr(:,:,:,tstep), dd_ptr(:,:,:,tstep), & ! OUT
                               uu_ptr(:,:,:,tstep), vv_ptr(:,:,:,tstep), & ! IN
                               nlev_M )      ! IN
          
       end do
       
    end if

  end subroutine UVtoVortDiv

!--------------------------------------------------------------------------
! VortDivToPsiChi
!--------------------------------------------------------------------------
  subroutine VortDivToPsiChi(statevector)
    use LamSpectralTransform_mod
    implicit none
   
    type(struct_gsv) :: statevector
 
    real(8), pointer :: qr_ptr(:,:,:,:), dd_ptr(:,:,:,:)
    real(8), pointer :: pp_ptr(:,:,:,:), cc_ptr(:,:,:,:)

    type(struct_lst)     :: lst_lapl   ! Spectral transform Parameters for Vort/Div -> Psi/Chi

    integer :: nlev_M, tstep

    integer :: trunc=125

    qr_ptr => gsv_getField_r8(statevector,'QR')
    dd_ptr => gsv_getField_r8(statevector,'DD')
    pp_ptr => gsv_getField_r8(statevector,'PP')
    cc_ptr => gsv_getField_r8(statevector,'CC')
    nlev_M = gsv_getNumLev(statevector,'MM')
    
    if (  statevector%hco%global ) then
       call abort3d('VortDivToPsiChi:global mode not available')
    else
       call lst_Setup( lst_lapl,                                & ! OUT
                       statevector%hco%ni, statevector%hco%nj,  & ! IN
                       statevector%hco%dlon, trunc,             & ! IN
                      'LatLonMN', nlev_M )                        ! IN

       do tstep = 1, statevector%numStep
          
          pp_ptr(:,:,:,tstep) = qr_ptr(:,:,:,tstep)
          cc_ptr(:,:,:,tstep) = dd_ptr(:,:,:,tstep)
         
          ! Vort -> Psi
          call lst_Laplacian( lst_lapl%id,         & ! IN
                              pp_ptr(:,:,:,tstep), & ! INOUT
                              'Inverse', nlev_M )    ! IN    

          ! Div -> Chi
          call lst_Laplacian( lst_lapl%id,         & ! IN
                              cc_ptr(:,:,:,tstep), & ! INOUT
                              'Inverse', nlev_M )    ! IN

       end do
       
    end if

  end subroutine VortDivToPsiChi


END MODULE variableTransforms_mod
