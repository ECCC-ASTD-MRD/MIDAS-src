MODULE GAUSSGRID_MOD
  implicit none
  save

  integer :: gaus_ni,gaus_nj
  real*8, allocatable :: gaus_rmu(:)
  real*8, allocatable :: gaus_rwocs(:)
  real*8, allocatable :: gaus_r1mu2(:)
  real*8, allocatable :: gaus_rsqm2(:)
  real*8, allocatable :: gaus_r1qm2(:)
  real*8, allocatable :: gaus_r1mui(:)
  real*8, allocatable :: gaus_r1mua(:)
  real*8, allocatable :: gaus_rwt(:)
  real*8, allocatable :: gaus_rlati(:)
  real*8, allocatable :: gaus_rcolat(:)
  real*8, allocatable :: gaus_conphy(:)
  real*8, allocatable :: gaus_conima(:)

  contains

  SUBROUTINE GAUS_SETUP
    !
    !**s/r GAUS_SETUP  - Initialisation of Gaussian latitudes, weights and related
    !     .              quantities
    use MathPhysConstants_mod
    use mpi
    implicit none
    integer :: ni,nj,nulnam,fnom,fclos,ierr
    integer njlath,jlat
    real*8 zpisu2
    NAMELIST /NAMDIM/NI, NJ

    ni=240
    nj=120

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namdim,iostat=ierr)
    write(*,*) 'gsv_setup: reading namelist, ierr=',ierr
    write(*,nml=namdim)
    ierr=fclos(nulnam)

    gaus_ni=ni
    gaus_nj=nj
    allocate(gaus_rmu(nj))  
    allocate(gaus_rwt(nj))
    allocate(gaus_rwocs(nj))
    allocate(gaus_r1mu2(nj))
    allocate(gaus_rsqm2(nj))
    allocate(gaus_rcolat(nj))
    allocate(gaus_r1qm2(nj))
    allocate(gaus_r1mui(nj))
    allocate(gaus_r1mua(nj))
    allocate(gaus_rlati((-1):(nj+2)))
    allocate(gaus_conphy(nj))
    allocate(gaus_conima(nj))

    njlath = (nj + 1)/2
    if(mpi_myid.eq.0) write(*,fmt='(//,6(" ***********"))')
    if(mpi_myid.eq.0) write(*,*)'     SUGAUSSGRID: initialisation of Gaussian', &
         ' latitudes, weights, etc...'
    if(mpi_myid.eq.0) write(*,fmt='(6(" ***********"))')

    !     1. GAUSSIAN LATITUDES AND WEIGHTS OVER AN HEMISPHERE
    !     -------------------------------------------------

    call gauss8(njlath,gaus_rmu(1),gaus_rwt(1),gaus_rsqm2(1),gaus_rcolat(1),gaus_rwocs(1) &
         ,gaus_r1qm2(1),gaus_r1mui(1),gaus_r1mu2(1))

    do jlat = 1, njlath
       gaus_rlati(jlat) = asin(gaus_rmu(jlat))
       gaus_r1mua(jlat) = r1sa*gaus_r1mui(jlat)
    enddo

    !     2. COMPLETION FOR THE SOUTHERN HEMISPHERE
    !     --------------------------------------

    do jlat = njlath +1, nj
       gaus_rmu(jlat)   =  -gaus_rmu(2*njlath +1 - jlat)
       gaus_rwocs(jlat) =   gaus_rwocs(2*njlath +1 - jlat)
       gaus_r1mu2(jlat) =   gaus_r1mu2(2*njlath +1 - jlat)
       gaus_rsqm2(jlat) =   gaus_rsqm2(2*njlath +1 - jlat)
       gaus_r1qm2(jlat) =   gaus_r1qm2(2*njlath +1 - jlat)
       gaus_r1mui(jlat) =   gaus_r1mui(2*njlath +1 - jlat)
       gaus_r1mua(jlat) =   gaus_r1mua(2*njlath +1 - jlat)
       gaus_rwt(jlat)   =   gaus_rwt(2*njlath +1 - jlat)
       gaus_rlati(jlat) = - gaus_rlati (2*njlath +1 - jlat)
    enddo

    zpisu2 = rpi/2.
    do jlat = 1, nj
       gaus_rcolat(jlat) = zpisu2 - gaus_rlati(jlat)
    enddo

    !*    3. Overdimensioning for interpolation

    gaus_rlati(-1) =   rpi-gaus_rlati(1)
    gaus_rlati(0) =   rpi*.5
    gaus_rlati(nj+1) =  -rpi*.5
    gaus_rlati(nj+2) =   -rpi-gaus_rlati(nj)

    do jlat = 1, nj
         gaus_conphy(jlat) = ra*gaus_r1qm2(jlat)
         gaus_conima(jlat) = r1sa*gaus_rsqm2(jlat)
    enddo

    !*    4. Print the content of GAUS

    if(mpi_myid.eq.0) write(*,fmt='(" JLAT:",4X," RLATI",8X,"RCOLAT",8X,"RMU",10X ,"RWT",12X,"RW0CS")')
    do jlat = 1, nj
       if(mpi_myid.eq.0) write(*,fmt='(2X,I4,5(2X,G23.16))')  &
            jlat,gaus_rlati(jlat),gaus_rcolat(jlat), gaus_rmu(jlat)  &
            ,gaus_rwt(jlat),gaus_rwocs(jlat)
    enddo

    if(mpi_myid.eq.0) write(*,fmt='(//," JLAT:",4X,"R1MU2",8X,"RSQM2",9X,"R1QM2",10X,"R1MUI",10X,"R1MUA")')

    do jlat = 1, nj
       if(mpi_myid.eq.0) write(*,fmt='(2X,I4,5(2X,G23.16))') jlat,gaus_r1mu2(jlat),gaus_rsqm2(jlat),gaus_r1qm2(jlat)  &
            ,gaus_r1mui(jlat),gaus_r1mua(jlat)
    enddo

  END SUBROUTINE GAUS_SETUP

  SUBROUTINE GAUSS8(NRACP,RACP,PG,SIA,RAD,PGSSIN2,SINM1,SINM2,SIN2)
!C     *****************************************************************
!C     CALCULE LES NRACP RACINES POSITIVES DU POLYNOME DE LEGENDRE DE
!C     DEGRE 2*NRACP (ICI-APRES NOTE PN) DEFINI SUR L INTERVALLE DES
!C     COLATITUDES ALLANT DE 0 (POLE NORD) A PI (POLE SUD). ON SAIT QUE
!C     LES 2*NRACP RACINES SONT ANTI-SYMETRIQUES P/R A L EQUATEUR PI/2,
!C     ETANT POSITIVES ENTRE COLAT=0 ET COLAT =PI/2.
!C     ON CALCULE ENSUITE LES POIDS DE GAUSS ASSOCIES AUX COLATITUDES
!C     GAUSSIENNES (ICI APRES NOTEES CG), AINSI QU UN CERTAIN NOMBRE DE
!C     FONCTIONS DE CG DEFINIES PLUS LOIN. ON RAPPELLE ENFIN QUE LA LATI-
!C     TUDE LAT=COLAT-PI/2, ET DONC QUE SIN(LAT)=COS(COLAT).
!C     NRACP        : NOMBRE DE RACINES POSITIVES DU POLYNOME DE LEGENDRE
!C                  : DE DEGRE 2*NRACP.
!C     RACP(I)      : RACINES DE PN, =SIN(LG)=COS(CG).
!C     PG(I)        : POIDS DE GAUSS CORRESPONDANTS.
!C     SIA(I)       : SIN(CG)=COS(LG).
!C     RAD(I)       : COLATITUDE CG EN RADIANS.
!C     PGSSIN2(I)   : POIDS DE GAUSS / (SIN(CG))**2.
!C     SINM1(I)     : (SIN(CG))**-1.
!C     SINM2(I)     : (SIN(CG))**-2.
!C     VOIR NST 8, CHAP. A, PP.1-7, ET APPENDICE D12, PP. 26-27.
!C     VERSION REVISEE PAR MICHEL BELAND, 9 DECEMBRE 1980.
!C     VERSION "REAL*8"  ... P. KOCLAS AVRIL 1993...
!C     *****************************************************************
      IMPLICIT NONE

      INTEGER NRACP
      REAL*8 RACP(*),PG(*),SIA(*),RAD(*),PGSSIN2(*),SINM1(*),SINM2(*),SIN2(*)

      REAL*8 XLIM,PI,FI,FI1,FN,DOT,DN,DN1,A,B,C,G,GM,GP,GT,RACTEMP,GTEMP
      INTEGER I,IR,IRM,IRP
!C     
!C     ON DEMANDE UNE PRECISION DE 1.E-13 POUR LES RACINES DE PN.
!C     
      XLIM=1.D-13
      PI = 4.D0*ATAN(1.D0)
      IR = 2*NRACP
      FI=DBLE(IR)
      FI1=FI+1.D0
      FN=DBLE(NRACP)
!C     
!C     ON UTILISE UNE FORMULE ASYMPTOTIQUE POUR OBTENIR LES VALEURS
!C     APPROXIMATIVES DES COLATITUDES GAUSSIENNES
!C     CG(I) = (PI/2) * (2*I-1)/(2*NRACP).
!C     VOIR ABRAMOWITZ AND STEGUN, P. 787, EQU. 22.16.6 .
!C     
      DO 20 I=1,NRACP
         DOT=DBLE(I-1)
         RACP(I)=-PI*.5D0*(DOT+.5D0)/FN + PI*.5D0
         RACP(I) =  SIN(RACP(I))
 20   CONTINUE
!C     
!C     ON CALCULE ENSUITE LES CONSTANTES FACTEURS DE P(N+1) ET P(N-1)
!C     DANS L EXPRESSION DE LA PSEUDO-DERIVEE DE PN.
!C     
      DN = FI/SQRT(4.D0*FI*FI-1.D0)
      DN1=FI1/SQRT(4.D0*FI1*FI1-1.D0)
      A = DN1*FI
      B = DN*FI1
      IRP = IR + 1
      IRM = IR -1
!C     
!C     ON EMPLOIE ENSUITE UNE METHODE DE NEWTON POUR AUGMENTER LA PREC.
!C     SI RACTEMP EST UNE SOL. APPROXIMATIVE  DE PN(RACP)=0., ALORS LA
!C     SEQUENCE RACTEMP(I+1)=RACTEMP(I)-PN(RACTEMP(I))/DER.PN(RACTEMP(I))
!C     CONVERGE VERS RACP DE FACON QUADRATIQUE.
!C     VOIR ABRAMOWITZ AND STEGUN, P.18, EQU. 3.9.5.
!C     ORDLEG CALCULE LA VALEUR DE PN (RACP) , NORMALISE.
!C     
      DO 50 I=1,NRACP
 42      CALL ORDLEG8(G,RACP(I),IR)
         CALL ORDLEG8(GM,RACP(I),IRM)
         CALL ORDLEG8(GP,RACP(I),IRP)
         GT = (A*GP-B*GM)/(RACP(I)*RACP(I)-1.D0)
         RACTEMP = RACP(I) - G/GT
         GTEMP = RACP(I) - RACTEMP
         RACP(I) = RACTEMP
         IF( ABS(GTEMP).GT.XLIM) GO TO 42
 50   CONTINUE
!C     
!C     ON CALCULE ENSUITE LES POIDS DE GAUSS SELON L ALGORITHME
!C     PG(I) = 2./[(1.-RACP(I)**2)*(DER.PN(RACP(I)))**2].
!C     VOIR ABRAMOWITZ AND STEGUN, P.887, EQU. 25.4.29.
!C     NOTE: ON DOIT MULTIPLIER LA PRECEDENTE FORMULE PAR UN FACTEUR
!C     DE DENORMALISATION, LES PN DONNES PAR ORDLEG ETANT NORMALISES.
!C     ON SE SERT D UNE FORMULE DE RECURRENCE POUR LA DERIVEE DE PN.
!C     
      DO 60 I=1,NRACP
         A=2.D0*(1.-RACP(I)**2)
         CALL ORDLEG8(B,RACP(I),IRM)
         B = B*B*FI*FI
         PG(I)=A*(FI-.5D0)/B
         RAD(I) =   ACOS(RACP(I))
         SIA(I) =  SIN(RAD(I))
         C=(SIA(I))**2
         SINM1(I) = 1.D0/SIA(I)
         SINM2(I) = 1.D0/C
         PGSSIN2(I) =PG(I)/C
         SIN2(I)=C
 60   CONTINUE

      RETURN
      END SUBROUTINE GAUSS8

END MODULE GAUSSGRID_MOD