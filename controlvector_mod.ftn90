!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! MODULE controlVector (prefix="cvm")
!!
!! *Purpose*: The control vector and related information.  
!!
!! Revisions:
!!       Ping Du, June-Sept 2014
!!       - Introduced optional consideration of arrays/variables for
!!         constituents. See variables *Bchm*.
!!       M. Sitwell Aug 2015
!!       - Added cvm_numSubvector
!--------------------------------------------------------------------------
MODULE ControlVector_mod
  use utilities_mod
  implicit none
  save
  private

  ! public variables
  public              :: cvm_nvadim, cvm_nvadim_mpiglobal
  ! public procedures
  public              :: cvm_Setup, cvm_getSubVector, cvm_getSubVector_mpiglobal
  public              :: cvm_getSubVector_r4, cvm_getSubVector_mpiglobal_r4


  logical             :: initialized = .false.
  integer             :: cvm_dimBHI
  integer             :: cvm_dimBEN
  integer             :: cvm_nvadim
  integer             :: cvm_dimBchm
  integer             :: cvm_dimBHI_mpiglobal
  integer             :: cvm_dimBEN_mpiglobal
  integer             :: cvm_nvadim_mpiglobal
  integer             :: cvm_dimBchm_mpiglobal

  integer, parameter  :: cvm_numSubvector=3 ! total number of possible valid subvectors


CONTAINS

  SUBROUTINE CVM_setup(DIMBHI_IN,DIMBEN_IN,DIMBCHM_IN)
    implicit none

    integer           :: dimBHI_in,dimBEN_in,dimBCHM_in
    integer           :: ierr

    cvm_dimbhi = dimbhi_in
    cvm_dimben = dimben_in
    cvm_dimbchm = dimbchm_in 

    call rpn_comm_allreduce(cvm_dimbhi,cvm_dimbhi_mpiglobal,1,"MPI_INTEGER","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(cvm_dimben,cvm_dimben_mpiglobal,1,"MPI_INTEGER","MPI_SUM","GRID",ierr)
    call rpn_comm_allreduce(cvm_dimbchm,cvm_dimbchm_mpiglobal,1,"MPI_INTEGER","MPI_SUM","GRID",ierr)

    cvm_nvadim = cvm_dimben + cvm_dimbhi + cvm_dimbchm 
    cvm_nvadim_mpiglobal = cvm_dimben_mpiglobal + cvm_dimbhi_mpiglobal + cvm_dimbchm_mpiglobal 

    write(*,*) 'cvm_setup: subvector dimensions            =',cvm_dimbhi,cvm_dimben, cvm_dimbchm,  &
                                                              cvm_nvadim
    write(*,*) 'cvm_setup: subvector dimensions (mpiglobal)=',cvm_dimbhi_mpiglobal,cvm_dimben_mpiglobal,       & 
                          cvm_dimbchm_mpiglobal, cvm_nvadim_mpiglobal

    initialized=.true.

  END SUBROUTINE CVM_setup

  FUNCTION CVM_getSubVector(controlVector,subVectorIndex) RESULT(subVector)
    implicit none

    real*8, pointer :: subVector(:)
    real*8, target  :: controlVector(:)
    integer         :: subVectorIndex
    logical, save   :: firstCall(cvm_numSubvector)=.true.

    if (subVectorIndex.lt.0.or.subVectorIndex.gt.cvm_numSubvector) then
       write(*,*) 'CVM_getSubVector: subVectorIndex = ',subVectorIndex
       call utl_abort('CVM_getSubVector: invalid value for subVectorIndex')
    end if

    nullify(subVector)

    if(subVectorIndex.eq.1 .and. cvm_dimbhi.gt.0) then
      subVector => controlVector(1:cvm_dimbhi)
    elseif(subVectorIndex.eq.2 .and. cvm_dimben.gt.0) then
      subVector => controlVector((cvm_dimbhi+1):(cvm_dimbhi+cvm_dimben))
    elseif(subVectorIndex.eq.3 .and. cvm_dimbchm.gt.0) then
      subVector => controlVector((cvm_dimbhi+cvm_dimben+1):(cvm_dimbhi+cvm_dimben+cvm_dimbchm))
    else
       if(firstCall(subVectorIndex)) then
          write(*,*) 'CVM_getSubVector: subVectorIndex ',subVectorIndex,' is not available'
          firstCall(subVectorIndex)=.false.
       endif
    endif

  END FUNCTION CVM_getSubVector

  FUNCTION CVM_getSubVector_r4(controlVector,subVectorIndex) RESULT(subVector)
    implicit none

    real*4, pointer :: subVector(:)
    real*4, target  :: controlVector(:)
    integer         :: subVectorIndex
    logical, save   :: firstCall(cvm_numSubvector)=.true.

    if (subVectorIndex.lt.0.or.subVectorIndex.gt.cvm_numSubvector) then
       write(*,*) 'CVM_getSubVector: subVectorIndex = ',subVectorIndex
       call utl_abort('CVM_getSubVector: invalid value for subVectorIndex')
    end if

    nullify(subVector)

    if(subVectorIndex.eq.1 .and. cvm_dimbhi.gt.0) then
      subVector => controlVector(1:cvm_dimbhi)
    elseif(subVectorIndex.eq.2 .and. cvm_dimben.gt.0) then
      subVector => controlVector((cvm_dimbhi+1):(cvm_dimbhi+cvm_dimben))
    elseif(subVectorIndex.eq.3 .and. cvm_dimbchm.gt.0) then
      subVector => controlVector((cvm_dimbhi+cvm_dimben+1):(cvm_dimbhi+cvm_dimben+cvm_dimbchm))
    else
       if(firstCall(subVectorIndex)) then
          write(*,*) 'CVM_getSubVector: subVectorIndex ',subVectorIndex,' is not available'
          firstCall(subVectorIndex)=.false.
       endif
    endif

  END FUNCTION CVM_getSubVector_r4

  FUNCTION CVM_getSubVector_mpiglobal(controlVector,subVectorIndex) RESULT(subVector)
    implicit none

    real*8, pointer :: subVector(:)
    real*8, target  :: controlVector(:)
    integer         :: subVectorIndex
    logical, save   :: firstCall(cvm_numSubvector)=.true.

    if (subVectorIndex.lt.0.or.subVectorIndex.gt.cvm_numSubvector) then
       write(*,*) 'CVM_getSubVector_mpiglobal: subVectorIndex = ',subVectorIndex
       call utl_abort('CVM_getSubVector_mpiglobal: invalid value for subVectorIndex')
    end if

    nullify(subVector)

    if(subVectorIndex.eq.1 .and. cvm_dimbhi_mpiglobal.gt.0) then
      subVector => controlVector(1:cvm_dimbhi_mpiglobal)
    elseif(subVectorIndex.eq.2 .and. cvm_dimben_mpiglobal.gt.0) then
      subVector => controlVector((cvm_dimbhi_mpiglobal+1):(cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal))
    elseif(subVectorIndex.eq.3 .and. cvm_dimbchm_mpiglobal.gt.0) then
      subVector => controlVector((cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal+1):(cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal+cvm_dimbchm_mpiglobal))
    else
      if(firstCall(subVectorIndex)) then
        write(*,*) 'CVM_getSubVector_mpiglobal: subVectorIndex ',subVectorIndex,' is not available'
        firstCall(subVectorIndex)=.false.
      endif
    endif

  END FUNCTION CVM_getSubVector_mpiglobal

  FUNCTION CVM_getSubVector_mpiglobal_r4(controlVector,subVectorIndex) RESULT(subVector)
    implicit none

    real*4, pointer :: subVector(:)
    real*4, target  :: controlVector(:)
    integer         :: subVectorIndex
    logical, save   :: firstCall(cvm_numSubvector)=.true.

    if (subVectorIndex.lt.0.or.subVectorIndex.gt.cvm_numSubvector) then
       write(*,*) 'CVM_getSubVector_mpiglobal: subVectorIndex = ',subVectorIndex
       call utl_abort('CVM_getSubVector_mpiglobal: invalid value for subVectorIndex')
    end if

    nullify(subVector)

    if(subVectorIndex.eq.1 .and. cvm_dimbhi_mpiglobal.gt.0) then
      subVector => controlVector(1:cvm_dimbhi_mpiglobal)
    elseif(subVectorIndex.eq.2 .and. cvm_dimben_mpiglobal.gt.0) then
      subVector => controlVector((cvm_dimbhi_mpiglobal+1):(cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal))
    elseif(subVectorIndex.eq.3 .and. cvm_dimbchm_mpiglobal.gt.0) then
      subVector => controlVector((cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal+1):(cvm_dimbhi_mpiglobal+cvm_dimben_mpiglobal+cvm_dimbchm_mpiglobal))
    else
      if(firstCall(subVectorIndex)) then
        write(*,*) 'CVM_getSubVector_mpiglobal: subVectorIndex ',subVectorIndex,' is not available'
        firstCall(subVectorIndex)=.false.
      endif
    endif

  END FUNCTION CVM_getSubVector_mpiglobal_r4

END MODULE ControlVector_mod
