!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! MODULE tovs_lin (prefix= no defined prefix)
!!
!! *Purpose*: Derived types, public variables and procedures related to the 
!!            tangent-linear and adjoint versions of RTTOV
!!
!--------------------------------------------------------------------------
Module tovs_lin_mod
  Use rttov_types, only : rttov_profile, rttov_radiance 
  Use tovs_nl_mod, only : tvs_nobtov,tvs_nsensors,tvs_lsensor,tvs_coefs,tvs_opts,tvs_nchan,tvs_isReallyPresent,tvs_ichan,tvs_listSensors
  use utilities_mod
  implicit none
  save
  private

  public :: tvslin_setupallo, tvslin_fill_profiles_tl, tvslin_rttov_tl, tvslin_fill_profiles_ad, tvslin_rttov_ad

  ! public derived types
  ! public derived type through inheritance (from module rttov_types)
  public :: rttov_radiance

  ! public variables (parameters)

  ! public variables (non-parameters)

  ! Derived types

  type( rttov_profile ) ,     allocatable :: profiles_tl(:)    ! tl profiles, all profiles
  type( rttov_profile ) ,     allocatable :: profiles_ad(:)    ! ad profiles, all profiles

contains


SUBROUTINE tvslin_SETUPALLO()
#if defined (DOC)
!
!  s/r tvslin_SETUPALLO : Memory allocation for the lineraized radiative transfer model
!                 variables.
!          (original name of routine: sutovalo)
!
!Author  : J. Halle *CMDA/AES Oct 1999
!    -------------------
!     Purpose: to allocate memory for the radiative transfer model variables.
!
! Revision:
!           S. Pellerin *ARMA/SMC May 2000
!            - Fix for F90 conversion
!           C. Chouinard *ARMA/SMC Aug 2000
!            - remove reference to nincrem in memory allocation
!           JM Belanger *CMDA/SMC!  aug 2000
!            - 32 bits conversion
!           J. Halle *CMDA/AES  dec 2000
!            - adapt to TOVS level 1b.
!           J. Halle CMDA/SMC May 2002
!            - adapt to RTTOV-7 code
!           J. Halle CMDA/SMC Feb 2003
!            - add codtyp for AMSUB (=181).
!           J. Halle CMDA/SMC Nov 2004
!            - adapt to RTTOV-8;
!            - convert to Fortran 90.
!           A. Beaulne CMDA/SMC June 2006
!            - modifications for AIRS
!            - allocation of ozone profiles
!           R. Sarrazin  CMDA   April 2008
!            - adapt to CSR
!           S. Heilliette
!            - adapt to IASI
!            - adapt to rttov 10.0 (october 2010)
!           S. Macpherson
!            - adapt to ATMS (codtyp 192)
!           S.  Heilliette
!            - adapt to CrIS (codtyp 193)
#endif
  Use rmatrix_mod
  use obsSpaceData_mod

  IMPLICIT NONE
#include "rttov_alloc_prof.interface"
!implicits

  Integer :: alloc_status(2)
  INTEGER ::  ival, IPLATFORM, ISAT, INSTRUM

  INTEGER ::  JO
  INTEGER ::  ISENS, NC, NL
  INTEGER ::  ASW

!-----------------------------------------------------------------------

  if (tvs_nsensors == 0) then
    write(*,*) 'tvslin_setupallo: tvs_nsensors is zero, skipping setup'
    return
  endif

!     1. Memory allocation for radiative tranfer model variables
!     .  -----------------------------------------------------

!___ profiles

! Initialization of the correlation matrices
  call rmat_init(tvs_nsensors,tvs_nobtov)
  if (rmat_lnondiagr) then
     do isens = 1, tvs_nsensors
        if (tvs_isReallyPresent(isens) ) call rmat_readCMatrix(tvs_listSensors(:,isens), isens, tvs_ichan(1:tvs_nchan(isens),isens)  )
     enddo
  endif

  alloc_status = 0
  allocate(profiles_tl(tvs_nobtov)      , stat= alloc_status(1))
  allocate(profiles_ad(tvs_nobtov)      , stat= alloc_status(2))
  call utl_checkAllocationStatus(alloc_status, " tvslin_SETUPALLO")
  
  print *,"tvslin_SETUPALLO tvs_nobtov",tvs_nobtov
  asw=1 ! to allocate
  do jo = 1, tvs_nobtov
     isens = tvs_lsensor(jo)
     nl = tvs_coefs(isens)%coef % nlevels
     ! allocate model tl profiles atmospheric arrays with RTTOV levels dimension
     call rttov_alloc_prof(alloc_status(1),1,profiles_tl(jo),nl, &
          tvs_opts(isens),asw,coefs=tvs_coefs(isens),init=.false. )
     call utl_checkAllocationStatus(alloc_status, " tvslin_SETUPALLO profiles_tl")
     
     ! allocate model ad profiles atmospheric arrays with RTTOV levels dimension
     call rttov_alloc_prof(alloc_status(1),1,profiles_ad(jo),nl, &
          tvs_opts(isens),asw,coefs=tvs_coefs(isens),init=.true. )
     call utl_checkAllocationStatus(alloc_status, " tvslin_SETUPALLO profiles_ad")
     
  end do


END SUBROUTINE tvslin_SETUPALLO


subroutine tvslin_fill_profiles_tl(column,columng)
!--------------------------------------------------------------------------
!! *Purpose*: Fill tangent linear profiles structure by interpolating 
!!            contents of columnData to RTTOV space
!!
!! @author j. halle *cmda/aes  april 12, 2005
!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                 -add ozone from climatology to all sensors
!
!revision 002  : j. halle  *cmda/smc  march 2007
!                 -fix zvlev for hybrid coordinate
!revision 003  : S. Heilliette septembre 2011
!                 -adapt to rttv-10
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
  use MathPhysConstants_mod
  use tovs_nl_mod
  use obsSpaceData_mod
  use columnData_mod
  use tovs_extrap_mod
  use rttov_const ,only : gas_unit_specconc
  use parkind1, Only : jpim     ,jprb
  use presProfileOperators_mod
  use utilities_mod
  implicit none

  type(struct_columnData) :: column,columng

  type(struct_vco), pointer :: vco_anl
  integer, allocatable :: iptobs    (:) 
  integer, allocatable :: iptobscma (:) 

  integer :: alloc_status(15)
  logical :: diagTtop,TopAt10hPa
  integer :: omp_get_num_threads, nthreads
  integer :: istride, ilen, imodulo
  integer :: nlevels,nobmax
  integer :: j, i, sensor_id, iobs, jj, stat
  integer :: ilowlvl_M,ilowlvl_T,count_profile,headerIndex,nlv_M,nlv_T
  integer :: jk, jn, jl
  integer :: status, Vcode
  integer :: jpmotop, jpmolev

  real(8), allocatable :: to_tl    (:,:)
  real(8), allocatable :: lqo_tl   (:,:)
  real(8), allocatable :: toext_tl (:,:)
  real(8), allocatable :: qoext_tl (:,:)
  real(8), allocatable :: zvlev    (:,:)
  real(8), allocatable :: dPdPs    (:,:)
  real(8), allocatable :: zt_tl    (:,:)
  real(8), allocatable :: zlq_tl   (:,:)
  real(8), allocatable :: zt       (:,:)
  real(8), allocatable :: zlq      (:,:)
  real(8), allocatable :: qoext    (:,:)
  real(8), allocatable :: zps_tl   (:)
  real(8), allocatable :: xpres    (:)

  real(8) :: zptop, zptopmbs
  real(8), pointer :: delTT(:), delLQ(:), TTb(:), HUb(:), Pres(:)

  if(tvs_nobtov==0) return    ! exit if there are not tovs data

  !     1.    Set index for model's lowest level and model top
  !     .     ------------------------------------------------

  nlv_M = col_getNumLev(columng,'MM')
  nlv_T = col_getNumLev(columng,'TH')

  if (  col_getPressure(columng,1,1,'TH') < col_getPressure(columng,nlv_T,1,'TH') ) then
     ilowlvl_M = nlv_M
     ilowlvl_T = nlv_T
  else
     ilowlvl_M = 1
     ilowlvl_T = 1
  endif

  vco_anl => col_getVco(columng)
  status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode)
  diagTtop = (Vcode==5002)

  ! find model level top, within 0.000001 mbs.
  zptop    = col_getPressure(columng,1,1,'TH')
  zptopmbs = zptop/100.d0
  zptopmbs = zptopmbs - 0.000001d0

  TopAt10hPa = ( abs( zptopmbs - 10.0d0 ) <= .1d0 )


!     1.1   Number of threads and memory allocation
!     .     ---------------------------------------

!$omp parallel 
  nthreads = omp_get_num_threads()
!$omp end parallel

!
!     2.  Fill profiles structure
!     .   -----------------------
! loop over all instruments
  sensor_loop: do sensor_id=1,tvs_nsensors
     ! loop over all obs.
     count_profile = 0

     obs_loop1: do iobs = 1,tvs_nobtov
        if (tvs_lsensor(iobs)/=sensor_id) cycle obs_loop1
        NOBMAX=iobs
        count_profile =count_profile +1
     enddo obs_loop1

     if (count_profile == 0) cycle sensor_loop

     nlevels=tvs_coefs(sensor_id) %coef%  nlevels
     allocate (xpres(nlevels))
     xpres = tvs_coefs(sensor_id)% coef % ref_prfl_p
     jpmotop = 1
     do jl = 2, nlevels
        if ( zptopmbs >= xpres(jl-1) .and.       &
             zptopmbs < xpres(jl)        ) then
           jpmotop = jl
           exit
        endif
     enddo
     jpmolev = (nlevels-jpmotop+1)

     alloc_status(:) = 0
     allocate (iptobs    (count_profile)          ,stat= alloc_status(1) )
     allocate (iptobscma (count_profile)          ,stat= alloc_status(2) )
     allocate (to_tl     (jpmolev,count_profile)  ,stat= alloc_status(3) )
     allocate (lqo_tl    (jpmolev,count_profile)  ,stat= alloc_status(4) )
     allocate (toext_tl  (nlevels  ,count_profile),stat= alloc_status(5) )
     allocate (qoext_tl  (nlevels  ,count_profile),stat= alloc_status(6) )
     allocate (zvlev     (nlv_T,count_profile)    ,stat= alloc_status(7) )
     allocate (dPdPs     (nlv_T,count_profile)    ,stat= alloc_status(8) )
     allocate (zt_tl     (nlv_T,count_profile)    ,stat= alloc_status(9) )
     allocate (zlq_tl    (nlv_T,count_profile)    ,stat= alloc_status(10))
     allocate (zt        (nlv_T,count_profile)    ,stat= alloc_status(11))
     allocate (zlq       (nlv_T,count_profile)    ,stat= alloc_status(12))
     allocate (qoext     (nlevels,count_profile)  ,stat= alloc_status(13))
     allocate (zps_tl    (count_profile)          ,stat= alloc_status(14))

     call utl_checkAllocationStatus(alloc_status, "  tvslin_fill_profiles_tl")
    
     iptobs   (:) = 0 
     iptobscma(:) = 0 
     toext_tl (:,:) = 0.0d0
     zvlev    (:,:) = 0.0d0
     dPdPs    (:,:) = 0.0d0
     zt_tl    (:,:) = 0.0d0
     zlq_tl   (:,:) = 0.0d0
     zt       (:,:) = 0.0d0
     zlq      (:,:) = 0.0d0
     qoext    (:,:) = 0.0d0
     zps_tl   (:)   = 0.0d0
     to_tl    (:,:) = 0.0d0
     lqo_tl   (:,:) = 0.0d0

     count_profile = 0

     obs_loop2: do iobs = 1, NOBMAX
        if (tvs_lsensor(iobs)/=sensor_id) cycle obs_loop2

        headerIndex = tvs_lobsno(iobs)

        count_profile = count_profile + 1

        zps_tl  (count_profile) = col_getElem(column,1,headerIndex,'P0')*MPC_MBAR_PER_PA_R8
        delTT => col_getColumn(column,headerIndex,'TT')
        delLQ => col_getColumn(column,headerIndex,'HU')
        TTb => col_getColumn(columng,headerIndex,'TT')
        HUb => col_getColumn(columng,headerIndex,'HU')
        Pres => col_getColumn(columng,headerIndex,'PR','TH')
        do jl = 1, nlv_T
           zt_tl (jl,count_profile) = delTT(jl)
           zlq_tl(jl,count_profile) = delLQ(jl)
           zt   (jl,count_profile)  = TTb(jl)
           zlq  (jl,count_profile)  = HUb(jl)
           zvlev(jl,count_profile)  = Pres(jl) *MPC_MBAR_PER_PA_R8
           dPdPs(jl,count_profile)  = col_getPressureDeriv(columng,jl,headerIndex,'TH')
        enddo

        ! Fix pour eviter probleme au toit avec GEM 4
        ! (grosse varibilite temperature au dernier niveau thermo due 
        !  a l'extrapolation utilisee)
        if ( diagTtop ) then
           zt_tl   (1,count_profile) =  0.d0
           zlq_tl  (1,count_profile) =  0.d0
           zt   (1,count_profile) =  zt   (2,count_profile) + tvs_mesosphereLapseRate *  &
                log( col_getPressure(columng,1,headerIndex,'TH') /  &
                col_getPressure(columng,2,headerIndex,'TH') )
           zlq  (1,count_profile) =  zlq  (2,count_profile)
        endif

        iptobs   (count_profile) = iobs
        iptobscma(count_profile) = headerIndex


     enddo obs_loop2
 
!     .  2.1  Vertical interpolation of model temperature and logarithm of
!             specific humidity to pressure levels required by tovs rt model
!     .       --------------------------------------------------------------

     do jn = 1, count_profile
        qoext(1:nlevels,jn) =  tvs_profiles(iptobs(jn)) % q(1:nlevels) !/ tvs_qMixratio2ppmv
     enddo
  
     to_tl (:,:) = 0.0d0
     lqo_tl(:,:) = 0.0d0
     imodulo = mod(count_profile,nthreads)
     if ( imodulo == 0 ) then
        istride = max(1,(count_profile/nthreads))
     else
        istride = max(1,(count_profile/nthreads)+1)
     endif
!$omp parallel do private(jn,ilen)
     do jn=1,count_profile,istride
        ilen = min (count_profile-jn+1,istride)
        if ( ilen .gt. 0) then

           call ppo_IntAvgTl(zvlev(:,jn:jn+ilen-1),dPdPs(:,jn:jn+ilen-1),zt_tl(:,jn:jn+ilen-1),zt(:,jn:jn+ilen-1), &
                zps_tl(jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),to_tl(:,jn:jn+ilen-1))
           call ppo_IntAvgTl(zvlev(:,jn:jn+ilen-1),dPdPs(:,jn:jn+ilen-1),zlq_tl(:,jn:jn+ilen-1),zlq(:,jn:jn+ilen-1), &
                zps_tl(jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),lqo_tl(:,jn:jn+ilen-1))

        endif
     enddo
!$omp end parallel do

!     .  2.2  Extrapolation of temperature profile above 10mb
!     .       -----------------------------------------------
     toext_tl(:,:) = 0.0d0
     if ( .not. TopAt10hPa ) then
        do jn = 1, count_profile
           toext_tl(jpmotop:nlevels,jn)=to_tl(1:jpmolev,jn)
           toext_tl(1:jpmotop-1,jn)=0.d0
        enddo
     else
        call lextrap (to_tl,toext_tl,jpmolev,nlevels,count_profile)
     endif
     
        !     .  2.3  Extrapolation of humidity profile (kg/kg)
        !             above rlimlvhu (normally 300mbs or 70mbs)
        !     .       -----------------------------------------

     qoext_tl(:,:) = 0.0d0
     
     do jn = 1, count_profile
        do jk = 1, jpmotop-1
           qoext_tl(jk,jn) = 0.d0
        enddo
        do jk = 1, jpmolev
           qoext_tl(nlevels-jpmolev+jk,jn) = qoext(nlevels-jpmolev+jk,jn)*lqo_tl(jk,jn)
        enddo
     enddo
     
     if ( TopAt10hPa ) then
        if ( tvs_debug ) then
           do jn = 1, count_profile
              write(*,*)'qoext_tl*1000 avant exthum4    = '
              write(*,'(1x,10f8.4)')(qoext_tl(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
        call lexthum4 (count_profile,nlevels,xpres(1:nlevels),qoext_tl,qoext)
        if ( tvs_debug ) then
           do jn = 1, count_profile
              write(*,*)'qoext_tl*1000 apres exthum4    = '
              write(*,'(1x,10f8.4)')(qoext_tl(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
     endif

        !     .  2.4  Fill profiles_tl structure
        !     .       --------------------------

     do  j = 1 , count_profile
        jj=iptobs(j)
        profiles_tl(jj) % gas_units       = gas_unit_specconc ! all gas profiles are supposed to be provided in kg/kg
        profiles_tl(jj) % nlevels         =  nlevels
        profiles_tl(jj) % nlayers         =  nlevels - 1
        if(tvs_coefs(sensor_id)%coef%nozone > 0) then
           profiles_tl(jj) % o3(:)        =  0.d0
        endif
        profiles_tl(jj) % ctp             = 0.0d0
        profiles_tl(jj) % cfraction       = 0.0d0
        profiles_tl(jj) % zenangle        = 0.0d0
        profiles_tl(jj) % azangle         = 0.0d0
        profiles_tl(jj) % skin % surftype = 0
        profiles_tl(jj) % skin % t        = col_getElem(column,1,iptobscma(j),'TG')
        profiles_tl(jj) % skin % fastem(:)= 0.0d0
        profiles_tl(jj) % skin % salinity = 0.0d0
        profiles_tl(jj) % s2m % t         = col_getElem(column,ilowlvl_T,iptobscma(j),'TT')

           !! The following line has been commented out because qoext(ilowlvl_T,j) may be out of bound
!!!        profiles_tl(jj) % s2m % q         = qoext(ilowlvl_T,j) * col_getElem(column,ilowlvl_T,iptobscma(j),'HU') * tvs_qMixratio2ppmv
   !! The right code should be
        !!profiles_tl(jj) % s2m % q         = exp(gomq1(ilowlvl_T,iptobscma(j))) * pgomq_tl(ilowlvl_T,iptobscma(j)) * tvs_qMixratio2ppmv
   !! but since the logical flag 'use_q2m' is set to .false. in rttov_const.F90 (in RTTOV code)
   !! this variable profiles_tl(jj) % s2m % q is not used so it can be set to 0
        profiles_tl(jj) % s2m % q         = 0.d0

        profiles_tl(jj) % s2m % p         = col_getElem(column,1,iptobscma(j),'P0')*MPC_MBAR_PER_PA_R8
        profiles_tl(jj) % s2m % u         = col_getElem(column,ilowlvl_M,iptobscma(j),'UU')
        profiles_tl(jj) % s2m % v         = col_getElem(column,ilowlvl_M,iptobscma(j),'VV')
        
        profiles_tl(jj) % p(1:nlevels)    = 0.d0
        profiles_tl(jj) % t(1:nlevels)    = toext_tl(1:nlevels,j)
        profiles_tl(jj) % q(1:nlevels)    = qoext_tl(1:nlevels,j) !* tvs_qMixratio2ppmv

     end do

     alloc_status(:) = 0
     deallocate (iptobs    ,stat= alloc_status(1) )
     deallocate (iptobscma ,stat= alloc_status(2) )
     deallocate (to_tl     ,stat= alloc_status(3) )
     deallocate (lqo_tl    ,stat= alloc_status(4) )
     deallocate (toext_tl  ,stat= alloc_status(5) )
     deallocate (qoext_tl  ,stat= alloc_status(6) )
     deallocate (zvlev     ,stat= alloc_status(7) )
     deallocate (dPdPs     ,stat= alloc_status(8) )
     deallocate (zt_tl     ,stat= alloc_status(9) )
     deallocate (zlq_tl    ,stat= alloc_status(10))
     deallocate (zt        ,stat= alloc_status(11))
     deallocate (zlq       ,stat= alloc_status(12))
     deallocate (qoext     ,stat= alloc_status(13))
     deallocate (zps_tl    ,stat= alloc_status(14))
     deallocate (xpres     ,stat= alloc_status(15))

     call utl_checkAllocationStatus(alloc_status, "tvslin_fill_profiles_tl", .false.)
    
  enddo sensor_loop

  !     3.  Close up
  !     .   --------
end subroutine tvslin_fill_profiles_tl

SUBROUTINE LEXTHUM4(KNPF,KLAPF,PPRES,PAV,PAV5)
!
!**** *lexthum4* - tangent linear of extrapolaatione upper level humidity profil!.
!                 (adapted from exthumtl by J. Eyre)
!
!     purpose.
!     --------
!          to extend mixing ratio profile into stratosphere in
!          a reasonable way.
!
!**   interface.
!     ----------
!          *call* *lexthum4(knpf,klapf,ppres,pav,pav5)*
!               *knpf*:  no. of profiles to be processed.
!               *klapf*: length of atm. profiles.
!               *ppres*: pressure levels of atm. profiles.
!               *pav*:   gradient humidity profiles.
!               *pav5*:  humidity profiles.
!
!     method.
!     -------
!          take top tropospheric mixing ratio (e.g. near 300 mb) and
!          extrapolate with given fall off into lower stratosphere
!          (e.g. to 70 mb).  constrain mixing ratio to be >= zwmin
!          (e.g. 0.000003 kg/kg).   in upper strat, mixing ratio = zwmin.
!
!     externals.
!     ----------
!          none.
!
!     reference.
!     ----------
!          ecmwf tech mem 176.
!

  use MathPhysConstants_mod
  use obsFilter_mod
  IMPLICIT none
!
  integer :: klapf, knpf
  REAL(8) PPRES(*),PAV(KLAPF,*),PAV5(KLAPF,*)
!
  REAL(8) :: ZPRES3(KLAPF)
!
  real(8) zwb5,zwb
  real(8) ,parameter :: ZP1 = 70.0D0  ! PRESS LIMITS (IN HPA) OF REGION  to be extrapolated
  integer :: inlvw,j,jnpf,ierr

!
!
!*         1.   extrapolate humidity profile.
!               ----------- -------- -------

!          find top level of given profile
  INLVW = -1
  DO J=KLAPF,1,-1
     IF (PPRES(J)<FILT_RLIMLVHU) THEN
        INLVW=J
        EXIT
     ENDIF
  end do
!
!** Null extrapolation case
!
  if (INLVW == -1) RETURN
!
!          constants defining p**3 fall off around tropopause
  DO J=1,INLVW
     ZPRES3(J)=(PPRES(J)/PPRES(INLVW+1))**3
  end do
!
  DO JNPF=1,KNPF
     ZWB =PAV (INLVW+1,JNPF)
     ZWB5=PAV5(INLVW+1,JNPF)
     DO J=1,INLVW
        IF (PPRES(J)<ZP1) THEN
           PAV(J,JNPF)=0.D0
        ELSE
           IF ( ZWB5*ZPRES3(J) <= MPC_MINIMUM_HU_R8 ) THEN
              PAV(J,JNPF)=0.D0
           ELSE
              PAV(J,JNPF)=ZWB*ZPRES3(J)
           ENDIF
        ENDIF
     end do
  end do
   
END SUBROUTINE LEXTHUM4

subroutine tvslin_rttov_tl(lobsSpaceData)
!--------------------------------------------------------------------------
!! *Purpose*: Tangent linear of computation of radiance with rttov_tl
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!
!revision 001  : a. beaulne *cmda/msc  june 2006
!                  - addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda   april 2008
!                  - adapt to CSR
!revision 003  : s. heilliette
!                  - adapt to IASI
!         S. heilliette:
!                  - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
  use MathPhysConstants_mod
  use tovs_nl_mod
  use obsSpaceData_mod
  use columnData_mod
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_tl.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: isurface
  integer :: nlevels
  integer :: count_tb
  integer :: alloc_status(6)
  integer :: rttov_err_stat                      ! rttov error return code
  integer,external :: omp_get_num_threads
  integer :: nthreads, max_nthreads
  integer :: sensor_id, iobs
  integer :: count_profile
  integer :: profile_index, index_tb, bodyIndex, headerIndex, ichn, istart, iend
  integer :: instrum
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)
  integer :: channel_index

  integer :: errorstatus
  integer,allocatable :: iptobs  (:) 

  real*8, allocatable :: surfem1       (:) 
  type(rttov_emissivity), allocatable :: emissivity_local (:)
  type(rttov_emissivity), allocatable :: emissivity_tl (:)
 
  type(rttov_radiance) :: radiancedata_d     ! radiances full structure buffer used in rttov calls
  type(rttov_radiance) :: radiancedata_tl    ! tl radiances full structure buffer used in rttov calls
  type(rttov_transmission) :: transmission       ! transmission
  type(rttov_transmission) :: transmission_tl    ! transmission tl
  type(rttov_profile)  , allocatable :: profilesdata_tl (:) ! tl profiles buffer used in rttov calls
  type(rttov_chanprof) , allocatable :: chanprof (:)
  logical ,save        :: first=.true.
  logical              :: init
    
  logical, allocatable :: calcemis  (:)
  integer ::  asw
         
  if (tvs_nobtov == 0) return       ! exit if there are not tovs data

!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!     

!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel
  alloc_status(1)=0
  allocate ( iptobs(tvs_nobtov),stat=alloc_status(1) )

!
!     2.  Computation of hx for tovs data only
!     .   ------------------------------------


! Loop over all sensors specified by user

  sensor_loop:  do sensor_id = 1, tvs_nsensors
       
     nlevels=tvs_coefs(sensor_id)%coef % nlevels
     sensor_type = tvs_coefs(sensor_id) % coef % id_sensor
     instrum = tvs_coefs(sensor_id) % coef % id_inst
!  loop over all obs.

     count_profile = 0
     obs_loop: do iobs = 1, tvs_nobtov
          
!    Currently processed sensor?

        if ( tvs_lsensor(iobs) == sensor_id ) then
           count_profile = count_profile + 1
           iptobs(count_profile) = iobs
        endif
     enddo obs_loop
     
     if (count_profile == 0) cycle sensor_loop

!     set nthreads to actual number of threads which will be used.

     nthreads = min(max_nthreads, count_profile)  

!     .  2.2  Prepare all input variables required by rttov.
!     .       ---------------------------------------------------------
     

!     compute max possible values for nchannels
     count_tb = tvs_countRadiances(iptobs, count_profile, lobsSpaceData)
     
     if ( count_tb == 0 ) cycle  sensor_loop

     alloc_status(:)=0
     allocate ( surfem1      (count_tb)       ,stat=alloc_status(1))
     allocate ( chanprof     (count_tb)       ,stat=alloc_status(2))
     allocate ( emissivity_local (count_tb)   ,stat=alloc_status(3))
     allocate ( emissivity_tl(count_tb)       ,stat=alloc_status(4))
     allocate ( calcemis     (count_tb)       ,stat=alloc_status(5))
     allocate ( profilesdata_tl(count_profile),stat=alloc_status(6))  ! profilesdata tl
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl")
    
!     get Hyperspecral IR emissivities
      
     if ( tvs_isInstrumHyperSpectral(instrum) ) call tvs_getHIREmissivities(sensor_id, iptobs, count_profile, lobsSpaceData, surfem1)

     call TVS_getChanprof(sensor_id, iptobs, count_profile, lobsSpaceData, chanprof)

     init=.true.
     asw=1 ! 1 to allocate,0 to deallocate
! allocate transmitance structure
     call rttov_alloc_transmission(alloc_status(1),transmission,nlevels=nlevels,      &
          nchanprof=count_tb,asw=asw,init=init )
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl transmission")
     
     call rttov_alloc_transmission(alloc_status(1),transmission_tl,nlevels=nlevels,   &
          nchanprof=count_tb,asw=asw,init=init )
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl transmission_tl")
! allocate radiance structures
     call rttov_alloc_rad (alloc_status(1) , count_tb, radiancedata_d, nlevels, asw, init=init)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl radiancedata_d")
     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_tl, nlevels, asw, init=init)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl radiancedata_tl")

     call tvs_getOtherEmissivities(chanprof, iptobs, count_tb, sensor_type, instrum, surfem1, calcemis)

     emissivity_local(:)%emis_in = surfem1(:)
       
! allocate profiledata_tl structures
     
     call rttov_alloc_prof (alloc_status(1), count_profile, profilesdata_tl, nlevels, &
          tvs_opts(sensor_id), asw=asw, coefs=tvs_coefs(sensor_id), init=init)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl profilesdata_tl")
      
!.. fill profilesdata_tl arrays

     call rttov_copy_prof( profilesdata_tl(1:count_profile), profiles_tl( iptobs(1:count_profile) ) )
 
!     .  2.3  Compute tl radiance with rttov_tl
!     .       ---------------------------------

     errorstatus   = 0
     emissivity_tl(:)%emis_in = 0.0d0
     call tmg_start(87,'rttov_tl')
     call rttov_parallel_tl(         &
          errorstatus,               & ! out
          chanprof,                  & ! in
          tvs_opts(sensor_id),       & ! in
          tvs_profiles(iptobs(1:count_profile)),  & ! in
          profilesdata_tl,           & ! inout
          tvs_coefs(sensor_id),      & ! in
          transmission,              & ! inout
          transmission_tl,           & ! inout
          radiancedata_d,            & ! inout
          radiancedata_tl,           & ! inout
          calcemis,                  & ! in
          emissivity_local,          & ! in
          emissivity_tl,             & ! inout
          nthreads=nthreads )          ! in
               
     if (errorstatus /= 0) then
        Write(*,*) "Error in rttov_parallel_tl",errorstatus
        write(*,*) 'temperature           profile=',tvs_profiles(iptobs(1)) % t(:)
        write(*,*) 'temperature increment profile=',profilesdata_tl(1) % t(:)
        call utl_abort('tovs_rttov_tl')
     endif

     call tmg_stop(87)

!     .  2.4  Store hx in obsSpaceData,OBS_WORK
!     .       ------------------------------------
!Could this loop be optimized ?
     tb_loop :do index_tb = 1, count_tb
        profile_index = chanprof(index_tb)%prof
        channel_index = chanprof(index_tb)%chan
        iobs = iptobs(profile_index)
        headerIndex = tvs_lobsno(iobs)
        istart = obs_headElem_i(lObsSpaceData,OBS_RLN,headerIndex)
        iend = obs_headElem_i(lObsSpaceData,OBS_NLV,headerIndex) + istart - 1
        do bodyIndex = istart, iend
           ichn = nint(obs_bodyElem_r(lobsSpaceData,OBS_PPP,bodyIndex))
           ichn = max(0,min(ichn,tvs_maxChannelNumber+1))
           ichn = ichn - tvs_channelOffset(sensor_id)
           if (ichn == tvs_ichan(channel_index,sensor_id) ) then
              call obs_bodySet_r(lobsSpaceData,OBS_WORK,bodyIndex, &
                   radiancedata_tl % bt(index_tb) )
              if ( tvs_debug ) then
                 write(*,'(a,i4,2f8.2)') ' ichn,sim,obs= ', &
                      channel_index,   radiancedata_tl % bt(index_tb), &
                      obs_bodyElem_r(lobsSpaceData,OBS_OMP,bodyIndex)
              endif
              cycle tb_loop
           endif
        end do
     enddo tb_loop

 
!     de-allocate memory

     asw=0 ! 1 to allocate,0 to deallocate
! deallocate transmitance structures
     call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
          nchanprof=count_tb,asw=asw )
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl transmission", .false.)
     
     
     call rttov_alloc_transmission(rttov_err_stat,transmission_tl,nlevels=nlevels,   &
          nchanprof=count_tb,asw=asw )
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl transmission_tl", .false.)
     
! deallocate radiance structures
     call rttov_alloc_rad (rttov_err_stat,count_tb,radiancedata_d,nlevels,asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl radiancedata_d", .false.)
     
     call rttov_alloc_rad (rttov_err_stat,count_tb,radiancedata_tl,nlevels,asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl radiancedata_tl", .false.)
    
 ! deallocate profilesdatat_tl structure
    
     call rttov_alloc_prof (rttov_err_stat,count_profile,profilesdata_tl,nlevels, &
          tvs_opts(sensor_id),asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rtttov_tl profilesdata_tl", .false.)
    
     alloc_status(:) = 0
    
     deallocate ( surfem1         ,stat=alloc_status(1) )
     deallocate ( chanprof        ,stat=alloc_status(2) )
     deallocate ( emissivity_local,stat=alloc_status(3) )
     deallocate ( emissivity_tl   ,stat=alloc_status(4) )
     deallocate ( calcemis        ,stat=alloc_status(5) )
     deallocate ( profilesdata_tl ,stat=alloc_status(6) )
     call utl_checkAllocationStatus(alloc_status, " tvslin_rtttov_tl", .false.)
    
  end do sensor_loop

  deallocate ( iptobs )


end subroutine tvslin_rttov_tl



subroutine tvslin_rttov_ad(lobsSpaceData)
!--------------------------------------------------------------------------
!! *Purpose*: Adjoint of computation of radiance with rttov_ad
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                  -addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda  april 2008
!                  -adapt to CSR
!revision 003  : s. heilliette
!                  -adapt to IASI
!           S. Heilliette
!              - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!--------------------------------------------------------------------------
  use MathPhysConstants_mod
  use tovs_nl_mod
  use obsSpaceData_mod
  use columnData_mod
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_ad.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"
#include "rttov_init_prof.interface"
#include "rttov_init_rad.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: nlevels
  integer :: count_tb
  integer :: alloc_status(6)
  integer :: rttov_err_stat                      ! rttov error return code
  integer :: omp_get_num_threads
  integer :: nthreads,max_nthreads
  integer :: sensor_id, iobs
  integer :: instrum, count_profile
  integer :: profile_index, tb_index, istart, iend, ichn, channel_index, headerIndex, bodyIndex
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)

  integer, allocatable :: iptobs          (:)  
  integer :: errorstatus 

  real*8, allocatable :: surfem1       (:) 
  type (rttov_emissivity), allocatable :: emissivity_local (:)
  type (rttov_emissivity), allocatable :: emissivity_ad (:)
  type (rttov_transmission) :: transmission,transmission_ad
  type (rttov_radiance) :: radiancedata_ad, radiancedata_d
  
  type(rttov_profile)   , allocatable :: profilesdata_ad (:) ! ad profiles buffer used in rttov calls
  type(rttov_chanprof)  , allocatable :: chanprof(:)
  logical              :: init
  integer :: asw
  logical, allocatable :: calcemis  (:)
         
  if (tvs_nobtov == 0) return      ! exit if there are not tovs data


!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!          
 
!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel

  allocate ( iptobs(tvs_nobtov) )


  call rttov_init_prof(profiles_ad )

!
!     2.  Computation of adjoint hx for tovs data only
!     .   --------------------------------------------

! Loop over all sensors specified by user

  sensor_loop:do  sensor_id = 1, tvs_nsensors
     
     nlevels=tvs_coefs(sensor_id) %coef % nlevels
     sensor_type = tvs_coefs(sensor_id) % coef% id_sensor
     instrum = tvs_coefs(sensor_id) % coef% id_inst
     
!  loop over all obs.

     count_profile = 0
     obs_loop: do iobs = 1, tvs_nobtov

!    Currently processed sensor?

        if ( tvs_lsensor(iobs) == sensor_id ) then
           count_profile = count_profile + 1
           iptobs(count_profile) = iobs
        endif
     enddo obs_loop

     if (count_profile == 0) cycle sensor_loop

!     .  2.1  Calculate the actual number of threads which will be used.
!     .       ----------------------------------------------------------

     nthreads = min(max_nthreads, count_profile )  

!     .  2.2  Prepare all input variables required by rttov_ad.
!     .       ---------------------------------------------------------
     

!     compute the number of radiances/tbs to be calculated
     count_tb = tvs_countRadiances(iptobs, count_profile, lobsSpaceData)

     if (count_tb == 0) cycle sensor_loop

     alloc_status(:)=0
     allocate ( chanprof     (count_tb)        ,stat=alloc_status(1))
     allocate ( emissivity_local (count_tb)    ,stat=alloc_status(2))
     allocate ( emissivity_ad(count_tb)        ,stat=alloc_status(3))
     allocate ( calcemis     (count_tb)        ,stat=alloc_status(4))
     allocate ( surfem1      (count_tb)        ,stat=alloc_status(5))
     allocate ( profilesdata_ad(count_profile) ,stat=alloc_status(6))
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad")
      
!     get Hyperspectral IR emissivities
      
     if ( tvs_isInstrumHyperSpectral(instrum) )  call tvs_getHIREmissivities(sensor_id, iptobs, count_profile, lobsSpaceData, surfem1)

! Build the list of channels/profiles indices

     call TVS_getChanprof(sensor_id, iptobs, count_profile, lobsSpaceData, chanprof)
!     get non Hyperspectral IR emissivities
     call tvs_getOtherEmissivities(chanprof, iptobs, count_tb, sensor_type, instrum, surfem1, calcemis)

     emissivity_local(:)%emis_in = surfem1(:)
        
! allocate transmittance structures
     asw=1
     init=.true.
     call rttov_alloc_transmission(alloc_status(1), transmission, nlevels=nlevels,      &
          nchanprof=count_tb, asw=asw, init=init)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad transmittances")

     call rttov_alloc_transmission(alloc_status(1), transmission_ad, nlevels=nlevels,   &
          nchanprof=count_tb, asw=asw, init=init)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad transmittances ad")
      

! allocate radiance structures

     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_d, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances")
     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_ad, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances ad")

! allocate profile structures
         
     call rttov_alloc_prof (alloc_status(1), count_profile, profilesdata_ad, nlevels, &
          tvs_opts(sensor_id), asw=asw, coefs=tvs_coefs(sensor_id), init=init)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances ad")

     call rttov_init_prof(profilesdata_ad(1:count_profile) )

     call rttov_init_rad( radiancedata_d )

!.. fill radiancedata_ad arrays
     call rttov_init_rad( radiancedata_ad ) ! set irrrelevant fields to zero
!Could this loop be optimized ?
     tb_loop:   do tb_index = 1, count_tb
        profile_index = chanprof(tb_index)%prof
        channel_index = chanprof(tb_index)%chan
        iobs = iptobs(profile_index)
        headerIndex = tvs_lobsno(iobs)
        istart = obs_headElem_i(lObsSpaceData,OBS_RLN,headerIndex)
        iend = obs_headElem_i(lObsSpaceData,OBS_NLV,headerIndex) + istart - 1
        do bodyIndex = istart, iend
           ichn = nint(obs_bodyElem_r(lobsSpaceData,OBS_PPP,bodyIndex))
           ichn = max(0,min(ichn,tvs_maxChannelNumber+1))
           ichn = ichn - tvs_channelOffset(sensor_id)
           if ( ichn == tvs_ichan(channel_index,sensor_id) ) then
              radiancedata_ad % bt( tb_index ) = obs_bodyElem_r(lobsSpaceData,OBS_WORK,bodyIndex)
              cycle tb_loop
           endif
        enddo
     enddo tb_loop

!

!     .  2.3  Compute ad radiance with rttov_ad
!     .       ---------------------------------

     errorstatus  = 0
     emissivity_ad(:)%emis_in = 0.0d0
     emissivity_ad(:)%emis_out = 0.0d0
     
     call tmg_start(84,'rttov_ad')
     call rttov_parallel_ad(        &
          errorstatus,              & ! out
          chanprof,                 & ! in
          tvs_opts(sensor_id),      & ! in
          tvs_profiles(iptobs(1:count_profile)), & ! in
          profilesdata_ad,          & ! in
          tvs_coefs(sensor_id),     & ! in
          transmission,             & ! inout
          transmission_ad,          & ! inout
          radiancedata_d,           & ! inout
          radiancedata_ad,          & ! inout
          calcemis=calcemis,           & ! in
          emissivity=emissivity_local, & ! inout
          emissivity_ad=emissivity_ad, & ! inout
          nthreads = nthreads )

     if (errorstatus /= 0) then
        Write(*,*) "Error in rttov_parallel_ad", errorstatus
        call utl_abort('tvslin_rttov_ad')
     endif

     call tmg_stop(84)

!.. store results from rttov_ad into profiles_ad

     do tb_index = 1, count_tb
        profile_index = chanprof(tb_index)%prof
        iobs = iptobs(profile_index)
        profiles_ad(iobs) % t(:)      =  profilesdata_ad(profile_index) % t(:)
        profiles_ad(iobs) % q(:)      =  profilesdata_ad(profile_index) % q(:)
        profiles_ad(iobs) % skin % t  =  profilesdata_ad(profile_index) % skin % t 
        profiles_ad(iobs) % s2m % t   =  profilesdata_ad(profile_index) % s2m % t
        profiles_ad(iobs) % s2m % q   =  profilesdata_ad(profile_index) % s2m % q
        profiles_ad(iobs) % s2m % p   =  profilesdata_ad(profile_index) % s2m % p
        profiles_ad(iobs) % s2m % u   =  profilesdata_ad(profile_index) % s2m % u
        profiles_ad(iobs) % s2m % v   =  profilesdata_ad(profile_index) % s2m % v
     enddo

    
!     de-allocate memory

     asw=0 ! 1 to allocate,0 to deallocate

     call rttov_alloc_transmission(alloc_status(1), transmission, nlevels=nlevels,      &
          nchanprof=count_tb, asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad transmittances", .false.)

     call rttov_alloc_transmission(alloc_status(1), transmission_ad, nlevels=nlevels,   &
          nchanprof=count_tb, asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad transmittances ad", .false.)
         
     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_d, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances", .false.)

     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_ad, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances ad", .false.)

     call rttov_alloc_prof (alloc_status(1), count_profile, profilesdata_ad, nlevels, &
          tvs_opts(sensor_id), asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad radiances ad", .false.)

     alloc_status(:) = 0
     deallocate ( profilesdata_ad ,stat=alloc_status(1))
     deallocate ( chanprof        ,stat=alloc_status(2))
     deallocate ( emissivity_local,stat=alloc_status(3))
     deallocate ( emissivity_ad   ,stat=alloc_status(4))
     deallocate ( calcemis        ,stat=alloc_status(5))
     deallocate ( surfem1         ,stat=alloc_status(6))
     call utl_checkAllocationStatus(alloc_status, " tvslin_rttov_ad", .false.)
     
  enddo sensor_loop

!     3.  Close up
!     .   --------

  deallocate ( iptobs )

end subroutine tvslin_rttov_ad


subroutine tvslin_fill_profiles_ad(column,columng)
!--------------------------------------------------------------------------
!! *Purpose*: Adjoint of filling tangent linear profiles structure by interpolating 
!!            contents of columnData to RTTOV space
!!
!! @author j. halle *cmda/aes  april 21, 2005
!
!revision 001  : j. halle  *cmda/smc  march 2007
!                    -fix zvlev for hybrid coordinate
!revision 002  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!
!--------------------------------------------------------------------------
  use MathPhysConstants_mod
  use tovs_nl_mod
  use columnData_mod
  use obsSpaceData_mod
  use presProfileOperators_mod
  use utilities_mod
  use tovs_extrap_mod
  implicit none

  type(struct_columnData) :: column,columng

  type(struct_vco), pointer :: vco_anl
  integer, allocatable :: iptobs    (:) 
  integer, allocatable :: iptobscma (:) 

  integer :: alloc_status(15)
  logical :: diagTtop,TopAt10hPa
  integer :: omp_get_num_threads, nthreads
  integer :: istride, ilen, imodulo
  integer :: nlevels,nobmax
  integer :: sensor_id, iobs, stat
  integer :: ilowlvl_T,ilowlvl_M,count_profile,headerIndex,nlv_M,nlv_T
  integer :: profile_index, level_index, rttov_index
  integer :: status, Vcode
  integer :: jpmotop, jpmolev

  real(8), allocatable :: to_ad    (:,:)
  real(8), allocatable :: lqo_ad   (:,:)
  real(8), allocatable :: toext_ad (:,:)
  real(8), allocatable :: qoext_ad (:,:)
  real(8), allocatable :: zvlev    (:,:)
  real(8), allocatable :: dPdPs    (:,:)
  real(8), allocatable :: zt_ad    (:,:)
  real(8), allocatable :: zlq_ad   (:,:)
  real(8), allocatable :: zt       (:,:)
  real(8), allocatable :: zlq      (:,:)
  real(8), allocatable :: qoext    (:,:)
  real(8), allocatable :: zps_ad   (:)
  real(8), allocatable :: xpres    (:)

  real(8) :: zptop, zptopmbs

  real(8), pointer :: uu_column(:),vv_column(:),tt_column(:),hu_column(:),ps_column(:),tg_column(:)
  real(8), pointer :: TTb(:), HUb(:), Pres(:)
         
  if (tvs_nobtov == 0) return    ! exit if there are not tovs data


!     1.    Set index for model's lowest level and model top
!     .     ------------------------------------------------

  nlv_M = col_getNumLev(columng,'MM')
  nlv_T = col_getNumLev(columng,'TH')

  if (  col_getPressure(columng,1,1,'TH') < col_getPressure(columng,nlv_T,1,'TH') ) then
     ilowlvl_M = nlv_M
     ilowlvl_T = nlv_T
  else
     ilowlvl_M = 1
     ilowlvl_T = 1
  endif

  vco_anl => col_getVco(columng)
  status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode)
  diagTtop = (Vcode==5002)

! find model level top, within 0.000001 mbs.
  zptop    = col_getPressure(columng,1,1,'TH')
  zptopmbs = zptop/100.d0
  zptopmbs = zptopmbs - 0.000001d0

  TopAt10hPa = ( abs( zptopmbs - 10.0d0 ) <= .1d0 )

!     1.1   Number of threads and memory allocation
!     .     ---------------------------------------

!$omp parallel 
  nthreads = omp_get_num_threads()
!$omp end parallel
  
!
!     2.  Adjoint of fill profiles structure
!     .   ----------------------------------

! loop over all instruments
  sensor_loop: do sensor_id = 1, tvs_nsensors

     count_profile = 0

     bobs1: do iobs = 1,tvs_nobtov
        if (tvs_lsensor(iobs) /= sensor_id) cycle bobs1
        NOBMAX = iobs
        count_profile = count_profile + 1   
     enddo bobs1

     if (count_profile == 0) cycle sensor_loop

     nlevels=tvs_coefs(sensor_id) %coef%  nlevels
     allocate (xpres(nlevels))
     xpres = tvs_coefs(sensor_id)% coef % ref_prfl_p
     jpmotop = 1
     do level_index = 2, nlevels
        if ( zptopmbs >= xpres(level_index-1) .and.       &
             zptopmbs < xpres(level_index)        ) then
           jpmotop = level_index
           exit
        endif
     enddo

     jpmolev = (nlevels-jpmotop+1)
     
     alloc_status(:) = 0
     allocate (iptobs   (count_profile)        ,stat= alloc_status(1) )
     allocate (iptobscma(count_profile)        ,stat= alloc_status(2) )
     allocate (to_ad    (jpmolev,count_profile),stat= alloc_status(3) )
     allocate (lqo_ad   (jpmolev,count_profile),stat= alloc_status(4) )
     allocate (toext_ad (nlevels,count_profile),stat= alloc_status(5) )
     allocate (qoext_ad (nlevels,count_profile),stat= alloc_status(6) )
     allocate (zvlev    (nlv_T,count_profile)  ,stat= alloc_status(7) )
     allocate (dPdPs    (nlv_T,count_profile)  ,stat= alloc_status(8) )
     allocate (zt_ad    (nlv_T,count_profile)  ,stat= alloc_status(9) )
     allocate (zlq_ad   (nlv_T,count_profile)  ,stat= alloc_status(10))
     allocate (zt       (nlv_T,count_profile)  ,stat= alloc_status(11))
     allocate (zlq      (nlv_T,count_profile)  ,stat= alloc_status(12))
     allocate (qoext    (nlevels,count_profile),stat= alloc_status(13))
     allocate (zps_ad   (count_profile)        ,stat= alloc_status(14))

     call utl_checkAllocationStatus(alloc_status, " tvslin_fill_profiles_ad")

     count_profile = 0 

! loop over all obs.
     bobs2: do iobs = 1, NOBMAX
        if (tvs_lsensor(iobs)/=sensor_id) cycle bobs2
        headerIndex = tvs_lobsno(iobs)
          
        count_profile = count_profile + 1

        TTb => col_getColumn(columng,headerIndex,'TT')
        HUb => col_getColumn(columng,headerIndex,'HU')
        Pres => col_getColumn(columng,headerIndex,'PR','TH')
        do level_index = 1, nlv_T
           zt   (level_index,count_profile) = TTb(level_index)
           zlq  (level_index,count_profile) = HUb(level_index)
           zvlev(level_index,count_profile) = Pres(level_index) *MPC_MBAR_PER_PA_R8
           dPdPs(level_index,count_profile) = col_getPressureDeriv(columng,level_index,headerIndex,'TH')
        enddo

! Fix pour eviter probleme au toit avec GEM 4
! (grosse variabilite de la temperature au dernier niveau thermo due 
!  a l'extrapolation utilisee)
        if (diagTtop) then
           zt   (1,count_profile) =  zt   (2,count_profile) + tvs_mesosphereLapseRate *  &
                log( col_getPressure(columng,1,headerIndex,'TH') /  &
                col_getPressure(columng,2,headerIndex,'TH') )
           zlq  (1,count_profile) =  zlq  (2,count_profile)
        endif

        iptobs   (count_profile) = iobs
        iptobscma(count_profile) = headerIndex
     enddo bobs2

!     .  2.4  Adjoint of filling profiles_ad structure
!     .       ----------------------------------------
     do profile_index = 1, count_profile
        qoext(:,profile_index) =  tvs_profiles(iptobs(profile_index)) % q(:) !/ tvs_qMixratio2ppmv
     enddo

     do  profile_index =  1, count_profile
        headerIndex = iptobscma(profile_index)
        rttov_index = iptobs(profile_index)
        ps_column => col_getColumn(column,headerIndex,'P0')
        tg_column => col_getColumn(column,headerIndex,'TG')
        tt_column => col_getColumn(column,headerIndex,'TT')
        hu_column => col_getColumn(column,headerIndex,'HU')
        uu_column => col_getColumn(column,headerIndex,'UU')
        vv_column => col_getColumn(column,headerIndex,'VV')

        toext_ad(:,profile_index)      = profiles_ad(rttov_index) % t(:)
        qoext_ad(:,profile_index)      = profiles_ad(rttov_index) % q(:) 
        ps_column(1)       = profiles_ad(rttov_index) % s2m % p *MPC_MBAR_PER_PA_R8
        tg_column(1)       = profiles_ad(rttov_index) % skin % t
        tt_column(ilowlvl_T) = profiles_ad(rttov_index) % s2m % t
!!!        hu_column(ilowlvl_T) = qoext(ilowlvl_T,profile_index) * profiles_ad(rttov_index) % s2m % q * tvs_qMixratio2ppmv
!!!        hu_column(ilowlvl_T) = qoext(ilowlvl_T,profikle_index) * profiles_ad(rttov_index) % s2m % q 
        hu_column(ilowlvl_T) = 0.d0 
        uu_column(ilowlvl_M) = profiles_ad(rttov_index) % s2m % u
        vv_column(ilowlvl_M) = profiles_ad(rttov_index) % s2m % v
     end do

!     .  2.3  Adjoint of extrapolation of humidity profile (kg/kg)
!             above rlimlvhu (normally 300mbs or 70mbs)
!     .  
     if ( TopAt10hPa ) then
        if ( tvs_debug ) then
           do profile_index = 1, count_profile
              write(*,*)'qoext_ad*1000 avant aexthum4    = '
              write(*,'(1x,10f8.4)')(qoext_ad(level_index,profile_index)*1000.d0,level_index=1,nlevels)
              write(*,*)' '
           enddo
        endif
        call aexthum4 (count_profile,nlevels,xpres(1:nlevels),qoext_ad,qoext)
        if ( tvs_debug ) then
           do profile_index = 1, count_profile
              write(*,*)'qoext_ad*1000 apres aexthum4    = '
              write(*,'(1x,10f8.4)')(qoext_ad(level_index,profile_index)*1000.d0,level_index=1,nlevels)
              write(*,*)' '
           enddo
        endif
     endif

! adjoint of conversion lnq --> q
     lqo_ad(:,:) = 0.0d0
     do profile_index = 1, count_profile
        do level_index = 1, jpmolev
           lqo_ad(level_index,profile_index) = qoext_ad(nlevels-jpmolev+level_index,profile_index) * qoext(nlevels-jpmolev+level_index,profile_index)
        enddo
     enddo

!     .  2.2  Adjoint of extrapolation of temperature profile above 10mb
!     .       ----------------------------------------------------------
     to_ad(:,:) = 0.0d0
     if ( .not. TopAt10hPa ) then
        do profile_index = 1, count_profile
           to_ad(1:jpmolev,profile_index)=to_ad(1:jpmolev,profile_index)+toext_ad(jpmotop:nlevels,profile_index)
        enddo
     else
        call aextrap (to_ad,toext_ad,jpmolev,nlevels,count_profile)
     endif
 
!     .  2.1  Adjoint of vertical interpolation of model temperature and logarithm of
!             specific humidity to pressure levels required by tovs rt model
!     .       -----------------------------------------------------------------------

     zt_ad (:,:) = 0.0d0
     zlq_ad(:,:) = 0.0d0
     zps_ad(:)   = 0.0d0


     imodulo = mod(count_profile,nthreads)
     if ( imodulo == 0 ) then
        istride = max(1,(count_profile/nthreads))
     else
        istride = max(1,(count_profile/nthreads)+1)
     endif
     call tmg_start(75,'intavgad')
!$omp parallel
!$omp do private(profile_index,ilen)
     do profile_index=1,count_profile,istride
        ilen = min (count_profile-profile_index+1,istride)
        if ( ilen > 0) then
           
           call ppo_IntAvgAd(zvlev(:,profile_index:profile_index+ilen-1), dPdPs(:,profile_index:profile_index+ilen-1), &
                zt_ad(:,profile_index:profile_index+ilen-1), zt(:,profile_index:profile_index+ilen-1), &
                zps_ad(profile_index:profile_index+ilen-1), nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),to_ad(:,profile_index:profile_index+ilen-1))
           call ppo_IntAvgAd(zvlev(:,profile_index:profile_index+ilen-1),dPdPs(:,profile_index:profile_index+ilen-1), &
                zlq_ad(:,profile_index:profile_index+ilen-1), zlq(:,profile_index:profile_index+ilen-1), &
                zps_ad(profile_index:profile_index+ilen-1), nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels), lqo_ad(:,profile_index:profile_index+ilen-1))

        endif
     enddo
!$omp end do
!$omp end parallel
     call tmg_stop(75)
 
! Fix pour eviter probleme au toit avec GEM 4
! (grosse variabilite temperature au dernier niveau thermo due 
!  a l'extrapolation utilisee)
     if ( diagTtop ) then
        do profile_index = 1, count_profile
           zt_ad (1,profile_index) = 0.d0
           zlq_ad(1,profile_index) = 0.d0
        enddo
     endif

!     .  2.1  Store adjoints in columnData object
!     .       -----------------------------------

     do  profile_index = 1 , count_profile 
        ps_column => col_getColumn(column,iptobscma(profile_index),'P0')
        tt_column => col_getColumn(column,iptobscma(profile_index),'TT')
        hu_column => col_getColumn(column,iptobscma(profile_index),'HU')
        
        ps_column(1) = ps_column(1) + zps_ad  (profile_index) * MPC_MBAR_PER_PA_R8
        do level_index = 1, col_getNumLev(column,'TH')
           tt_column(level_index) = tt_column(level_index) + zt_ad  (level_index,profile_index)
           hu_column(level_index) = hu_column(level_index) + zlq_ad (level_index,profile_index)
        enddo
     enddo

     alloc_status(:) = 0
     deallocate (iptobs   ,stat= alloc_status(1) )
     deallocate (iptobscma,stat= alloc_status(2) )
     deallocate (to_ad    ,stat= alloc_status(3) )
     deallocate (lqo_ad   ,stat= alloc_status(4) )
     deallocate (toext_ad ,stat= alloc_status(5) )
     deallocate (qoext_ad ,stat= alloc_status(6) )
     deallocate (zvlev    ,stat= alloc_status(7) )
     deallocate (dPdPs    ,stat= alloc_status(8) )
     deallocate (zt_ad    ,stat= alloc_status(9) )
     deallocate (zlq_ad   ,stat= alloc_status(10))
     deallocate (zt       ,stat= alloc_status(11))
     deallocate (zlq      ,stat= alloc_status(12))
     deallocate (qoext    ,stat= alloc_status(13))
     deallocate (zps_ad   ,stat= alloc_status(14))
     deallocate (xpres    ,stat= alloc_status(15))

     call utl_checkAllocationStatus(alloc_status, " tvslin_fill_profiles_ad", .false.)

!    next bunch !

     count_profile = 0

  enddo sensor_loop

end subroutine tvslin_fill_profiles_ad



SUBROUTINE AEXTHUM4(KNPF,KLAPF,PPRES,PAV,PAV5)
!
!*****aexthum4* - adjoint of extrapolation of upper level humidity profile.
!                (adapted from exthumad by J. Eyre)
!
!     purpose.
!     --------
!          ad of routine
!          to extend mixing ratio profile into stratosphere in
!          a reasonable way.
!
!**   interface.
!     ----------
!          *call* *aexthum4(knpf,klapf,ppres,pav,pav5)*
!               *knpf*:  no. of profiles to be processed.
!               *klapf*: length of atm. profiles.
!               *ppres*: pressure levels of atm. profiles.
!               *pav*:   ad of humidity profiles.
!               *pav5*:  humidity profiles.
!
!     method.
!     -------
!          take top tropospheric mixing ratio (e.g. near 300 mb) and
!          extrapolate with given fall off into lower stratosphere
!          (e.g. to 70 mb).  constrain mixing ratio to be >= zwmin
!          (e.g. 0.000003 kg/kg).   in upper strat, mixing ratio = zwmin.
!
!     externals.
!     ----------
!          none.
!

  use MathPhysConstants_mod
  use obsFilter_mod
  IMPLICIT none

  integer :: klapf,knpf
  REAL(8) PPRES(*),PAV(KLAPF,*), PAV5(KLAPF,*)

  REAL(8) :: ZPRES3(KLAPF)

  real(8) zwmix,zwb
  real(8),parameter ::  ZP1 = 70.0D0 ! PRESS LIMITS (IN HPA) OF REGION to be extrapolated
  integer :: inlvw,j,jnpf
    

!          find top level of given profile
  INLVW = -1
  DO J=KLAPF,1,-1
     IF (PPRES(J)<FILT_RLIMLVHU) THEN
        INLVW=J
        EXIT
     ENDIF
  end do
!
!** Null extrapolation case
!
  if (INLVW == -1) RETURN

!          constants defining p**3 fall off around tropopause
  DO J=1,INLVW
     ZPRES3(J)=(PPRES(J)/PPRES(INLVW+1))**3
  end do

  DO JNPF=1,KNPF
     ZWB=0.D0
     DO J=1,INLVW
        ZWMIX=PAV(J,JNPF)
        PAV(J,JNPF)=0.D0
        IF (PPRES(J)>=ZP1) THEN
           IF (PAV5(J,JNPF)>MPC_MINIMUM_HU_R8) THEN
              ZWB=ZWB+ZWMIX*ZPRES3(J)
           ENDIF
        ENDIF
     end do
     PAV(INLVW+1,JNPF)=PAV(INLVW+1,JNPF)+ZWB
  end do
   

END SUBROUTINE AEXTHUM4

 
End Module tovs_lin_mod

