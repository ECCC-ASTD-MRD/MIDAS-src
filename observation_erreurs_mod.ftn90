!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

module observation_erreurs_mod

  use MathPhysConstants_mod
  use obsSpaceData_mod
  use tovs_nl_mod
  use codtyp_mod
  use bufr
  implicit none
  private

  ! public procedures
  ! -----------------

  public :: oer_set_obs_erreurs

  ! TOVS OBS ERRORS
  ! ---------------

  real(8) :: toverrst(jpchmax,jpnsatmax)

  !
  ! CONVENTIONAL OBS ERRORS 
  ! -----------------------

  real(8) :: xstd_ua_ai_sw(20,11)
  real(8) :: xstd_sf(9,4)
  real(8) :: xstd_pr(2)
  real(8) :: xstd_sc(1)

  ! RETRIEVED CONSTITUENT OBS ERROR STD. DEV. (TR family)
  ! -----------------------------------------------------
  !
  ! Variable              Description
  ! --------              -----------
  ! nstd_stnid_tr         Number of sub-families (identified via STNIDs)
  ! cstd_stnid_tr         sub-families (STNIDs; * are wild cards)
  ! nstd_bfr_tr           BUFR/BURP element in data block 
  ! nstd_brp_tr           0: Set entirely from the ascii file being read. No 
  !                          initial values read from BURP files
  !                       1: Initial values in obs BURP files 
  !                          (may be adjusted after input)
  ! nstd_type_tr          Index of setup approach (used in combination with
  !                           nstd_brp_tr)
  !                       For nstd_brp_tr value 0 or 1, 
  !                       0: xstd_std1_tr or BURP file vales (sigma)
  !                       1: min(xstd_std3_tr,max(xstd_std2_tr,xstd_std1_tr*ZVAL))
  !                                                   or
  !                           max(xstd_std2_tr(ISTNID),xstd_std1_tr(ILEV)*sigma)
  !                       2: sqrt(xstd_std2_tr**2+(xstd_std1_tr*ZVAL)**2))
  !                                                   or
  !                                              not applicable
  ! nstd_ibegin_tr        Position index of start of data for given
  !                       sub-family in the arrays xstd_std1_tr,xstd_lvl_tr,xstd_lat_tr
  ! nstd_lvl_tr           Number of vertical levels
  ! xstd_lvl_tr           Vertical levels (in coordinate of sub-family data)
  ! nstd_lat_tr           Number of latitudes
  ! xstd_lat_tr           Latitudes (degrees; ordering in increasing size)
  ! xstd_std1_tr          See nstd_type_tr for usage
  ! xstd_std2_tr          See nstd_type_tr for usage
  ! xstd_std3_tr          See nstd_type_tr for usage
  !
  integer ::  nstd_stnid_tr
  character(len=12), allocatable :: cstd_stnid_tr(:)
  integer, allocatable :: nstd_bfr_tr(:),nstd_type_tr(:),nstd_lat_tr(:)
  integer, allocatable :: nstd_brp_tr(:),nstd_ibegin_tr(:),nstd_lvl_tr(:)
  real(8),  allocatable :: xstd_std1_tr(:),xstd_std2_tr(:),xstd_std3_tr(:)
  real(8), allocatable :: xstd_lvl_tr(:),xstd_lat_tr(:)
  
  save
  contains

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_set_obs_erreurs(lobsSpaceData)
  !
  ! s/r set_observation_erreurs -SET OBSERVATION ERROR STDDEV FOR ALL DATA 
  !
  ! Author  : S. Laroche  February 2014
  ! Revision: Y. Rochon, Nov 2014
  !           - Added call to oer_read_obs_erreurs_tr
  !
  ! Purpose: read and set observation error stddev (from former sucovo subroutine).
  !
  !

  type(struct_obs) :: lobsSpaceData

  !
  ! Read in the observation error stddev for radiance data
  !
  call oer_read_obs_erreurs_tovs

  !
  ! Read in the observation error stddev for conventional data
  !
  call oer_read_obs_erreurs_conv

  !
  ! Read in the observation error stddev for constituent data
  !
  call oer_read_obs_erreurs_tr
  
  !
  ! Set obs error information in obsSpaceData object
  !
  call oer_fill_obs_erreurs(lobsSpaceData)

  !
  ! Deallocate temporary storage
  !
  call oer_dealloc_obs_erreurs

  end subroutine oer_set_obs_erreurs

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_read_obs_erreurs_tovs
  !
  ! s/r oer_read_obs_erreurs_tovs
  ! - Read the observation erreur statistics and utilization flag for TOVS processing.
  !
  !
  ! Author  : J. Halle !CMDA/AES  May 08, 1996
  !
  ! Revision 01  : J. Halle !CMDA/AES  Oct 1999
  !               - change file name to stats_tovs
  !
  ! Revision 002  : J. Halle !CMDA/AES  dec 2000
  !                adapt to TOVS level 1b.
  !
  ! Revision 003  : J. Halle !CMDA/SMC  may 2002
  !                adapt to RTTOV-7.
  !
  ! Revision 004  : J. Halle !CMDA/SMC  sept 2006
  !                adapt to RTTOV-8.
  !
  ! Revision 005  : A. Beaulne !CMDA/SMC  fevr 2007
  !                adapt utilization flag for AIRS channels
  !
  ! Revision 006  : S. Heilliette
  !                adapt utilization flag for IASI channels
  !
  ! Revision 007: S. Macpherson ARMA, Feb 2013
  !              - add NPP/ATMS codtyp=192
  !
  ! Revision 008  : S. Macpherson      apr 2013
  !              - adapt for new-format stats_tovs file
  !
  ! Revision 008  : S. Laroche      Mar 2014
  !              - upgrade of former f77 subroutine sutovst
  !              - f90 conversion and cleanup 
  !
  !    -------------------
  !    Purpose: Read the observation error statistics and
  !             utilization flag for TOVS processing. This information
  !             resides on an ASCII file and is read using a free format.

      
  use topLevelControl_mod
  use hir_chans
  use mpivar_mod
  use tovs_nl_mod
  use rmatrix_mod
  implicit none

  integer,external  :: FNOM, FCLOS, ISRCHEQ
  integer  :: IER, ILUTOV, JI, JJ, JK, JL, JM, I, IPOS1, IPOS2, INUMSAT, ISAT, IPLF
  integer, dimension(JPNSATMAX)         :: IPLATFORM, ISATID, IINSTRUMENT, NUMCHN, NUMCHNIN
  integer, dimension(JPCHMAX,JPNSATMAX) :: IUTILST, ICHN, ICHNIN
  
  real :: ZDUM

  real(8), dimension(JPCHMAX,2,JPNSATMAX) :: TOVERRIN

  character (len=132) :: CLDUM,CPLATF,CINSTR

  WRITE(*,'(//,10x,"-oer_read_obs_erreurs_tovs: reading observation error statistics required for TOVS processing")')

  !
  !    1. Initialize
  !       ----------
  !
  DO JL = 1, JPNSATMAX  
     DO JI = 1, JPCHMAX
        TOVERRST(JI,JL) = 0.0D0
      TOVERRIN(JI,1,JL) = 0.0D0
      TOVERRIN(JI,2,JL) = 0.0D0
      IUTILST   (JI,JL) = 0
     ENDDO
  ENDDO

  DO JL = 1, JPNSATMAX
     IPLATFORM(JL) = 0
        NUMCHN(JL) = 0
      NUMCHNIN(JL) = 0
     DO JI = 1, JPCHMAX
        ICHN(JI,JL) = 0
      ICHNIN(JI,JL) = 0
     ENDDO
  ENDDO

  if (nobtov==0) return

  !
  !     2. Open the file
  !        -------------
  !
  ilutov = 0
  IER =  FNOM(ILUTOV,'stats_tovs','SEQ+FMT',0)
  IF(IER.LT.0)THEN
     WRITE ( *, '(" oer_read_obs_erreurs_tovs: Problem opening ","file stats_tovs ")' )
     CALL ABORT3D ('oer_read_obs_erreurs_tovs')
  END IF

  !
  !     3. Print the file contents
  !        -----------------------
  !
  IF(MPI_MYID.EQ.0) THEN
     WRITE(*,'(20X,"ASCII dump of stats_tovs file: "//)')
     DO JI = 1, 9999999
       READ (ILUTOV,'(A)',IOSTAT=IER) CLDUM
       IF(IER.EQ.-1) EXIT
       WRITE(*,'(A)')   CLDUM
     ENDDO
  ENDIF

  !
  !     4. Read number of satellites
  !        -------------------------
  !
  REWIND(ILUTOV)
  READ (ILUTOV,*)
  READ (ILUTOV,*) INUMSAT
  READ (ILUTOV,*)

  !
  !     5. Read the satellite identification, the number of channels,
  !        the observation errors and the utilization flags
  !        ----------------------------------------------------------
  !
  WRITE(*,'(5X,"oer_read_obs_erreurs_tovs: Reading stats_tovs file: "//)')

  DO JL = 1, INUMSAT

     READ (ILUTOV,*)
     READ (ILUTOV,'(A)') CLDUM
     WRITE(*,'(A)') CLDUM
     CINSTR=CLDUM
     call split(CINSTR," ",CPLATF)
     Write(*,*) "CINSTR: ",CINSTR
     Write(*,*) "CPLATF: ",CPLATF
     READ (ILUTOV,*)
     READ (ILUTOV,*) ISATID(JL), NUMCHNIN(JL)

     DO JI = 1, 3
       READ (ILUTOV,*)
     ENDDO

     IPLATFORM(JL) = -1    
     DO I = 1, MXPLATFORM
      IPOS1=LEN_TRIM(CPLATFORM(I))
      IPOS2 = INDEX(CPLATF,CPLATFORM(I)(1:IPOS1))
      IF ( IPOS2 .NE. 0 ) THEN
         IPLATFORM(JL) = NOPLATFORM(I)
         EXIT
      ENDIF
     ENDDO

     IF ( IPLATFORM(JL) .EQ. -1 ) THEN
      WRITE ( *, '(" oer_read_obs_erreurs_tovs: Unknown platform!"/)' )
      CALL ABORT3D ('oer_read_obs_erreurs_tovs')
     ENDIF

     IINSTRUMENT(JL) = -1    
     DO I = 1, JPNSATMAX
      IPOS1=LEN_TRIM(CINSTRUMENT(I))
      IPOS2 = INDEX(CINSTR,CINSTRUMENT(I)(1:IPOS1))
      IF ( IPOS2 .NE. 0 ) THEN
       IINSTRUMENT(JL) = NOINSTRUMENT(I)
      ENDIF
     ENDDO

     IF ( IINSTRUMENT(JL) .EQ. -1 ) THEN
       WRITE ( *, '(" oer_read_obs_erreurs_tovs: Unknown instrument!"/)' )
       CALL ABORT3D ('oer_read_obs_erreurs_tovs')
     ENDIF  

     DO JI = 1, NUMCHNIN(JL)
       READ (ILUTOV,*) ICHNIN(JI,JL), TOVERRIN(ICHNIN(JI,JL),1,JL), TOVERRIN(ICHNIN(JI,JL),2,JL), IUTILST(ICHNIN(JI,JL),JL), ZDUM
     ENDDO
     READ (ILUTOV,*)

  ENDDO

  !
  !   Select input error to use: if ANAL mode, use ERRANAL (JJ=2);
  !   otherwise use ERRBGCK (JJ=1)
  !
  IF ( top_AnalysisMode() ) THEN
     JJ = 2
  ELSE
     JJ = 1
  ENDIF

  !
  !   Fill the observation error array TOVERRST
  !
  WRITE(*,'(5X,"oer_read_obs_erreurs_tovs: Fill error array TOVERRST: "//)')
  DO JM= 1, INUMSAT
    DO JL = 1, NSENSORS
      IF ( PLATFORM (JL) .EQ. IPLATFORM(JM) .AND. SATELLITE(JL) .EQ. ISATID(JM) ) THEN
        IF ( INSTRUMENT (JL) .EQ. IINSTRUMENT(JM) ) THEN
          NUMCHN(JL)=NUMCHNIN(JM)
          DO JI = 1, JPCHMAX
            TOVERRST(JI,JL) = TOVERRIN(JI,JJ,JM)
            ICHN(JI,JL) = ICHNIN(JI,JM)
          ENDDO
          IF (top_AnalysisMode().and.rmat_lnondiagr) call rmat_setFullRMatrix ( TOVERRST(:,JL), JL, chanoffset(JL) )
        ENDIF
      ENDIF
    ENDDO
  ENDDO

  !
  !  Check that oberservation error statistics have been defined for
  !  all the satellites specified in the namelist.
  !
  DO JL = 1, NSENSORS
     IPLF = ISRCHEQ ( IPLATFORM  , INUMSAT, PLATFORM  (JL) )
     ISAT = ISRCHEQ ( ISATID     , INUMSAT, SATELLITE (JL) )
     IF ( IPLF .EQ. 0 .OR. ISAT .EQ. 0 ) THEN
       WRITE ( *, '(" oer_read_obs_erreurs_tovs: Observation errors not ","defined for sensor # ", I3)' ) JL
       CALL ABORT3D ('oer_read_obs_erreurs_tovs')
     END IF
     IF ( NUMCHN(JL) .EQ. 0 ) THEN 
       WRITE ( *, '(" oer_read_obs_erreurs_tovs: Problem setting errors ","for sensor # ", I3)' ) JL
       CALL ABORT3D ('oer_read_obs_erreurs_tovs')
     ENDIF
  ENDDO

  !
  !   Utilization flag for AIRS,IASI and CrIS channels (bgck mode only)
  !
  IF ( top_BgckMode() ) THEN
     DO JM= 1, INUMSAT
      IF (   IPLATFORM(JM) .EQ. 9  .AND. &
           IINSTRUMENT(JM) .EQ. 11 ) THEN

         call hir_set_assim_chan("AIRS",IUTILST(ICHNIN(1:NUMCHNIN(JM),JM),JM))
      END IF
      IF (   IPLATFORM(JM) .EQ. 10 .AND. &
           IINSTRUMENT(JM) .EQ. 16 ) THEN
         call hir_set_assim_chan("IASI",IUTILST(ICHNIN(1:NUMCHNIN(JM),JM),JM))
      END IF
      IF (   IPLATFORM(JM) .EQ. 17 .AND. &
           IINSTRUMENT(JM) .EQ. 27 ) THEN
         call hir_set_assim_chan("CRIS",IUTILST(ICHNIN(1:NUMCHNIN(JM),JM),JM))
      END IF
     ENDDO
  END IF

  !
  !    6. Print out observation errors for each sensor
  !       --------------------------------------------
  !
  IF(MPI_MYID.eq.0) THEN
     WRITE(*,'(//1X,"Radiance observation errors read from file")')
     WRITE(*,'(  1X,"------------------------------------------")')
     DO JL = 1, NSENSORS
      WRITE(*,'(/1X,"SENSOR #",I2,". Platform: ",A,"Instrument: ",A)') &
              JL, CSATID(JL), CINSTRUMENTID(JL)
      WRITE(*,'(1X,"Channel",5X,"  error   ")')
      DO JI = 1, NUMCHN(JL)
       WRITE (*,'(1X,I7,1(5X,F10.2))') ICHN(JI,JL),TOVERRST(ICHN(JI,JL),JL)
      ENDDO
     ENDDO
  ENDIF

  !
  !    7. Close the file
  !       --------------
  !
  IER = FCLOS(ILUTOV)
  IF(IER.NE.0)THEN
     CALL ABORT3D ('oer_read_obs_erreurs_tovs')
  END IF

      contains

      subroutine compact(str)
! Code from Benthien's module: http://www.gbenthien.net/strings/index.html
! Converts multiple spaces and tabs to single spaces; deletes control characters;
! removes initial spaces.

        character(len=*):: str
        character(len=1):: ch
        character(len=len_trim(str)):: outstr
        integer isp,k,lenstr,i,ich

        str=adjustl(str)
        lenstr=len_trim(str)
        outstr=' '
        isp=0
        k=0

        do i=1,lenstr
           ch=str(i:i)
           ich=iachar(ch)

           select case(ich)
           case(9,32)    ! space or tab character         
              if(isp==0) then
                 k=k+1
                 outstr(k:k)=' '
              end if
              isp=1
           case(33:)              ! not a space, quote, or control character
              k=k+1
              outstr(k:k)=ch
              isp=0
           end select

        end do

        str=adjustl(outstr)

      end subroutine compact

      subroutine split(str,delims,before)
! Code extracted from Benthien's module: http://www.gbenthien.net/strings/index.html
! Routine finds the first instance of a character from 'delims' in the
! the string 'str'. The characters before the found delimiter are
! output in 'before'. The characters after the found delimiter are
! output in 'str'. 

        character(len=*) :: str,delims,before
        character :: ch,cha
        integer lenstr,i,k,ipos,iposa
        str=adjustl(str)
        call compact(str)
        lenstr=len_trim(str)

        if(lenstr == 0) return ! string str is empty
        k=0
        before=' '
        do i=1,lenstr
           ch=str(i:i)
         
           ipos=index(delims,ch)

           if(ipos == 0) then ! character is not a delimiter
              k=k+1
              before(k:k)=ch
              cycle
           end if
           if(ch /= ' ') then ! character is a delimiter that is not a space
              str=str(i+1:)
              exit
           end if

         cha=str(i+1:i+1)  ! character is a space delimiter
         iposa=index(delims,cha)
         if(iposa > 0) then   ! next character is a delimiter 
            str=str(i+2:)
            exit
         else
            str=str(i+1:)
            exit
         end if
      end do
      if(i >= lenstr) str=''

      str=adjustl(str) ! remove initial spaces
   
      return

      end subroutine split

  end subroutine oer_read_obs_erreurs_tovs

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_read_obs_erreurs_conv
  !
  ! s/r oer_read_obs_erreurs_conv -READ OBSERVATION ERROR OF CONVENTIONAL DATA 
  !
  ! Author  : S. Laroche  February 2014
  ! Revision:
  !          
  ! Purpose: read observation errors (modification of former readcovo subroutine).
  !

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, icodtyp, nulstat, ios, isize, icount
  logical :: LnewExists

  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS
!
!     CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obserr',EXIST=LnewExists)
  IF (LnewExists )then
    WRITE(*,*) '--------------------------------------------------------'
    WRITE(*,*) 'read_obs_errors_conv: reads observation errors in obserr'
    WRITE(*,*) '--------------------------------------------------------'
  else
    CALL ABORT3D('read_obs_errors_conv: NO OBSERVATION STAT FILE FOUND!!')     
  ENDIF
!
!     Read observation errors from file obserr for conventional data
!     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obserr','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
    write(*,*) 'read_obs_errors_conv: File =  ./obserr'
    write(*,*) ' opened as unit file ',nulstat
    open(unit=nulstat, file='obserr', status='OLD')
  ELSE
    CALL ABORT3D('read_obs_errors_conv:COULD NOT OPEN FILE obserr!!!')
  ENDIF

  write(*, '(A)') ' '

  do jlev = 1,3
    read(nulstat, '(A)') ligne
    write(*, '(A)') ligne
  enddo

  do jlev = 1, 19
    read(nulstat, * ) (xstd_ua_ai_sw(jlev,jelm), jelm=1,11)
    write(*, '(f6.0,10f6.1)' )  (xstd_ua_ai_sw(jlev,jelm), jelm=1,11)
  enddo

  do jlev = 1,5
    read(nulstat, '(A)') ligne
    write(*, '(A)') ligne
  enddo

  read(nulstat, * ) xstd_pr(1),xstd_pr(2)
  write(*, '(2f6.1)' )  xstd_pr(1),xstd_pr(2)

  do jlev = 1,5
    read(nulstat, '(A)') ligne
    write(*, '(A)') ligne
  enddo

  read(nulstat, * ) xstd_sc(1)
  write(*, '(f8.3)' )  xstd_sc(1)

  read(nulstat, '(A)') ligne
  write(*, '(A)') ligne

  do icodtyp = 1,9
    do jlev = 1,4
      read(nulstat, '(A)') ligne
      write(*, '(A)') ligne
    enddo
    read(nulstat, * ) (xstd_sf(icodtyp,jelm), jelm=1,4)
    write(*, '(f6.2,2f6.1,f8.3)' )  (xstd_sf(icodtyp,jelm), jelm=1,4)
  enddo

  write(*, '(A)') ' '

  CLOSE(UNIT=NULSTAT)
  IERR=FCLOS(NULSTAT)    

  end subroutine oer_read_obs_erreurs_conv

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_read_obs_erreurs_tr
!
!  s/r oer_read_obs_erreurs_tr - READ OBSERVATION ERROR OF CONSTITUENT DATA 
!
!  Author   : Y. Rochon, Nov 2014 
!             (initial part follows the format of oer_read_obs_erreurs_conv)
!  Revisions: 
!          
! Purpose: Read observation error std. dev. as needed for TR family obs.
!
!----------------------------------------------------------------------------------------

  implicit none

  integer :: FNOM, FCLOS
  integer :: IERR, JLEV, JELM, nulstat, ios, isize, icount
  logical :: LnewExists
  
  character (len=128) :: ligne

  EXTERNAL FNOM,FCLOS

! Initialization

  nstd_stnid_tr=0
!
! CHECK THE EXISTENCE OF THE NEW FILE WITH STATISTICS
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  INQUIRE(FILE='obsinfo_tr',EXIST=LnewExists)
  IF (LnewExists )then
!    WRITE(*,*) '---------------------------------------------------------------'
!    WRITE(*,*) 'oer_read_*_tr: read observation error stddev in obsinfo_tr     '
!    WRITE(*,*) '---------------------------------------------------------------'
  else
    WRITE(*,*) '---------------------------------------------------------------'
    WRITE(*,*) 'WARNING! read_obs_errors_tr: obsinfo_tr not available.         '
    WRITE(*,*) 'WARNING! Default TR family stddev to be applied if needed.     '
    WRITE(*,*) '---------------------------------------------------------------'
!    CALL ABORT3D('read_obs_errors_tr: NO OBSERVATION STAT FILE FOUND!!')     
  ENDIF
!
! Read observation error std dev. from file obsinfo_tr for constituent data
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
  NULSTAT=0
  IERR=FNOM(NULSTAT,'obsinfo_tr','SEQ',0)
  IF ( IERR .EQ. 0 ) THEN
!    write(*,*) 'read_obs_errors_tr: File =  ./obsinfo_tr'
!    write(*,*) 'opened as unit file ',nulstat
    open(unit=nulstat, file='obsinfo_tr', status='OLD')
  ELSE
    CALL ABORT3D('read_obs_errors_tr: COULD NOT OPEN FILE obsinfo_tr!')
  ENDIF


! Read error standard deviations for constituents if available.
! (TR family; ozone and others)
  
  ios=0
  read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  do while (trim(adjustl(ligne(1:12))).ne.'SECTION I:') 
      read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
  end do    
  
! Read number of observation set sub-families (STNIDs and ...) and allocate space

  read(nulstat,*,iostat=ios,err=10,end=10) nstd_stnid_tr
  read(nulstat,*,iostat=ios,err=10,end=10) isize

  allocate(cstd_stnid_tr(nstd_stnid_tr))
  allocate(nstd_type_tr(nstd_stnid_tr),nstd_lat_tr(nstd_stnid_tr))
  allocate(nstd_brp_tr(nstd_stnid_tr),nstd_ibegin_tr(nstd_stnid_tr))
  allocate(nstd_bfr_tr(nstd_stnid_tr),nstd_lvl_tr(nstd_stnid_tr))
  allocate(xstd_std1_tr(isize),xstd_std2_tr(nstd_stnid_tr),xstd_std3_tr(nstd_stnid_tr))
  allocate(xstd_lvl_tr(isize),xstd_lat_tr(isize))
 
  nstd_bfr_tr(:)=0
  nstd_brp_tr(:)=0
  nstd_type_tr(:)=0
  nstd_lvl_tr(:)=1
  nstd_lat_tr(:)=1

! Begin reading for each sub-family
! Important: Combination of STNID, BUFR element and number of vertical levels
!            to determine association to the observations.

  icount=0
  do jelm=1,nstd_stnid_tr
    nstd_ibegin_tr(jelm)=icount+1

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne

    ! Read STNID (* as wildcard)    
    read(nulstat,'(2X,A9)',iostat=ios,err=10,end=10) cstd_stnid_tr(jelm) 

!   Read (1) BUFR element,
!        (2) Flag indication if EOR provided from this ascii file or
!            to be read from the BURP file,
!        (3) Index specifying OER setup method,
!        (4) Number of vertical levels
!        (5) Number of latitudes
!
!   Important: Combination of STNID, BUFR element and number of vertical levels
!              to determine association to the observations.
!
    read(nulstat,*,iostat=ios,err=10,end=10) nstd_bfr_tr(jelm),nstd_brp_tr(jelm),  &
       nstd_type_tr(jelm), nstd_lvl_tr(jelm), nstd_lat_tr(jelm),  &
       xstd_std2_tr(jelm), xstd_std3_tr(jelm)

    if (nstd_lvl_tr(jelm).lt.1) nstd_lvl_tr(jelm)=1
    if (nstd_lat_tr(jelm).lt.1) nstd_lat_tr(jelm)=1
    
    if (icount+nstd_lvl_tr(jelm)*nstd_lat_tr(jelm).gt.isize) then
       write(*,'(10X,"Max array size exceeded: ",I6)') isize
       CALL ABORT3D('oer_read_obs_erreurs_tr: PROBLEM READING OBSERR STD DEV.')    
    end if

    ! disregard line of dashes
    read(nulstat,'(A)',iostat=ios,err=10,end=10) ligne
    
    if (nstd_lvl_tr(jelm).eq.1.and.nstd_lat_tr(jelm).eq.1) then
    
!      Read one value only (independent of level and latitude)
       
       icount=icount+1
       read(nulstat,*,iostat=ios,err=10,end=10) xstd_std1_tr(icount)

    else if (nstd_lvl_tr(jelm).eq.1.and.nstd_lat_tr(jelm).gt.1) then
    
!      Value dependent on latitude only
       
!      Read reference latitudes (must be in order of increasing size)
       
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              xstd_lat_tr(icount+1:icount+nstd_lat_tr(jelm))
      
!      Read OER-related values
  
       read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 xstd_std1_tr(icount+1:icount+nstd_lat_tr(jelm))

       icount=icount+nstd_lat_tr(jelm)

    else if (nstd_lvl_tr(jelm).gt.1.and.nstd_lat_tr(jelm).eq.1) then
    
!      Value dependent on vertical level only
      
       do jlev=1,nstd_lvl_tr(jelm)
          icount=icount+1
          
!         Read vertical level and OER-related value.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                 &
                 xstd_lvl_tr(icount),xstd_std1_tr(icount)

       end do
   
    else if (nstd_lvl_tr(jelm).gt.1.and.nstd_lat_tr(jelm).gt.1) then
    
!      Value dependent on vertical level and latitude 
       
!      Read reference latitudes (must be in order of increasing size)
       read(nulstat,*,iostat=ios,err=10,end=10)                      &
              xstd_lat_tr(icount+1:icount+nstd_lat_tr(jelm))
!       write(*, '(10X,20F9.3)') xstd_lat_tr(icount+1:icount+nstd_lat_tr(jelm))
      
       do jlev=1,nstd_lvl_tr(jelm)
          
!         Read vertical level and OER-related lat-dependent values.
          
          read(nulstat,*,iostat=ios,err=10,end=10)                   &
                 xstd_lvl_tr(icount+jlev),                           &
                 xstd_std1_tr(icount+(jlev-1)*nstd_lat_tr(jelm)+1:icount+jlev*nstd_lat_tr(jelm))

       end do
       icount=icount+nstd_lat_tr(jelm)*nstd_lvl_tr(jelm)
    end if
  end do
   
 10 if (ios.gt.0) then
       WRITE(*,*) 'File read error message number: ',ios
       CALL ABORT3D('oer_read_obs_erreurs_tr: PROBLEM READING OBSERR STD DEV.')    
    end if
 
 11 CLOSE(UNIT=NULSTAT)
    IERR=FCLOS(NULSTAT)    

  end subroutine oer_read_obs_erreurs_tr

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_fill_obs_erreurs(lobsSpaceData)
  !
  ! s/r oer_fill_obs_erreurs -FILL OBSERVATION ERRORS IN lobsSpaceData
  !
  ! Author  : S. Laroche  February 2014
  ! Revision: Y. Rochon, Nov 2014
  !           - Added consideration of 'TR' family
  !           - Removal of 'OZ' family
  !           - Added availability of CSTNID
  !          
  !
  ! Purpose: read observation errors (modification of former readcovo subroutine).
  !
  !--------------------------------------------------------------------------------------

  implicit none

  type(struct_obs) :: lobsSpaceData

  integer :: JN, JI, INDEX_BODY, INDEX_HEADER, ITYP, IFLG, IASS, IDATA, IDATEND, IDBURP
  integer :: ISAT, ICHN, IPLATF, INSTR, IPLATFORM, INSTRUM
  integer :: ILEV,ISTNID,IBEGIN,JINT,NLEV,IFIRST
  integer :: ielem,icodtyp,ilen1,ilen2,iset
  real(8) :: ZLAT, ZLON, ZLEV, ZVAL, ZSIG, zwb, zwt, sigma(300), wgt

  CHARACTER(len=2)  :: SENSORTYPE,CFAM
  CHARACTER(len=12) :: CSTNID

  !
  !     ========================================================================== 
  !
  WRITE(*,'(10X,"Fill_obs_errors")')
  WRITE(*,'(10X,"-----------------",/)')
  WRITE(*,'(10X,"***********************************")')
  WRITE(*,'(10X,"Fill_obs_errors:",/)')
  WRITE(*,'(10X,"***********************************")')

  !
  !     SET STANDARD DEVIATION ERRORS FOR EACH DATA FAMILY
  !     ---------------------------------------------------
  !
  DO INDEX_HEADER = 1, obs_numheader(lobsSpaceData)

     IDATA   = obs_headElem_i(lobsSpaceData,OBS_RLN,INDEX_HEADER)
     IDATEND = obs_headElem_i(lobsSpaceData,OBS_NLV,INDEX_HEADER) + IDATA - 1
     CFAM    = obs_getFamily(lobsSpaceData,INDEX_HEADER)
     ZLAT    = obs_headElem_r(lobsSpaceData,OBS_LAT,INDEX_HEADER)
     ZLON    = obs_headElem_r(lobsSpaceData,OBS_LON,INDEX_HEADER)
     IDBURP  = obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER)
     IPLATF  = obs_headElem_i(lobsSpaceData,OBS_SAT,INDEX_HEADER)
     INSTR   = obs_headElem_i(lobsSpaceData,OBS_INS,INDEX_HEADER)
     CSTNID  = obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER)

     IFIRST=0
     NLEV = IDATEND-IDATA+1

     DO INDEX_BODY  = IDATA, IDATEND

      ITYP  = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
      IFLG  = obs_bodyElem_i(lobsSpaceData,OBS_FLG,INDEX_BODY)
      IASS  = obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY)
      ZVAL  = obs_bodyElem_r(lobsSpaceData,OBS_VAR,INDEX_BODY)

      IF ( IASS .EQ. 1 ) THEN

  !***********************************************************************
  !                           TOVS DATA
  !***********************************************************************

        IF ( CFAM .EQ. 'TO' ) THEN

         IF ( ITYP .EQ. BUFR_NBT1 .OR. &
              ITYP .EQ. BUFR_NBT2 .OR. &
              ITYP .EQ. BUFR_NBT3     )THEN

            ICHN = NINT(obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY))
            CALL MAP_SAT(IPLATF,IPLATFORM,ISAT)
            CALL MAP_INSTRUM(INSTR,INSTRUM,SENSORTYPE)

             DO JN = 1, NSENSORS
                IF ( IPLATFORM .EQ.   PLATFORM(JN) .AND. &
                          ISAT .EQ.  SATELLITE(JN) .AND. &
                       INSTRUM .EQ. INSTRUMENT(JN)      ) THEN
                    call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,TOVERRST(ICHN,JN))
                ENDIF
             ENDDO

         ENDIF

  !***********************************************************************
  !                      RADIOSONDE DATA
  !***********************************************************************

        ELSE IF ( CFAM .EQ. 'UA' ) THEN

         ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)

         IF ( (ITYP .EQ. BUFR_NEUS) .OR. (ITYP .EQ. BUFR_NEVS) )THEN
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,4))
         ELSE IF (ITYP .EQ. BUFR_NETS) THEN
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,2))
         ELSE IF (ITYP .EQ. BUFR_NESS) THEN
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,3))
         ELSE IF (ITYP .EQ. BUFR_NEPS ) THEN
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,1))
         ELSE IF (ITYP .EQ. BUFR_NEPN ) THEN
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,1))
         ELSE

            if ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) ) then
              ielem = 4
            else if (ITYP .EQ. BUFR_NETT) then
              ielem = 2
            else if (ITYP .EQ. BUFR_NEES) then
              ielem = 3
            else if (ITYP .EQ. BUFR_NEGZ) then
              ielem = 5
            endif

            if ( (ZLEV*MPC_MBAR_PER_PA_R8) >= xstd_ua_ai_sw(1,1) ) then

               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_ua_ai_sw(1,ielem))

            else if ( (ZLEV*MPC_MBAR_PER_PA_R8) <= xstd_ua_ai_sw(19,1) ) then

               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_ua_ai_sw(19,ielem))

            else

               do jn = 1,18
                   if ( (ZLEV*MPC_MBAR_PER_PA_R8) >= xstd_ua_ai_sw(jn+1,1) ) exit
               end do

               zwb = log((ZLEV*MPC_MBAR_PER_PA_R8)/xstd_ua_ai_sw(JN,1)) / log(xstd_ua_ai_sw(JN+1,1)/xstd_ua_ai_sw(JN,1))
               zwt = 1.0D0 - zwb

               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,zwt*xstd_ua_ai_sw(JN,ielem) + zwb*xstd_ua_ai_sw(JN+1,ielem))

            endif

         ENDIF

  !***********************************************************************
  !                          AMV, AIREP, AMDAR DATA
  !***********************************************************************

        ELSE IF ( CFAM .EQ. 'AI'.OR. CFAM .EQ. 'SW') THEN

         ZLEV=obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)

         IF ( IDBURP .EQ. 188 ) THEN ! AMV
            if ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) ) then
               ielem = 11
            endif

         ELSE IF (IDBURP .EQ. 128 ) THEN ! AIREP
            if ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) ) then
               ielem = 7
            else if ( ITYP .EQ. BUFR_NETT ) then
               ielem = 6
            endif

         ELSE IF (IDBURP .EQ. 42 .OR. IDBURP .EQ. 157 .OR. IDBURP .EQ. 177) THEN ! AMDAR
            if ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) ) then
               ielem = 10
            else if ( ITYP .EQ. BUFR_NETT ) then
               ielem = 8
            else if ( ITYP .EQ. BUFR_NEES ) then
               ielem = 9
            endif

         ENDIF

         if ( (ZLEV*MPC_MBAR_PER_PA_R8) >= xstd_ua_ai_sw(1,1) ) then
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_ua_ai_sw(1,ielem))
         else if ( (ZLEV*MPC_MBAR_PER_PA_R8) <= xstd_ua_ai_sw(19,1) ) then
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_ua_ai_sw(19,ielem))
         else

            do jn = 1,18
               if ( (ZLEV*MPC_MBAR_PER_PA_R8) >= xstd_ua_ai_sw(jn+1,1) ) exit
            enddo

            zwb = log((ZLEV*MPC_MBAR_PER_PA_R8)/xstd_ua_ai_sw(JN,1)) / log(xstd_ua_ai_sw(JN+1,1)/xstd_ua_ai_sw(JN,1))
            zwt = 1.0D0 - zwb 

            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,zwt*xstd_ua_ai_sw(JN,ielem) + zwb*xstd_ua_ai_sw(JN+1,ielem))

         endif

  !***********************************************************************
  !                         SURFACE DATA
  !***********************************************************************

        ELSE IF ( CFAM .EQ. 'SF' ) THEN
                               icodtyp = 1   ! Default values
        IF ( IDBURP .EQ. 12  ) icodtyp = 2   ! SYNOP
        IF ( IDBURP .EQ. 13  ) icodtyp = 3   ! SHIP NON-AUTOMATIQUE
        IF ( IDBURP .EQ. 14  ) icodtyp = 4   ! DRIBU
        IF ( IDBURP .EQ. 18  ) icodtyp = 5   ! DRIFTER
        IF ( IDBURP .EQ. 145 ) icodtyp = 6   ! STATION AUTOMATIQUE
        IF ( IDBURP .EQ. 146 ) icodtyp = 7   ! ASYNOP
        IF ( IDBURP .EQ. 147 ) icodtyp = 8   ! ASHIP
        IF ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) .OR. &
             (ITYP .EQ. BUFR_NEGZ) .OR. (ITYP .EQ. BUFR_NETT) .OR. (ITYP .EQ. BUFR_NEES) ) icodtyp = 9  ! Others

        IF ( (ITYP .EQ. BUFR_NEUS) .OR. (ITYP .EQ. BUFR_NEVS) )THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,4))
        ELSE IF (ITYP .EQ. BUFR_NETS) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,2))
        ELSE IF (ITYP .EQ. BUFR_NESS) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,3))
        ELSE IF (ITYP .EQ. BUFR_NEPS ) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,1))
        ELSE IF (ITYP .EQ. BUFR_NEPN ) THEN
           if(icodtyp == 2  .or. icodtyp == 7) then
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(1,1))
           else
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,1))
           endif
        ELSE IF ( (ITYP .EQ. BUFR_NEUU) .OR. (ITYP .EQ. BUFR_NEVV) )THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,4))
        ELSE IF (ITYP .EQ. BUFR_NEGZ) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,1))
        ELSE IF (ITYP .EQ. BUFR_NETT) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,2))
        ELSE IF (ITYP .EQ. BUFR_NEES) THEN
           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(icodtyp,3))
        ENDIF

  !***********************************************************************
  !                             GPS RO DATA
  !***********************************************************************

        ELSE IF ( CFAM .EQ. 'RO' ) THEN
  !     
  !                 Process only refractivity data (codtyp 169)
  !
         IF ( obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER) .EQ. 169 ) THEN

            IF ( ITYP .EQ. BUFR_NEPS ) THEN
               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, 50.D0)
            ENDIF
            IF ( ITYP .EQ. BUFR_NETT) THEN
               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, 10.D0)
            ENDIF
            IF ( ITYP .EQ. BUFR_NERF) THEN
               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,1001.D0)
            ENDIF
            IF ( ITYP .EQ. BUFR_NEBD) THEN
               call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,1001.D0)
            ENDIF

         ENDIF

  !***********************************************************************
  !                          GB-GPS SFC MET DATA
  !***********************************************************************

  !              ERRORS ARE SET TO SYNO SFC OBS ERRORS FROM S/R SUCOVO
  !              AND WEIGHTED BY FACTOR YSFERRWGT FOR 3D-VAR FGAT OR 4D-VAR ASSIM.
  !              OF TIME-SERIES (YSFERRWGT = 1.0 FOR 3D THINNING) 
  !
        ELSE IF ( CFAM .EQ. 'GP' ) THEN

         IF ( ITYP .EQ. BUFR_NEPS ) THEN ! Psfc Error (Pa)
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(2,1))
         ENDIF
         IF ( ITYP .EQ. BUFR_NETS ) THEN ! Tsfc Error (K)
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(2,2))
         ENDIF
         IF ( ITYP .EQ. BUFR_NESS ) THEN ! T-Td Error (K)
            call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sf(2,3))
         ENDIF
         ! ZTD Error (m) (value is formal error, real error set later in s/r seterrgpsgb)
         ! If error is missing, set to dummy value (1 m).
         IF ( ITYP .EQ. BUFR_NEZD ) THEN
            IF (obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY) .LE. 0.0D0) call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, 1.0D0)
         ENDIF

  !***********************************************************************
  !        SCATTEROMETER AND WIND PROFILER DATA
  !***********************************************************************

        ELSE IF ( CFAM .EQ. 'SC' ) THEN

           call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_sc(1))

        ELSE IF ( CFAM .EQ. 'PR' ) THEN

          ZLEV= obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY) - obs_headElem_r(lobsSpaceData,OBS_ALT,INDEX_HEADER)

          IF ( ZLEV .GE. 6000. ) THEN
             call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_pr(2))
          ELSE
             call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,xstd_pr(1))
          ENDIF

 !***********************************************************************
 !               CONSTITUENT DATA (OZONE AND OTHER CHEMICALS)
 !***********************************************************************
 
        ELSE IF ( CFAM .EQ. 'TR' ) THEN
 !
 !        Process only retrieved constituent data
 !        Also, exclude 8090 element as a data value!
           
           IF (IDBURP .EQ. CODTYP_CHEMREMOTE .OR. &
                IDBURP .EQ. CODTYP_CHEMINSITU) THEN
         
             
             IF (IFIRST.EQ.0) THEN  
                IFIRST=1
               
                ! Subtract the number of occurances of code 8090 from number of levels
                do ji=0,nlev-1
                   if (obs_bodyElem_i(lobsSpaceData,OBS_VNM,IDATA+ji).eq.8090) then
                      nlev = nlev-1
                   end if
                end do
 
 !              Important: Combination of STNID, BUFR element and number of vertical levels
 !              to determine association to the observations.

 !              Find stnid with same number of vertical levels and same BUFR element.
 !              Note: * in cstd_stndi_tr stands for a wildcard
                
                ISTNID=0
                DO JN=1,nstd_stnid_tr

!                  First compare STNID values allowing for * and blanks in 
!                  cstd_stnid_tr(JN) as wildcards

                   ilen1=len_trim(cstd_stnid_tr(JN))
                   ilen2=len_trim(CSTNID)            
                   IF (ilen1.le.ilen2) THEN          
                       iset=1
                       DO ji=1,ilen1
                          IF (cstd_stnid_tr(JN)(ji:ji).ne.'*'.AND.   &
                             CSTNID(ji:ji).ne.cstd_stnid_tr(JN)(ji:ji)) THEN
                              iset=0
                              exit
                          END IF
                       END DO
                   END IF
                   
                   IF (iset.eq.1) THEN
                      IF (NLEV .EQ. nstd_lvl_tr(JN) .AND. &
                          ITYP .EQ. nstd_bfr_tr(JN) ) THEN
                         ISTNID=JN
                         exit
                      END IF
                   END IF 
                END DO

                IF (ISTNID.EQ.0) THEN
                   WRITE(*,'(1X,"Error std. dev. for STNID= ",A10," not found. Set to 5%.")') &
                         CSTNID
                ELSE
                   ! IF (nstd_brp_tr(ISTNID).NE.0) THEN
               
                      !   Read initial error standard deviations from obs BURP file.
                      !   Dimension must be equivalent to NLEV
                      ! ...
                   
                      ! sigma(:) = ...
                   
                   ! END IF

                   IF (nstd_lat_tr(ISTNID) .GT. 1) THEN

!                     Find latitude index for interpolation.
!                     Assuming increasing latitudes in xstd_lat_tr

                      ibegin=nstd_ibegin_tr(ISTNID)-1
                      IF (ZLAT .GE. xstd_lat_tr(ibegin+nstd_lat_tr(ISTNID))) THEN
                         JINT=nstd_lat_tr(ISTNID)+1
                      ELSE
                         DO JINT=1,nstd_lat_tr(ISTNID)
                            IF (ZLAT .LE. xstd_lat_tr(ibegin+JINT) ) exit
                         END DO
                      END IF
                                           
                   END IF
                END IF 
             END IF
            
!            Identify level if needed
                   
             IF (ISTNID .EQ. 0) THEN

!               Set error standard deviations as 5% default value.
                
                call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, &
                          0.05D0*ZVAL)
             
             ELSE
             
                IF (nstd_lvl_tr(ISTNID) .GT. 1) THEN
                  
!                  Find nearest vertical level (no interpolation)
                 
                   ZLEV  = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
                   zwb=1.E10
                   ibegin=nstd_ibegin_tr(ISTNID)-1
                   DO JN=1,nstd_lvl_tr(ISTNID)
                      IF (zwb .GT. abs(ZLEV-xstd_lvl_tr(ibegin+JN)) ) THEN
                         ILEV=JN
                         zwb=abs(ZLEV-xstd_lvl_tr(ibegin+JN))
                      END IF
                   END DO
                   ILEV=ibegin+(ILEV-1)*nstd_lat_tr(ISTNID)+1
                ELSE
                   ILEV=nstd_ibegin_tr(ISTNID)     
                END IF

                IF (nstd_lat_tr(ISTNID) .GT. 1) THEN
                
!                  Apply interpolation

                   ILEV=ILEV+JINT-1
                   ibegin=nstd_ibegin_tr(ISTNID)-1
                   IF (JINT.EQ.1.OR.JINT.GT.nstd_lat_tr(ISTNID)) THEN
                      wgt=xstd_std1_tr(ILEV)
                   ELSE
                      wgt=(xstd_std1_tr(ILEV-1)*(xstd_lat_tr(ibegin+JINT)-ZLAT)+ &
                           xstd_std1_tr(ILEV)*(ZLAT-xstd_lat_tr(ibegin+JINT-1)))/ &
                           (xstd_lat_tr(ibegin+JINT)-xstd_lat_tr(ibegin+JINT-1))
                   END IF                    
                ELSE
                    wgt=xstd_std1_tr(ILEV)                
                END IF 
                                         
                IF (nstd_brp_tr(ISTNID).EQ.0) THEN
               
!                  Set error standard deviations from scratch using content of
!                  previously read content of the "obsinfo_tr" file.
                
                   IF (nstd_type_tr(ISTNID).EQ. 0) THEN
                        call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY,wgt)
                   ELSE IF (nstd_type_tr(ISTNID).EQ. 1) THEN
                        call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, &
                             min(xstd_std3_tr(ISTNID),                         &
                             max(xstd_std2_tr(ISTNID),wgt*ZVAL)))
                   ELSE IF (nstd_type_tr(ISTNID) .EQ. 2) THEN
                        call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, &
                             sqrt(xstd_std2_tr(ISTNID)**2+(wgt*ZVAL)**2))
                   ELSE 
                        IF (INDEX_BODY.EQ.IDATA)  &
                           WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
                                  nstd_type_tr(ISTNID) , CSTNID
                   END IF

                ELSE
          
!                  Adjust error standard deviations read from BURP file if requested.
                     
                   IF (nstd_type_tr(ISTNID).EQ. 0) THEN
                        call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, &
                             sigma(INDEX_BODY-IDATA+1))
                   ELSE IF (nstd_type_tr(ISTNID).EQ. 1) THEN
                        call obs_bodySet_r(lobsSpaceData,OBS_OER,INDEX_BODY, &
                             max(xstd_std2_tr(ISTNID),wgt*sigma(INDEX_BODY-IDATA+1)))
                   ELSE 
                        IF (INDEX_BODY.EQ.IDATA)  &
                            WRITE(*,'(1X,"EOR setup type ",I3," for STNID ",A10," is not recognized.")')     &
                                    nstd_type_tr(ISTNID) , CSTNID
                   END IF
                END IF   
              
             END IF
          END IF
          
        ELSE

           WRITE(*,*)' UNKNOWN DATA FAMILY:',CFAM

        ENDIF

  !***********************************************************************
  !              Check for case where error should have been set but was
  !              not. 3dvar will abort in this case.
  !***********************************************************************

        IF (obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY) .LE. 0.0D0) THEN

          WRITE(*,*)'  PROBLEM OBSERR VARIANCE FAM= ',CFAM

          WRITE(*,'(1X,"STNID= ",A10,"IDBURP= ",I5," LAT= ",F10.2," LON = ",F10.2)') &
             obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER),    &
               IDBURP,                                           &
               ZLAT*MPC_DEGREES_PER_RADIAN_R8,                   &
               ZLON*MPC_DEGREES_PER_RADIAN_R8

          WRITE(*,'(1X,"ELEMENT= ",I6," LEVEL= ",F10.2," OBSERR = ",E10.2)')         &
               ITYP,                                             &
               obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY), &
               obs_bodyElem_r(lobsSpaceData,OBS_OER,INDEX_BODY)

          CALL ABORT3D('oer_fill_obs_erreurs: PROBLEM OBSERR VARIANCE.')

        ENDIF

      ENDIF ! end of IASS .EQ. 1

    END DO ! end of INDEX_BODY loop 

  END DO ! end of INDEX_HEADER loop

  WRITE(*,'(10X,"Fill_obs_errors")')
  WRITE(*,'(10X,"---------------",/)')

  end subroutine oer_fill_obs_erreurs

!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------

  subroutine oer_dealloc_obs_erreurs
  !
  ! s/r oer_dealloc_obs_erreurs - Deallocate temporary storage space.
  !
  ! Author  : Y. Rochon  Nov 2014
  ! Revision: 
  !
  ! Purpose: Deallocate temporary storage space.
  !
  !---------------------------------------------------------------------------------------
  
  !
  ! Deallocate temporary space used for the TR family
  !
  if (nstd_stnid_tr.gt.0) then
      deallocate(cstd_stnid_tr)
      deallocate(nstd_lvl_tr,nstd_type_tr,nstd_ibegin_tr)
      deallocate(nstd_bfr_tr,nstd_brp_tr,nstd_lat_tr)
      deallocate(xstd_std1_tr,xstd_std2_tr,xstd_std3_tr)
      deallocate(xstd_lvl_tr,xstd_lat_tr)
  end if
  
  end subroutine oer_dealloc_obs_erreurs

!-----------------------------------------------------------------------------------------



end module observation_erreurs_mod
