!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------


!--------------------------------------------------------------------------
! MODULE innovation_mod,(prefix="inn")
!
! Purpose: 
!
! Subroutines:
!
! Dependencies:
!    none
!--------------------------------------------------------------------------
module innovation_mod
  use mpi_mod
  use topLevelControl_mod
  use obsSpaceData_mod
  use columnData_mod
  use timeCoord_mod
  use obsOperators_mod
  use topLevelControl_mod
  use EarthConstants_mod
  use MathPhysConstants_mod
  use mpivar_mod
  use horizontalCoord_mod
  use columnData_mod 
  use gridStateVector_mod
  use WindRotation_mod
  use tt2phi_mod
  use utilities_mod
  use obsFilter_mod  
  use gps_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use multi_ir_bgck_mod
  use burpFiles_mod
  implicit none
  save
  private

  ! public procedures
  public :: inn_setupObs, inn_setupBackgroundColumns, inn_computeInnovation

contains

  !--------------------------------------------------------------------------
  ! inn_setup
  !--------------------------------------------------------------------------
  SUBROUTINE INN_SETUPOBS(obsSpaceData,obsColumnMode,obsMpiStrategy)
    !
    !**s/r INN_SETUPOBS  - Initialisation of observation parameters and constants
    !
    IMPLICIT NONE

    type(struct_obs) :: obsSpaceData
    character(len=*) :: obsMpiStrategy
    character(len=*) :: obsColumnMode
    integer :: get_max_rss

    WRITE(*,FMT=9000)
9000 FORMAT(/,1x,' INN_SETUPOBS - Initialisation of observations',/,1x,3('- -----------'))

    !
    ! Specify the active observation-array columns
    !
    call obs_class_initialize(obsColumnMode)
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    !
    ! Allocate memory for observation arrays
    !
    call obs_initialize(obsSpaceData,mpi_local=top_BurpSplit() )
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    !
    ! Read the NAMELIST NAMGGPSRO
    !
    call gps_setupro
    !
    ! Initialize GB-GPS processing (read NAMGPSGB in namelist file)
    !
    call gps_setupgb
    !
    ! Initialize TOVS processing
    !
    call tovs_setup
    !
    ! Set up the list of elements to be assimilated and flags for rejection
    !
    call filt_setup

    call tmg_start(11,'READ_BURP')
    CALL burp_readFiles(obsSpaceData)
    call tmg_stop(11)

    !
    ! Filter out data from CMA
    !
    call tmg_start(14,'SUPREP')
    call filt_sethind(obsSpaceData)
    call filt_suprep(obsSpaceData)
    call tmg_stop(14)

    !
    ! set OBS_IPC and OBS_IPT columns according to the chosen strategy
    !
    write(*,*)
    write(*,*) 'INN_SETUPOBS - Using obsMpiStrategy = ', trim(obsMpiStrategy)
    call setObsMpiStrategy(obsSpaceData,obsMpiStrategy)

    !
    ! Check env variable ARMA_BURP_SPLIT to know if burp files already split
    !
    if ( top_BurpSplit() ) then 
       ! local observations files, so just do reallocation to reduce memory used
       call obs_squeeze(obsSpaceData)
       call obs_MpiRedistribute(obsSpaceData,OBS_IPC)
       write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    else
       ! global observations files so have to localize them for each MPI process
       ! NOTE: not currently supported, but may be useful for future versions
       call obs_reduceToMpiLocal(obsSpaceData)
    end if

    !
    !- Memory allocation for TOVS processing
    !
    call tovs_nl_setupallo(obsSpaceData)
    if ( top_BgckIrMode() ) call BGCK_IR_SETUP(obsSpaceData)
    if ( top_AnalysisMode() ) call tovs_lin_setupallo()

  END SUBROUTINE INN_SETUPOBS

  subroutine inn_setupBackgroundColumns(columng,columnhr,lobsSpaceData)
    !
    ! Purpose: Fill in COLUMNG and COLUMNHR with trial profiles
    !
    ! Arguments: COLUMNG, COLUMNHR
    !
    implicit none

    type(struct_columnData) :: columng,columnhr
    type(struct_obs) :: lobsSpaceData
    type(struct_vco), pointer :: vco_anl, vco_trl
    type(struct_hco), pointer :: hco_anl

    integer ezgprm,fnom,fclos,fstouv,fstfrm
    integer ezsetopt,gdxyfll, gdllfxy
    integer jlev,jobs,ierr,iset,jstep,jlatlontile
    integer ini, inj,ink,iig1,iig2,iig3,iig4,jvar
    integer itrlnlev
    integer idata,idatend,jdata

    character*1 clgrtyp
    character*2 cltypvar
    character*12 cletiket
    real*8, allocatable :: varInterphr_T(:,:),varInterphr_M(:,:),varInterphr_VV(:,:)
    integer ip1_pak_trl,ip1_vco_trl
    integer nlv_T,nlv_M
    integer, parameter :: jpnflev = 200
    integer itrlgid,iip1s(jpnflev),iip2,iip3
    integer, allocatable :: idate(:),itime(:)
    integer :: newdate,nstepanltime
    integer, allocatable :: nobsgid(:) ! (nstepobs) grid id for ezscint corresponding to stepobs bin
    integer, allocatable :: notag(:,:) ! (nobtot,nstepobs) obs tag associated to observations of each bin
    integer, allocatable :: nobs(:),nobs_maxmpiglobal(:) ! number of headers for each stepobs bin
    integer, allocatable :: nobsgid_mpiglobal(:,:),nobs_mpiglobal(:,:)
    integer, allocatable :: datestamplist(:)
    integer :: numColumn_maxmpiglobal

    real :: lat_r4, lon_r4, lat_deg_r4, lon_deg_r4, xpos_r4, ypos_r4, xposLowerBoundAnl_r4, xposUpperBoundAnl_r4
    real*8 :: lat_r8,lon_r8, ypos_r8, xpos_r8, lat_rot, lon_rot

    character(len=2) :: flnum
    character(len=128) :: trialfile
    character(len=4) :: varnameForGetfldprm2

    integer, allocatable :: nultrl(:)
    integer :: nultrl2

    logical :: trialExists, noUpperGZ

    real*8  :: zig1,zig2,zig3,zig4,stepObsIndex
    real*8, allocatable ::  dlonfld(:), dlatfld(:)
    real*8, allocatable ::  dlonfld_mpiglobal(:,:), dlatfld_mpiglobal(:,:)

    integer :: ig1obs,ig2obs,ig3obs,ig4obs
    integer :: status,Vcode_trl,Vcode_anl

    real*8, pointer :: column_ptr(:) => null()
    integer :: get_max_rss

    write(*,*) ' '
    write(*,*) '-------- ENTERING INN_SETUPBACKGROUNDCOLUMNS ---------'
    write(*,*) ' '
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    if (mpi_myid.eq.0) write(*,*) 'nstepobs=',tim_nstepobs
    call tmg_start(10,'INN_SETUPBACKGROUNDCOLUMNS')

    !
    !     Ensure that all trial field files exist and
    !     open all trial field files (assume 1 file per time step)
    !
    allocate(nultrl(tim_nStepObs))
    nultrl(:)=0
    do jstep = 1, tim_nStepObs
       write(flnum,'(I2.2)') jstep
       trialfile='./trlm_'//trim(flnum)
       inquire(file=trim(trialfile),exist=trialExists)
       if (.not.trialExists) then
          write(*,*) 'File missing=',trialfile
          call varAbort('INN_SETUPBACKGROUNDCOLUMNS:DID NOT FIND A TRIAL FIELD FILE')
       else
          ierr=fnom(nultrl(jstep),trim(trialfile),'RND+OLD+R/O',0)
          ierr=fstouv(nultrl(jstep),'RND+OLD')
          write(*,*) 'ITRIAL - File :', trialfile
          write(*,*) ' opened as unit file ',nultrl(jstep)
       end if
    enddo

    !
    !     Vertical coordinate parameters 
    !
    vco_anl => col_getVco(columng)
    vco_trl => col_getVco(columnhr)
    nlv_M = vco_getNumLev(vco_trl,'MM')
    nlv_T = vco_getNumLev(vco_trl,'TH')
    if (mpi_myid.eq.0) write(*,*)'INN_SETUPBACKGROUNDCOLUMNS:niv thermo:',nlv_T,' momentum',nlv_M

    if ( top_spatialDimensions() /= '2D') then
       status = vgd_get(vco_trl%vgrid,key='ig_1 - vertical coord code',value=Vcode_trl)
       status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Vcode_trl= ',Vcode_trl, &
            '  Vcode_anl= ',Vcode_anl
       if (Vcode_trl.ne.5002.and.Vcode_trl.ne.5005) &
            call varAbort('INN_SETUPBACKGROUNDCOLUMNS: invalid vertical coord for background state!')
       if (Vcode_anl.ne.5002.and.Vcode_anl.ne.5005) &
            call varAbort('INN_SETUPBACKGROUNDCOLUMNS: invalid vertical coord for analysis increment!')
    else
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: skipping vcode check because this is a 2D spatial configuration'
    end if

    !
    !     Compute the maximum number of columns over all processors (lat-lon tiles)
    !
    call rpn_comm_allreduce(col_getNumCol(columng),numColumn_maxmpiglobal,1,  &
         "MPI_INTEGER","MPI_MAX","GRID",ierr)

    !
    !     Allocate trial field column object and other local arrays
    !
    if (col_getNumCol(columng).gt.0) then
       allocate(notag(col_getNumCol(columng),tim_nStepObs))
       allocate(varInterphr_T(nlv_T,col_getNumCol(columng)))
       allocate(varInterphr_M(nlv_M,col_getNumCol(columng)))
       allocate(varInterphr_VV(nlv_M,col_getNumCol(columng)))
       varInterphr_T(:,:)=0.0d0
       varInterphr_M(:,:)=0.0d0
       varInterphr_VV(:,:)=0.0d0
    endif

    allocate(dlonfld(numColumn_maxmpiglobal))
    allocate(dlatfld(numColumn_maxmpiglobal))
    allocate(dlonfld_mpiglobal(numColumn_maxmpiglobal,mpi_nprocs))
    allocate(dlatfld_mpiglobal(numColumn_maxmpiglobal,mpi_nprocs))
    allocate(nobsgid(tim_nStepObs))
    allocate(nobs(tim_nStepObs))
    allocate(nobs_maxmpiglobal(tim_nStepObs))
    allocate(datestamplist(tim_nStepObs))
    allocate(idate(tim_nStepObs))
    allocate(itime(tim_nStepObs))
    allocate(nobsgid_mpiglobal(tim_nStepObs,mpi_nprocs))
    allocate(nobs_mpiglobal(tim_nStepObs,mpi_nprocs))

    !
    !     Computing date and time of step obs for error message
    !
    call tim_getstamplist(datestamplist,tim_nStepObs,tim_getDatestamp())
    do jstep = 1,tim_nStepObs
       ierr = newdate(datestamplist(jstep),idate(jstep),itime(jstep),-3)
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: datestamplist=',jstep,datestamplist(jstep)
       if (datestamplist(jstep) == tim_getDatestamp()) nstepanltime = jstep
    end do

    !
    !     Setting degree of horizontal interpolations
    !
    ierr = ezsetopt('INTERP_DEGREE', 'LINEAR')
    !ierr = ezsetopt('INTERP_DEGREE', 'NEAREST')

    !
    !-    Get the Analysis Grid structure
    !
    hco_anl => hco_Get('Analysis')

    if ( hco_anl % global ) then
       xposLowerBoundAnl_r4 = - huge(1.0) ! no limit since grid is global (periodic)
       xposUpperBoundAnl_r4 = + huge(1.0) ! no limit since grid is global (periodic)
    else
       xposLowerBoundAnl_r4 = 1.0
       xposUpperBoundAnl_r4 = real(hco_anl % ni)
    end if

    !
    !     The following code replaces the subroutine suobsgid
    !
    nobs(:) = 0
    varnameForGetfldprm2='NONE'
    do jvar=1,vnl_numvarmax2D
       if (gsv_varExist(varName=vnl_varNameList2D(jvar))) then
          varnameForGetfldprm2=vnl_varNameList2D(jvar)
          exit
       end if
    end do
    if (trim(varnameForGetfldprm2) == 'NONE' ) then
       do jvar=1,vnl_numvarmax3D
          if (gsv_varExist(varName=vnl_varNameList3D(jvar))) then
             varnameForGetfldprm2=vnl_varNameList3D(jvar)
             exit
          end if
       end do
    end if

    if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: varname for getfldprm2 =',trim(varnameForGetfldprm2)

    do jstep = 1,tim_nStepObs
       !
       !- Get horizontal grid parameters to be used to test grid bounds
       !
       call utl_getfldprm(IIP1S,IIP2,IIP3,ITRLNLEV,CLETIKET,CLTYPVAR,  &
            ITRLGID,trim(varnameForGetfldprm2),datestamplist(jstep),jpnflev,  &
            nultrl(:),ip1_pak_trl,ip1_vco_trl,tim_nStepObs,  &
            nultrl2)
       if (itrlnlev <= 0 ) then
          call varAbort('INN_SETUPBACKGROUNDCOLUMNS:Problem with background file')
       end if
       ierr = ezgprm(itrlgid,clgrtyp,ini,inj,iig1,iig2,iig3,iig4)

       dlonfld(:)=0.0d0
       dlatfld(:)=0.0d0

       do jobs=1, obs_numheader(lobsSpaceData)

          call tim_getStepObsIndex(stepObsIndex,tim_getDatestamp(),  &
               obs_headElem_i(lobsSpaceData,OBS_DAT,jobs),  &
               obs_headElem_i(lobsSpaceData,OBS_ETM,jobs),tim_nstepobs)

          ! check if obs is outside of assimilation window when jstep = 1
          if (jstep.eq.1 .and.  &
               (stepobsIndex.lt.1.0 .or. stepObsIndex.gt.real(tim_nstepobs,8)) ) then
             write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Observation time outside assimilation window: ',  &
                  obs_headElem_i(lobsSpaceData,OBS_DAT,jobs),obs_headElem_i(lobsSpaceData,OBS_ETM,jobs)

             ! put the obs in the first time bin (it has to go somewhere!)
             stepObsIndex=1.0d0

             ! flag it as out of time domain and turn off its assimilation flag
             idata = obs_headElem_i(lobsSpaceData,OBS_RLN,jobs)
             idatend = obs_headElem_i(lobsSpaceData,OBS_NLV,jobs) + idata -1
             do jdata = idata, idatend
                call obs_bodySet_i(lobsSpaceData,OBS_ASS,JDATA, 0)
             end do
             call obs_headSet_i(lobsSpaceData,OBS_ST1,jobs,  &
                  ibset( obs_headElem_i(lobsSpaceData,OBS_ST1,jobs), 05))
          end if

          if ( nint(stepObsIndex) == jstep ) then

             nobs(jstep) = nobs(jstep) + 1
             notag(nobs(jstep),jstep) = jobs

             !- Get LatLon of observation location
             lat_r8=obs_headElem_r(lobsSpaceData,OBS_LAT,jobs)
             lon_r8=obs_headElem_r(lobsSpaceData,OBS_LON,jobs)
             lat_r4=real(lat_r8)
             lon_r4=real(lon_r8)
             if (lon_r4.lt.0.0         ) lon_r4 = lon_r4 + 2.0*MPC_PI_R4
             if (lon_r4.ge.2.*MPC_PI_R4) lon_r4 = lon_r4 - 2.0*MPC_PI_R4

             lat_deg_r4=lat_r4 * MPC_DEGREES_PER_RADIAN_R4 ! Radian To Degree
             lon_deg_r4=lon_r4 * MPC_DEGREES_PER_RADIAN_R4

             !
             !- Find the position in the analysis grid
             !
             ierr = gdxyfll( hco_anl % EZscintID, xpos_r4, ypos_r4, &
                  lat_deg_r4, lon_deg_r4, 1)

             !- Test if the obs is outside the analysis grid
             if ( xpos_r4 < xposLowerBoundAnl_r4  .or. &
                  xpos_r4 > xposUpperBoundAnl_r4  .or. &
                  ypos_r4 < 1.0                   .or. &
                  ypos_r4 > real(hco_anl % nj) ) then

                if ( hco_anl % global ) then
                   ! Modify latitude if we have an observation at or near the poles
                   write(*,*) ''
                   write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Moving OBS inside the GLOBAL ANALYSIS grid, ', jobs
                   write(*,*) '  true position : ', lat_deg_r4, lon_deg_r4, ypos_r4, xpos_r4

                   !- Move the observation to the nearest grid point
                   if ( ypos_r4 < 1.0 )                ypos_r4 = 1.0
                   if ( ypos_r4 > real(hco_anl % nj) ) ypos_r4 = real(hco_anl % nj)

                   ierr = gdllfxy( hco_anl % EZscintID, &    ! IN
                        lat_deg_r4, lon_deg_r4, & ! OUT
                        xpos_r4, ypos_r4, 1)      ! IN

                   write(*,*) '  new  position : ', lat_deg_r4, lon_deg_r4, ypos_r4, xpos_r4

                   lat_r8 = real(lat_deg_r4,8) * MPC_RADIANS_PER_DEGREE_R8
                   lon_r8 = real(lon_deg_r4,8) * MPC_RADIANS_PER_DEGREE_R8
                   call obs_headSet_r(lobsSpaceData,OBS_LAT,jobs, lat_r8) ! IN
                   call obs_headSet_r(lobsSpaceData,OBS_LON,jobs, lon_r8) ! IN

                else
                   ! The observation is outside the domain
                   ! In LAM Analysis mode we must discard this observation
                   write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Rejecting OBS outside the LAM ANALYSIS grid domain, ', jobs
                   write(*,*) '  position : ', lat_deg_r4, lon_deg_r4, ypos_r4, xpos_r4

                   idata   = obs_headElem_i(lobsSpaceData,OBS_RLN,jobs)
                   idatend = obs_headElem_i(lobsSpaceData,OBS_NLV,jobs) + idata -1
                   do jdata = idata, idatend
                      call obs_bodySet_i(lobsSpaceData,OBS_ASS,JDATA, 0)
                   end do
                   call obs_headSet_i(lobsSpaceData,OBS_ST1,jobs,  &
                        ibset( obs_headElem_i(lobsSpaceData,OBS_ST1,jobs), 05))
                end if

             end if

             !- Convert to rotated grid if needed
             if (hco_anl % rotated) then
                call uvr_RotateLatLon( lat_rot, lon_rot,       & ! OUT (radians)
                     lat_r8,                 & ! IN  (radians)
                     lon_r8,                 & ! IN  (radians)
                     'ToLatLonRot')            ! IN
             else
                lat_rot = lat_r8
                lon_rot = lon_r8
             end if

             !- Store the above 3 pairs of values in column structure
             ypos_r8 = real(ypos_r4,8)
             xpos_r8 = real(xpos_r4,8)
             call col_setLatLon( columng , jobs, lat_r8, lon_r8,   & ! IN
                  ypos_r8, xpos_r8, lat_rot, lon_rot ) ! IN
             call col_setLatLon( columnhr, jobs, lat_r8, lon_r8,   & ! IN
                  ypos_r8, xpos_r8, lat_rot, lon_rot ) ! IN

             !
             !- Find the position in the trial field grid
             !
             ierr=gdxyfll(itrlgid, xpos_r4, ypos_r4, lat_deg_r4, lon_deg_r4, 1)

             if ( xpos_r4 >= 1.0 .and. xpos_r4 <= real(ini) .and.  &
                  ypos_r4 >= 1.0 .and. ypos_r4 <= real(inj) ) then

                dlonfld(nobs(jstep)) = lon_r8
                dlatfld(nobs(jstep)) = lat_r8
                if (dlonfld(nobs(jstep)).lt.0.0d0)  &
                     dlonfld(nobs(jstep)) = dlonfld(nobs(jstep)) +  &
                     2*MPC_PI_R8
                if (dlonfld(nobs(jstep)).ge.2.0d0*MPC_PI_R8)  &
                     dlonfld(nobs(jstep)) =dlonfld(nobs(jstep)) -  &
                     2*MPC_PI_R8
                dlonfld(nobs(jstep))=dlonfld(nobs(jstep))*MPC_DEGREES_PER_RADIAN_R8
                dlatfld(nobs(jstep))=dlatfld(nobs(jstep))*MPC_DEGREES_PER_RADIAN_R8

             else
                ! The observation is outside the domain
                ! With a LAM trial field we must discard this observation
                write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Rejecting OBS outside the TRIAL field domain, ', jobs
                write(*,*) '  position : ', lat_deg_r4, lon_deg_r4, ypos_r4, xpos_r4

                idata   = obs_headElem_i(lobsSpaceData,OBS_RLN,jobs)
                idatend = obs_headElem_i(lobsSpaceData,OBS_NLV,jobs) + idata -1
                do jdata = idata, idatend
                   call obs_bodySet_i(lobsSpaceData,OBS_ASS,JDATA, 0)
                end do
                call obs_headSet_i(lobsSpaceData,OBS_ST1,jobs,  &
                     ibset( obs_headElem_i(lobsSpaceData,OBS_ST1,jobs), 05))

                ! However, we must assigned a realistic lat-lon to this point
                ! to avoid problem later in Hx computation.
                ierr=gdllfxy(itrlgid, lat_deg_r4, lon_deg_r4, real(ini)/2.0,  &
                     real(inj)/2.0, 1) ! Middle of the domain
                dlonfld(nobs(jstep)) = real(lon_deg_r4,8)
                dlatfld(nobs(jstep)) = real(lat_deg_r4,8)
             end if

          end if
       end do ! jobs

       ! gather and compute the max number of obs over all processors for each timestep
       call rpn_comm_allreduce(nobs(jstep),nobs_maxmpiglobal(jstep),1,  &
            "MPI_INTEGER","MPI_MAX","GRID",ierr)
       call rpn_comm_allgather(nobs(jstep),1,"mpi_integer",       &
            nobs_mpiglobal(jstep,:),1,"mpi_integer", &
            "GRID",ierr)
       ! gather lon-lat of observations from all processors
       call rpn_comm_allgather(dlonfld,numColumn_maxmpiglobal,"mpi_double_precision",       &
            dlonfld_mpiglobal,numColumn_maxmpiglobal,"mpi_double_precision", &
            "GRID",ierr)
       call rpn_comm_allgather(dlatfld,numColumn_maxmpiglobal,"mpi_double_precision",       &
            dlatfld_mpiglobal,numColumn_maxmpiglobal,"mpi_double_precision", &
            "GRID",ierr)

       zig1 = 0.0D0
       zig2 = 0.0D0
       zig3 = 1.0D0
       zig4 = 1.0D0
       call utl_cxgaig('L',ig1obs,ig2obs,ig3obs,ig4obs,zig1,zig2,zig3,zig4)

       do jlatlontile = 1,mpi_nprocs
          if (nobs_mpiglobal(jstep,jlatlontile).gt.0) then
             nobsgid_mpiglobal(jstep,jlatlontile) = utl_ezgdef(nobs_mpiglobal(jstep,jlatlontile),  &
                  1,'Y','L',ig1obs,ig2obs,ig3obs,ig4obs,  &
                  dlonfld_mpiglobal(1:nobs_mpiglobal(jstep,jlatlontile),jlatlontile),  &
                  dlatfld_mpiglobal(1:nobs_mpiglobal(jstep,jlatlontile),jlatlontile))
          else
             !write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: NO OBS found for this time/lat bin =',jstep,jlatlontile
             nobsgid_mpiglobal(jstep,jlatlontile) = -999
          end if
       end do

    end do ! jstep

    !
    !     reading 2D fields
    !
    do jvar=1,vnl_numvarmax2D
       if (.not.gsv_varExist(varName=vnl_varNameList2D(jvar))) cycle

       call readTrialField(varInterphr_M,varInterphr_VV,vnl_varNameList2D(jvar),'SF')

       if (col_getNumCol(columng).gt.0) then       
          if (vnl_varNameList2D(jvar).eq.'P0  ') then
             varInterphr_M(:,:)=varInterphr_M(:,:)*MPC_PA_PER_MBAR_R8
          endif
          call col_fillmvo(columng ,varInterphr_M,vnl_varNameList2D(jvar))
          call col_fillmvo(columnhr,varInterphr_M,vnl_varNameList2D(jvar))
       endif

    enddo

    !
    !     Derive the pressure fields at observation points from the hybrid
    !     levels, the hybrid coordinate parameters of the
    !     analysis increment and the surface pressure of the trial field
    !      
    if (col_getNumCol(columng).gt.0 .and. top_spatialDimensions() /= '2D') then

       call col_calcPressure(columng)

       do jlev = 1,col_getNumLev(columng,'MM')
          if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: jlev, col_getPressure(COLUMNG,jlev,1,MM) = ',  &
               jlev,col_getPressure(COLUMNG,jlev,1,'MM')
       end do

       !     Calculate profiles of pressure values at station location


       !     Compute Pressure fields at desired trial field levels
       call col_calcPressure(columnhr)

       do jlev = 1,col_getNumLev(columnhr,'MM')
          if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: jlev, col_getPressure(COLUMNHR,jlev,1,MM) = ',  &
               jlev,col_getPressure(columnhr,jlev,1,'MM')
       end do
       do jlev = 1,col_getNumLev(columnhr,'TH')
          if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: jlev, col_getPressure(COLUMNHR,jlev,1,TH) = ',  &
               jlev,col_getPressure(columnhr,jlev,1,'TH')
       end do
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: surface Pressure=',col_getElem(columnhr,1,1,'P0')

    end if

    !      
    !     Variable GZ qui se trouve sur les niveaux momentum et thermodynamiques
    !
    write(*,*)' ----- Initializing GZ ----'

    !
    !     Lire les GZ des niveaux Momentum
    !
    call readTrialField(varInterphr_M,varInterphr_VV,'GZ  ','MM',noUpperGZ)

    if (col_getNumCol(columng).gt.0) then       
       varInterphr_M(:,:)=varInterphr_M(:,:)*10.0d0*RG
       call col_fillmvo(columnhr,varInterphr_M,'GZ  ','MM')
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS:GZ_M'
       do jlev = 1,nlv_M
          if (mpi_myid.eq.0) write(*,*) 'GZ,',jlev,varInterphr_M(jlev,1)
       enddo
    endif

    !
    !     Lire les GZ des niveaux Thermodynamique
    !
    call readTrialField(varInterphr_T,varInterphr_VV,'GZ  ','TH',noUpperGZ)

    if (col_getNumCol(columng).gt.0) then       
       varInterphr_T(:,:)=varInterphr_T(:,:)*10.0d0*RG
       call col_fillmvo(columnhr,varInterphr_T,'GZ  ','TH')
       if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS:GZ_TH'
       do jlev = 1,nlv_T
          if (mpi_myid.eq.0) write(*,*)'GZ,',jlev,varInterphr_T(jlev,1)
       enddo
    endif

    !
    !     Now all of the other 3D variables
    !
    do jvar=1, vnl_numvarmax3D

       if (.not.gsv_varExist(varName=vnl_varNameList3D(jvar))) cycle

       select case ( vnl_varNameList3D(jvar) )
          !
          !       Variables sur les niveaux momentum
          !
       case ('UU')
          write(*,*)' ----- Initializing UU and VV  ----'

          call readTrialField(varInterphr_M,varInterphr_VV,'UV  ','MM')

          if (col_getNumCol(columng).gt.0) then       

             if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: UU ,nlev= ',nlv_M
             do jlev = 1,nlv_M
                if (mpi_myid.eq.0) write(*,*) 'UU',jvar,jlev,varInterphr_M(jlev,1)
             enddo
             if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: VV ,nlev= ',nlv_M
             do jlev = 1,nlv_M
                if (mpi_myid.eq.0) write(*,*) 'VV',jvar,jlev,varInterphr_VV(jlev,1)
             enddo

             call col_fillmvo(columnhr,varInterphr_M,'UU  ')
             call col_fillmvo(columnhr,varInterphr_VV,'VV  ')
             call col_vintprof(columnhr,columng,'UU')
             call col_vintprof(columnhr,columng,'VV')

             ! conversion from knots to m/s
             do jobs=1,col_getNumCol(columng)
                column_ptr => col_getColumn(columnhr,jobs,'UU')
                do jlev=1,col_getNumLev(columnhr,'MM')
                   column_ptr(jlev)=column_ptr(jlev)*MPC_M_PER_S_PER_KNOT_R8
                enddo
                column_ptr => col_getColumn(columnhr,jobs,'VV')
                do jlev=1,col_getNumLev(columnhr,'MM')
                   column_ptr(jlev)=column_ptr(jlev)*MPC_M_PER_S_PER_KNOT_R8
                enddo
                column_ptr => col_getColumn(columng,jobs,'UU')
                do jlev=1,col_getNumLev(columng,'MM')
                   column_ptr(jlev)=column_ptr(jlev)*MPC_M_PER_S_PER_KNOT_R8
                enddo
                column_ptr => col_getColumn(columng,jobs,'VV')
                do jlev=1,col_getNumLev(columng,'MM')
                   column_ptr(jlev)=column_ptr(jlev)*MPC_M_PER_S_PER_KNOT_R8
                enddo
             enddo

          endif

          !
          !       Variable sur les niveaux thermodynamiques
          !
       case ('TT','HU')
          write(*,*)' ----- Initializing ',vnl_varNameList3D(jvar),' ----'

          call readTrialField(varInterphr_T,varInterphr_VV,vnl_varNameList3D(jvar),'TH')

          if (col_getNumCol(columng).gt.0) then       

             if (mpi_myid.eq.0) write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS:',vnl_varNameList3D(jvar)
             do jlev = 1,nlv_T
                if (mpi_myid.eq.0) write(*,*) trim(vnl_varNameList3D(jvar)),',',jlev,varInterphr_T(jlev,1)
             enddo

             call col_fillmvo(columnhr,varInterphr_T,vnl_varNameList3D(jvar))
             if (top_spatialDimensions() /= '2D') then
                call col_vintprof(columnhr,columng,vnl_varNameList3D(jvar))
             else
                ! Do not try interpolate: In 2D mode trial and analysis are on the same level by construction
                call col_vintprof(columnhr,columng,vnl_varNameList3D(jvar),noInterp=.true.)
             end if

             if (vnl_varNameList3D(jvar).eq.'TT  ') then
                ! conversion from Celcius to Kelvin
                do jobs=1,col_getNumCol(columng)
                   column_ptr => col_getColumn(columnhr,jobs,'TT')
                   do jlev=1,col_getNumLev(columnhr,'TH')
                      column_ptr(jlev)=column_ptr(jlev)+MPC_K_C_DEGREE_OFFSET_R8
                   enddo
                   column_ptr => col_getColumn(columng,jobs,'TT')
                   do jlev=1,col_getNumLev(columng,'TH')
                      column_ptr(jlev)=column_ptr(jlev)+MPC_K_C_DEGREE_OFFSET_R8
                   enddo
                enddo
             elseif (vnl_varNameList3D(jvar).eq.'HU  ') then
                ! conversion from specific humidity to log(humidity)
                do jobs=1,col_getNumCol(columng)
                   column_ptr => col_getColumn(columnhr,jobs,'HU')
                   do jlev=1,col_getNumLev(columnhr,'TH')
                      column_ptr(jlev)=log(max(column_ptr(jlev),rhumin))
                   enddo
                   column_ptr => col_getColumn(columng,jobs,'HU')
                   do jlev=1,col_getNumLev(columng,'TH')
                      column_ptr(jlev)=log(max(column_ptr(jlev),rhumin))
                   enddo
                enddo
             endif

          endif

       end select
    enddo

    !
    !- Initialisation of TLM operators
    !
    if (top_spatialDimensions() /= '2D') call subasic_obs(columng)

    !
    !- Using T, q and PS to compute GZ for columng
    !
    do jobs = 1, col_getNumCol(columng)
       call col_setMountain(columng ,jobs,col_getMountain(columnhr,jobs))
    enddo
    if (top_spatialDimensions() /= '2D') call tt2phi(columng)

    !
    !- Using T, q and PS to compute GZ for columnhr
    !
    if (noUpperGZ .and. top_spatialDimensions() /= '2D') then
       write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: No upper level GZ found, computing'
       call tt2phi(columnhr)
    endif

    !
    !- Close the files
    !
    do jstep=1,tim_nStepObs
       ierr=fstfrm(nultrl(jstep))  
       ierr=fclos(nultrl(jstep))  
    enddo

    !
    !- Deallocate the local arrays
    !
    if (col_getNumCol(columng).gt.0) then       
       deallocate(notag)
       deallocate(varInterphr_T)
       deallocate(varInterphr_M)
       deallocate(varInterphr_VV)
    endif
    deallocate(datestamplist)
    deallocate(nobsgid)
    deallocate(nobs,nobs_maxmpiglobal)
    deallocate(nultrl)
    deallocate(idate)
    deallocate(itime)
    deallocate(dlonfld)
    deallocate(dlatfld)
    deallocate(dlonfld_mpiglobal)
    deallocate(dlatfld_mpiglobal)
    deallocate(nobsgid_mpiglobal)
    deallocate(nobs_mpiglobal)

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    write(*,*) ' '
    write(*,*) '-------- Leaving INN_SETUPBACKGROUNDCOLUMNS ---------'
    write(*,*) ' '
    call tmg_stop(10)

  contains

    subroutine readTrialField(varInterphr_MT,varInterphr_VV,varName_in,varLevel,noUpperGZ)
      !
      ! s/r readTrialField
      !
      !     Author  : M. Buehner, Dec 2012
      !
      !     Purpose: Read and interpolate all levels/time steps for a single variable of trial field
      !
      implicit none
      character(len=*) :: varName_in
      character(len=*) :: varLevel
      character(len=4) :: varName
      logical, optional :: noUpperGZ
      real*8 :: varInterphr_MT(:,:),varInterphr_VV(:,:)
      real*4, allocatable :: varTrial_r4(:,:),varTrial_VV_r4(:,:)
      real*4, allocatable :: varTrial_zero_r4(:,:)
      real*8, allocatable :: varInterp(:,:,:),varInterp_VV(:,:,:)
      real*8, allocatable :: varInterp2(:),varInterp2_VV(:)
      real*8, allocatable :: varInterp_recv(:,:),varInterp_recv_VV(:,:)
      integer :: nlevel,nsize,iip1,pe_send,pe_recv,tag,tag2
      integer :: fstlir,ezdefset

      integer, parameter :: maxnumkeys = 500
      integer :: numkeys, keys(maxnumkeys)
      integer :: key, fstinf, fstprm, fstinl, EZscintID, ezqkdef
      integer :: ni, nj, nk
      integer :: dateo, deet, npas, nbits, datyp
      integer :: ip1, ip2, ip3, swa, lng, dltf, ubc
      integer :: extra1, extra2, extra3
      integer :: ig1, ig2, ig3, ig4

      !
      ! Determine the type and number of vertical levels
      !
      if (trim(varName_in).eq.'UV') then
         varName='UU  '
      else
         varName=varName_in
      endif

      nlevel = col_getNumLev(columnhr,varLevel)

      !
      ! Check if too few GZ levels are in file, if so then just read surface
      !
      if (trim(varName).eq.'GZ' .and. present(noUpperGZ)) then
         if ( top_spatialDimensions() /= '2D') then
            ierr = fstinl(nultrl(1), ni, nj, nk, -1, ' ', -1, -1, -1, &
                 ' ','GZ',keys, numkeys, maxnumkeys)
            write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: nlevel =  ', nlevel, ', numkeys = ', numkeys
            if (numkeys.lt.nlevel) then
               write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: Too few GZ levels found, will only read surface'
               noUpperGZ = .true.
            else
               write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: sufficient levels of GZ found, will read all'
               noUpperGZ = .false.
            endif
         else
            write(*,*) 'INN_SETUPBACKGROUNDCOLUMNS: In 2D spatial mode, we only read GZ at the surface'
            noUpperGZ = .true.
         end if
      endif

      !
      ! Determine grid size and EZSCINT ID
      !
      dateo  = -1
      cletiket = ' '
      ip1    = -1
      ip2    = -1
      ip3    = -1
      cltypvar = ' '

      key = fstinf( nultrl(1),                                        & ! IN
           ni, nj, nk,                                       & ! OUT
           dateo, cletiket, ip1, ip2, ip3, cltypvar, varName ) ! IN

      if (key < 0) then
         write(6,*)
         write(6,*) 'INN_SETUPBACKGROUNDCOLUMNS: Unable to find trial field = ',varName
         call varAbort('INN_SETUPBACKGROUNDCOLUMNS')
      end if

      ierr = fstprm( key,                                              & ! IN
           dateo, deet, npas, ni, nj, nk, nbits,              & ! OUT
           datyp, ip1, ip2, ip3, cltypvar, varName, cletiket, & ! OUT
           clgrtyp, ig1, ig2, ig3,                            & ! OUT
           ig4, swa, lng, dltf, ubc, extra1, extra2, extra3 )   ! OUT

      EZscintID  = ezqkdef( ni, nj, clgrtyp, ig1, ig2, ig3, ig4, nultrl(1) )   ! IN

      allocate(varTrial_r4(ni,nj))
      allocate(varTrial_VV_r4(ni,nj))
      allocate(varTrial_zero_r4(ni,nj))
      allocate(varInterp(maxval(nobs_mpiglobal),nlevel,mpi_nprocs))
      allocate(varInterp_VV(maxval(nobs_mpiglobal),nlevel,mpi_nprocs))
      allocate(varInterp2(maxval(nobs_mpiglobal)))
      allocate(varInterp2_VV(maxval(nobs_mpiglobal)))
      allocate(varInterp_recv(maxval(nobs_mpiglobal),nlevel))
      allocate(varInterp_recv_VV(maxval(nobs_mpiglobal),nlevel))
      varTrial_zero_r4(:,:) = 0.0

      ! in the case that not all variable have the same etiket or typvar
      ! (this is necessary for extra 3d-var done before gen_coeff)
      cletiket='            '
      cltypvar='  '

      do jstep = 1,tim_nStepObs

         if (nobs_maxmpiglobal(jstep) > 0) then

            call rpn_comm_barrier("GRID",ierr)

            do jlev = (1+mpi_myid),nlevel,mpi_nprocs

               if (trim(varName).eq.'GZ'.and.jlev.eq.nlevel) then
                  ! use surface level IP1 for GZ (essential for Vcode=5005)
                  IIP1 = vco_trl%ip1_sfc
               elseif (varLevel.eq.'MM') then
                  IIP1 = vco_trl%ip1_M(jlev)
               elseif (varLevel.eq.'TH') then
                  IIP1 = vco_trl%ip1_T(jlev)
               elseif (varLevel.eq.'SF') then
                  IIP1 = -1
               else
                  call varAbort('INN_SETUPBACKGROUNDCOLUMNS: unknown varLevel')
               endif

               if (trim(varName).eq.'GZ'.and.present(noUpperGZ)) then
                  if (noUpperGZ.and.jlev.ne.nlevel) then
                     ! do not try to read GZ above surface if it does not exist
                     varTrial_r4(:,:) = 0.0
                  else
                     ierr=fstlir(varTrial_r4(:,:),nultrl(jstep),ni,nj,ink,  &
                          datestamplist(jstep) ,cletiket,iip1,-1,-1,  &
                          cltypvar,varName)
                  endif
               else
                  ierr=fstlir(varTrial_r4(:,:),nultrl(jstep),ni,nj,ink,  &
                       datestamplist(jstep) ,cletiket,iip1,-1,-1,  &
                       cltypvar,varName)
               endif

               if (ierr.lt.0)then
                  write(*,2001) varName,iip1,idate(jstep),itime(jstep)
                  call varAbort('INN_SETUPBACKGROUNDCOLUMNS: Problem with background file')
               end if

               if (varName.eq.'UU') then
                  ierr=fstlir(varTrial_VV_r4(:,:),nultrl(jstep),ni,nj,ink,  &
                       datestamplist(jstep) ,cletiket,iip1,-1,-1,  &
                       cltypvar,'VV')
                  if (ierr.lt.0)then
                     write(*,2001) 'VV',iip1,idate(jstep),itime(jstep)
                     call varAbort('INN_SETUPBACKGROUNDCOLUMNS: Problem with background file')
                  end if
               endif

               ! Interpolate to mpiglobal set of columns for a subset of levels
               do jlatlontile = 1,mpi_nprocs
                  if (nobs_mpiglobal(jstep,jlatlontile).gt.0) then
                     iset = ezdefset(nobsgid_mpiglobal(jstep,jlatlontile),EZscintID)
                     if (trim(varName).eq.'UU') then

                        ierr = utl_ezuvint(varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile),  &
                             varInterp_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile),  &
                             varTrial_r4,varTrial_zero_r4,  &
                             nobs_mpiglobal(jstep,jlatlontile),ni*nj)
                        ierr = utl_ezuvint(varInterp2(1:nobs_mpiglobal(jstep,jlatlontile)),  &
                             varInterp2_VV(1:nobs_mpiglobal(jstep,jlatlontile)),  &
                             varTrial_zero_r4,varTrial_VV_r4,  &
                             nobs_mpiglobal(jstep,jlatlontile),ni*nj)

                        varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile) =  &
                             varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile) +  &
                             varInterp2(1:nobs_mpiglobal(jstep,jlatlontile))
                        varInterp_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile) =  &
                             varInterp_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile) +  &
                             varInterp2_VV(1:nobs_mpiglobal(jstep,jlatlontile))

                     else
                        ierr = utl_ezsint2(varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile),  &
                             varTrial_r4,  &
                             nobs_mpiglobal(jstep,jlatlontile),1,1,ni,nj,1)
                     endif
                  endif
               enddo

            enddo

            do jlatlontile = 1,mpi_nprocs
               if (nobs_mpiglobal(jstep,jlatlontile).gt.0) then
                  do jlev = 1,nlevel

                     pe_send = mod(jlev-1,mpi_nprocs)
                     pe_recv = jlatlontile-1
                     tag  = pe_recv*500 + pe_send
                     tag2 = pe_recv*500 + pe_send + 1000000

                     if (pe_send.eq.pe_recv) then
                        if (mpi_myid.eq.pe_send) then
                           varInterp_recv(1:nobs_mpiglobal(jstep,jlatlontile),jlev) =  &
                                varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile)
                           if (trim(varName).eq.'UU') then
                              varInterp_recv_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev) =  &
                                   varInterp_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile)
                           endif
                        endif
                     else
                        if (mpi_myid.eq.pe_send) then
                           nsize=nobs_mpiglobal(jstep,jlatlontile)
                           call rpn_comm_send(varInterp(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile), &
                                nsize,"mpi_double_precision",pe_recv,tag,"GRID",ierr)
                           if (trim(varName).eq.'UU') then
                              call rpn_comm_send(varInterp_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev,jlatlontile), &
                                   nsize,"mpi_double_precision",pe_recv,tag2,"GRID",ierr)
                           endif
                        endif

                        if (mpi_myid.eq.pe_recv) then
                           nsize=nobs_mpiglobal(jstep,jlatlontile)
                           call rpn_comm_recv(varInterp_recv(1:nobs_mpiglobal(jstep,jlatlontile),jlev), &
                                nsize,"mpi_double_precision",pe_send,tag,"GRID",status,ierr)
                           if (trim(varName).eq.'UU') then
                              call rpn_comm_recv(varInterp_recv_VV(1:nobs_mpiglobal(jstep,jlatlontile),jlev), &
                                   nsize,"mpi_double_precision",pe_send,tag2,"GRID",status,ierr)
                           endif
                        endif
                     endif

                  enddo
               endif
            enddo

            do jlev = 1,nlevel
               do jobs = 1, nobs(jstep)
                  varInterphr_MT(jlev,notag(jobs,jstep)) = varInterp_recv(jobs,jlev)
                  if (trim(varName).eq.'UU') then
                     varInterphr_VV(jlev,notag(jobs,jstep)) = varInterp_recv_VV(jobs,jlev)
                  endif
               enddo
            enddo

         endif !nobs>0

      enddo !jstep

      deallocate(varTrial_r4,varTrial_VV_r4)
      deallocate(varTrial_zero_r4)
      deallocate(varInterp,varInterp_VV)
      deallocate(varInterp_recv,varInterp_recv_VV)
      deallocate(varInterp2,varInterp2_VV)

2001  format(1x,'INN_SETUPBACKGROUNDCOLUMNS: Problem finding variable',1x,a4,1x,'at level',  &
           i10,1x,', on',1x,i8,1x,'at',1x,i8.8,1x,'HHMMSSss')

    end subroutine readTrialField

  end subroutine inn_setupBackgroundColumns

  subroutine inn_computeInnovation(columng,columnhr,obsSpaceData)
    !
    !**s/r inn_computeInnovation  - Initialise Observation Innovations.
    !
    !
    implicit none

    type(struct_columnData) :: columnhr,columng
    type(struct_obs) :: obsSpaceData

    real*8 zjo,zjoraob,zjosatwind,zjosurfc
    real*8 zjosfcsf,zjosfcua,zjotov,zjoairep,zjosfcsc,zjoprof
    real*8 zjogpsro,zjogpsgb,zjosfcgp
    integer :: ierr, get_max_rss
    logical lgpdata

    write(*,*) '--Starting subroutine inn_computeInnovation--'
    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

    write(*,*) 'PRDATABIN: Before filtering done in INN_COMPUTEINNOVATION'
    call prdatabin(obsSpaceData,tim_nstepobs)
    !
    !     Reject observed elements too far below the surface. Pressure values
    !     for elements slightly below the surface are replaced by the surface
    !     pressure values of the trial field.
    !
    !     GB-GPS (met and ZTD) observations are processed in s/r filt_topoSFC (in obsFilter_mod.ftn90)
    !
    call filt_topo(columnhr,obsSpaceData)
    !
    !     Remove surface station wind observations
    !
    IF ( top_AnalysisMode() ) CALL filt_surfaceWind(obsSpaceData)
    !
    !     Find interpolation layer in model profiles 
    !
    if ( top_spatialDimensions() /= '2D') call vobslyrs(columnhr,obsSpaceData)
    !
    !
    !------ Calculate the innovations Y - H(Xb) and place
    !       the result in obsSpaceData in OBS_OMP column
    !
    !        RAOBS
    !------------------------------
    !
    call tmg_start(48,'NL_OBS_OPER')
    CALL oonl_ppp(columnhr,obsSpaceData,ZJORAOB,'UA')
    !
    !        AIREPS
    !--------------------------------
    CALL oonl_ppp(columnhr,obsSpaceData,ZJOAIREP,'AI')
    !
    !        SATWINDS
    !--------------------------------
    CALL oonl_ppp(columnhr,obsSpaceData,ZJOSATWIND,'SW')
    !
    !        SURFACE (SF, UA, SC AND GP FAMILIES)
    !-------------------------------
    call oonl_sfc(columnhr,obsSpaceData,ZJOSFCSF,'SF')
    call oonl_sfc(columnhr,obsSpaceData,ZJOSFCUA,'UA')
    call oonl_sfc(columnhr,obsSpaceData,ZJOSFCSC,'SC')
    call oonl_sfc(columnhr,obsSpaceData,ZJOSFCGP,'GP')
    ZJOSURFC = ZJOSFCUA + ZJOSFCSF + ZJOSFCSC + ZJOSFCGP
    !
    !        TOVS - RADIANCE
    !-------------------------------
    call oonl_tovs(columnhr,obsSpaceData,tim_getDatestamp(),filt_rlimlvhu,top_BgckIrMode(),ZJOTOV)
    !
    !        PROFILER
    !------------------------------
    call oonl_zzz(columnhr,obsSpaceData,ZJOPROF,'PR')
    !
    !        GPS - RADIO OCCULTATION
    !-------------------------------
    CALL filt_gpsro(columnhr,obsSpaceData)
    CALL SETERRGPSRO(columnhr,obsSpaceData)
    call oonl_gpsro(columnhr,obsSpaceData,ZJOGPSRO)
    !
    !        GPS - GROUND-BASED ZENITH DELAY
    !-------------------------------
    !
    ZJOGPSGB=0.0D0
    CALL SETERRGPSGB(columnhr,obsSpaceData,lgpdata,top_AnalysisMode())
    if (lgpdata) call oonl_gpsgb(columnhr,obsSpaceData,ZJOGPSGB,top_AnalysisMode())

    call tmg_stop(48)
    !
    !=======================================================================
    ZJO =  ZJORAOB + ZJOAIREP + ZJOSATWIND + &
         ZJOSURFC + ZJOTOV + ZJOPROF + ZJOGPSRO + ZJOGPSGB
    !=======================================================================

    write(*,*) 'Cost function values for this MPI task:'
    write(*,'(a15,f30.16)') 'JORAOB   = ',ZJORAOB
    write(*,'(a15,f30.16)') 'JOAIREP  = ',ZJOAIREP
    write(*,'(a15,f30.16)') 'JOSURFC  = ',ZJOSURFC
    write(*,'(a15,f30.16)') 'JOSFCSF  = ',ZJOSFCSF
    write(*,'(a15,f30.16)') 'JOSFCUA  = ',ZJOSFCUA
    write(*,'(a15,f30.16)') 'JOSFCSC  = ',ZJOSFCSC
    write(*,'(a15,f30.16)') 'JOSFCGP  = ',ZJOSFCGP
    write(*,'(a15,f30.16)') 'JOTOV    = ',ZJOTOV
    write(*,'(a15,f30.16)') 'JOSATWIND= ',ZJOSATWIND
    write(*,'(a15,f30.16)') 'JOPROF   = ',ZJOPROF
    write(*,'(a15,f30.16)') 'JOGPSRO  = ',ZJOGPSRO
    write(*,'(a15,f30.16)') 'JOGPSGB  = ',ZJOGPSGB
    write(*,'(a15,f30.16)') 'Total Jo = ',ZJO

    call mpi_allreduce_sumreal8scalar(ZJORAOB,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOAIREP,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSURFC,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSFCSF,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSFCUA,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSFCSC,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSFCGP,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOTOV,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOSATWIND,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOPROF,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOGPSRO,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJOGPSGB,"GRID")
    call mpi_allreduce_sumreal8scalar(ZJO,"GRID")

    write(*,*) 'Cost function values summed for all MPI tasks:'
    write(*,'(a15,f30.16)') 'JORAOB   = ',ZJORAOB
    write(*,'(a15,f30.16)') 'JOAIREP  = ',ZJOAIREP
    write(*,'(a15,f30.16)') 'JOSURFC  = ',ZJOSURFC
    write(*,'(a15,f30.16)') 'JOSFCSF  = ',ZJOSFCSF
    write(*,'(a15,f30.16)') 'JOSFCUA  = ',ZJOSFCUA
    write(*,'(a15,f30.16)') 'JOSFCSC  = ',ZJOSFCSC
    write(*,'(a15,f30.16)') 'JOSFCGP  = ',ZJOSFCGP
    write(*,'(a15,f30.16)') 'JOTOV    = ',ZJOTOV
    write(*,'(a15,f30.16)') 'JOSATWIND= ',ZJOSATWIND
    write(*,'(a15,f30.16)') 'JOPROF   = ',ZJOPROF
    write(*,'(a15,f30.16)') 'JOGPSRO  = ',ZJOGPSRO
    write(*,'(a15,f30.16)') 'JOGPSGB  = ',ZJOGPSGB
    write(*,'(a15,f30.16)') 'Total Jo = ',ZJO

    !
    !     Find interpolation layer in model profiles 
    !
    if ( top_spatialDimensions() /= '2D') CALL VOBSLYRS(columng,obsSpaceData)

    write(*,*) 'PRDATABIN: After filtering done in INN_COMPUTEINNOVATION'
    call prdatabin(obsSpaceData,tim_nstepobs)

    write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
    write(*,*) '--Done subroutine inn_computeInnovation--'

  end subroutine inn_computeInnovation

  SUBROUTINE VOBSLYRS(lcolumnghr,lobsSpaceData)

    !*    Purpose:
    !      Find which model levels to use for the vertical interpolation
    !      of model fields to CMA data.
    !
    use EarthConstants_mod
    use MathPhysConstants_mod
    use obsSpaceData_mod
    use columnData_mod 
    use bufr
    IMPLICIT NONE
    type(struct_columnData) :: lcolumnghr
    type(struct_obs) :: lobsSpaceData

    INTEGER :: JK,JDATA,NLEV
    REAL(8) :: ZLEV,ZPT,ZPB
    INTEGER :: IOBS,IK,ITYP
    LOGICAL :: LLOK
    CHARACTER(len=2) :: varLevel
    integer :: index_header, index_body
    !
    !-----------------------------------------------------------------------
    !         --------
    !           ETA
    !         --------
    !
    !     1. Find where extrapolation is needed
    !        ----------------------------------
    !
    !     1.1 PPP Vertical coordinate
    !
    Write(*,*) "Entering subroutine VOBSLYRS"

    DO JDATA= 1,obs_numbody(lobsSpaceData)
       LLOK = ( (obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. 1     .OR. &
            obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. -1) .AND. &
            obs_bodyElem_i(lobsSpaceData,OBS_VCO,JDATA) .EQ. 2 )
       IF ( LLOK ) THEN
          IF(obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA) .NE. BUFR_NEDZ ) THEN
             ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,JDATA)
          ELSE
             call varAbort('vobslyr: ZLEV cannot be set, BUFR_NEDZ not supported!')
          ENDIF
          IOBS = obs_bodyElem_i(lobsSpaceData,OBS_HIND,JDATA)
          ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA)
          varLevel = vnl_varLevelFromVarnum(ITYP)
          ZPT= col_getPressure(LCOLUMNGHR,1,IOBS,varLevel)
          ZPB= col_getPressure(LCOLUMNGHR,COL_GETNUMLEV(LCOLUMNGHR,varLevel),IOBS,varLevel)
          IF ( ZLEV .LT. ZPT ) THEN
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,1)
             !
             !- !!! WARNING !!! This obs is above the model lid. 
             !  We must turn off its assimilation flag  because the
             !  current obs operators cannot deal with this situation (JFC)                  
             if(varLevel.ne.'SF') then
                write(*,*) "vobslyrs: Rejecting OBS above model lid, pressure = ", ZLEV," < ",ZPT
                call obs_bodySet_i(lobsSpaceData,OBS_ASS,JDATA, 0)
             endif
          ELSE IF ( ZLEV .GT. ZPB ) THEN
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,2)
          ELSE
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,0)
          ENDIF
       ENDIF
    END DO
    !
    !     1.2 ZZZ Vertical coordinate
    !
    DO JDATA= 1,obs_numbody(lobsSpaceData)
       LLOK = (obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. 1 .AND. &
            obs_bodyElem_i(lobsSpaceData,OBS_VCO,JDATA) .EQ. 1 )
       IF ( LLOK ) THEN
          IF(obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA) .NE. BUFR_NEDZ ) THEN
             ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,JDATA)
          ELSE
             call varAbort('vobslyr: ZLEV cannot be set, BUFR_NEDZ not supported!')
          ENDIF
          IOBS = obs_bodyElem_i(lobsSpaceData,OBS_HIND,JDATA)
          ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA)
          varLevel = vnl_varLevelFromVarnum(ITYP)
          if(varLevel.eq.'SF') then
             nlev=col_getNumLev(lcolumnghr,'TH')
             ZPT= col_getHeight(lcolumnghr,1,IOBS,'TH')/RG
             ZPB= col_getHeight(lcolumnghr,NLEV,IOBS,'TH')/RG                 
          else
             nlev=col_getNumLev(lcolumnghr,varLevel)
             ZPT= col_getHeight(lcolumnghr,1,IOBS,varLevel)/RG
             ZPB= col_getHeight(lcolumnghr,NLEV,IOBS,varLevel)/RG
          endif
          IF ( ZLEV .GT. ZPT ) THEN
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,1)
             write(*,*) "vobslyrs: Rejecting OBS above model lid, height =", ZLEV," > ",ZPT
             call obs_bodySet_i(lobsSpaceData,OBS_ASS,JDATA, 0)
          ELSE IF ( ZLEV .LT. ZPB ) THEN
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,2)
          ELSE
             call obs_bodySet_i(lobsSpaceData,OBS_XTR,JDATA,0)
          ENDIF
       ENDIF
    END DO
    !
    !
    !     2. FInd interpolation layer
    !        ------------------------
    !        (Model levels are assumed to be in increasing order in Mbs)
    !        ...The SIGN and MAX intrinsincs are used for vectorization
    !           purposes......
    !
    !     2.1  PPP Vertical coordinate
    !
    DO JDATA=1,obs_numbody(lobsSpaceData)
       call obs_bodySet_i(lobsSpaceData,OBS_LYR,JDATA,0)
    END DO
    !
    DO JDATA= 1,obs_numbody(lobsSpaceData)
       LLOK = ( (obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. 1     .OR. &
            obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. -1) .AND. &
            obs_bodyElem_i(lobsSpaceData,OBS_VCO,JDATA) .EQ. 2 )
       IF ( LLOK ) THEN
          IOBS = obs_bodyElem_i(lobsSpaceData,OBS_HIND,JDATA)
          ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,JDATA)
          ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA)
          IK = 1
          varLevel = vnl_varLevelFromVarnum(ITYP)
          nlev=COL_GETNUMLEV(LCOLUMNGHR,varLevel)
          DO JK = 2,NLEV - 1
             ZPT = col_getPressure(LCOLUMNGHR,JK,IOBS,varLevel)
             IF( ZLEV .GT. ZPT ) IK = JK
          END DO
          ZPT = col_getPressure(LCOLUMNGHR,IK,IOBS,varLevel)
          ZPB = col_getPressure(LCOLUMNGHR,IK+1,IOBS,varLevel) 
          call obs_bodySet_i(lobsSpaceData,OBS_LYR,JDATA, IK)
       ENDIF
    END DO
    !
    !     2.2  ZZZ Vertical coordinate and surface observations
    !
    DO JDATA= 1,obs_numbody(lobsSpaceData)
       LLOK = ( (obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. 1     .OR. &
            obs_bodyElem_i(lobsSpaceData,OBS_ASS,JDATA) .EQ. -1) .AND. &
            obs_bodyElem_i(lobsSpaceData,OBS_VCO,JDATA) .EQ. 1 )
       IF ( LLOK ) THEN
          IOBS = obs_bodyElem_i(lobsSpaceData,OBS_HIND,JDATA)
          ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,JDATA)
          ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,JDATA)
          IK = 1
          varLevel = vnl_varLevelFromVarnum(ITYP)
          nlev=COL_GETNUMLEV(LCOLUMNGHR,varLevel)
          DO JK = 2,NLEV - 1
             ZPT = col_getHeight(lcolumnghr,JK,IOBS,varLevel)/RG
             IF( ZLEV .LT. ZPT ) IK = JK
          END DO
          IF ( ITYP.EQ.BUFR_NEPS .or. ITYP.EQ.BUFR_NEPN .or. &
               ITYP.EQ.BUFR_NEZD ) THEN
             ! for surface observations associated with surface analysis variables
             IK = 0
          ELSEIF ( ITYP.EQ.BUFR_NETS .or. ityp.eq.BUFR_NESS .OR. &
               ITYP.EQ.BUFR_NEUS .or. ityp.eq.BUFR_NEVS .OR. &
               ITYP.EQ.BUFR_NEHS) THEN
             ! for surface observations associated with NON-surface analysis variables
             IK = nlev - 1
          ENDIF
          call obs_bodySet_i(lobsSpaceData,OBS_LYR,JDATA, IK)
       ENDIF
    END DO
    !
  END SUBROUTINE VOBSLYRS

  subroutine subasic_obs(lcolumng)

    use MathPhysConstants_mod
    use physicsFunctions_mod
    use columnData_mod 
    implicit none

    ! s/r SUBASIC_OBS
    !     OBJECT: Initialise background state dependant factors
    !             and vectors for use in TLM and adjoint of
    !             non-linear operator
    !
    !     Author  : S. Pellerin *ARMA/AES Sept. 98
    !
    !
    type(struct_columnData) :: lcolumng
    type(struct_vco), pointer :: vco_anl
    integer :: jlev,jobs,nlev_T,vcode_anl,status
    real(8) :: zhu,one

    vco_anl => col_getVco(lcolumng)
    one=1.0D0
    nlev_T = col_getNumLev(lcolumng,'TH')
    status = vgd_get(vco_anl%vgrid,key='ig_1 - vertical coord code',value=Vcode_anl)

    if(Vcode_anl .ne. 5002 .and. &
         Vcode_anl .ne. 5005 ) then
       call varAbort('subasic_obs: invalid vertical coord!')
    endif

    ! initialize virtual temperature operator

    !$OMP PARALLEL DO PRIVATE(jlev,jobs,zhu)
    do jlev = 1, nlev_T
       do jobs=1,col_getNumCol(lcolumng)

          zhu=exp(col_getElem(lcolumng,jlev,jobs,'HU'))
          lcolumng%oltv(1,jlev,jobs) = fottva(zhu,one)
          lcolumng%oltv(2,jlev,jobs) = folnqva(zhu,col_getElem(lcolumng,  &
               jlev,jobs,'TT'),one)

       enddo
    enddo
    !$OMP END PARALLEL DO

  end subroutine subasic_obs

end module innovation_mod
