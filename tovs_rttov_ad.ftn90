!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Adjoint of computation of radiance with rttov_ad
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                  -addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda  april 2008
!                  -adapt to CSR
!revision 003  : s. heilliette
!                  -adapt to IASI
!           S. Heilliette
!              - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!--------------------------------------------------------------------------
subroutine tovs_rttov_ad(lobsSpaceData)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use obsSpaceData_mod
  use columnData_mod
  Use rttov_const, only : sensor_id_mw, gas_id_watervapour,surftype_land, &
       surftype_seaice
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_ad.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"
#include "rttov_init_prof.interface"
#include "rttov_init_rad.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: joff, ilev
  integer :: isurface
  integer :: nlevels
  integer :: len_nchannels
  integer :: nchannels_max
  integer :: alloc_status(6)
  integer :: rttov_err_stat                      ! rttov error return code
  integer :: omp_get_num_threads
  integer :: nthreads,max_nthreads
  integer :: j, i, krtid, io, jf, iobs, iobs1, jch
  integer :: jj
  integer :: ival, iplatform, isat, knpf
  integer :: jo, jdata, idata, idatend
  integer :: jn, jl, ig
  integer :: instrum
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)
  integer :: nrank, ichn

  integer, allocatable :: iptobs          (:)  
  integer :: errorstatus 

  real*8, allocatable :: surfem1       (:) 
  type (rttov_emissivity), allocatable :: emissivity_local (:)
  type (rttov_emissivity), allocatable :: emissivity_ad (:)
  type (rttov_transmission) :: transmission,transmission_ad
  type (rttov_radiance) :: radiancedata_ad, radiancedata_d
  
  type(rttov_profile)   , allocatable :: profilesdata_ad (:) ! ad profiles buffer used in rttov calls
  type(rttov_chanprof)  , allocatable :: chanprof(:)
  logical              :: init
  integer :: asw
  logical, allocatable :: calcemis  (:)
  
         
  if (NOBTOV == 0) return      ! exit if there are not tovs data

!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!          
 
!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel

  allocate ( iptobs(NOBTOV) )

!
!     2.  Computation of adjoint hx for tovs data only
!     .   --------------------------------------------

! Loop over all sensors specified by user

  binst:do  krtid = 1, nsensors

     nlevels=coefs(krtid) %coef % nlevels

     sensor_type = coefs(krtid) % coef% id_sensor
     iplatform = coefs(krtid) % coef% id_platform
     isat = coefs(krtid) % coef% id_sat
     instrum = coefs(krtid) % coef% id_inst
     
!  loop over all obs.

     knpf = 0
     bobs: do iobs = 1, NOBTOV

!    Currently processed sensor?

        if ( lsensor(iobs) == krtid ) then
           knpf = knpf + 1
           iptobs(knpf) = iobs
        endif
     enddo bobs

     if (knpf == 0) cycle binst


!     .  2.1  Calculate the actual number of threads which will be used.
!     .       ----------------------------------------------------------

      nthreads = min(max_nthreads, knpf )  

!     .  2.2  Prepare all input variables required by rttov_ad.
!     .       ---------------------------------------------------------
      alloc_status(:)=0

!     compute max possible values for nchannels using knpf, i.e. maximum number of profiles.

      nchannels_max = knpf * nchan(krtid)
      
      allocate ( chanprof     (nchannels_max)    ,stat=alloc_status(1))
      allocate ( emissivity_local (nchannels_max),stat=alloc_status(2))
      allocate ( emissivity_ad(nchannels_max)    ,stat=alloc_status(3))
      allocate ( calcemis     (nchannels_max)    ,stat=alloc_status(4))
      allocate ( surfem1      (nchannels_max)    ,stat=alloc_status(5))
      allocate ( profilesdata_ad(knpf)           ,stat=alloc_status(6))

      if( any(alloc_status /= 0) ) then
         write(*,*) ' tovs_rttov_ad: alloc_status = ', alloc_status(:)
         write(*,'(" tovs_rttov_ad:  arrays #2 memory allocation error")')
        call utl_abort('tovs_rttov_ad')
      end if

!     get Hyperspectral IR emissivities
      
      if ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
        surfem1(:) = 0.98d0
        do jn = 1, knpf
          iobs1 = iptobs(jn)
          jo = lobsno(iobs1)
          idata    = obs_headElem_i(lobsSpaceData,OBS_RLN,jo)
          idatend  = obs_headElem_i(lobsSpaceData,OBS_NLV,jo) + idata - 1
          do jdata = idata, idatend
            if(obs_bodyElem_i(lobsSpaceData,OBS_ASS,jdata)==1) then
              ichn = nint(obs_bodyElem_r(lobsSpaceData,OBS_PPP,jdata))
              ichn = max(0,min(ichn,jpchmax+1))
              do nrank = 1, nchan(krtid)
                if ( ichn == ichan(nrank,krtid) ) exit
              end do
              surfem1 ( nrank + (jn-1)*nchan(krtid) ) = obs_bodyElem_r(lobsSpaceData,OBS_SEM,jdata)
            end if
          end do
        end do
      end if

! Build the list of channels/profiles indices

      ichn = 0
      Do j = 1 , knpf
         DO  jch = 1,nchan(krtid)
            ichn = ichn +1
            chanprof(ichn)%prof=j
            chanprof(ichn)%chan=jch
         End Do
      End Do

      len_nchannels = nchan(krtid)
      do  j = 1 , knpf
         joff=len_nchannels*(j-1)
         isurface = profiles(iptobs(j)) % skin % surftype 
         if     (sensor_type == sensor_id_mw ) then
            if ( isurface ==  surftype_land .or. &
                 isurface ==  surftype_seaice     ) then
               calcemis(joff+1:joff+len_nchannels ) = .false.
               surfem1 (joff+1:joff+len_nchannels ) = 0.75d0
            else
               calcemis(joff+1:joff+len_nchannels ) = .true.
               surfem1 (joff+1:joff+len_nchannels) = 0.d0
            endif
         elseif ( tvs_Is_Instrum_Hyperspectral(instrum) ) then
            calcemis(joff+1:joff+len_nchannels) = .false. 
         elseif ( tvs_Is_Instrum_Geostationary(instrum) ) then
            calcemis(joff+1:joff+len_nchannels ) = .true.
            surfem1 (joff+1:joff+len_nchannels) = 0.d0
         else
            call utl_abort('tovs_rttov_ad. invalid sensor type')
         endif
      enddo

      emissivity_local(:)%emis_in = surfem1(:)
        
     
      ! allocate transmittance structures
      asw=1
      init=.true.
      call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
           nchanprof=nchannels_max,asw=asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_ad')
      endif
      call rttov_alloc_transmission(rttov_err_stat,transmission_ad,nlevels=nlevels,      &
           nchanprof=nchannels_max,asw=asw,init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in transmittance_ad allocation",rttov_err_stat
         call utl_abort('tovs_rttov_ad')
      endif

         ! allocate radiance structures

      call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_d,nlevels,asw)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance allocation",rttov_err_stat
         call utl_abort('tovs_rttov_ad')
      endif
      call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_ad,nlevels,asw)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in radiance ad allocation",rttov_err_stat
         call utl_abort('tovs_rttov_ad')
      endif

         ! allocate profile structures
         
      call rttov_alloc_prof (rttov_err_stat,knpf,profilesdata_ad,nlevels, &
           opts(krtid),asw=asw,coefs=coefs(krtid),init=init)
      if (rttov_err_stat/=0) THEN
         Write(*,*) "Error in profiles ad allocation",rttov_err_stat
         call utl_abort('tovs_rttov_ad')
      endif
    
     !.. climatological moisture clip for profiles arrays
! Modifie par S.Heilliette
! pour utiliser le bon profil min ou max pour chaque instrument
! au lieu du premier (AIRS) habituellement en mode analyse
! ne doit rien changer en mode background check
! Deplace (temporairement?) dans rttov: opts(JK)%config%apply_reg_limits=.true.
!      ig=coefs(krtid)%coef%fmv_gas_pos(gas_id_watervapour)
!      do  j = 1 , knpf
!         jj = iptobs(j)
!         do  jl = 1 , nlevels
!            if     ( profiles(jj) % q(jl)  &
!                 .le.  coefs(krtid)%coef%lim_prfl_gmin(jl,ig)   ) then
!               profiles(jj) % q(jl)  = coefs(krtid)%coef%lim_prfl_gmin(jl,ig)
!            elseif ( profiles(jj) % q(jl)  &
!                 .ge. coefs(krtid)%coef%lim_prfl_gmax(jl,ig)   ) then
!               profiles(jj) % q(jl)  = coefs(krtid)%coef%lim_prfl_gmax(jl,ig)
!           endif
!         enddo
!      end do

      call rttov_init_prof(profilesdata_ad(1:knpf) )

      call rttov_init_rad( radiancedata_d )
     !.. fill radiancedata_ad_th arrays

      call rttov_init_rad( radiancedata_ad )
!

!     .  2.3  Compute ad radiance with rttov_ad
!     .       ---------------------------------

      errorstatus  = 0
      emissivity_ad(:)%emis_in = 0.0d0
      emissivity_ad(:)%emis_out = 0.0d0

      call tmg_start(84,'rttov_ad')

      call rttov_parallel_ad(        &
           errorstatus,              & ! out
           chanprof,                 & ! in
           opts(krtid),              & ! in
           profiles(iptobs(1:knpf)), & ! in
           profilesdata_ad,          & ! in
           coefs(krtid),             & ! in
           transmission,             & ! inout
           transmission_ad,          & ! inout
           radiancedata_d,           & ! inout
           radiancedata_ad,          & ! inout
           calcemis,                 & ! in
           emissivity_local,         & ! inout
           emissivity_ad,            & ! inout
           nthreads = nthreads )

      if (errorstatus /= 0) then
         Write(*,*) "Error in rttov_parallel_ad", errorstatus
         call utl_abort('tovs_rttov_ad')
      endif

     call tmg_stop(84)

     !.. store results from rttov_ad into profiles_ad

     do  j = 1 , knpf
        io = iptobs(j)
        profiles_ad(io) % t(:)      =  profilesdata_ad(j) % t(:)
        profiles_ad(io) % q(:)      =  profilesdata_ad(j) % q(:)
        profiles_ad(io) % skin % t  =  profilesdata_ad(j) % skin % t 
        profiles_ad(io) % s2m % t   =  profilesdata_ad(j) % s2m % t
        profiles_ad(io) % s2m % q   =  profilesdata_ad(j) % s2m % q
        profiles_ad(io) % s2m % p   =  profilesdata_ad(j) % s2m % p
        profiles_ad(io) % s2m % u   =  profilesdata_ad(j) % s2m % u
        profiles_ad(io) % s2m % v   =  profilesdata_ad(j) % s2m % v
     end do
     

     !.. adjoint of climatological moisture clip for profiles_ad arrays
! Modifie par S.Heilliette
! pour utiliser le bon profil min ou max pour chaque instrument
! au lieu du premier (AIRS) habituellement en mode analyse
     ! ne doit rien changer en mode background check
! Deplace (temporairement?) dans rttov: opts(JK)%config%apply_reg_limits=.true.
!     ig=coefs(krtid)%coef%fmv_gas_pos(gas_id_watervapour)
!     do  j = 1 , knpf
!        io = iptobs(j)
!        do  jl = 1 , coefs(krtid) % coef%nlevels
!           if     ( profiles(io) % q(jl)  &
!                .le.  coefs(krtid)%coef%lim_prfl_gmin(jl,ig)   ) then
!              profiles_ad(io) % q(jl)  = 0.0d0
!           elseif ( profiles(io) % q(jl)  &
!                .ge. coefs(krtid)%coef%lim_prfl_gmax(jl,ig)   ) then
!              profiles_ad(io) % q(jl)  = 0.0d0
!           endif
!        enddo
!     end do


!     de-allocate memory

     asw=0 ! 1 to allocate,0 to deallocate

     call rttov_alloc_transmission(rttov_err_stat,transmission,nlevels=nlevels,      &
          nchanprof=nchannels_max,asw=asw)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in transmittance deallocation",rttov_err_stat
        call utl_abort('tovs_rttov_ad')
     endif

     call rttov_alloc_transmission(rttov_err_stat,transmission_ad,nlevels=nlevels,   &
          nchanprof=nchannels_max,asw=asw)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in transmittance ad allocation",rttov_err_stat
        call utl_abort('tovs_rttov_ad')
     endif
         
     call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_d,nlevels,asw)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in radiance deallocation",rttov_err_stat
        call utl_abort('tovs_rttov_ad')
     endif

     call rttov_alloc_rad (rttov_err_stat,nchannels_max,radiancedata_ad,nlevels,asw)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in radiance ad deallocation",rttov_err_stat
        call utl_abort('tovs_rttov_ad')
     endif

     call rttov_alloc_prof (rttov_err_stat,knpf,profilesdata_ad,nlevels, &
          opts(krtid),asw=asw)
     if (rttov_err_stat/=0) THEN
        Write(*,*) "Error in profiles ad deallocation",rttov_err_stat
        call utl_abort('tovs_rttov_ad')
     endif

     alloc_status(:) = 0
     deallocate ( profilesdata_ad ,stat=alloc_status(1))
     deallocate ( chanprof        ,stat=alloc_status(2))
     deallocate ( emissivity_local,stat=alloc_status(3))
     deallocate ( emissivity_ad   ,stat=alloc_status(4))
     deallocate ( calcemis        ,stat=alloc_status(5))
     deallocate ( surfem1         ,stat=alloc_status(6))
     
     if( any(alloc_status /= 0) ) then
        write(*,*) ' tovs_rttov_ad: alloc_status = ', alloc_status(:)
        write(*,'(" tovs_rttov_ad: arrays #2 memory deallocation error")')
        call utl_abort('tovs_rttov_ad')
     end if


  enddo binst

!     3.  Close up
!     .   --------

deallocate ( iptobs )

end subroutine tovs_rttov_ad
