!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! *Purpose*: Adjoint of computation of radiance with rttov_ad
!!
!! @author j. halle *cmda/aes  april 19, 2005
!!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                  -addition of ozone and IR surface emissivities
!revision 002  : r. sarrazin cmda  april 2008
!                  -adapt to CSR
!revision 003  : s. heilliette
!                  -adapt to IASI
!           S. Heilliette
!              - adaptation to rttov 10.0 (october 2010)
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!--------------------------------------------------------------------------
subroutine tovs_rttov_ad(lobsSpaceData)
  use MathPhysConstants_mod
  use tovs_nl_mod
  use tovs_lin_mod
  use obsSpaceData_mod
  use columnData_mod
  use utilities_mod
  implicit none
!implicits
#include "rttov_parallel_ad.interface"
#include "rttov_alloc_prof.interface"
#include "rttov_alloc_rad.interface"
#include "rttov_alloc_transmission.interface"
#include "rttov_copy_prof.interface"
#include "rttov_init_prof.interface"
#include "rttov_init_rad.interface"

  type(struct_obs) :: lobsSpaceData

  integer :: nlevels
  integer :: count_tb
  integer :: alloc_status(6)
  integer :: rttov_err_stat                      ! rttov error return code
  integer :: omp_get_num_threads
  integer :: nthreads,max_nthreads
  integer :: sensor_id, iobs
  integer :: instrum, count_profile
  integer :: profile_index, tb_index
  integer :: sensor_type   ! sensor type (1=infrared; 2=microwave; 3=high resolution, 4=polarimetric)

  integer, allocatable :: iptobs          (:)  
  integer :: errorstatus 

  real*8, allocatable :: surfem1       (:) 
  type (rttov_emissivity), allocatable :: emissivity_local (:)
  type (rttov_emissivity), allocatable :: emissivity_ad (:)
  type (rttov_transmission) :: transmission,transmission_ad
  type (rttov_radiance) :: radiancedata_ad, radiancedata_d
  
  type(rttov_profile)   , allocatable :: profilesdata_ad (:) ! ad profiles buffer used in rttov calls
  type(rttov_chanprof)  , allocatable :: chanprof(:)
  logical              :: init
  integer :: asw
  logical, allocatable :: calcemis  (:)
         
  if (tvs_nobtov == 0) return      ! exit if there are not tovs data


!     1.  Get number of threads available and allocate memory for some variables
!     .   ---------------------------------------------------------------------- 
!          
 
!$omp parallel 
  max_nthreads = omp_get_num_threads()
!$omp end parallel

  allocate ( iptobs(tvs_nobtov) )

!
!     2.  Computation of adjoint hx for tovs data only
!     .   --------------------------------------------

! Loop over all sensors specified by user

  sensor_loop:do  sensor_id = 1, tvs_nsensors

     nlevels=tvs_coefs(sensor_id) %coef % nlevels
     sensor_type = tvs_coefs(sensor_id) % coef% id_sensor
     instrum = tvs_coefs(sensor_id) % coef% id_inst
     
!  loop over all obs.

     count_profile = 0
     obs_loop: do iobs = 1, tvs_nobtov

!    Currently processed sensor?

        if ( tvs_lsensor(iobs) == sensor_id ) then
           count_profile = count_profile + 1
           iptobs(count_profile) = iobs
        endif
     enddo obs_loop

     if (count_profile == 0) cycle sensor_loop

!     .  2.1  Calculate the actual number of threads which will be used.
!     .       ----------------------------------------------------------

      nthreads = min(max_nthreads, count_profile )  

!     .  2.2  Prepare all input variables required by rttov_ad.
!     .       ---------------------------------------------------------
     

!     compute the number of radiances/tbs to be calculated
      count_tb = tvs_countRadiances(iptobs, count_profile, lobsSpaceData)

      if (count_tb == 0) cycle sensor_loop

      alloc_status(:)=0
      allocate ( chanprof     (count_tb)        ,stat=alloc_status(1))
      allocate ( emissivity_local (count_tb)    ,stat=alloc_status(2))
      allocate ( emissivity_ad(count_tb)        ,stat=alloc_status(3))
      allocate ( calcemis     (count_tb)        ,stat=alloc_status(4))
      allocate ( surfem1      (count_tb)        ,stat=alloc_status(5))
      allocate ( profilesdata_ad(count_profile) ,stat=alloc_status(6))
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad")
      
!     get Hyperspectral IR emissivities
      
      if ( tvs_isInstrumHyperSpectral(instrum) )  call tvs_getHIREmissivities(sensor_id, iptobs, count_profile, lobsSpaceData, surfem1)

! Build the list of channels/profiles indices

      call TVS_getChanprof(sensor_id, iptobs, count_profile, lobsSpaceData, chanprof)
!     get non Hyperspectral IR emissivities
      call tvs_getOtherEmissivities(chanprof, iptobs, count_tb, sensor_type, instrum, surfem1, calcemis)

      emissivity_local(:)%emis_in = surfem1(:)
        
      ! allocate transmittance structures
      asw=1
      init=.true.
      call rttov_alloc_transmission(alloc_status(1), transmission, nlevels=nlevels,      &
           nchanprof=count_tb, asw=asw, init=init)
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad transmittances")

      call rttov_alloc_transmission(alloc_status(1), transmission_ad, nlevels=nlevels,   &
           nchanprof=count_tb, asw=asw, init=init)
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad transmittances ad")
      

         ! allocate radiance structures

      call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_d, nlevels, asw)
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances")
      call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_ad, nlevels, asw)
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances ad")

         ! allocate profile structures
         
      call rttov_alloc_prof (alloc_status(1), count_profile, profilesdata_ad, nlevels, &
           tvs_opts(sensor_id), asw=asw, coefs=tvs_coefs(sensor_id), init=init)
      call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances ad")

      call rttov_init_prof(profilesdata_ad(1:count_profile) )

      call rttov_init_rad( radiancedata_d )
     !.. fill radiancedata_ad_th arrays

      call rttov_init_rad( radiancedata_ad )
!

!     .  2.3  Compute ad radiance with rttov_ad
!     .       ---------------------------------

      errorstatus  = 0
      emissivity_ad(:)%emis_in = 0.0d0
      emissivity_ad(:)%emis_out = 0.0d0

      call tmg_start(84,'rttov_ad')
      call rttov_parallel_ad(        &
           errorstatus,              & ! out
           chanprof,                 & ! in
           tvs_opts(sensor_id),      & ! in
           tvs_profiles(iptobs(1:count_profile)), & ! in
           profilesdata_ad,          & ! in
           tvs_coefs(sensor_id),     & ! in
           transmission,             & ! inout
           transmission_ad,          & ! inout
           radiancedata_d,           & ! inout
           radiancedata_ad,          & ! inout
           calcemis=calcemis,           & ! in
           emissivity=emissivity_local, & ! inout
           emissivity_ad=emissivity_ad, & ! inout
           nthreads = nthreads )

      if (errorstatus /= 0) then
         Write(*,*) "Error in rttov_parallel_ad", errorstatus
         call utl_abort('tovs_rttov_ad')
      endif

     call tmg_stop(84)

     !.. store results from rttov_ad into profiles_ad

     do tb_index = 1, count_tb
        profile_index = chanprof(tb_index)%prof
        iobs = iptobs(profile_index)
        profiles_ad(iobs) % t(:)      =  profilesdata_ad(profile_index) % t(:)
        profiles_ad(iobs) % q(:)      =  profilesdata_ad(profile_index) % q(:)
        profiles_ad(iobs) % skin % t  =  profilesdata_ad(profile_index) % skin % t 
        profiles_ad(iobs) % s2m % t   =  profilesdata_ad(profile_index) % s2m % t
        profiles_ad(iobs) % s2m % q   =  profilesdata_ad(profile_index) % s2m % q
        profiles_ad(iobs) % s2m % p   =  profilesdata_ad(profile_index) % s2m % p
        profiles_ad(iobs) % s2m % u   =  profilesdata_ad(profile_index) % s2m % u
        profiles_ad(iobs) % s2m % v   =  profilesdata_ad(profile_index) % s2m % v
     enddo

    
!     de-allocate memory

     asw=0 ! 1 to allocate,0 to deallocate

     call rttov_alloc_transmission(alloc_status(1), transmission, nlevels=nlevels,      &
          nchanprof=count_tb, asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad transmittances", .false.)

     call rttov_alloc_transmission(alloc_status(1), transmission_ad, nlevels=nlevels,   &
          nchanprof=count_tb, asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad transmittances ad", .false.)
         
     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_d, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances", .false.)

     call rttov_alloc_rad (alloc_status(1), count_tb, radiancedata_ad, nlevels, asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances ad", .false.)

     call rttov_alloc_prof (alloc_status(1), count_profile, profilesdata_ad, nlevels, &
          tvs_opts(sensor_id), asw=asw)
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad radiances ad", .false.)

     alloc_status(:) = 0
     deallocate ( profilesdata_ad ,stat=alloc_status(1))
     deallocate ( chanprof        ,stat=alloc_status(2))
     deallocate ( emissivity_local,stat=alloc_status(3))
     deallocate ( emissivity_ad   ,stat=alloc_status(4))
     deallocate ( calcemis        ,stat=alloc_status(5))
     deallocate ( surfem1         ,stat=alloc_status(6))
     call utl_checkAllocationStatus(alloc_status, " tovs_rttov_ad", .false.)
    
  enddo sensor_loop

!     3.  Close up
!     .   --------

deallocate ( iptobs )

end subroutine tovs_rttov_ad
