!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE oda_sumJo(lobsSpaceData,PJO)
      use masks_mod
      use mpi
      use obsSpaceData_mod
      implicit none
      real*8 pjo ! Total observation cost function
c
c Purpose:
c Compute the sum of Jo contributions saved in ROBDATA8(NCM_OMI,*)
c Also, compute contribution of each family of observation (for
c diagnostic purposes)
c
c Author  : S. Pellerin *ARMA/MRB January 2009
c
c Revision:
c L. Fillion, ARMA/EC, 5 Jun 2009. Introduce 1 Obs experiment.
c
c S. Macpherson, ARMA 14 Sep 2009. Add ground-based GPS (ZTD).
C  Bin He   *ARMA/MRB  Oct.  2009
C         -- Implement MPI to 3DVAR
c L. Fillion, ARMA/EC, 11 May 2010. Limit printout to processor 0.
c L. Fillion, ARMA/EC, 20 May 2010. Relocate call to restore_robdata8
C              and correct bug ROBDATA8(NCM_OMI,JDATA)

#include "comlun.cdk"
#include "cvcord.cdk"
*
      type(struct_obs) :: lobsSpaceData
      INTEGER IBEGIN,ILAST,ILASTOB,IBEGINOB,IDATEND
      INTEGER J,JDATA,JO,IDATA,ITYP,indata,numbody_max
      LOGICAL LLOK
      logical, pointer,dimension(:) :: llmask

      real*8,target :: dljoraob,dljoairep,dljosatwind,dljosurfc,dljotov
      real*8,target :: dljoprof,dljogpsro,dljogpsztd
      real*8 :: dlsum1
      real*8, pointer :: dlsum
C
      !logical,allocatable, dimension(:) :: lmask_g 
      real*8,allocatable, dimension(:) :: ROBDATA8_g  
      integer :: ierr 
C Compute the observation cost function value based on the sequence of
c the data array
C 
      numbody_max=obs_numbody_max(lobsSpaceData)
      ALLOCATE(ROBDATA8_g(numbody_max),STAT=ierr)
      IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to ROBDATA_g')


        CALL restore_robdata8(robdata8_g,numbody_max)  
         pjo = pjo + sumJo(1,numbody_max,lmask_g)
c
c       Compute family contributions for diagnostic purposes
c       The remaining of the code has no effect on the minimization
c
        dljogpsztd = 0.d0
        dljoraob = 0.d0
        dljoairep = 0.d0
        dljosatwind = 0.d0
        dljosurfc = 0.d0
        dljotov = 0.d0
        dljogpsro = 0.d0
        dljoprof = 0.d0

        DO J = 1,NFILES
      !bhe  IF (NBEGINTYP(J) .GT. 0)THEN
          select case(CFAMTYP(J))
            case('UA')
              ! llmask = lmaskpp_in .or. lmaskpp_out
              llmask => lmaskpp_inout_g(1:numbody_max)
              dlsum1 = sumJo(nbegintyp_g(j),nendtyp_g(j),llmask)
              dljoraob = dljoraob + dlsum1

              llmask => lmasksf_inout_g(1:numbody_max)
              dlsum => dljosurfc
            case('AI')
              llmask => lmaskpp_inout_g(1:numbody_max)
              dlsum => dljoairep
            case('SW')
              llmask => lmaskpp_inout_g(1:numbody_max) 
              dlsum => dljosatwind
            case('SF','SC')
              llmask => lmasksf_inout_g(1:numbody_max) 
              dlsum => dljosurfc
            case('TO')
              llmask => lmaskto_g(1:numbody_max)
              dlsum => dljotov
            case('RO')
              llmask => lmaskro_g(1:numbody_max)
              dlsum => dljogpsro
            case('PR')
              llmask => lmaskzp_g(1:numbody_max)
              dlsum => dljoprof
            case('GP')
              llmask => lmaskgp_g(1:numbody_max)
              dlsum1 = sumJo(nbegintyp_g(j),nendtyp_g(j),llmask)
              dljogpsztd = dljogpsztd + dlsum1
              llmask = lmasksf_inout_g(1:numbody_max) 
              dlsum => dljosurfc
          end select
          dlsum1 = sumJo(nbegintyp_g(j),nendtyp_g(j),llmask)
          dlsum = dlsum + dlsum1
        end do
!
        IF(mpi_myid == 0) THEN
          write(nulout,'(a15,f23.16)') 'Jo(RAOB)   = ',DLJORAOB
          write(nulout,'(a15,f23.16)') 'Jo(AIREP)  = ',DLJOAIREP
          write(nulout,'(a15,f23.16)') 'Jo(SURFC)  = ',DLJOSURFC
          write(nulout,'(a15,f23.16)') 'Jo(ATOV)   = ',DLJOTOV
          write(nulout,'(a15,f23.16)') 'Jo(SATWIND)= ',DLJOSATWIND
          write(nulout,'(a15,f23.16)') 'Jo(PROF)   = ',DLJOPROF
          write(nulout,'(a15,f23.16)') 'Jo(GPSRO)  = ',DLJOGPSRO
          write(nulout,'(a15,f23.16)') 'Jo(GPSZTD) = ',DLJOGPSZTD
        endif 
        DEALLOCATE(robdata8_g) 
!
      contains

      function sumJo(kbegin,klast,ll_mask)
*
      real*8  :: sumJo
      integer, intent(in) :: kbegin,klast
      logical, intent(in),dimension(numbody_max) :: ll_mask
*
*     Local variables
*
      integer :: jdata
      sumJo = 0.d0
      DO JDATA=kbegin,klast
        IF (ll_mask(jdata)) THEN
          sumJo = sumJo + ROBDATA8_g(JDATA)
        ENDIF
      END DO
      return
      END function sumJo

      SUBROUTINE restore_robdata8(robdata8_g,kdata)
       INTEGER :: kdata 
       REAL*8 ,DIMENSION(kdata) :: robdata8_g

       INTEGER :: bodyIndex_mpilocal,bodyIndex_mpiglobal,ierr  

       robdata8_g=0.0D0  
       DO bodyIndex_mpilocal=1,obs_numbody(lobsSpaceData)
         bodyIndex_mpiglobal=obs_elem_i(lobsSpaceData,'GBI ',bodyIndex_mpilocal)
         robdata8_g(bodyIndex_mpiglobal)=obs_elem_r(lobsSpaceData,'OMI ',bodyIndex_mpilocal)
       ENDDO  
       CALL rpn_comm_allreduce(ROBDATA8_g,ROBDATA8_g,kdata,"MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr) 

      END SUBROUTINE restore_robdata8

      end subroutine oda_sumJo
