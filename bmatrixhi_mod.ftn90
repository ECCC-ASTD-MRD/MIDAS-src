!--------------------------------------------------------------------------
! MODULE bMatrixHI (Background-error Covariance Matrix estimated
!                       using lagged forecast differences or ensemble 
!                       members and based on horizontally homogeneous/isotropic
!                       correlations.  prefix="bhi")
!
! Purpose: Performs transformation from control vector to analysis increment 
!          using the spatially localized ensemble covariance matrix
!
! Subroutines:
!    bhi_setup (public)
!    bhi_BSqrt (public)
!    bhi_BSqrtAd (public)
!    cain
!    cainAd
!
! Dependencies:
!    globalSpectralTransform
!--------------------------------------------------------------------------
MODULE BmatrixHI

  use MathPhysConstants_mod
  use gridStateVector_mod
  implicit none
  save
  private

  public             :: bhi_Setup,bhi_BSqrt,bhi_BSqrtAd

  logical            :: initialized = .false.
  integer            :: nj_l,ni_l
  integer            :: nflev_l,nkgdim_l,nksdim2_l
  integer            :: ntrunc_l,nla_l
  integer            :: cvDim_l
  integer            :: gstID,myid,myidx,myidy

  real*8             :: ra = 6371229.D0
  integer            :: nlev_bdl

  real*8,allocatable :: theta(:,:)
  real*8,allocatable :: PtoT(:,:,:)

  real*8,pointer     :: rgsig(:,:)
  real*8,pointer     :: rgsiguu(:,:),rgsigvv(:,:),rgsigtt(:,:),rgsigtb(:,:),rgsigq(:,:)
  real*8,pointer     :: rgsigps(:),rgsigpsb(:)
  real*8,allocatable :: tgstdbg(:,:)

  real*8,allocatable :: corns(:,:,:)
  real*8,allocatable :: rstddev(:,:)

  ! originally from common blocks and possibly from the namelist:
  integer,parameter  :: maxNumLevels=200
  real*8             :: scaleFactor(maxNumLevels)
  integer            :: ntoar = 3
  real*8             :: ralphatoar = 0.2
  integer            :: ntgcorrtyp=1
  real*8             :: rcscltg(1)=100000.
  logical            :: lbgsto=.false.
  real*8             :: rfacthum=1.0
  real*8             :: rlimsuptg=3.0
  logical            :: llimtg=.true.
  integer            :: nulbgst=0
  integer            :: nflevptot_l=79
  real*8             :: rvlocbalt   = 6.0
  real*8             :: rvlocpsi    = 6.0
  real*8             :: rvlocchi    = 6.0
  real*8             :: rvlocpsitt  = 6.0
  real*8             :: rvlocunbalt = 4.0
  real*8             :: rvloclq     = 4.0
  integer            :: nlatmin1    = 40
  integer            :: nlatmax1    = 50
  integer            :: nlatmin2    = 71
  integer            :: nlatmax2    = 81
  real*8             :: rlimlv_bdl  = 85000.0

  ! this should come from state vector object
  integer            :: numvar3d
  integer            :: numvar2d
  integer            :: nspositVO 
  integer            :: nspositDI 
  integer            :: nspositTT 
  integer            :: nspositQ
  integer            :: nspositPS 
  integer            :: nspositTG
  real*8,allocatable :: pressureProfile(:)

  ! constants
  real*8             :: rday
  real*8             :: rsiyea
  real*8             :: rsiday
  real*8             :: romega


CONTAINS

  SUBROUTINE BHI_setup(NI_IN,NJ_IN,NFLEV_IN,pressureProfile_in,CVDIM_OUT)
    use globalSpectralTransform
    implicit none

    integer        :: ni_in,nj_in,nflev_in
    integer        :: cvDim_out
    real*8         :: pressureProfile_in(nflev_in)

    integer        :: ntrunc,gensize,jlev,mpiMode,nulnam,ierr,fnom,fclos
    logical        :: llfound

    !namelist
    NAMELIST /NAMBHI/ntrunc,scaleFactor

    ! parameters set from the ensemble member files
    ntrunc=108
    scaleFactor(:)=0.0d0

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    write(*,*) 'bhi_setup: reading namelist, ierr=',ierr
    read(nulnam,nml=nambhi)
    write(*,nml=nambhi)
    ierr=fclos(nulnam)

    do jlev=1,nflev_in
      if(scaleFactor(jlev).gt.0.0d0) then 
        scaleFactor(jlev)=sqrt(scaleFactor(jlev))
      else
        scaleFactor(jlev)=0.0d0
      endif
    enddo

    CALL rpn_comm_mype(myid,myidx,myidy) 

    allocate(pressureProfile(nflev_in))
    pressureProfile(:)=pressureProfile_in(:)

    ! some constants
    RDAY=86400.D0
    RSIYEA=365.25D0*RDAY*2.*MPC_PI_R8/6.283076D0
    RSIDAY=RDAY/(1.D0+RDAY/RSIYEA)
    ROMEGA=2.D0*MPC_PI_R8/RSIDAY

    ! this should come from the state vector object
    nspositVO=1
    nspositDI=1*nflev_in+1
    nspositTT=2*nflev_in+1
    nspositQ =3*nflev_in+1
    nspositPS=4*nflev_in+1
    nspositTG=4*nflev_in+2
    numvar3d = 4
    numvar2d = 2

    nflev_l=nflev_in
    nkgdim_l=numvar3d*nflev_l+numvar2d 
    nksdim2_l=nkgdim_l+nflev_l

    ntrunc_l=ntrunc
    nla_l=(ntrunc_l+1)*(ntrunc_l+2)/2
    
    ni_l=ni_in
    nj_l=nj_in

    mpiMode=0
    gstID = gst_setup(6,ni_l,nj_l,ntrunc_l,mpiMode)
    write(*,*) 'BHI:returned value of gstID=',gstID

    cvDim_l=((ntrunc_l+1)*(ntrunc_l+2)-ntrunc_l-1)*nkgdim_l
    cvDim_out=cvDim_l

    allocate(PtoT(nflev_l+1,nflev_l,nj_l))
    allocate(theta(nflev_l,nj_l))
    allocate(rgsig(nj_l,nkgdim_l))
    allocate(tgstdbg(ni_l,nj_l))
    rgsiguu => rgsig(1:nj_l,           1 :   nflev_l)
    rgsigvv => rgsig(1:nj_l,   nflev_l+1 : 2*nflev_l)
    rgsigtt => rgsig(1:nj_l, 2*nflev_l+1 : 3*nflev_l)
    rgsigq  => rgsig(1:nj_l, 3*nflev_l+1 : 4*nflev_l)
    rgsigps => rgsig(1:nj_l, 4*nflev_l+1)
    allocate(rgsigtb(nj_l,nflev_l))
    allocate(rgsigpsb(nj_l))
    allocate(corns(nksdim2_l,nksdim2_l,0:ntrunc_l))
    allocate(rstddev(nksdim2_l,0:ntrunc_l))

    llfound = .false.
    nlev_bdl=0
    do jlev = 1, nflev_l
      if(.not.llfound .and. (pressureProfile(jlev) .ge. rlimlv_bdl  )) then
        nlev_bdl = jlev
        llfound = .true.
      endif
    enddo
    !write(*,*) 'NLEV_BDL=',nlev_bdl
    call flush(6)

    call BHI_sunewstats
    call BHI_sucorns2
    write(*,*) 'END OF BHI_SETUP'
    call flush(6)

    initialized = .true.

  END SUBROUTINE BHI_setup


  SUBROUTINE BHI_SUNEWSTATS
    implicit none

    integer ierr,iulbgsto
    integer fnom,fstouv,fstfrm,fclos
    logical lExists
    character(len=8) :: bFileName = './glbcov'

    !write(*,*) 'SUNEWSTAT: set-up of the background error statistics'

    inquire(file=bFileName,exist=lExists)
    IF ( lexists )then
      ierr=fnom(nulbgst,bFileName,'RND+OLD+R/O',0)
      if ( ierr .eq. 0 ) then
        !write(6,*) 'IBGST - File :', bFileName
        !write(6,*) ' opened as unit file ',nulbgst
        ierr =  fstouv(nulbgst,'RND+OLD')
      else
        write(*,*) 'SUFILNAM:NO BACKGROUND STAT FILE!!'
        call exit(1)
      endif
    endif

    iulbgsto = 0
    if(lbgsto) then
      ierr = fnom(iulbgsto,'newstat_modular1','RND',0)
      ierr = fstouv(iulbgsto,'RND')
    endif

    call BHI_rdspptot(iulbgsto)

    !write(*,*) 'SUNEWSTATS: READING CORNS'
    call BHI_readcorns2(iulbgsto)

    call BHI_sutg(nulbgst)

    call BHI_rdspstd(iulbgsto)

    call BHI_scalestd

    if(lbgsto) then
      ierr = fstfrm(iulbgsto)
      ierr = fclos (iulbgsto)
    endif

    return
  END SUBROUTINE BHI_SUNEWSTATS


  SUBROUTINE BHI_scalestd
    implicit none

    integer jlev,jlon,jlat

    do jlev=1,nflev_l
      do jlat=1,nj_l
        rgsiguu(jlat,jlev)=scaleFactor(jlev)*rgsiguu(jlat,jlev)
        rgsigvv(jlat,jlev)=scaleFactor(jlev)*rgsigvv(jlat,jlev)
        rgsigtt(jlat,jlev)=scaleFactor(jlev)*rgsigtt(jlat,jlev)
        rgsigq(jlat,jlev) =scaleFactor(jlev)*rgsigq(jlat,jlev)
        rgsigtb(jlat,jlev)=scaleFactor(jlev)*rgsigtb(jlat,jlev)
      enddo
    enddo
    do jlat=1,nj_l
      rgsigpsb(jlat)=scaleFactor(nflev_l)*rgsigpsb(jlat)
      rgsigps(jlat) =scaleFactor(nflev_l)*rgsigps(jlat)
    enddo
    do jlat=1,nj_l
      do jlon=1,ni_l
        tgstdbg(jlon,jlat)=scaleFactor(nflev_l)*tgstdbg(jlon,jlat)
      enddo
    enddo

  END SUBROUTINE BHI_scalestd


  SUBROUTINE BHI_SUCORNS2
    use globalSpectralTransform
    implicit none

    real*8 eigenv(nksdim2_l), eigen(nksdim2_l,nksdim2_l),eigen2(nksdim2_l,nksdim2_l)
    real*8 sqrtin(nksdim2_l,nksdim2_l),sqrtin2(nksdim2_l,nksdim2_l)

    integer ij,ii,ii2,in,jk1,jk2,jr
    integer ier,ilwork,info,klatptot
    integer iulcorvert, ikey

    real*8 result2(nksdim2_l,nkgdim_l),zwork(2*4*nksdim2_l)
    real*8 ztt(nflev_l,nflev_l,(ntrunc_l+1)),ztpsi(nflev_l,nflev_l,(ntrunc_l+1))
    real*8 ztlen,zcorr,zr,zpres1,zpres2
    real*8 zfact,zfact2,zcoriolis,zpsips(nflev_l)
    real*8 zpsi(nflev_l,nflev_l),zfacttb(nj_l,nflev_l),zfactpsb(nj_l)
    real*8 corvert(nksdim2_l,nksdim2_l)
    logical lldebug

    ! standard file variables
    integer ini,inj,ink, inpas, inbits, idatyp, ideet     &
           ,ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf  &
           ,iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas,ntrials
    integer iliste(100),idate(100),idimax,infon,iheures,idateo
    character(len=2)  :: cltypvar
    character(len=1)  :: clgrtyp
    character(len=4)  :: clnomvar
    character(len=12) :: cletiket
    integer vfstlir,vfstecr,fstprm,fstinf
    integer fnom,fstouv,fstfrm,fclos

    external dsyev

    lldebug = .false.

    !write(6,*)'  **********************************'
    !write(6,*)'  SUCORNS2 --- Calculate CORNS^(0.5)'

    ilwork=4*nksdim2_l*2
    iulcorvert = 0
    if(myid==0) then
      ierr = fnom(iulcorvert,'corvert_modular.fst','RND',0)
      ierr = fstouv(iulcorvert,'RND')
    endif

    klatptot=1
    zfactpsb(:)=0.0d0
    zfacttb(:,:)=0.0d0

    !write(*,*) 'KLATPTOT=',klatptot

    if(lldebug) then
      do ii=1,nflev_l
        do ii2=1,nflevptot_l
          write(622,*) ii,ii2,klatptot,ptot(ii,ii2,klatptot)
        enddo
      enddo
    endif

    ! explicitly compute the balanced temperature and temperature-psi correlations

    do in=0,ntrunc_l

      do ij=1,nksdim2_l
         do ii=1,nksdim2_l
            eigen(ii,ij)=0.0
         enddo
      enddo
      do ij=1,nflev_l
         do ii=1,nflev_l
            ztpsi(ii,ij,in+1)=0.0
            ztt(ii,ij,in+1)=0.0
         enddo
      enddo
      do ij=1,nflevptot_l
        do ii=1,nflev_l
          do ii2=1,nflevptot_l
            ztpsi(ii,ij,in+1)=ztpsi(ii,ij,in+1)+ptot(ii,ii2,klatptot)*corns(ii2,ij,in)
          enddo
        enddo
      enddo
      if(nflevptot_l.lt.nflev_l) then
        do ij=(nflevptot_l+1),nflev_l
          do ii=1,nflev_l
            ztpsi(ii,ij,in+1)=ztpsi(ii,nflevptot_l,in+1)
          enddo
        enddo
      endif
      do ij=1,nflev_l
        do ii=1,nflev_l
          do ii2=1,nflevptot_l
            ztt(ii,ij,in+1)=ztt(ii,ij,in+1)+ztpsi(ii,ii2,in+1)*ptot(ij,ii2,klatptot)
          enddo
        enddo
      enddo
    enddo

    if(lldebug) then
      write(620,*) ztt
      write(621,*) ztpsi
    endif

    ! fill in blocks for balance temperature

    do in=0,ntrunc_l
      do ij=1,nflev_l
        do ii=1,nflev_l
          corns(nkgdim_l+ii,nkgdim_l+ij,in)=ztt(ii,ij,in+1)
          corns(       ii,nkgdim_l+ij,in)=ztpsi(ij,ii,in+1)
          corns(nkgdim_l+ii,       ij,in)=ztpsi(ii,ij,in+1)
        enddo
      enddo
    enddo

    ! Save un-localized PSI correlations
    do jk2 = 1, nflev_l
      do jk1 = 1, nflev_l
        zpsi(jk1,jk2) = 0.0
        do in = 0, ntrunc_l
          zpsi(jk1,jk2) = zpsi(jk1,jk2)+((2*in+1)*corns(jk1,jk2,in))
        enddo
      enddo
    enddo

    ! Apply vertical localization to corrns

    ! unbalanced temperature
    ztlen=rvlocunbalt
    !write(*,*)'sucorns2:ztlen(UNBALT)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        zpres1=log(pressureProfile(jk1))
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1+2*nflev_l,jk2+2*nflev_l,in)  =   &
                 corns(jk1+2*nflev_l,jk2+2*nflev_l,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! balanced temperature
    ztlen=rvlocbalt
    !write(*,*)'sucorns2:ztlen(BALT)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        zpres1=log(pressureProfile(jk1))
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1+nkgdim_l,jk2+nkgdim_l,in)  =        &
                 corns(jk1+nkgdim_l,jk2+nkgdim_l,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! streamfunction 
    ztlen= rvlocpsi    ! specify length scale (in units of ln(Pressure))
    !write(*,*)'sucorns2:ztlen(PSI)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        zpres1=log(pressureProfile(jk1))
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1,jk2,in)  =corns(jk1,jk2,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! temp-psi cross-correlations
    ztlen= rvlocpsitt    ! specify length scale (in units of ln(Pressure))
    !write(*,*)'sucorns2:ztlen(PSI-TT)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        zpres1=log(pressureProfile(jk1))
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1,jk2+nkgdim_l,in)=corns(jk1,jk2+nkgdim_l,in)*zcorr
            corns(jk1+nkgdim_l,jk2,in)=corns(jk1+nkgdim_l,jk2,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! velocity potential (unbalanced)
    ztlen= rvlocchi    ! specify length scale (in units of ln(Pressure))
    !write(*,*)'sucorns2:ztlen(CHI)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        if(jk1.gt.nflev_l) then
          zpres1=log(pressureProfile(nflev_l))
        else
          zpres1=log(pressureProfile(jk1))
        endif
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1+nflev_l,jk2+nflev_l,in)  =corns(jk1+nflev_l,jk2+nflev_l,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! cross-correlation t'-ps'
    if(.true.) then
    ztlen= rvlocunbalt    ! specify length scale (in units of ln(Pressure))
    !write(*,*)'sucorns2:ztlen(UNBALT)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        if(jk1.gt.nflev_l) then
          zpres1=log(pressureProfile(nflev_l))
        else
          zpres1=log(pressureProfile(jk1))
        endif
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            if(jk1.eq.nflev_l) then
              corns(1+4*nflev_l,jk2+2*nflev_l,in)  =       &
                   corns(1+4*nflev_l,jk2+2*nflev_l,in)*zcorr
              corns(jk2+2*nflev_l,1+4*nflev_l,in)  =       &
                   corns(jk2+2*nflev_l,1+4*nflev_l,in)*zcorr
            endif
          enddo
        enddo
      enddo
    endif
    endif

    ! humidity
    ztlen= rvloclq    ! specify length scale (in units of ln(Pressure))
    !write(*,*)'sucorns2:ztlen(LQ)= ',ztlen
    if(ztlen.gt.0.0) then
      ! calculate 5'th order function (from Gaspari and Cohn)
      do jk1=1,nflev_l
        if(jk1.gt.nflev_l) then
          zpres1=log(pressureProfile(nflev_l))
        else
          zpres1=log(pressureProfile(jk1))
        endif
        do jk2=1,nflev_l
          zpres2=log(pressureProfile(jk2))
          zr = abs(zpres2 - zpres1)
          zcorr=gasparicohn(ztlen,zr)
          do in=0,ntrunc_l
            corns(jk1+3*nflev_l,jk2+3*nflev_l,in)  =       &
                 corns(jk1+3*nflev_l,jk2+3*nflev_l,in)*zcorr
          enddo
        enddo
      enddo
    endif

    ! compute total vertical correlations (including for balanced temperature)
    if(.true.) then
      do jk2 = 1, nksdim2_l
        do jk1 = 1, nksdim2_l
          corvert(jk1,jk2) = 0.0
          do in = 0, ntrunc_l
            corvert(jk1,jk2) = corvert(jk1,jk2)+((2*in+1)*corns(jk1,jk2,in))
          enddo
        enddo
        !if(jk2.ge.320 .and. jk2.le. 400) then
        !  print*,'corvert:jk2,corvert(jk2,jk2)= ',jk2,corvert(jk2,jk2)
        !endif
      enddo

      if(lldebug) then
        write(701,*) corvert
        write(702,*) zpsi
      endif

      if(myid == 0) then
        ikey =fstinf(NULBGST,ini,inj,ink,-1,'CORRNS',-1,0,-1,' ','ZZ')
        ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits        &
             ,idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp      &
             ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2      &
             ,iextr3)

        ini = nksdim2_l
        inj = nksdim2_l
        ink = 1
        ip1 = 0
        ip2 = ntrunc_l
        ip3 = 0
        clnomvar= 'ZV'
        cletiket= 'CORVERT'
        idatyp  = 5

        ierr = vfstecr(corvert, corvert, -inbits, iulcorvert, idateo    &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,      &
             .true.)
        ! WHY IS THIS READ IN AGAIN AFTER JUST WRITING IT?????????????
        !ierr = vfstlir(corvert,iulcorvert,INI,INJ,INK    &
        !   ,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        do jk2 = 1, nksdim2_l
          !if(jk2.ge.320 .and. jk2.le. 400) then
          !  print *,'corvert lire:jk2,corvert(jk2,jk2)= ',jk2,corvert(jk2,jk2)
          !endif
        enddo

      endif

      ! Modify RGSIGTB to obtain correct sigma_Tb
      do jk1=1,nflev_l          
        zfact=corvert(jk1+nkgdim_l,jk1+nkgdim_l)
        do ij=1,nj_l
          zcoriolis = abs(2.*romega*gst_getrmu(ij))
          if(zfact.gt.0.0.and.zcoriolis.ne.0.0) then
            zfact2=1/(zfact*zcoriolis*zcoriolis)
          else 
            zfact2=0.0
          endif
          zfacttb(ij,jk1)=zfacttb(ij,jk1)+zfact2
        enddo
      enddo

      ! Modify RGSIGPSB to obtain correct sigma_PSb
      do ij=1,nj_l
        do jk2=1,nflevptot_l
          zpsips(jk2)=0.0d0
          do jk1=1,nflevptot_l
            zpsips(jk2)=zpsips(jk2)+ptot(nflev_l+1,jk1,klatptot)*zpsi(jk1,jk2)
          enddo
        enddo
        zfact=0.0d0
        do jk1=1,nflevptot_l
          zfact=zfact+ptot(nflev_l+1,jk1,klatptot)*zpsips(jk1)
        enddo
        zcoriolis = abs(2.*romega*gst_getrmu(ij))
        if(zfact.gt.0.0.and.zcoriolis.ne.0.0) then
          zfact2=1/(zfact*zcoriolis*zcoriolis)
        else 
          zfact2=0.0
        endif
        zfactpsb(ij)=zfactpsb(ij)+zfact2
      enddo
    endif

    ! Modify RGSIGTB and RGSIGPSB to obtain correct sigma_Tb and sigma_Psb
    do ij=1,nj_l
      if(zfactpsb(ij).gt.0.0) then
        rgsigpsb(ij)=rgsigpsb(ij)*sqrt(zfactpsb(ij))
      else
        rgsigpsb(ij)=0.0
      endif          
      do jk1=1,nflev_l
        if(zfacttb(ij,jk1).gt.0.0) then
          rgsigtb(ij,jk1)=rgsigtb(ij,jk1)*sqrt(zfacttb(ij,jk1))
        else
          rgsigtb(ij,jk1)=0.0
        endif
      enddo
    enddo

    ! compute square-root of corns
    do in=0,ntrunc_l
      do ij=1,nksdim2_l
         do ii=1,nksdim2_l
            eigen(ii,ij)=corns(ii,ij,in)
         enddo
      enddo

      ! CALCULATE EIGENVALUES AND EIGENVECTORS.
      call dsyev('V','U',nksdim2_l,eigen,nksdim2_l,eigenv,zwork,ilwork,info)

      do ii=1,nksdim2_l
        if(eigenv(ii).lt.1.0d-15) then
          sqrtin(ii,ii) = 0.0
        else
          sqrtin(ii,ii)=sqrt(eigenv(ii))
        endif
        !if(in.eq.12) write(*,*) 'SUCORNS2: E-VALUES=',ii,eigenv(ii)
      enddo
 
      ! Reverse the order of E-values and vectors
      do ij=1,nksdim2_l
        sqrtin2(ij,ij)=sqrtin(nksdim2_l-ij+1,nksdim2_l-ij+1)            
        do ii=1,nksdim2_l
          eigen2(ii,ij) =eigen(ii,nksdim2_l-ij+1)            
        enddo
      enddo

      do ij=1,nksdim2_l
         do ii=1,nksdim2_l
            corns(ii,ij,in)=0.0
            result2(ii,ij)=eigen2(ii,ij)*sqrtin2(ij,ij)
         enddo
      enddo

      do ij=1,nkgdim_l
         do ii=1,nksdim2_l
            corns(ii,ij,in)=result2(ii,ij)
         enddo
      enddo

    enddo

    if(myid==0) then
      ierr = fstfrm(iulcorvert)
    endif

    return
  END SUBROUTINE BHI_SUCORNS2


  FUNCTION GASPARICOHN(ztlen,zr)

    real*8  :: gasparicohn
    real*8  :: ztlen,zr,zlc

    zlc=ztlen/2.0
    if(zr.le.zlc) then
      gasparicohn=-0.250*(zr/zlc)**5+0.5*(zr/zlc)**4             &
                  +0.625*(zr/zlc)**3-(5.0/3.0)*(zr/zlc)**2+1.0
    elseif(zr.le.(2.0*zlc)) then
      gasparicohn=(1.0/12.0)*(zr/zlc)**5-0.5*(zr/zlc)**4         &
                  +0.625*(zr/zlc)**3+(5.0/3.0)*(zr/zlc)**2       &
                  -5.0*(zr/zlc)+4.0-(2.0/3.0)*(zlc/zr)
    else
      gasparicohn= 0.0d0
    endif
    if(gasparicohn.lt.0.0) gasparicohn=0.0d0

  END FUNCTION GASPARICOHN


  SUBROUTINE BHI_CALCCORR(zgd,pcscl,klev,kcorrtyp)
    use globalSpectralTransform
    implicit none
    integer klev,kcorrtyp
    real*8 zgd(ni_l,klev,nj_l)
    real*8 pcscl(klev)

    integer  jlev, jgl, jlon
    real*8 zr
    real*8 dlalpha, dlfac, dltemp, dln, dlcsurn, dlc, dlcorr

    dlalpha = 1.d0*ralphatoar
    dlfac   = 1.d0/(1.d0+dlalpha)
    dln     = 1.d0*float(ntoar)
    dltemp  = (3.d0*(1.d0 + dlalpha))/(1.d0 + dlalpha/(dln*dln))
    dltemp  = dsqrt(dltemp)

    if (kcorrtyp.eq.1) then
      ! Gaussian correlation
      do  jlev = 1, klev
        dlc = 1.d0/dble(pcscl(jlev))
        dlc = 0.5*dlc*dlc
        do  jgl = 1, nj_l
          zr = ra * acos(gst_getRmu(jgl))
          dlcorr = dexp(-(zr**2)*dlc)
          do  jlon = 1, ni_l
            zgd(jlon,jlev,jgl) = dlcorr
          enddo
        enddo
      enddo
    elseif (kcorrtyp.eq.2) then
      ! Autoregressive (SOAR) correlation
      do jlev = 1, klev
        dlc = dltemp/dble(pcscl(jlev))
        dlcsurn = dlc/dln
        do jgl = 1, nj_l
          zr = ra * acos(gst_getRmu(jgl))
          dlcorr = (1.d0 + dlc*zr + zr*dlc*zr*dlc/3.d0)*dexp(-zr*dlc)    &
            + dlalpha*(1.d0 + dlcsurn*zr + zr*dlcsurn*zr*dlcsurn/3.d0)*dexp(-zr*dlcsurn)
          dlcorr = dlcorr*dlfac
          do jlon = 1, ni_l
            zgd(jlon,jlev,jgl) = dlcorr
          enddo
        enddo
      enddo
    else
      write(*,*) 'CALCCORR- Undefined correlation type'
      call exit(1)
    endif

    return
  END SUBROUTINE BHI_calcCorr


  SUBROUTINE BHI_SUTG(KULSSF)
    use globalSpectralTransform
    implicit none

    integer kulssf

    logical  llpb
    integer ikey, jlat, jlon, jla, ezgprm, igdgid, ezqkdef
    integer jn, jm, ila, inlev, itggid, inmxlev,ier, iset,numlev
    integer ezdefset, vezsint
    integer ip1style,ip1kind
    integer koutmpg
    real*8, allocatable :: dltg(:,:)
    real*8 cortgg(nla_l,2)
    real*8 zabs, zpole, zconst, dlfac, dlcorr
    real*8 zsp(nla_l,2,1),zgd(ni_l,1,nj_l)

    ! standard file variables
    integer ini,inj,ink, inpas, inbits, idatyp, ideet     &
           ,ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf  &
           ,iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas,ntrials
    integer iliste(100),idate(100),idimax,infon,iheures,idateo
    character*2 cltypvar
    character*1 clgrtyp
    character*4 clnomvar
    character*12 cletiket
    integer vfstlir,vfstecr,fstprm,fstinf


    !write(6,fmt='(8x,2A)')'SUTG- initialisation of TG background error variances'
    clnomvar='TG'
    idateo=-1
    inmxlev=1
    ntrials=1

    call getfldprm2(IP1,IP2,IP3,INLEV,CLETIKET,CLTYPVAR,ITGGID,       &
         clnomvar, idateo, inmxlev, kulssf, 6,ip1style,ip1kind,  &
         ntrials,koutmpg)

    ier = ezgprm(itggid,CLGRTYP,INI,INJ,IG1,IG2,IG3,IG4)
    allocate(dltg(ini,inj))

    !write(*,*)'reading TG variances'

    ikey = vfstlir(dltg,koutmpg,ini,inj,ink,idateo,cletiket,ip1,   &
           ip2, ip3, cltypvar, clnomvar)

    if(clgrtyp == 'G' .and. ni_l == ini .and. nj_l == inj .and. ig1 == 0  &
          .and. ig2 ==0 .and. ig3 == 0 .and.ig4 == 0) then

      do jlat = 1, nj_l
        do jlon = 1,ni_l
          tgstdbg(jlon,jlat) = dltg(jlon,nj_l-jlat+1)
        enddo
      enddo

    elseif(clgrtyp == 'G' .and. ni_l == ini .and. nj_l == inj .and. ig1 ==   &
            0 .and. ig2 ==1 .and. ig3 == 0 .and.ig4 == 0) then
      do jlat = 1, nj_l
        do jlon = 1,ni_l
          tgstdbg(jlon,jlat) = dltg(jlon,jlat)
        enddo
      enddo

    else

      ! Interpolate to a gaussian grid stored from North to South(IG2=1)
      igdgid = ezqkdef(ni_l, nj_l, 'G', 0, 1, 0, 0 ,0)
      iset = ezdefset(igdgid,itggid)
      ier = vezsint(tgstdbg,dltg,ni_l,nj_l,1,ini,inj,1)

    endif

    ! If specified in namelist Do not accept tg errors of more than  value specified in namelist
    if ( llimtg ) then
       where ( tgstdbg > rlimsuptg) tgstdbg = rlimsuptg
    endif

    zgd(:,:,:)=0.0d0
    zsp(:,:,:)=0.0d0

    do jla = 1, nla_l
       cortgg(jla,1) = 0.0
       cortgg(jla,2) = 0.0
    enddo

    ! 4.2  Compute correlations in physical space
    !write(*,*) ' SUTG. RCSCLTG    = ', RCSCLTG(1)
    !write(*,*) ' SUTG. NTGCORRTYP = ', NTGCORRTYP
    numlev=1
    call BHI_calccorr(zgd,rcscltg,numlev,ntgcorrtyp)

    ! 4.3  Bring back the result in spectral space
    call tmg_start(53,'REESPE') 
    call gst_reespe(zsp,zgd,1,1)
    call tmg_stop(53) 

    ! 4.4  Check positiveness
    llpb = .false.
    do jla=1,ntrunc_l+1
      zabs = abs(zsp(jla,1,1))
      llpb =llpb.or.((zsp(jla,1,1).lt.0.).and.(zabs.gt.MPC_PRECISION_OF_ZERO_R8))
    enddo
    if(llpb) then
      write(*,*)' AUTOCORRELATION  NEGATIVES'
      call exit(1)
    endif
    do jla = 1, ntrunc_l+1
      zsp(jla,1,1) = abs(zsp(jla,1,1))
    enddo

    zpole = 0.
    do  jla = 1, ntrunc_l+1
      jn = jla-1
      zpole = zpole + zsp(jla,1,1)*sqrt((2.*jn+1.)/2.)
    enddo
    if(zpole.le.0.) then
      write(*,*) 'POLE VALUE NEGATIVE IN SUTG'
      call exit(1)
    endif
    do jla = 1, ntrunc_l+1
      zsp(jla,1,1) = zsp(jla,1,1)/zpole
      zsp(jla,2,1) = zsp(jla,2,1)/zpole
    enddo

    !  4.5  Correlation
    zconst  = 1.e10
    do jm   = 0, ntrunc_l
      do jn   = jm, ntrunc_l
        jla  = gst_getNIND(jm) + jn - jm
        dlfac = 0.5/dsqrt((2*jn+1.d0)/2.d0)
        cortgg(jla,1) = dlfac * zsp(jn+1,1,1)
        cortgg(jla,2) = dlfac * zsp(jn+1,1,1)
      enddo
    enddo

    ! 5. For zonal modes : set to zero the imaginary part and set the correct factor 1.0 for the real part
    do jla = 1, ntrunc_l + 1
      cortgg(jla,1) = 0.5*cortgg(jla,1)
      cortgg(jla,2) = 0.0
    enddo

    ! 6. Result in corns array
    do jn = 0, ntrunc_l
      ila = jn + 1
      corns(nspositTG,nspositTG,jn) = 2.d0*cortgg(ila,1)
    enddo

    deallocate(dltg)
    !write(*,*)'DONE in SUTG'

    return
  END SUBROUTINE BHI_sutg


  SUBROUTINE BHI_convol
    use globalSpectralTransform
    implicit none

    integer inj,injmin
    parameter(injmin=120)
    real*8 dlfact2,dlc,dsummed
    real*8 dtlen,zr,dlfact
    integer ilen,jn,jlat,jk
    real*8 zlegi(0:ntrunc_l, nj_l),zleg(0:ntrunc_l, nj_l),zsp(0:ntrunc_l,nkgdim_l),zgr(nj_l,nkgdim_l)
    real*8 dlwti(nj_l),zrmu(nj_l)

    integer inracp
    real*8 zpg(nj_l),zsia(nj_l),zrad(nj_l),zpgssin2(nj_l)
    real*8 zsinm1(nj_l),zsinm2(nj_l),zsin2(nj_l),zsinlat(nj_l)
    real*8 dlfact1, dln
    real*8 dlnorm(0:ntrunc_l)

    real*8         :: RPORVO   = 6000.D3
    real*8         :: RPORDI   = 6000.D3
    real*8         :: RPORTT   = 3000.D3
    real*8         :: RPORQ    = 3000.D3
    real*8         :: RPORPS   = 3000.D3



! I don't understand why this commented code is needed
!    if (nj_l.ge.injmin) then
       inj=nj_l
       do jlat = 1, nj_l
          dlwti(jlat) = gst_getrwt(jlat)
          zrmu(jlat)  = gst_getrmu(jlat)
       end do
!    else
!       ! apply minimum length to legendre poly expansion.
!       inj=injmin
!       inracp=inj/2
!       call gauss8(inracp,zsinlat,zpg,zsia,zrad,zpgssin2,
!   1        zsinm1,zsinm2,zsin2)
!       do jn=1,inracp
!          zrmu(inracp+jn)=zsinlat(jn)
!          zrmu(jn)=-zsinlat(inracp+1-jn)
!          dlwti(inracp+jn)=zpg(jn)
!          dlwti(jn)=zpg(inracp+1-jn)
!       enddo
!    endif

    do jlat = 1, inj
       zleg(0,jlat) = sqrt(0.5)
       zleg(1,jlat) = sqrt(1.5)*zrmu(jlat)
    enddo
    do jn = 0, ntrunc_l
       dln = 1.d0*dfloat(jn)
       dlnorm(jn) = dsqrt((2.*dln + 1.d0)/2.d0)
    enddo

    do jn = 1, ntrunc_l-1
       dln = dfloat(jn)
       dlfact1 = ((2.*dln+1.)/(dln+1.))*(dlnorm(jn+1)/dlnorm(jn))
       dlfact2 = (dln/(dln+1.))*(dlnorm(jn+1)/dlnorm(jn-1))
       do jlat = 1,inj
          zleg(jn+1,jlat) = dlfact1*zrmu(jlat)*zleg(jn,jlat) - dlfact2*zleg(jn-1,jlat)
       enddo
    enddo

    do jlat = 1, inj
       do jn = 0, ntrunc_l
         zlegi(jn,jlat) = zleg(jn,jlat)
       enddo
    enddo

!     1.2 CONVERT THE CORRELATIONS IN SPECTRAL SPACE INTO SPECTRAL
!         COEFFICIENTS OF THE CORRELATION FUNCTION AND FUNCTION TO BE
!         SELF-CONVOLVED
    do jn=0,ntrunc_l
      dlfact=((2.0*jn+1)/2.0)**0.25
      dlfact2=((2.0*JN +1.0)/2.0)**(0.25)
      do jk=1,nkgdim_l
        zsp(jn,jk)=rstddev(jk,jn)*dlfact*dlfact2
      enddo
    enddo

    ! Transform to physical space
    call zleginv(zgr,zsp,zlegi,dlwti,ntrunc_l,inj,nkgdim_l,nj_l,nkgdim_l,ntrunc_l)

    ! Truncate in horizontal extent with Gaussian window
    do jk=1,nkgdim_l
      if (jk.ge.nspositVO.and.jk.lt.nspositVO+nflev_l) then
        dtlen = rporvo
      elseif (jk.ge.nspositDI.and.jk.lt.nspositDI+nflev_l) then
        dtlen = rpordi
      elseif (jk.ge.nspositTT.and.jk.lt.nspositTT+nflev_l) then
        dtlen = rportt
      elseif (jk.ge.nspositQ.and.jk.lt.nspositQ+nflev_l) then
        dtlen = rporq
      elseif (jk.eq.nspositPS) then
        dtlen = rporps
      endif

      if(dtlen.gt.0.0) then
        dlc = 1.d0/dble(dtlen)
        dlc = 0.5*dlc*dlc
        do jlat=1,inj
          zr = ra * acos(zrmu(jlat))
          dlfact = dexp(-(zr**2)*dlc)
          zgr(jlat,jk)=dlfact*zgr(jlat,jk)
        enddo
      endif

      !write(*,*) 'zeroing length (km)=',jk,dtlen/1000.0
    enddo

    ! Transform back to spectral space
    call zlegdir(zgr,zsp,zlegi,dlwti,ntrunc_l,inj,nkgdim_l,nj_l,nkgdim_l,ntrunc_l)

    ! Convert back to correlations
    do jk=1,nkgdim_l
      do jn=0,ntrunc_l
         zsp(jn,jk)=zsp(jn,jk)*(2.0/(2.0*jn+1.0))**(0.25)
      enddo
    enddo

    ! PUT BACK INTO RSTDDEV
    do jn=0,ntrunc_l
      do jk=1,nkgdim_l
         rstddev(jk,jn)=zsp(jn,jk)
      enddo
    enddo
 
    ! Re-normalize to ensure correlations
    do jk=1,nkgdim_l
      dsummed=0.d0
      do jn=0,ntrunc_l
        dsummed=dsummed+ dble(rstddev(jk,jn)**2)*sqrt(((2.*jn)+1.)/2.)
      enddo
      dsummed=sqrt(dsummed)
      do jn=0,ntrunc_l
        if(dsummed.gt.1.d-30) rstddev(jk,jn)=rstddev(jk,jn)/dsummed
      enddo
    enddo

    !     CONVERT THE SPECTRAL COEFFICIENTS OF THE CORRELATION FUNCTION
    !     .  BACK INTO CORRELATIONS OF SPECTRAL COMPONENTS
    do jn=0,ntrunc_l
      dlfact=sqrt(0.5)*(1.0/((2.0*jn+1)/2.0))**0.25
      do jk=1,nkgdim_l
        rstddev(jk,jn)=rstddev(jk,jn)*dlfact
      enddo
    enddo

    return
  END SUBROUTINE BHI_convol


  SUBROUTINE BHI_setCrossCorr(kn)
    implicit none

    integer kn,jblock1,inbrblock,jblock2
    real*8 dlfact
    integer jk1, jk2

    !write(*,*) 'setcrosscorr: Set to zero all cross-variable correlations but T_u-ps_u'
    !call flush(6)

    inbrblock = numvar3d

    ! Set cross-variable correlations to 0 ...
    do jblock1 = 1, inbrblock
      do jblock2 = 1, inbrblock
        if (jblock1.ne.jblock2) then
          do jk2 = 1, nflev_l
            do jk1 = 1,nflev_l
              corns(jk1 + nflev_l*(jblock1 -1),jk2 + nflev_l*(jblock2 -1),kn) = 0.0
            enddo
          enddo
        endif
      enddo
    enddo

    ! ... but T'ln(ps') correlations
    do jk2 = 1,nkgdim_l
      do jk1 = inbrblock*nflev_l+1,inbrblock*nflev_l+numvar2d
        if ((jk1.ne.nspositPS.or.jk2.lt.nspositTT.or.    &
             jk2.ge.(nspositTT+nflev_l)).and.(jk1.ne.jk2)) then
          corns(jk1,jk2,kn) = 0.0
        endif
      enddo
    enddo

    do jk2 = inbrblock*nflev_l+1,inbrblock*nflev_l+numvar2d
      do jk1 = 1,nkgdim_l
        if ((jk2.ne.nspositPS.or.jk1.lt.nspositTT.or.   &
             jk1.ge.(nspositTT+nflev_l)) .and.(jk1.ne.jk2)) then
          corns(jk1,jk2,kn) = 0.0
        endif
      enddo
    enddo

    !write(*,*) 'setcrosscorr: done'
    !call flush(6)

    return
  END SUBROUTINE BHI_setCrossCorr


  SUBROUTINE BHI_READCORNS2(kulbgsto)
    implicit none

    character*1 clblock
    integer kulbgsto,kip1
    integer jn, istdkey,icornskey
    integer iksdim,jcol,jrow,jblock,jlevo,jlevi
    real*8 zwork
    real*8, allocatable, dimension(:) :: zstdsrc
    real*8, allocatable, dimension(:,:) :: zcornssrc

    ! standard file variables
    integer ini,inj,ink, inpas, inbits, idatyp, ideet     &
           ,ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf  &
           ,iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas
    integer iliste(100),idate(100),idimax,infon,iheures,idateo
    character*2 cltypvar
    character*1 clgrtyp
    character*4 clnomvar
    character*12 cletiket
    integer vfstlir,vfstecr,fstprm,fstinf


    iksdim = 4*nflev_l+1    ! assume 4 3d variables and 1 2d variable (TG not included)
    allocate(zcornssrc(iksdim,iksdim))
    allocate(zstdsrc(iksdim))

    !write(*,*)'READCORNS2'

    kip1=-1

    do jn = 0, ntrunc_l
      !write(*,*)' Reading RSTDDEV spectral coefficients number',jn

      ! Looking for FST record parameters..

      idateo = -1
      cletiket = 'RSTDDEV'
      ip1 = kip1
      ip2 = jn
      ip3 = -1
      cltypvar = 'X'
      clnomvar = 'SS'

      istdkey = vfstlir(ZSTDSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      if(istdkey .lt.0 ) then
        write(*,*) 'READCORNS2: Problem with background stat file'
        call exit(1)
      endif

      if (ini .ne. iksdim) then
        write(*,*) 'READCORNS2: BG stat levels inconsitencies'
        call exit(1)
      endif

      !write(*,*)' Reading CORNS spectral coefficients number',jn
      !call flush(6)

      ! Looking for FST record parameters..

      idateo = -1
      cletiket = 'CORRNS'
      ip1 = kip1
      IP2 = JN
      ip3 = -1
      cltypvar = 'X'
      clnomvar = 'ZZ'
      icornskey = vfstlir(ZCORNSSRC,nulbgst,INI,INJ,INK,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      !write(*,*)' done reading...'
      !call flush(6)

      if(icornskey .lt.0 ) then
        write(*,*) 'READCORNS2: Problem with background stat file'
        call exit(1)
      endif

      if (ini .ne. iksdim .or. inj .ne. iksdim) then
        write(*,*) 'READCORNS2: BG stat levels inconsitencies'
        call exit(1)
      endif

      do jcol = 1,nksdim2_l
        rstddev(jcol,jn) = 0.0d0
        do jrow = 1,nksdim2_l
          corns(jrow,jcol,jn) = 0.0
        enddo
      enddo
      !write(*,*)' done initializing...'
      !call flush(6)

      do jcol = 1,iksdim
        do jrow = 1, iksdim
          corns(jrow,jcol,jn) = zcornssrc(jrow,jcol)
        enddo
      enddo
      !write(*,*)' done copying over corns...'
      !call flush(6)

      ! Set cross-variable correlations to zero except between T' and ln(ps')
      call BHI_setcrosscorr(jn)

      do jrow = 1, iksdim
        rstddev(jrow,jn) = zstdsrc(jrow)
      enddo

    enddo

    ! Apply convolution to RSTDDEV correlations

    call BHI_convol

    do jn = 0, ntrunc_l

      if ( kulbgsto .gt. 0 ) then

        ! Writing starndard deviation to file
        ierr = fstprm(istdkey,idateo,ideet,inpas,ini,inj,ink, inbits,  &
             idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp     &
             ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2    &
             ,iextr3)
        ini = nkgdim_l
        inj = 1
        ink = 1
        ip2 = jn
        ierr = vfstecr(rstddev(1,jn), zwork, -inbits, kulbgsto, idateo  &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,      &
             .true.)

        ! Writing correlation matrix to file
        ierr = fstprm(icornskey,idateo,ideet,inpas,ini,inj,ink, inbits  &
             ,idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp     &
             ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2     &
             ,iextr3)
        ini = nkgdim_l
        inj = nkgdim_l
        ink = 1
        ip2 = jn
        ierr = vfstecr(corns(1,1,jn), zwork, -inbits, kulbgsto, idateo  &
             , ideet,inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,             &
             clnomvar,cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,              &
             .true.)
      endif

      ! Re-build of correlation matrix: factorization of corns with convoluted RSTDDEV
      do jcol = 1,nkgdim_l
        do jrow = 1,nkgdim_l
          corns(jrow,jcol,jn) = rstddev(jrow,jn) * corns(jrow,jcol,jn)* rstddev(jcol,jn)
        enddo
      enddo

    enddo

    deallocate(zcornssrc)
    deallocate(zstdsrc)

    !write(*,*) 'Done in READCORNS2'
    return
  END SUBROUTINE BHI_READCORNS2


  SUBROUTINE BHI_RDSPSTD(kulbgsto)
    use globalSpectralTransform
    implicit none

    integer kulbgsto

    integer, parameter  :: inbrvar3d=5
    integer, parameter  :: inbrvar2d=2
    integer jvar,jn,inix,injx,inkx
    integer ikey, jlevo, jlat
    real*8 zsp(0:ntrunc_l,nflev_l),zspbuf(nflev_l),zwork
    real*8 zleg(0:ntrunc_l,nj_l),zgr(nj_l,nflev_l),zgsig(1,nj_l,nflev_l),zstddev(nksdim2_l,nj_l)
    character(len=4) :: varName3d(inbrvar3d),varName2d(inbrvar2d)

    ! standard file variables
    integer ini,inj,ink, inpas, inbits, idatyp, ideet     &
           ,ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf  &
           ,iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas
    integer iliste(100),idate(100),idimax,infon,iheures,idateo
    character*1 clgrtyp
    character*2 cltypvar
    character*4 clnomvar
    character*12 cletiket
    integer vfstlir,vfstecr,fstprm,fstinf

    data varName3d/'PP  ','UC  ','UT  ','LQ  ','TB  '/
    data varName2d/'UP  ','PB  '/

    call gst_zlegpol(zleg)

    rgsig(:,:)=0.0d0
    rgsigtb(:,:)=0.0d0
    rgsigpsb(:)=0.0d0

!   2. Reading the data

    idate(1) = -1
    ip1      = -1
    ip2      = -1
    ip3      = -1

    cletiket = 'SPSTDDEV'
    cltypvar = 'X'

    !write(*,*) 'Reading 3D variables'
    do jvar = 1, inbrvar3d
      clnomvar = varName3d(jvar)
      !write(*,*)'Reading ',clnomvar
      do jn = 0,ntrunc_l
        ip2 = jn
        ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf,nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
           if ( kulbgsto .gt. 0 ) then
            ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits,        &
                   idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp      &
                   ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1            &
                   ,iextr2,iextr3)
          endif
        else
          write(*,*) 'WARNING: CANNOT FIND SPSTD FOR ',clnomvar,jn
          write(*,*) 'WARNING: SETTING TO ZERO!!!'
          zspbuf(:)=0.0
        endif

        if (ini .ne. nflev_l) then
          write(*,*) 'RDSPSTD: BG stat levels inconsitencies'
          call exit(1)
        endif

        do jlevo = 1, nflev_l
          zsp(jn,jlevo) = zspbuf(jlevo)
        enddo
      enddo

      call zleginv2(zgr,zsp,zleg,ntrunc_l,nj_l,nflev_l,nj_l,nflev_l,ntrunc_l)

      if(clnomvar .eq. 'PP') then
        do jlat = 1, nj_l
          do jlevo = 1, nflev_l
            rgsiguu(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      elseif(clnomvar .eq. 'UC' .or. clnomvar .eq. 'CC') then
        do jlat = 1, nj_l
          do jlevo = 1, nflev_l
            rgsigvv(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      elseif(clnomvar .eq. 'UT') then
        do jlat = 1, nj_l
          do jlevo = 1, nflev_l
            rgsigtt(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      elseif(clnomvar .eq. 'TB') then
        do jlat = 1, nj_l
          do jlevo = 1, nflev_l
            rgsigtb(jlat,jlevo) = zgr(jlat,jlevo)
          enddo
        enddo
      elseif(clnomvar .eq. 'LQ') then
        do jlat = 1, nj_l
          do jlevo = 1, nflev_l
            rgsigq(jlat,jlevo) = zgr(jlat,jlevo)*rfacthum
          enddo
        enddo
      endif

      if ( kulbgsto .gt. 0 ) then

        do jlat = 1, nj_l
          do jlevo = 1,nflev_l
            zgsig(1,jlat,jlevo) = zgr(nj_l-jlat+1,jlevo)
          enddo
        enddo

        ierr = vfstecr(zgsig, zwork, -inbits, kulbgsto, idateo, ideet,   &
               inpas, 1, nj_l, nflev_l, 0, 0, ip3, 'E', clnomvar,            &
               'STDDEV  ',clgrtyp,ig1, ig2, ig3, ig4, idatyp, .true.)

      endif
    enddo

    !write(*,*) 'Reading 2D variables'
    do jvar = 1, inbrvar2d
      clnomvar = varName2d(jvar)
      !write(*,*)'Reading ',clnomvar
      do jn = 0,ntrunc_l
        ip2 = jn
        ikey = fstinf(nulbgst,inix,injx,inkx,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

        if(ikey .ge.0 ) then
          ikey = vfstlir(zspbuf,nulbgst,ini,inj,ink,idate(1),cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
          if ( kulbgsto .gt. 0 ) then
            ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits,       &
                  idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp      &
                  ,ig1,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1            &
                  ,iextr2,iextr3)
          endif

        else
          write(*,*) 'WARNING: CANNOT FIND SPSTD FOR ',clnomvar,jn
          write(*,*) 'WARNING: SETTING TO ZERO!!!'
          zspbuf(:)=0.0
        endif

        zsp(jn,1) = zspbuf(1)

      enddo

      call zleginv2(zgr,zsp,zleg,ntrunc_l,nj_l,1,nj_l,nflev_l,ntrunc_l)

      if(clnomvar .eq. 'UP') then
        do jlat = 1, nj_l
          rgsigps(jlat) = zgr(jlat,1)*100.0
        enddo
      endif
      if(clnomvar .eq. 'PB') then
        do jlat = 1, nj_l
          rgsigpsb(jlat) = zgr(jlat,1)*100.0
        enddo
      endif

      if ( kulbgsto .gt. 0 ) then

        do jlat = 1, nj_l
          zgsig(1,jlat,1) = zgr(nj_l-jlat+1,1)
        enddo

        ierr = vfstecr(zgsig, zwork, -inbits, kulbgsto, idateo, ideet,  &
               inpas, 1, nj_l, 1, 0, 0, ip3, 'E', clnomvar,               &
               'STDDEV  ',clgrtyp,ig1, ig2, ig3, ig4, idatyp, .true.)

      endif
    enddo

    !write(*,*)'DONE in RDSPSTD'

    return
  END SUBROUTINE BHI_RDSPSTD


  SUBROUTINE BHI_RDSPPTOT(kulbgsto)
    use globalSpectralTransform
    IMPLICIT NONE

    integer kulbgsto

    integer jn, jk1, jk2, ikey, ilen,jlat,jcol,inix,injx,inkx
    real*8 zsptheta(0:ntrunc_l,nflev_l)
    real*8 zgrtheta(nj_l,nflev_l)
    real*8 zleg(0:ntrunc_l,nj_l)
    real*8 zwork
    real*8 zptotsrc(nflev_l+1,nflev_l)
    real*8 zspptot(0:ntrunc_l,nflev_l+1,nflev_l)
    real*8 zgrptot(nj_l,nflev_l+1,nflev_l)
    real*8 ztheta(nflev_l)
    real*8 zptotecr(nflev_l+1,nflev_l,nj_l)
    
    ! standard file variables
    integer ini,inj,ink, inpas, inbits, idatyp, ideet     &
           ,ip1,ip2,ip3,ig1,ig2,ig3,ig4,iswa,ilength,idltf  &
           ,iubc,iextr1,iextr2,iextr3,ierr,ipak,ipas
    integer iliste(100),idate(100),idimax,infon,iheures,idateo
    character*2 cltypvar
    character*1 clgrtyp
    character*4 clnomvar
    character*12 cletiket
    integer vfstlir,vfstecr,fstprm,fstinf
    

    !write(*,*) 'RDSPPTOT - Begin'

    !write(*,*) 'RDSPPTOT: set up simple spectral transforms'

    call gst_zlegpol(zleg)

    ip1 = -1
    ip3 = -1
    idateo = -1
    cletiket = 'SP_THETA'
    cltypvar = 'X'
    clnomvar = 'ZZ'

    ! read spectral coefficients for theta

    !write(*,*) 'RDSPPTOT: Start reading in THETA from unit:',nulbgst
    do jn = 0,ntrunc_l
      ip2 = jn
      ikey = fstinf(nulbgst,inix,injx,inkx,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      if(ikey .ge.0 ) then
        ikey = vfstlir(ztheta,nulbgst,ini,inj,ink,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        if ( kulbgsto .gt. 0 ) then
          ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits,          &
                 idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp,ig1      &
                 ,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2,iextr3)
        endif
      else
        write(*,*) 'WARNING: CANNOT FIND THETA FOR ',jn
        write(*,*) 'WARNING: SETTING TO ZERO!!!'
        ztheta(:)=0.0
      endif

      do jk1 = 1,nflev_l
        zsptheta(jn,jk1) = ztheta(jk1)
      enddo

    enddo

    ! converting theta in physical space

    !write(*,*) 'RDSPPTOT: converting theta in physical space'
    call zleginv2(zgrtheta,zsptheta,zleg,ntrunc_l,nj_l,nflev_l,nj_l,nflev_l,ntrunc_l)

    do jlat = 1, nj_l
      do jk1 = 1, nflev_l
        theta(jk1,jlat) = zgrtheta(jlat,jk1)
      end do
    end do

    if ( kulbgsto .gt. 0 ) then
      ini = nflev_l
      inj = nj_l
      ink = 1
      ip1 = 0
      ip2 = 0
      cletiket = 'THETA   '

      ierr = vfstecr(theta, zwork, -inbits, kulbgsto, idateo, ideet,    &
             inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar, clnomvar,   &
             cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp, .true.)
    endif

    !write(*,*) 'RDSPPTOT: Start Reading in SP_PtoT from unit:',nulbgst
    ip1 = -1
    ip2 = -1
    ip3 = -1
    idateo = -1
    cletiket = 'SP_PtoT'
    cltypvar = 'X'
    clnomvar = 'ZZ'

    ! read of spectral coefficients for P to T operator

    do jn = 0,ntrunc_l
      ip2 = jn
      ikey = fstinf(nulbgst,inix,injx,inkx,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)

      if(ikey .ge.0 ) then
        ikey = vfstlir(zptotsrc,nulbgst,ini,inj,ink,idateo,cletiket,ip1,ip2,ip3,cltypvar,clnomvar)
        if ( kulbgsto .gt. 0 ) then
          ierr = fstprm(ikey,idateo,ideet,inpas,ini,inj,ink, inbits,           &
                 idatyp,ip1,ip2,ip3,cltypvar,clnomvar,cletiket,clgrtyp,ig1     &
                ,ig2,ig3,ig4,iswa,ilength,idltf,iubc,iextr1,iextr2,iextr3)
        endif
      else
        write(*,*) 'WARNING: CANNOT FIND P_to_T FOR ',jn
        write(*,*) 'WARNING: SETTING TO ZERO!!!'
        zptotsrc(:,:)=0.0
      endif

      do jk2 = 1,nflev_l
        do jk1 = 1,nflev_l+1
          zspptot(jn,jk1,jk2) = zptotsrc(jk1,jk2)
        enddo
      enddo

    enddo

    !write(*,*) 'RDSPPTOT: converting PtoT in physical space'
    ilen = nflev_l*(nflev_l+1)
    call zleginv2(zgrptot,zspptot,zleg,ntrunc_l,nj_l,ilen,nj_l,ilen,ntrunc_l)

    do jlat = 1, nj_l
      do jk2 = 1,nflev_l
        do jk1 = 1, nflev_l+1
          ptot(jk1,jk2,jlat) = zgrptot(jlat,jk1,jk2)
        end do
      end do
    enddo

    if ( kulbgsto .gt. 0 ) then

      do jlat = 1, nj_l
        do jk2 = 1,nflev_l
          do jk1 = 1, nflev_l + 1
            zptotecr(jk1,jk2,jlat) = ptot(jk1,jk2,nj_l-jlat+1)
          enddo
        enddo
      enddo

      ini = nflev_l + 1
      inj = nflev_l
      ink = nj_l
      ip1 = 0
      ip2 = 0
      cletiket = 'P_to_T'

        ierr = vfstecr(zptotecr, zwork, -inbits, kulbgsto, idateo,       &
               ideet, inpas, ini, inj, ink, ip1, ip2, ip3, cltypvar,     &
               clnomvar, cletiket,clgrtyp,ig1, ig2, ig3, ig4, idatyp,    &
               .true.)

    endif

    !write(*,*)'DONE in RDSPPTOT'

    return
  END SUBROUTINE BHI_RDSPPTOT


  SUBROUTINE BHI_bSqrt(controlVector_in,statevector)
    implicit none

    real*8    :: controlVector_in(cvDim_l)
    type(struct_gsv) :: statevector
    real*8, allocatable :: gd_out(:,:,:)
    real*8, pointer :: field(:,:,:)
    real*8    :: hiControlVector(nla_l,2,nkgdim_l)
    integer   :: jvar, ilev1, ilev2

    allocate(gd_out(ni_l,nkgdim_l,nj_l))

    if(.not. initialized) then
      write(*,*) 'bMatrixHI not initialized'
      return
    endif

    write(*,*) 'bhi_bsqrt: starting'
    call flush(6)

    call bhi_cain(controlVector_in,hiControlVector)

    call copyFromStatevector(statevector,gd_out)

    call bhi_spa2gd(hiControlVector,gd_out)

    call copyToStatevector(statevector,gd_out)

    deallocate(gd_out)

    write(*,*) 'bhi_bsqrt: done'
    call flush(6)

  END SUBROUTINE BHI_bSqrt


  SUBROUTINE BHI_bSqrtAd(statevector,controlVector_out)
    implicit none

    real*8    :: controlVector_out(cvDim_l)
    type(struct_gsv) :: statevector
    real*8, allocatable :: gd_in(:,:,:)
    real*8, pointer :: field(:,:,:)
    real*8    :: hiControlVector(nla_l,2,nkgdim_l)
    integer   :: jvar, ilev1, ilev2

    if(.not. initialized) then
      write(*,*) 'bMatrixHI not initialized'
      return
    endif

    write(*,*) 'bhi_bsqrtad: starting'
    call flush(6)

    allocate(gd_in(ni_l,nkgdim_l,nj_l))

    call copyFromStatevector(statevector,gd_in)

    call bhi_spa2gdad(gd_in,hiControlVector)

    call bhi_cainad(hiControlVector,controlVector_out)

    deallocate(gd_in)

    write(*,*) 'bhi_bsqrtad: done'
    call flush(6)

  END SUBROUTINE BHI_bSqrtAd


  SUBROUTINE copyToStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real*8          :: gd(:,:,:)
    integer :: jvar, ilev1, ilev2
    real*8, pointer :: field(:,:,:)

    do jvar=1,vnl_numvarmax 
      if(gsv_varExist(varnamelist(jvar))) then
        field => gsv_getField3D(statevector,varnamelist(jvar))
        if(varnamelist(jvar).eq.'UU  ') then
          ilev1=nspositVO
        elseif(varnamelist(jvar).eq.'VV  ') then
          ilev1=nspositDI
        elseif(varnamelist(jvar).eq.'TT  ') then
          ilev1=nspositTT
        elseif(varnamelist(jvar).eq.'HU  ') then
          ilev1=nspositQ
        elseif(varnamelist(jvar).eq.'P0  ') then
          ilev1=nspositPS
        elseif(varnamelist(jvar).eq.'TG  ') then
          ilev1=nspositTG
        else
          write(*,*) 'bmatrixhi_mod: copyToStatevector: No covariances available for variable:',varnamelist(jvar)
          call flush(6)
          call qqexit(1)
        endif
        ilev2=ilev1 - 1 + gsv_getNumLev(statevector,vnl_vartypeFromVarname(varNameList(jvar)))
        field(:,:,:)=gd(:,ilev1:ilev2,:)
      endif
    enddo

  END SUBROUTINE copyToStatevector


  SUBROUTINE copyFromStatevector(statevector,gd)
    implicit none
    type(struct_gsv) :: statevector
    real*8          :: gd(:,:,:)
    integer :: jvar, ilev1, ilev2
    real*8, pointer :: field(:,:,:)

    do jvar=1,vnl_numvarmax 
      if(gsv_varExist(varnamelist(jvar))) then
        field => gsv_getField3D(statevector,varnamelist(jvar))
        if(varnamelist(jvar).eq.'UU  ') then
          ilev1=nspositVO
        elseif(varnamelist(jvar).eq.'VV  ') then
          ilev1=nspositDI
        elseif(varnamelist(jvar).eq.'TT  ') then
          ilev1=nspositTT
        elseif(varnamelist(jvar).eq.'HU  ') then
          ilev1=nspositQ
        elseif(varnamelist(jvar).eq.'P0  ') then
          ilev1=nspositPS
        elseif(varnamelist(jvar).eq.'TG  ') then
          ilev1=nspositTG
        else
          write(*,*) 'bmatrixhi_mod: copyFromStatevector: No covariances available for variable:',varnamelist(jvar)
          call flush(6)
          call qqexit(1)
        endif
        ilev2=ilev1 - 1 + gsv_getNumLev(statevector,vnl_vartypeFromVarname(varNameList(jvar)))
        gd(:,ilev1:ilev2,:)=field(:,:,:)
      endif
    enddo

  END SUBROUTINE copyFromStatevector


  SUBROUTINE BHI_cain(controlVector_in,hiControlVector_out)
    implicit none

    real*8    :: controlVector_in(cvDim_l)
    real*8    :: hiControlVector_out(nla_l,2,nkgdim_l)

    integer jdim, jlev, jla

    jdim = 0
    hiControlVector_out(:,:,:)=0.0d0
    do jlev = 1, nkgdim_l
      do jla = 1, ntrunc_l + 1
        jdim = jdim + 1
        hiControlVector_out(jla,1,jlev) = controlVector_in(jdim)
      enddo
      do jla = ntrunc_l+2, nla_l
        jdim = jdim + 1
        hiControlVector_out(jla,1,jlev) = controlVector_in(jdim)
        jdim = jdim + 1
        hiControlVector_out(jla,2,jlev) = controlVector_in(jdim)
      enddo
    enddo

    return
  end SUBROUTINE BHI_cain


  SUBROUTINE BHI_cainAd(hiControlVector_in,controlVector_out)
    IMPLICIT NONE

    real*8    :: controlVector_out(cvDim_l)
    real*8    :: hiControlVector_in(nla_l,2,nkgdim_l)

    integer jdim, jlev, jla

    jdim = 0
    do jlev = 1, nkgdim_l
      do jla = 1, ntrunc_l+1
        jdim = jdim+1
        controlVector_out(JDIM) = controlVector_out(JDIM) + hiControlVector_in(jla,1,jlev)
      enddo
      do jla = ntrunc_l + 2, nla_l
        jdim = jdim + 1
        ! factor of 2 is value of scalpm1 in original code
        controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(jla,1,jlev)*2.0d0
        jdim = jdim + 1
        controlVector_out(jdim) = controlVector_out(jdim) + hiControlVector_in(jla,2,jlev)*2.0d0
      enddo
    enddo

    return
  END SUBROUTINE BHI_cainAd

  SUBROUTINE BHI_SPA2GD(hiControlVector_in,gd_out)
    use globalSpectralTransform
    IMPLICIT NONE

    real*8    :: hiControlVector_in(nla_l,2,nkgdim_l)
    real*8    :: gd_out(ni_l,nkgdim_l,nj_l)

    real*8    :: gd(ni_l,nkgdim_l,nj_l)
    real*8    :: sptb(nla_l,2,nflev_l),sp(nla_l,2,nkgdim_l)
    real*8    :: tb0(ni_l,nflev_l,nj_l)

    integer ilen,jn,jm,jk,ila
    integer ji,jj,idum1,idum2,idum3,idum4
    real*8 zmin,zmax
    real*8 sq2
    real*8 , allocatable,dimension(:,:,:) :: zsp, zsp2
    real*8 zp(ni_l,nflev_l,nj_l),zp2d(ni_l,1,nj_l)

    integer ilensp, ilengd, ierr, ilon, jlev, jlon, jlat, jla, iulout
    integer jlatmin, jlatmax, klatptot
    real*8 z1mnu2, zsqrtnu2
    real*8 zgdpsi(ni_l,nflev_l,nj_l),zgdchi(ni_l,nflev_l,nj_l)
    real*8 dlzsomme, dldsomme, dla2, dl1sa2, dlfact,dlnormpsi, dlnormchi, zcoriolis, zpsb(ni_l,nj_l)

    integer :: jn0,ins,jns,ntrunchf
    integer :: thdid,numthd,omp_get_thread_num,omp_get_num_threads
    real*8 two
    data two /2.0d0/
    real*8 one8,zero8
    data one8,zero8/1.d0,0.d0/


    klatptot=1

    sq2=sqrt(two)
!    tb_out(:,:,:)=0.0d0
    ntrunchf=ntrunc_l/2
!$OMP PARALLEL PRIVATE(thdid,numthd,jn,jm,jk,ila,ins,jn0,jns,zsp2,zsp)
    thdid=omp_get_thread_num()
    numthd=omp_get_num_threads()

    allocate(zsp(nkgdim_l,2,0:ntrunc_l))
    allocate(zsp2(nksdim2_l,2,0:ntrunc_l))
    do jn0 = thdid,ntrunchf,numthd
      ins=1
      if(jn0 == (ntrunc_l-jn0))ins=0
      do jns=0,ins
        jn=(1-jns)*jn0+jns*(ntrunc_l-jn0)

        do jm = 0, jn
          ila = gst_getNind(jm) + jn - jm
          do jk = 1, nkgdim_l
            zsp(jk,1,jm) = hiControlVector_in(ila,1,jk)
            zsp(jk,2,jm) = hiControlVector_in(ila,2,jk)
          enddo
        enddo

        CALL DGEMUL(corns(1,1,jn),nksdim2_l,'N',zsp(1,1,0),nkgdim_l,'N',zsp2(1,1,0),nksdim2_l,nksdim2_l,nkgdim_l,2*(jn+1))

        ila = gst_getNind(0) +jn
        do jk = 1, nkgdim_l
          sp(ila,1,jk) = zsp2(jk,1,0)*sq2
          sp(ila,2,jk) = zsp2(jk,2,0)*sq2
        enddo
        do jk = 1, nflev_l
          sptb(ila,1,jk) = zsp2(jk+nkgdim_l,1,0)*sq2
          sptb(ila,2,jk) = zsp2(jk+nkgdim_l,2,0)*sq2
        enddo

        do jm = 1, jn
          ila = gst_getNind(jm) +jn - jm
          do jk = 1, nkgdim_l
            sp(ila,1,jk) = zsp2(jk,1,jm)
            sp(ila,2,jk) = zsp2(jk,2,jm)
          enddo
        enddo
        do jm = 1, jn
          ila = gst_getNind(jm) +jn - jm
          do jk = 1, nflev_l
            sptb(ila,1,jk) = zsp2(jk+nkgdim_l,1,jm)
            sptb(ila,2,jk) = zsp2(jk+nkgdim_l,2,jm)
          enddo
        enddo

        do jk=1,nkgdim_l
          do ila=1,ntrunc_l+1
            sp(ila,2,jk)=0.0
          enddo
        enddo
        do jk=1,nflev_l
          do ila=1,ntrunc_l+1
            sptb(ila,2,jk)=0.0
          enddo
        enddo
      enddo
    enddo
    deallocate(zsp)
    deallocate(zsp2)
!$OMP END PARALLEL

    dla2   = dble(ra)*dble(ra)
    dl1sa2 = 1.d0/dla2

    gd(:,:,:)=0.0d0
    tb0(:,:,:)=0.0d0
    call tmg_start(52,'SPEREE') 
    call gst_speree(sp,gd,nkgdim_l,nkgdim_l)
    call gst_speree(sptb,tb0,nflev_l,nflev_l)
    call tmg_stop(52) 

    zgdpsi(:,:,:)=0.0d0
    zgdchi(:,:,:)=0.0d0

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          zgdpsi(jlon,jlev,jlat)= gd(jlon,nspositVO+jlev-1,jlat)
          zgdchi(jlon,jlev,jlat)= gd(jlon,nspositDI+jlev-1,jlat)
        enddo
      enddo
    enddo

    zp(:,:,:)=0.0d0
    do jlat = 1, nj_l
      zcoriolis = 2.*romega*gst_getRmu(jlat)
      do jlev = 1, nflevptot_l
        do jlon = 1, ni_l
          zp(jlon,jlev,jlat) = zcoriolis*zgdpsi(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!    call maxmin(zp,ni_l,nj_l,nflev_l,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','ZP_')

    do jlat = 1, nj_l
      do jlon = 1, ni_l
        zpsb(jlon,jlat)=0.0
        do jlev=1,nflevptot_l
          zpsb(jlon,jlat)=zpsb(jlon,jlat) + PtoT(nflev_l+1,jlev,klatptot)*zp(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!    call maxmin(zpsb,ni_l,nj_l,1,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','PSB')

    do jlat = 1, nj_l
      zcoriolis = 2.*romega*gst_getRmu(jlat)
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          tb0(jlon,jlev,jlat)= zcoriolis*tb0(jlon,jlev,jlat)
        enddo
      enddo
    enddo

    do jlat = 1, nj_l
      do jlev = 1, (nkgdim_l-1)
        do jlon = 1,ni_l
          gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo
    enddo
    do  jlat = 1, nj_l
      do jlon = 1,ni_l
        gd(jlon,nspositTG,jlat)=gd(jlon,nspositTG,jlat)*tgstdbg(jlon,jlat)
      enddo
    enddo

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          tb0(jlon,jlev,jlat)= tb0(jlon,jlev,jlat)*rgsigtb(jlat,jlev)
          gd(jlon,nspositTT+jlev-1,jlat)= gd(jlon,nspositTT+jlev-1,jlat)+tb0(jlon,jlev,jlat)
        enddo
      enddo
    enddo
    do jlat = 1, nj_l
      do jlon = 1, ni_l
        zpsb(jlon,jlat)= zpsb(jlon,jlat)*rgsigpsb(jlat)
        gd(jlon,nspositPS,jlat)= gd(jlon,nspositPS,jlat)+zpsb(jlon,jlat)
        zp2d(jlon,1,jlat)=gd(jlon,nspositPS,jlat)
      enddo
    enddo
!    call maxmin(zpsb,ni_l,nj_l,1,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','PSB')
!    call maxmin(zp2d,ni_l,nj_l,1,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','PS_')

!$OMP PARALLEL DO PRIVATE(DLNORMPSI,DLNORMCHI,ILON,JLEV,JLAT,JLON)
    do jlev = 1, nflev_l
      do jlat = 1, nj_l
        dlnormpsi = rgsiguu(jlat,jlev)
        dlnormchi = rgsigvv(jlat,jlev)
        do jlon = 1, ni_l
          zgdpsi(jlon,jlev,jlat) = zgdpsi(jlon,jlev,jlat)*dlnormpsi
          zgdchi(jlon,jlev,jlat) = zgdchi(jlon,jlev,jlat)*dlnormchi
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call bhi_divbal(zgdpsi,zgdchi)

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          gd(jlon,nspositVO+jlev-1,jlat) = zgdpsi(jlon,jlev,jlat)
          gd(jlon,nspositDI+jlev-1,jlat) = zgdchi(jlon,jlev,jlat)
        enddo
      enddo
    enddo

    sp(:,:,:)=0.0d0
    call tmg_start(53,'REESPE') 
    call gst_REESPE(sp,gd,nkgdim_l,nkgdim_l)
    call tmg_stop(53) 

!$OMP PARALLEL DO
    do jlev = 1, nflev_l
      do jla = 1, nla_l
        sp(jla,1,nspositVO+jlev-1)=sp(jla,1,nspositVO+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,2,nspositVO+jlev-1)=sp(jla,2,nspositVO+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,1,nspositDI+jlev-1)=sp(jla,1,nspositDI+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,2,nspositDI+jlev-1)=sp(jla,2,nspositDI+jlev-1)*dl1sa2*gst_getrnnp1(jla)
      enddo
    enddo
!$OMP END PARALLEL DO

    gd(:,:,:)=0.0d0
    call tmg_start(54,'SPGD_SPGDA')
    call gst_spgd(sp,gd,nkgdim_l,nflev_l,nkgdim_l)
    call tmg_stop(54)

    if(.false.) then  ! this is for debugging only
    do jk = 1,nflev_l
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp(ji,jk,jj) = gd(ji,nspositTT+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp,ni_l,nj_l,nflev_l,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','T0_')
    do jk = 1,nflev_l
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp(ji,jk,jj) = gd(ji,nspositVO+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp,ni_l,nj_l,nflev_l,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','UU_')
    do jk = 1,nflev_l
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp(ji,jk,jj) = gd(ji,nspositDI+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp,ni_l,nj_l,nflev_l,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','VV_')
    do jk = 1,nflev_l
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp(ji,jk,jj) = gd(ji,nspositQ+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp,ni_l,nj_l,nflev_l,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','LQ_')
    do jk = 1,1
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp2d(ji,jk,jj) = gd(ji,nspositPS+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp2d,ni_l,nj_l,1,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','PS_')
    do jk = 1,1
      do jj = 1,nj_l
        do ji = 1,ni_l
          zp2d(ji,jk,jj) = gd(ji,nspositTG+jk-1,jj)
        enddo
      enddo
    enddo
    call maxmin(zp2d,ni_l,nj_l,1,zmin,zmax,idum1,idum2,idum3,idum4,'spa2gd         ','TG_')
    endif ! if(.false.)

!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = 1, nj_l
      do jlev = 1, nkgdim_l
        do jlon = 1,ni_l
          gd_out(jlon,jlev,jlat) = gd_out(jlon,jlev,jlat) + gd(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    !write(*,*) 'end of spa2gd!!!'

    return
  END SUBROUTINE BHI_SPA2GD


  SUBROUTINE BHI_SPA2GDAD(gd_in,hiControlVector_out)
    use globalSpectralTransform
    implicit none

    real*8    :: hiControlVector_out(nla_l,2,nkgdim_l)
    real*8    :: gd_in(ni_l,nkgdim_l,nj_l)

    real*8    :: sptb(nla_l,2,nflev_l),sp(nla_l,2,nkgdim_l)
    real*8    :: tb0(ni_l,nflev_l,nj_l)

    integer jn,jm,jk,ila,jlatmin,jlatmax
    real*8 sq2
    real*8 ,allocatable,dimension(:,:,:) :: zsp,zsp2
    real*8 zp(ni_l,nflev_l,nj_l)
    real*8 zmin,zmax,zmean,zmax2,zmax3
    integer idum1,idum2,idum3,idum4

    integer ierr, ilon, jlev, jlon, jlat, jla, klatptot
    real*8 dl1sa2,dla2,znormpsi, znormchi, zcoriolis, zpsb(ni_l,nj_l)
    real*8,allocatable,dimension(:,:,:) :: zgdpsi ,zgdchi
    real*8 gd(ni_l,nkgdim_l,nj_l)

    integer :: ntrunchf,jn0,ins,jns,thdid,numthd
    integer :: omp_get_thread_num, omp_get_num_threads

    real*8 two
    real*8 one8,zero8
    data one8,zero8/1.d0,0.d0/

    two = 2.d0
    dla2   = dble(ra)*dble(ra)
    dl1sa2 = 1.d0/dla2

    allocate(zgdpsi(ni_l,nflev_l,nj_l))
    allocate(zgdchi(ni_l,nflev_l,nj_l))

    klatptot=1

!$OMP PARALLEL DO PRIVATE(JLAT,JLEV,JLON)
    do jlat = 1, nj_l
      do jlev = 1, nkgdim_l
        do jlon = 1,ni_l
          gd(jlon,jlev,jlat) = gd_in(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_start(54,'SPGD_SPGDA')
    call gst_SPGDA(sp,gd,nkgdim_l,nflev_l,nkgdim_l)
    call tmg_stop(54)

!$OMP PARALLEL DO
    do jlev = 1, nflev_l
      do jla = 1, nla_l
        sp(jla,1,nspositVO+jlev-1)=sp(jla,1,nspositVO+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,2,nspositVO+jlev-1)=sp(jla,2,nspositVO+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,1,nspositDI+jlev-1)=sp(jla,1,nspositDI+jlev-1)*dl1sa2*gst_getrnnp1(jla)
        sp(jla,2,nspositDI+jlev-1)=sp(jla,2,nspositDI+jlev-1)*dl1sa2*gst_getrnnp1(jla)
      enddo
    enddo
!$OMP END PARALLEL DO

    call tmg_start(52,'SPEREE') 
    CALL gst_SPEREE(sp,gd,nkgdim_l,nkgdim_l)
    call tmg_stop(52) 

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          zgdpsi(jlon,jlev,jlat) = gd(jlon,nspositVO+jlev-1,jlat)
          zgdchi(jlon,jlev,jlat) = gd(jlon,nspositDI+jlev-1,jlat)
        enddo
      enddo
    enddo

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          tb0(jlon,jlev,jlat)=gd(jlon,nspositTT+jlev-1,jlat)
          tb0(jlon,jlev,jlat)=tb0(jlon,jlev,jlat)*rgsigtb(jlat,jlev)
        enddo
      enddo
    enddo
    do jlat = 1, nj_l
      do jlon = 1, ni_l
        zpsb(jlon,jlat)=gd(jlon,nspositPS,jlat)
        zpsb(jlon,jlat)=zpsb(jlon,jlat)*rgsigpsb(jlat)
      enddo
    enddo

    do jlat = 1, nj_l
      do jlev = 1, (nkgdim_l-1)
        do jlon = 1,ni_l
          gd(jlon,jlev,jlat) = gd(jlon,jlev,jlat)*rgsig(jlat,jlev)
        enddo
      enddo
    enddo
    do  jlat = 1, nj_l
      do jlon = 1,ni_l
        gd(jlon,nspositTG,jlat)=gd(jlon,nspositTG,jlat)*tgstdbg(jlon,jlat)
      enddo
    enddo

    call bhi_adivbal(zgdpsi,zgdchi)

!$OMP PARALLEL DO PRIVATE(ILON,ZNORMPSI,ZNORMCHI)
    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        znormpsi = rgsiguu(jlat,jlev)
        znormchi = rgsigvv(jlat,jlev)
        do jlon = 1, ni_l
          zgdpsi(jlon,jlev,jlat) = zgdpsi(jlon,jlev,jlat)*znormpsi
          zgdchi(jlon,jlev,jlat) = zgdchi(jlon,jlev,jlat)*znormchi
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

    do jlat = 1, nj_l
      zcoriolis = 2.*romega*gst_getRMU(jlat)
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          tb0(jlon,jlev,jlat)= zcoriolis*tb0(jlon,jlev,jlat)
        enddo
      enddo
    enddo

    do jlat = 1, nj_l
      do jlon = 1, ni_l
        do jlev=1,nflevptot_l
          zp(jlon,jlev,jlat) = PtoT(nflev_l+1,jlev,klatptot)*zpsb(jlon,jlat)
        enddo
      enddo
    enddo
    do jlat = 1, nj_l
      zcoriolis = 2.*romega*gst_getRMU(jlat)
      do jlev = 1, nflevptot_l
        do jlon = 1, ni_l
          zgdpsi(jlon,jlev,jlat) = zcoriolis*zp(jlon,jlev,jlat)+zgdpsi(jlon,jlev,jlat)
        enddo
      enddo
    enddo

    do jlat = 1, nj_l
      do jlev = 1, nflev_l
        do jlon = 1, ni_l
          gd(jlon,nspositVO+jlev-1,jlat) = zgdpsi(jlon,jlev,jlat)
          gd(jlon,nspositDI+jlev-1,jlat) = zgdchi(jlon,jlev,jlat)
        enddo
      enddo
    enddo

    call tmg_start(53,'REESPE') 
    call gst_REESPE(sp,gd,nkgdim_l,nkgdim_l)
    call gst_REESPE(sptb,tb0,nflev_l,nflev_l)
    call tmg_stop(53) 

    ntrunchf=ntrunc_l/2
    sq2=sqrt(two)
!$OMP PARALLEL PRIVATE(thdid,numthd,JN,JM,JK,ILA,JN0,INS,JNS,zsp,zsp2)
    thdid=omp_get_thread_num()
    numthd=omp_get_num_threads()

    allocate(zsp(nkgdim_l,2,0:ntrunc_l))
    allocate(zsp2(nksdim2_l,2,0:ntrunc_l))

    do jn0 = thdid, ntrunchf,numthd
      ins=1
      if(jn0 == (ntrunc_l-jn0))ins=0
      do jns=0,ins
        jn=(1-jns)*jn0+jns*(ntrunc_l-jn0)

        do jm = 0, jn
          ila = gst_getNind(jm) + jn - jm
          do jk = 1, nkgdim_l
            zsp2(jk,1,jm) = sp(ila,1,jk)
            zsp2(jk,2,jm) = sp(ila,2,jk)
          enddo
        enddo
        do jm = 0, jn
          ila = gst_getNind(jm) + jn - jm
          do jk = 1, nflev_l
            zsp2(jk+nkgdim_l,1,jm) = sptb(ila,1,jk)
            zsp2(jk+nkgdim_l,2,jm) = sptb(ila,2,jk)
          enddo
        enddo

!        call dgemm('T','N',nkgdim_l,2*(jn+1),nksdim2_l,one8,corns(1,1,jn),nksdim2_l,  &
!                   zsp2(1,1,0),nksdim2_l,zero8,zsp(1,1,0),nkgdim_l)
        CALL DGEMUL(corns(1,1,jn),nksdim2_l,'T',zsp2(1,1,0),nksdim2_l,'N',zsp(1,1,0),nkgdim_l,nkgdim_l,nksdim2_l,2*(jn+1))

        ila = gst_getNind(0) +jn
        do jk = 1, nkgdim_l
          hiControlVector_out(ila,1,jk) = zsp(jk,1,0)*sq2
          hiControlVector_out(ila,2,jk) = zsp(jk,2,0)*sq2
        enddo
        ila = gst_getNind(0) +jn

        do jm = 1, jn
          ila = gst_getNind(jm) +jn - jm
          do jk = 1, nkgdim_l
            hiControlVector_out(ila,1,jk) = zsp(jk,1,jm)
            hiControlVector_out(ila,2,jk) = zsp(jk,2,jm)
            if(abs(zsp(jk,1,jm)).gt.zmax) zmax=abs(zsp(jk,1,jm))
          enddo
        enddo

      enddo
    enddo
    deallocate(zsp)
    deallocate(zsp2)
!$OMP END PARALLEL

    do jk=1,nkgdim_l
      do ila=1,ntrunc_l+1
        hiControlVector_out(ila,2,jk)=0.0
      enddo
    enddo

    deallocate(zgdpsi)
    deallocate(zgdchi)

    !write(*,*) 'end of spa2gdad!!!'
    return
  END SUBROUTINE BHI_SPA2GDAD


  SUBROUTINE bhi_divbal(pgdpsi,pgdchi)
    implicit none

    integer ilon, jk1, jlon, jlat
    real*8 zfact
    real*8 pgdpsi(ni_l,nflev_l,nj_l)
    real*8 pgdchi(ni_l,nflev_l,nj_l)

    do jlat = 1, nj_l
      do jk1=nlev_bdl,nflev_l
        zfact=-tan(theta(jk1,jlat))
        do jlon = 1, ni_l
          pgdchi(jlon,jk1,jlat)=pgdchi(jlon,jk1,jlat) + zfact*pgdpsi(jlon,jk1,jlat)
        enddo
      enddo
    enddo

  END SUBROUTINE bhi_divbal


  SUBROUTINE bhi_adivbal(pgdpsi,pgdchi)
    implicit none

    integer ilon, jk1, jlon, jlat
    real*8 zfact
    real*8 pgdpsi(ni_l,nflev_l,nj_l)
    real*8 pgdchi(ni_l,nflev_l,nj_l)

    do jlat = 1, nj_l
      do jk1=nlev_bdl,nflev_l
        zfact=-tan(theta(jk1,jlat))
        do jlon = 1, ni_l
          pgdpsi(jlon,jk1,jlat)=pgdpsi(jlon,jk1,jlat) + zfact*pgdchi(jlon,jk1,jlat)
        enddo
      enddo
    enddo

  END SUBROUTINE bhi_adivbal

  SUBROUTINE ZLEGDIR(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!**s/r ZLEGDIR  - Direct Legendre transform restricted to
!
!*Arguments
!*     i   PF(KNJDIM,KLEVDIM)   : field in physical space
!*     o   PN(0:KNDIM, KLEVDIM ): spectral coefficients
!*     o   PLEG(0:KNDIM, KNJDIM): Legendre polynomials evaluated at the Gaussian latitudes
!*     i   DDWT(KNJDIM)          : weights of the Gaussian quadrature
!*     i   KNJ                  : number of Gaussian latitudes
!*     i   KTRUNC               : spectral truncation
!*     i   KLEV                 : number of fields to transform
!*     i   KNJDIM               : dimensioning of the field (in latitude)
!*     i   KLEVDIM              : dimensioning of the field (in KLEV)
!*     I   KNDIM                : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL*8    PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL*8 DDWT(KNJ)

      INTEGER J, JN, IERR
      REAL*8, ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))
      DO J = 1, KNJ
         DO JN = 0,KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)*DDWT(J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'N',PF(1,1),KNJDIM,'N',PN(0,1),KNDIM+1,KNDIM+1,KNJ,KLEV) 

      DEALLOCATE(ZWORK)

      RETURN
  END SUBROUTINE ZLEGDIR


  SUBROUTINE ZLEGINV(PF,PN,PLEG,DDWT,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV  - Direct Legendre transform restricted to
!*     .           fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   DDWT(KNJDIM)         : weights of the Gaussian quadrature
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL*8    PF(KNJDIM,4*KLEVDIM), PN(0:KNDIM, 4*KLEVDIM), PLEG(0:KNDIM,KNJDIM)
      REAL*8 DDWT(KNJDIM)

      INTEGER J, JN, IERR
      REAL*8, ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0,KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV) 

      DEALLOCATE(ZWORK)

      RETURN
  END SUBROUTINE ZLEGINV


  SUBROUTINE ZLEGINV2(PF,PN,PLEG,KTRUNC,KNJ,KLEV,KNJDIM,KLEVDIM,KNDIM)
!***s/r ZLEGINV2  - Direct Legendre transform restricted to
!*     .            fields that vary with latitude only
!*Arguments
!*     o   PF(KNJDIM,KLEVDIM)  : field in physical space
!*     i   PN(0:KNDIM, KLEVDIM): spectral coefficients
!*     i   PLEG(0:KNDIM,KNJDIM): Legendre functions evaluated at the KNJ Gaussian
!*     .                         latitudes
!*     i   KNJ                 : number of Gaussian latitudes
!*     i   KTRUNC              : spectral truncation
!*     i   KLEV                : number of fields to transform
!*     i   KNJDIM              : dimensioning of the field (in latitude)
!*     i   KLEVDIM             : dimensioning of the field (in KLEV)
!*     I   KNDIM               : dimensioning of the field (in KTRUNC)
      IMPLICIT NONE

      INTEGER KNJ, KLEV, KTRUNC, KNJDIM, KLEVDIM, KNDIM
      REAL*8    PF(KNJDIM,KLEVDIM), PN(0:KNDIM, KLEVDIM), PLEG(0:KNDIM,KNJDIM)

      INTEGER J, JN, IERR
      REAL*8, ALLOCATABLE :: ZWORK(:,:)

      ALLOCATE(ZWORK(0:KTRUNC,KNJ))

      DO J = 1, KNJ
         DO JN = 0,KTRUNC
            ZWORK(JN,J) = PLEG(JN,J)
         END DO
      END DO

      CALL DGEMUL(ZWORK(0,1),KTRUNC+1,'T',PN(0,1),KNDIM+1,'N',PF(1,1),KNJDIM,KNJ,KTRUNC+1,KLEV) 

      DEALLOCATE(ZWORK)

      RETURN
  END SUBROUTINE ZLEGINV2

END MODULE BmatrixHI
