!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine postmin(lcolumng,lobsSpaceData)
#if defined (DOC)
*
***s/r postmin  - Post-minimization control of the 3Dvar
*
*
*Author  : S. Pellerin *ARMA/SMC  May 2000
*Revision:
*	    S. Pellerin: fix to spa2sp/spgd call conditions
*           C. Charette - ARMA/SMC - Sep. 2004
*            - Conversion to hybrid vertical coordinate
*           Bin He  *ARMA/SMC Dec. 2006
*            - added calling memfree before varout to free some memories
*              which are not needed in varout.
*           S. Pellerin August 2008
*            - Added calls to 'tmg_*' subroutines
*           L. Fillion - ARMA/SMC - Feb. 2005 - Limited area LAM4D analysis option.
*           L. Fillion ARMA/EC May 2006: LAM4D upgrade to v10_0_0.
*           L. Fillion ARMA/EC 21 Feb 2007: Include option to write glb-st-dev on anal incr file (anal res).
*           L. Fillion ARMA/EC 14 Aug 2007 - Update LAM4D to v_10_0_3.
*           L. Fillion ARMA/EC 14 Oct 2009 - Comment call to stdevout.ftn ... impacts minimization in v1033 if used in sucov.ftn ...
*           Bin He   *ARMA/MRB   Oct. 2009 
*                  - Implemented MPI to 3DVAR  
*           L. Fillion ARMA/EC Oct 2009 - Include global rotated grid option. Rewrite varout.ftn for rotated regional and 'LU' mode
*           L. Fillion ARMA/EC 4&20 May 2010 - Upgrade to v_11_01b. Skip
*                     some preliminary obs-space treatment below when in l1obs mode.
*                     Improve output of HU field.
*    -------------------
**
*
*Arguments
*    -NONE-
#endif
      use MathPhysConstants_mod
      use globalSpectralTransform
      use mod4dv, only : l4dvar
      use obsSpaceData_mod
      use controlVector_mod
      use minimization_mod
      use bmatrix
      use columnData_mod
      use modfgat
      use mpi
      use gridStateVector
      IMPLICIT NONE
*implicits
#include "pardim.cdk"
#include "comdim.cdk"
#include "comlun.cdk"
#include "comcva.cdk"
#include "comgem.cdk"
#include "comgdpar.cdk"
#include "compost.cdk"
#include "comgd0.cdk"
#include "compdg.cdk"
#include "localpost.cdk"
#include "comvfiles.cdk"
*
      type(struct_obs),target :: lobsSpaceData
      type(struct_columnData),target :: lcolumng
C
      LOGICAL LLTEST,llstdevout
      INTEGER IZS(1)
      REAL*8 ZZS(1)
      REAL*8 DLDS(1)
      real*8 zpsig(ni,nflev,nj)
      real*8 z3d(ni,nflev,nj)
      type(struct_gsv) :: statevector

      CHARACTER *8 CSTATUS
C
      INTEGER IMPRES, IMODE, ITERMAX, ISIMMAX, INDIC, ISCALE
      INTEGER IERR,ITERDONE,ITERTOT,JK, JLA,ilen,jj,ji
      REAL*8 ZJSP, ZXMIN, ZDF1, ZEPS, ZSMACH,ztemp,zy,zr
      REAL*8 DLGNORM, DLXNORM, DLGNORM0, DLGNORMS
C
      integer idum1,idum2,idum3,idum4,ipt,ibeg,iend,jbeg,jend
      integer ini,index,ii,ij,jk1,jk2
      real*8 zcon,zcorr,zx,zl
      real*8  zmin,zmax
!
      LOGICAL LSTAGTEMP
      INTEGER FNOM,FCLOS
      EXTERNAL FNOM,FCLOS
      EXTERNAL SUPOST
c
c     if a restart file was writen at the end of minimize.ftn,
c     lrestart was turn to .true. to avoid postmin exection
c
      if (lrestart) return
c
      write(*,*) '-------------------------------'
      write(*,*) '--Starting subroutine postmin--'
      write(*,*) '-------------------------------'
c
      LVARDIAG=.FALSE.
      llstdevout = .false.
!
      ILEN = NI*NFLEV*NJ
      CALL HPALLOC(PXTTG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXGZG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXHUG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXUUG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXVVG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXPP,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXQQ,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXCC,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXQR,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXDD,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXTTB,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXTTU,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXTV,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXGZ,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXGZB,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXGZU,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXES,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXESG,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXHU,MAX(1,ILEN),IERR,8)
      CALL HPALLOC(PXO3,MAX(1,NI*NJ),IERR,8)
      CALL HPALLOC(PXPSG,MAX(1,NI*NJ),IERR,8)
      CALL HPALLOC(PXPSB,MAX(1,NI*NJ),IERR,8)
      CALL HPALLOC(PXPSU,MAX(1,NI*NJ),IERR,8)
      CALL HPALLOC(PXPT,MAX(1,NI*NJ),IERR,8)

*
      CALL ZERO(ILEN,ZQQ(1,1,1))
      CALL ZERO(ILEN,ZQR(1,1,1))
      CALL ZERO(ILEN,ZPP(1,1,1))
      CALL ZERO(ILEN,ZDD(1,1,1))
      CALL ZERO(ILEN,ZCC(1,1,1))
      CALL ZERO(ILEN,ZUUG(1,1,1))
      CALL ZERO(ILEN,ZVVG(1,1,1))
      CALL ZERO(ILEN,ZTTG(1,1,1))
      CALL ZERO(ILEN,ZGZG(1,1,1))
      CALL ZERO(ILEN,ZTTB(1,1,1))
      CALL ZERO(ILEN,ZTTU(1,1,1))
      CALL ZERO(ILEN,ZTV(1,1,1))
      CALL ZERO(ILEN,ZGZ(1,1,1))
      CALL ZERO(ILEN,ZGZB(1,1,1))
      CALL ZERO(ILEN,ZGZU(1,1,1))
      CALL ZERO(ILEN,ZES(1,1,1))
      CALL ZERO(ILEN,ZESG(1,1,1))
      CALL ZERO(ILEN,ZHU(1,1,1))
      CALL ZERO(ILEN,ZHUG(1,1,1))
      CALL ZERO(NI*NJ,ZO3(1,1))
      CALL ZERO(NI*NJ,zpsg(1,1))
      CALL ZERO(NI*NJ,zpsb(1,1))
      CALL ZERO(NI*NJ,zpsu(1,1))
      CALL ZERO(NI*NJ,zpt(1,1))

C     Copy REAL*8 part of CMA back to REAL*4 CMA counterpart
C     after minimization has ended. From this point all CMA
C     references are to ROBDATA.

        call cprob8to4(lobsSpaceData)
C
        IF (LVARQC) CALL LISTREJ(lobsSpaceData)
C
        CALL VINT3DFD('OMA ',lobsSpaceData)
        CALL VINT3DFD('OMF ',lobsSpaceData)
        CALL SETASSFLG(lobsSpaceData)
        CALL FILBRPPOST(lcolumng,lobsSpaceData)
c
        CALL SUPOST  ! problem with nflev = 1
c
        NIP2  = NIP2A
        NIG2  = NIG2A
        NDEET = NDEETA
        NPAS  = NPASA
        NSTAMP= NSTAMPA
        CVARPOST = 'R'
c
C In l4dvar mode transform of variables has already been done in ENDSIM2
C at the end of minimize
      if(.not. l4dvar .or. .not. ltlmend) then
        call tmg_start(51,'VAR_CH') !

        call gsv_allocate(statevector,ni,nj,nkgdim,nflev,nstepobsinc)
        call oda_sqrtB(cvm_vazx,cvm_nvadim,statevector)
        gd(:,:,:)=statevector%gd3d(:,:,:)
        call gsv_deallocate(statevector)

        WRITE(NULOUT,*)' postmin: Transform analysis variables to'
     S       ,' model variables -'

        call tmg_stop (51)      !
      endif
c
C      Compute increments of HU on analysis grid
c      This field is compulsary because it is used
c      to produce the analysis of HU in FELIX
c
        do jj=1,nj
          do jk=1,nflev
            do ji=1,ni
              zuug(ji,jk,jj)=utg(ji,jk,jj)
              zvvg(ji,jk,jj)=vtg(ji,jk,jj)
              zttg(ji,jk,jj)=ttg(ji,jk,jj)
              zgzg(ji,jk,jj)=gzg(ji,jk,jj)
              zhug(ji,jk,jj)=qg(ji,jk,jj)
            enddo
          enddo
        enddo
        do ji=1,ni
          do jj=1,nj
            zpsg(ji,jj)=gpsg(ji,1,jj)
          enddo
        enddo
!
        do jk = 1,nflev
          do jj = 1,nj
            do ji = 1,ni
              z3d(ji,jk,jj) = ut0(ji,jk,jj)
            enddo
          enddo
        enddo
        call maxmin(z3d,ni,nj,nflev,zmin,zmax,
     &              idum1,idum2,idum3,idum4,'postmin        ',
     &              'U0 ')
        do jk = 1,nflev
          do jj = 1,nj
            do ji = 1,ni
              z3d(ji,jk,jj) = tt0(ji,jk,jj)
            enddo
          enddo
        enddo
        call maxmin(z3d,ni,nj,nflev,zmin,zmax,
     &              idum1,idum2,idum3,idum4,'postmin        ',
     &              'T0 ')
!
        do jk = 1,nflev
          do jj = 1,nj
            do ji = 1,ni
              z3d(ji,jk,jj) = q0(ji,jk,jj)
            enddo
          enddo
        enddo
        call maxmin(z3d,ni,nj,nflev,zmin,zmax,
     &              idum1,idum2,idum3,idum4,'postmin        ',
     &              'Q0 ')
!
      ibeg = 1
      iend = ni
      jbeg = 1
      jend = nj
c
      IF ( CHUM .EQ. 'LQ') THEN
        zhu(:,:,:) = 0.0
        do jk = 1,nflev
          do jj = jbeg,jend
            do ji = ibeg,iend
              ZTEMP = log(zhug(ji,jk,jj)) + q0(ji,jk,jj)
              zhu(ji,jk,jj) = EXP(ZTEMP) - zhug(ji,jk,jj)
            enddo
          enddo
        enddo
      endif
!
      call diag3dvar
      call memfree(nulout,lobsSpaceData)
!
      call tmg_start(99,'VAROUT')
!
      if(mpi_myid == 0 ) then
          call varout
      endif
!
      call tmg_stop(99)
C
      CALL HPDEALLC(PXTTG,IERR,1)
      CALL HPDEALLC(PXHUG,IERR,1)
      CALL HPDEALLC(PXUUG,IERR,1)
      CALL HPDEALLC(PXVVG,IERR,1)
      CALL HPDEALLC(PXPP,IERR,1)
      CALL HPDEALLC(PXQQ,IERR,1)
      CALL HPDEALLC(PXCC,IERR,1)
      CALL HPDEALLC(PXQR,IERR,1)
      CALL HPDEALLC(PXDD,IERR,1)
      CALL HPDEALLC(PXTTB,IERR,1)
      CALL HPDEALLC(PXTTU,IERR,1)
      CALL HPDEALLC(PXTV,IERR,1)
      CALL HPDEALLC(PXGZ,IERR,1)
      CALL HPDEALLC(PXGZB,IERR,1)
      CALL HPDEALLC(PXGZU,IERR,1)
      CALL HPDEALLC(PXES,IERR,1)
      CALL HPDEALLC(PXESG,IERR,1)
      CALL HPDEALLC(PXHU,IERR,1)
      CALL HPDEALLC(PXO3,IERR,1)
      CALL HPDEALLC(PXPSG,IERR,1)
      CALL HPDEALLC(PXPSB,IERR,1)
      CALL HPDEALLC(PXPSU,IERR,1)
      CALL HPDEALLC(PXPT,IERR,1)

      write(nulout,*) 'LEAVING POSTMIN'
      RETURN
      END
