!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine postmin(lcolumng,lcolumnhr,lobsSpaceData)
#if defined (DOC)
*
***s/r postmin  - Post-minimization control of the 3Dvar
*
*Author  : S. Pellerin *ARMA/SMC  May 2000
*
#endif
      use MathPhysConstants_mod
      use mod4dv, only : l4dvar
      use obsSpaceData_mod
      use controlVector_mod
      use columnData_mod
      use minimization_mod
      use bmatrix_mod
      use mpi
      use gridStateVector_mod
      use gaussGrid_mod
      IMPLICIT NONE
*implicits
#include "comlun.cdk"
#include "comvfiles.cdk"
#include "comfilt.cdk"
#include "cvcord.cdk"
*
      type(struct_obs),target :: lobsSpaceData
      type(struct_columnData),target :: lcolumng,lcolumnhr
C
      type(struct_gsv) :: statevector,statevectorg

      CHARACTER *8 CSTATUS
C
      INTEGER IMPRES, IMODE, ISIMMAX, INDIC, ISCALE
      INTEGER IERR,JK, JLA,ilen,jj,ji
      REAL*8 ZJSP, ZXMIN, ZDF1, ZEPS, ZSMACH,ztemp,zy,zr
      REAL*8 DLGNORM, DLXNORM, DLGNORM0, DLGNORMS
C
      integer idum1,idum2,idum3,idum4,ipt
      integer ini,index,ii,ij,jk1,jk2
      real*8 zcon,zcorr,zx,zl
      real*8  zmin,zmax
      real*8 :: zes(gaus_ni,lcolumng%vco%nlev_M,gaus_nj)
      real*8 :: ztv(gaus_ni,lcolumng%vco%nlev_M,gaus_nj)
      real*8 :: zgz(gaus_ni,lcolumng%vco%nlev_M,gaus_nj)
      real*8 :: zhu(gaus_ni,lcolumng%vco%nlev_M,gaus_nj)
!
      LOGICAL LSTAGTEMP
      INTEGER FNOM,FCLOS
      EXTERNAL FNOM,FCLOS
      EXTERNAL SUPOST
c
c     if a restart file was writen at the end of minimize.ftn,
c     lrestart was turn to .true. to avoid postmin exection
c
      if (lrestart) return
c
      write(*,*) '-------------------------------'
      write(*,*) '--Starting subroutine postmin--'
      write(*,*) '-------------------------------'
c
C     Copy REAL*8 part of CMA back to REAL*4 CMA counterpart
C     after minimization has ended. From this point all CMA
C     references are to ROBDATA.

      call cprob8to4(lobsSpaceData)
C
      IF (LVARQC) CALL LISTREJ(lobsSpaceData)
C
      CALL VINT3DFD('OMA ',lobsSpaceData)
      CALL VINT3DFD('OMF ',lobsSpaceData)
      CALL SETASSFLG(lobsSpaceData)
      CALL FILBRPPOST(lcolumng,lobsSpaceData)
c
      CALL SUPOST  ! problem with nflev = 1
c
C In l4dvar mode transform of variables has already been done in ENDSIM2
C at the end of minimize
      call gsv_allocate(statevector,gaus_ni,gaus_nj,lcolumng%vco%nlev_M,
     +                  nstepobsinc,obs_get_datestamp(lobsSpaceData))
      statevector%vco => lcolumng%vco
      if(.not. l4dvar .or. .not. ltlmend) then
        call tmg_start(51,'VAR_CH') !

        call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

        WRITE(NULOUT,*)' postmin: Transform analysis variables to'
     S       ,' model variables -'

        call tmg_stop (51)      !
      endif
c
C      Compute increments of HU on analysis grid
c      This field is compulsary because it is used
c      to produce the analysis of HU in FELIX
c
!
!     Prepare background fields at initial time for flow-dependent control variables
!
      call gsv_allocate(statevectorg,gaus_ni,gaus_nj,lcolumng%vco%nlev_M,
     +                  nstepobs,obs_get_datestamp(lobsSpaceData))
      statevectorg%vco => lcolumng%vco
      call subasic_gd(statevectorg,lcolumnhr)
!
!     *** Compute increment HU from LQ increment
!
      zhu(:,:,:) = 0.0
      do jk = 1,statevectorg%vco%nlev_M
        do jj = 1,statevectorg%nj
          do ji = 1,statevectorg%ni
            ZTEMP = log(statevectorg%hu3d(ji,jk,jj)) + statevector%hu3d(ji,jk,jj)
            zhu(ji,jk,jj) = EXP(ZTEMP) - statevectorg%hu3d(ji,jk,jj)
          enddo
        enddo
      enddo
!
!     *** ES ***
!
      call lq2esgd(zes,statevector,statevectorg)
!
!     *** Total GZ ***
!
      call lt2tvgd(ztv,statevector%tt3d,statevector%hu3d,statevectorg%hu3d,
     +             statevectorg%ni,statevectorg%nj,statevectorg%nlev)
      call ltt2phigd(zgz,ztv,statevectorg)
!
      call memfree(nulout,lobsSpaceData)
!
      call tmg_start(99,'VAROUT')
!
      if(mpi_myid == 0 ) then
          call varout(statevector,zes,ztv,zgz,zhu)
      endif
!
      call tmg_stop(99)
C
      call gsv_deallocate(statevector)
      call gsv_deallocate(statevectorg)

      write(nulout,*) 'LEAVING POSTMIN'
      RETURN
      END SUBROUTINE POSTMIN
