!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_H(lcolumn,lcolumng,lobsSpaceData)
  use mpi
  use EarthConstants_mod
  use MathPhysConstants_mod
  use obsSpaceData_mod
  use columnData_mod 
  use bufr
  implicit none
  !
  !Purpose:
  !Compute simulated observations from profiled model
  !increments.
  !It returns Hdx in ROBDATA8(OBS_OMA,*)
  !Calls the several linear observation operators
  !
  !Author  : S. Pellerin *ARMA/MRB January 2009
  !
  !Revision:
  ! L. Fillion, ARMA/EC, 5 Jun 2009. Introduce 1 Obs experiment.
  ! S. Macpherson ARMA  11 Sep 2009
  !            - added ground-based GPS (ZTD) observation operator
  !
  !Local declarations
  integer, save :: nl_ncall = 0
  real*8 :: dl_bidon
#include "comgpsgb.cdk"
  type(struct_columnData) :: lcolumn,lcolumng
  type(struct_obs) :: lobsSpaceData
  type(struct_vco), pointer :: vco_anl

  IF(mpi_myid == 0) THEN
    write(*,*)'ODA_H- Linearized observation operators'
    call flush(6)
  endif

  vco_anl => col_getVco(lcolumng)

  nl_ncall = nl_ncall + 1

  call tmg_start(42,'OBS_PPP_TLAD') !
  call oda_Hpp              ! fill in OBS_OMA : Hdx
  call tmg_stop(42)

  call tmg_start(43,'OBS_SFC_TLAD')
  call oda_Hsf              ! fill in OBS_OMA : Hdx
  call tmg_stop (43)

  call tmg_start(44,'OBS_TOV_TLAD') !
  call oda_Hto              ! fill in OBS_OMA : Hdx
  call tmg_stop (44)

  call tmg_start(45,'OBS_GPSRO_TLAD') !
  call oda_Hro
  call tmg_stop (45)        !

  call tmg_start(46,'OBS_ZZZ_TLAD') !
  call oda_Hzp
  call tmg_stop (46)        !

  call tmg_start(47,'OBS_GPSGB_TLAD') !
  call oda_Hgp
  call tmg_stop (47)        !


  CONTAINS

      SUBROUTINE oda_Hpp
!*
!* Purpose: Compute simulated Upper Air observations from profiled model
!*          increments.
!*          It returns Hdx in ROBDATA8(OBS_OMA,*)
!*          Interpolate vertically the contents of commvo to
!*          the pressure levels of the observations.
!*          A linear interpolation in ln(p) is performed.
!*
!*implicits
      INTEGER IPB,IPT
      INTEGER INDEX_HEADER,INDEX_FAMILY,IK
      INTEGER J,INDEX_BODY,ITYP
      REAL*8 ZDADPS,ZCON
      REAL*8 ZWB,ZWT, ZEXP, ZGAMMA,ZLTV,ZTVG,ZPPOST
      REAL*8 ZLEV,ZPT,ZPB,ZLAT,ZLON,ZTORAD,ZPRESBPB,ZPRESBPT
      REAL*8 columnVarB,columnVarT,columngVarB,columngVarT,lqtoes,lqtoes_tl
      LOGICAL LLASSIM,LLDIAG
      INTEGER, PARAMETER :: numFamily=3
      CHARACTER(len=2) :: list_family(numFamily)
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C
      zgamma = 0.0065D0 / GRAV
      zexp = MPC_RGAS_DRY_AIR_R8*zgamma

      list_family(1) = 'UA'
      list_family(2) = 'AI'
      list_family(3) = 'SW'

      FAMILY: do index_family=1,numFamily

        call obs_set_current_body_list(lobsSpaceData, list_family(index_family))
        BODY: do
          index_body = obs_getBodyIndex(lobsSpaceData)
          if (index_body < 0) exit BODY

          llassim= (obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body) .EQ. 1) &
             .AND. (obs_bodyElem_i(lobsSpaceData,OBS_XTR,index_body) .EQ. 0) &
             .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VCO,index_body) .EQ. 2)
          lldiag = (obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body) .EQ. -1) &
             .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VCO,index_body) .EQ. 2)
          IF (llassim .or. lldiag) THEN
            INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
            ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
            ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
            IK   = obs_bodyElem_i(lobsSpaceData,OBS_LYR,INDEX_BODY)
            IPT  = IK + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1
            ZPT  = col_getPressure(LCOLUMNG,IK  ,INDEX_HEADER,'NA')
            ZPB  = col_getPressure(LCOLUMNG,IK+1,INDEX_HEADER,'NA')
            ZWB  = LOG(ZLEV/ZPT)/LOG(ZPB/ZPT)
            ZWT  = 1.0D0 - ZWB
            zpresbpt = vco_anl%db_M(ik)
            zpresbpb = vco_anl%db_M(ik+1)
            ZDADPS   = ( (ZPRESBPT/ZPT)*LOG(ZLEV/ZPB)  &
                -(ZPRESBPB/ZPB)*LOG(ZLEV/ZPT) )  &
                /LOG(ZPB/ZPT)**2

            if(ityp.eq.bufr_nees) then
              columnVarB=lqtoes_tl(col_getElem(lcolumn,IK+1,INDEX_HEADER,'HU'), &
                                   col_getElem(lcolumn,IK+1,INDEX_HEADER,'TT'), &
                                   col_getElem(lcolumn,1,INDEX_HEADER,'P0'), &
                                   col_getElem(lcolumng,IK+1,INDEX_HEADER,'HU'), &
                                   col_getPressure(lcolumng,IK+1,INDEX_HEADER,'NA'), &
                                   vco_anl%dhyb_m(IK+1),vco_anl%db_m(IK+1))
              columnVarT=lqtoes_tl(col_getElem(lcolumn,IK  ,INDEX_HEADER,'HU'), &
                                   col_getElem(lcolumn,IK  ,INDEX_HEADER,'TT'), &
                                   col_getElem(lcolumn,1,INDEX_HEADER,'P0'), &
                                   col_getElem(lcolumng,IK  ,INDEX_HEADER,'HU'), &
                                   col_getPressure(lcolumng,IK  ,INDEX_HEADER,'NA'),  &
                                   vco_anl%dhyb_m(IK  ),vco_anl%db_m(IK  ))
              columngVarB=lqtoes(col_getElem(lcolumng,IK+1,INDEX_HEADER,'HU'), &
                                 col_getElem(lcolumng,IK+1,INDEX_HEADER,'TT'), &
                                 col_getPressure(lcolumng,IK+1,INDEX_HEADER,'NA'))
              columngVarT=lqtoes(col_getElem(lcolumng,IK  ,INDEX_HEADER,'HU'), &
                                 col_getElem(lcolumng,IK  ,INDEX_HEADER,'TT'), &
                                 col_getPressure(lcolumng,IK  ,INDEX_HEADER,'NA'))
            else
              columnVarB=col_getElem(lcolumn,IPB,INDEX_HEADER)
              columnVarT=col_getElem(lcolumn,IPT,INDEX_HEADER)
              columngVarB=col_getElem(lcolumng,IPB,INDEX_HEADER)
              columngVarT=col_getElem(lcolumng,IPT,INDEX_HEADER)
            endif
            call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY,   &
                 ZWB*columnVarB + ZWT*columnVarT+  &
                 (columngVarB - columngVarT)*  &
                 ZDADPS*col_getElem(LCOLUMN,1,INDEX_HEADER,'P0'))
          elseif( (obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body) .EQ. 1) &
            .AND. (obs_bodyElem_i(lobsSpaceData,OBS_XTR,index_body) .EQ. 2) &
            .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VCO,index_body) .EQ. 2) ) then
            INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
            ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
!C
!c-----------TL model for height data below model's orography
!c
            ZLTV = lcolumng%OLTV(1,col_getNumLev(LCOLUMN),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(LCOLUMN),INDEX_HEADER,'TT') &
                 + lcolumng%OLTV(2,col_getNumLev(LCOLUMN),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(LCOLUMN),INDEX_HEADER,'HU')
            ZTVG = lcolumng%OLTV(1,col_getNumLev(LCOLUMN),INDEX_HEADER)*col_getElem(lcolumng,col_getNumLev(LCOLUMN),INDEX_HEADER,'TT')
            ZCON =(ZLEV/col_getElem(lcolumng,1,INDEX_HEADER,'P0'))**ZEXP
            call obs_bodySet_r(lobsSpaceData,OBS_OMA,index_body, (1.-zcon)/zgamma*ZLTV &
                + MPC_RGAS_DRY_AIR_R8*ZTVG*zcon*col_getElem(lcolumn,1,index_header,'P0') &
                /col_getElem(lcolumng,1,index_header,'P0'))
          endif

        ENDDO BODY

      ENDDO FAMILY

      END subroutine oda_Hpp


      SUBROUTINE oda_Hsf
!*
!* Purpose: Compute simulated surface observations from profiled model
!*          increments.
!*          It returns Hdx in ROBDATA8(OBS_OMA,*)
!*
      IMPLICIT NONE

      INTEGER IPB,IPT,IXTR
      INTEGER INDEX_HEADER,IK
      INTEGER J,INDEX_BODY,ITYP,INDEX_FAMILY
      REAL*8 ZCON
      REAL*8 ZWB,ZWT, ZEXP,ZEXPGZ,ZGAMMA,ZLTV,ZTVG,ZPPOST
      REAL*8 ZLEV,ZPT,ZPB,ZDELPS,ZDELTV,ZGAMAZ,ZHHH
      REAL*8 columnVarB,lqtoes_tl
      INTEGER, PARAMETER :: numFamily=4
      CHARACTER(len=2) :: list_family(numFamily)
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C
      zgamma = 0.0065 / GRAV
      zexp   = 1.0/(MPC_RGAS_DRY_AIR_R8*zgamma)
      zexpGZ = MPC_RGAS_DRY_AIR_R8*zgamma
!C
!C
      list_family(1) = 'UA'
      list_family(2) = 'SF'
      list_family(3) = 'SC'
      list_family(4) = 'GP'

      FAMILY: do index_family=1,numFamily

        call obs_set_current_body_list(lobsSpaceData, list_family(index_family))
        BODY: do
          index_body = obs_getBodyIndex(lobsSpaceData)
          if (index_body < 0) exit BODY

! Process all data within the domain of the model
          ityp = obs_bodyElem_i(lobsSpaceData,OBS_VNM,index_body)
          if(    (obs_bodyElem_i(lobsSpaceData,OBS_VCO,index_body).eq.1) &
           .and. (obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body).eq.1) &
           .and. (ityp.eq.bufr_nets .or. ityp.eq.bufr_neps  &
             .or. ityp.eq.bufr_nepn .or. ityp.eq.bufr_ness  &
             .or. ityp.eq.bufr_neus .or. ityp.eq.bufr_nevs  &
             .or. obs_bodyElem_i(lobsSpaceData,OBS_XTR,index_body).eq.0) ) then

            INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
            ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
            IXTR = obs_bodyElem_i(lobsSpaceData,OBS_XTR,INDEX_BODY)
            IK   = obs_bodyElem_i(lobsSpaceData,OBS_LYR,INDEX_BODY)
            ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
            ZHHH = ZLEV * GRAV
            IPT  = col_getNumLev(LCOLUMN)-1 + col_getOffsetFromVarno(lcolumng,ityp)
            IPB  = IPT+1

            IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NESS .OR.  &
                ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS) THEN
              if(ITYP.eq.BUFR_NESS) THEN
                columnVarB=lqtoes_tl(col_getElem(lcolumn,col_getNumLev(lcolumn),INDEX_HEADER,'HU'), &
                                     col_getElem(lcolumn,col_getNumLev(lcolumn),INDEX_HEADER,'TT'), &
                                     col_getElem(lcolumn,1,INDEX_HEADER,'P0'), &
                                     col_getElem(lcolumng,col_getNumLev(lcolumn),INDEX_HEADER,'HU'), &
                                     col_getPressure(lcolumng,col_getNumLev(lcolumn),INDEX_HEADER,'NA'),  &
                                     vco_anl%dhyb_m(col_getNumLev(lcolumn)),vco_anl%db_m(col_getNumLev(lcolumn)))
              else
                columnVarB=col_getElem(LCOLUMN,IPB,INDEX_HEADER)
              endif
              call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY,columnVarB)
            ELSEIF (ITYP.EQ.BUFR_NEPS .OR. ITYP.EQ.BUFR_NEPN) THEN
              ZLTV  = lcolumng%OLTV(1,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(lcolumn),INDEX_HEADER,'TT')  & 
                    + lcolumng%OLTV(2,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(lcolumn),INDEX_HEADER,'HU')
              ZTVG  = lcolumng%OLTV(1,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(lcolumng,col_getNumLev(lcolumn),INDEX_HEADER,'TT')
              ZGAMAZ= ZGAMMA*(ZHHH-col_getHeight(lcolumng,col_getNumLev(lcolumn),INDEX_HEADER,'NA'))
              ZCON  = ((ZTVG-ZGAMAZ)/ZTVG)
              ZDELPS= (col_getElem(LCOLUMN,1,INDEX_HEADER,'P0')*ZCON**ZEXP)
              ZDELTV= ((col_getElem(lcolumng,1,INDEX_HEADER,'P0')*ZEXP*ZCON**(ZEXP-1))  &
                   *(ZGAMAZ/(ZTVG*ZTVG)*ZLTV))
              call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY, ZDELPS+ZDELTV)
            ELSE
              IPT  = IK + col_getOffsetFromVarno(lcolumng,ityp)
              IPB  = IPT+1
              ZPT  = col_getHeight(lcolumng,IK,INDEX_HEADER,'NA')
              ZPB  = col_getHeight(lcolumng,IK+1,INDEX_HEADER,'NA')
              ZWB  = (ZPT-ZHHH)/(ZPT-ZPB)
              ZWT  = 1. - ZWB
              call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY,  &
                   ZWB*col_getElem(LCOLUMN,IPB,INDEX_HEADER) + ZWT*col_getElem(LCOLUMN,IPT,INDEX_HEADER)+  &
                   (col_getElem(lcolumng,IPB,INDEX_HEADER)-col_getElem(lcolumng,IPT,INDEX_HEADER)))
            ENDIF
          elseif( (obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body) .EQ. 1) &
            .AND. (obs_bodyElem_i(lobsSpaceData,OBS_XTR,index_body) .EQ. 2) &
            .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VNM,index_body) .EQ. BUFR_NEGZ ) &
            .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VCO,index_body) .EQ. 1)    ) then
            INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
            ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
!C
!C                 CONTRIBUTION TO Jo
!C
!c  TL model for height data below model's orography
!c
            ZLTV = lcolumng%OLTV(1,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(lcolumn),INDEX_HEADER,'TT') &
                 + lcolumng%OLTV(2,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(LCOLUMN,col_getNumLev(lcolumn),INDEX_HEADER,'HU')
            ZTVG = lcolumng%OLTV(1,col_getNumLev(lcolumn),INDEX_HEADER)*col_getElem(lcolumng,col_getNumLev(lcolumn),INDEX_HEADER,'TT')
            ZCON=(ZLEV/col_getElem(lcolumng,1,INDEX_HEADER,'P0'))**ZEXPGZ
            call obs_bodySet_r(lobsSpaceData,OBS_OMA,index_body,(1.-zcon)/zgamma*ZLTV &
                + MPC_RGAS_DRY_AIR_R8*ZTVG*zcon*col_getElem(lcolumn,1,index_header,'P0') &
                /col_getElem(lcolumng,1,index_header,'P0'))
          endif

        enddo BODY

      enddo FAMILY

      END subroutine oda_Hsf

      subroutine oda_Hto
  !
  ! Purpose: Compute simulated radiances observations from profiled model
  !          increments.
  !          It returns Hdx in ROBDATA8(OBS_OMA,*)
  !
  !author        : j. halle *cmda/aes  april 8, 2005
  !
  !revision 001  : a. beaulne *cmda/smc  july 2006
  !                    -addition of geopotential field in call to
  !                     tovs_fill_profiles
  !                S. Pellerin, ARMA, August 2008
  !                    - Avoid multiple (iterative) interpolation to 43 levels
  !                      background variable profiles
  !                S. Pellerin, ARMA, January 2009
  !                    - call to oda_storeHdx_radiances instead computing Jo
  !

  integer, save :: nbr_call = 0

  !     1.   Prepare atmospheric profiles for all tovs observation points for use in rttov
  !     .    -----------------------------------------------------------------------------
  !
  ! put lcolumng into column1  (why?)
!  column1%all(:,:) = lcolumng%all(:,:)
  if (nbr_call == 0) then
     call tovs_fill_profiles(lcolumng,lobsSpaceData)
  endif

  !     2.   Prepare atmospheric tl profiles for all tovs observation points for use in rttov
  !     .    --------------------------------------------------------------------------------
  !
  call tovs_fill_profiles_tl(lcolumn,lcolumng,lobsSpaceData)

  !     3.   Compute radiance
  !     .    ----------------
  !
  call tovs_rttov_tl(lobsSpaceData)


  call oda_storeHdx_radiances(lobsSpaceData)

  nbr_call = nbr_call + 1

  return

end subroutine oda_Hto


      SUBROUTINE oda_Hro
!*
!* Purpose: Compute simulated GPSRO observations from profiled model
!*          increments.
!*          It returns Hdx in ROBDATA8(OBS_OMA,*)
!*Author  : J. M. Aparicio Jan 2004
      use modgps04profile
      use modgps06gravity
      use modgps08refop
      use IndexListDepot_mod, only:  struct_index_list

      REAL*8 ZLAT, Lat
      REAL*8 ZLON, Lon
      REAL*8, allocatable :: ZETA(:)
      REAL*8, allocatable :: BTT(:)
      REAL*8, allocatable :: BHU(:)
      REAL*8, allocatable :: BGZ(:)
      REAL*8 BP0
      REAL*8 BPT, BPR, BCF
      REAL*8 BMT
      REAL*8 DH
      REAL*8 HNH1

      REAL*8 ZMHXL
      REAL*8 JAC(ngpscvmx)
      REAL*8 DX (ngpscvmx)

      INTEGER IDATYP
      INTEGER JL, JV, NGPSLEV
      integer :: index_header, index_body
      type(struct_index_list), pointer :: local_current_list

      LOGICAL  ASSIM, LUSE

      INTEGER NH, NH1
      TYPE(GPSPROFILE)           :: PRF
      REAL(DP)     , ALLOCATABLE :: H   (:)
      TYPE(GPSDIFF), ALLOCATABLE :: RSTV(:)
!C
!C     * 1.  Initializations
!C     *     ---------------
      allocate(ZETA(col_getNumLev(lcolumn)))
      allocate(BTT(col_getNumLev(lcolumn)))
      allocate(BHU(col_getNumLev(lcolumn)))
      allocate(BGZ(col_getNumLev(lcolumn)))
!C
!C     *     Eta vector:
!C
      NGPSLEV=col_getNumLev(lcolumn)
      DO JL = 1, col_getNumLev(lcolumn)
        ZETA(JL) = vco_anl%dhyb_m(JL)
      ENDDO

!C
!  loop over all header indices of the 'RO' family (Radio Occultation)
!C
      ! Set the header list (start at the beginning of the list)
      call obs_set_current_header_list(lobsSpaceData,'RO')
!$omp parallel default(shared) &
!$omp private(idatyp,assim,nh) &
!$omp private(luse,lat,lon,zlat,zlon,jl,btt) &
!$omp private(bhu,bgz,bp0,bpt,bmt,bpr,bcf,dx,prf) &
!$omp private(h,rstv,nh1,hnh1) &
!$omp private(jac,zmhxl,jv) &
!$omp private(index_header,index_body,local_current_list)
      nullify(local_current_list)
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
!C
!C     *        Process only refractivity data (codtyp 169)
!C
         IDATYP = obs_headElem_i(lobsSpaceData,OBS_ITY,index_header)
         DATYP: IF ( IDATYP .EQ. 169 ) THEN
           ASSIM = .FALSE.
!C
!C                 Loops over data in the observation
!C
!C
!C                 Scan for requested assimilations, and count them
!C
           NH = 0
           ! loop over all body indices for this index_header
           call obs_set_current_body_list(lobsSpaceData, index_header, &
                                          current_list=local_current_list)
           BODY: do 
              index_body = obs_getBodyIndex(local_current_list)
              if (index_body < 0) exit BODY

              LUSE=( obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body).EQ.1 )
              IF ( LUSE ) THEN
                ASSIM = .TRUE.
                NH = NH + 1
              ENDIF
           ENDDO BODY
!C
!C     *           If assimilations are requested, apply the observation
!c operator
!C
           ASSIMILATE: IF (ASSIM) THEN
!C
!C     *              Profile at the observation location:
!C
              Lat  = obs_headElem_r(lobsSpaceData,OBS_LAT,index_header)
              Lon  = obs_headElem_r(lobsSpaceData,OBS_LON,index_header)
              ZLAT = Lat * MPC_DEGREES_PER_RADIAN_R8
              ZLON = Lon * MPC_DEGREES_PER_RADIAN_R8
              DO JL = 1, col_getNumLev(lcolumn)
!C
!C     *                 Profile x_b
!C
                BTT(JL) = col_getElem(lcolumng,JL,index_header,'TT') - 273.15
                BHU(JL) = col_getElem(lcolumng,JL,index_header,'HU')
                BGZ(JL) = col_getHeight(lcolumng,JL,index_header,'NA')
              ENDDO
              BP0 = col_getElem(lcolumng,1,index_header,'P0')
              BPT = col_getPressure(LCOLUMNG,1,index_header,'NA')
              BMT = BGZ(col_getNumLev(lcolumn))/RG
              BMT = gpsgeopotential(Lat, BMT)/RG
              BPR = vco_anl%dprf_M
              BCF = vco_anl%drcf1
!C
!C     *              Local vector state
!C
              DO JL = 1, col_getNumLev(lcolumn)
                DX (      JL) = col_getElem(LCOLUMN,JL,index_header,'TT')
                DX (col_getNumLev(lcolumn)+JL) = col_getElem(LCOLUMN,JL,index_header,'HU')
              ENDDO
              DX (2*col_getNumLev(lcolumn)+1)  = col_getElem(LCOLUMN,1 ,index_header,'P0')
!C
!C     *              GPS profile structure:
!C
              CALL GPSSTRUCT1H(NGPSLEV,ZLAT,ZLON,ZETA,  &
                   BTT,BHU,BP0,BMT,BPT,BPR,BCF,PRF)
              call gpsgeo(prf)
!C
!C     *              Prepare the vector of all the observations:
!C
              ALLOCATE( H    (NH) )
              ALLOCATE( RSTV (NH) )
              NH1 = 0
              ! loop over all body indices for this index_header
              call obs_set_current_body_list(lobsSpaceData, index_header, &
                                            current_list=local_current_list)
              BODY_2: do 
                index_body = obs_getBodyIndex(local_current_list)
                if (index_body < 0) exit BODY_2

                LUSE=( obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body).EQ.1 )
                IF ( LUSE ) THEN
                  NH1 = NH1 + 1
                  HNH1  = obs_bodyElem_r(lobsSpaceData,OBS_PPP,index_body)
                  H(NH1)= gpsgeopotential(Lat,HNH1)/9.80616
                ENDIF
              ENDDO BODY_2
!C
!C     *              Apply the observation operator:
!C
              CALL GPSREFOPV(H, PRF, RSTV)
!C
!C     *              Perform the (H(xb)DX-Y')/S operation
!C
              NH1 = 0
             ! loop over all body indices for this index_header
             call obs_set_current_body_list(lobsSpaceData, index_header, &
                                            current_list=local_current_list)
             BODY_3: do 
                index_body = obs_getBodyIndex(local_current_list)
                if (index_body < 0) exit BODY_3

                LUSE=( obs_bodyElem_i(lobsSpaceData,OBS_ASS,index_body).EQ.1 )
                IF ( LUSE ) THEN
                  NH1 = NH1 + 1
!C
!C     *                    Observation jacobian
!C
                  JAC = RSTV(NH1)%DVAR
!C
!C     *                    Evaluate H(xb)DX
!C
                  ZMHXL = 0._DP
                  DO JV = 1, 2*PRF%NGPSLEV+1
                    ZMHXL = ZMHXL + JAC(JV) * DX(JV)
                  ENDDO
!C
!C     *                    Normalized increment
!C
!C                          O-F Tested criteria:
!C
!C     *                    Accumulate observation cost function (per
!c profile):
!C
!C     *                    Store in CMA
!C
                  call obs_bodySet_r(lobsSpaceData,OBS_OMA,index_body, ZMHXL)

                ENDIF
              ENDDO BODY_3
              DEALLOCATE( RSTV )
              DEALLOCATE( H    )
           ENDIF ASSIMILATE
         ENDIF DATYP
!C
!C     *        Accumulate the observation cost function (all GPSRO):
!C
      ENDDO HEADER
!$omp end parallel

      deallocate(ZETA)
      deallocate(BTT)
      deallocate(BHU)
      deallocate(BGZ)

      RETURN
      END subroutine oda_Hro


      SUBROUTINE oda_Hzp
!*
!* Purpose: Compute simulated profiler observations from profiled model
!*          increments.
!*          It returns Hdx in ROBDATA8(OBS_OMA,*)
!*          Interpolate vertically the contents of commvo to heights
!*          (in meters) of the observations.
!*          A linear interpolation in z is performed.
!*
!*Author  :  J. St-James, CMDA/SMC July 2003

      INTEGER IPB,IPT
      INTEGER INDEX_HEADER,IK
      INTEGER J,INDEX_BODY,ITYP
      REAL*8 ZVAR,ZDA1,ZDA2
      REAL*8 ZWB,ZWT, ZLTV,ZTVG,ZPPOST
      REAL*8 ZLEV,ZPT,ZPB,ZLAT,ZLON,ZTORAD,ZDENO
      LOGICAL LLOK, LLPRINT, LLUV

      call obs_set_current_body_list(lobsSpaceData, 'PR')
      BODY: do
        index_body = obs_getBodyIndex(lobsSpaceData)
        if (index_body < 0) exit BODY

        IF (   (obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY) .EQ. 1) &
         .AND. (obs_bodyElem_i(lobsSpaceData,OBS_XTR,INDEX_BODY) .EQ. 0) &
         .AND. (obs_bodyElem_i(lobsSpaceData,OBS_VCO,INDEX_BODY) .EQ. 1)  ) THEN
          INDEX_HEADER = obs_bodyElem_i(lobsSpaceData,OBS_HIND,INDEX_BODY)
          ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
          IK   = obs_bodyElem_i(lobsSpaceData,OBS_LYR,INDEX_BODY)
          ITYP = obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY)
          IPT  = IK + col_getOffsetFromVarno(lcolumng,ityp)
          IPB  = IPT+1
          ZPT  = col_getHeight(lcolumng,IK  ,INDEX_HEADER,'NA')/RG
          ZPB  = col_getHeight(lcolumng,IK+1,INDEX_HEADER,'NA')/RG
          ZDENO= ZPT-ZPB
          ZWB  = (ZPT-ZLEV)/ZDENO
          ZWT  = 1.0D0 - ZWB

          ZDA1= (ZLEV-ZPB)/(ZDENO**2)
          ZDA2= (ZPT-ZLEV)/(ZDENO**2)

          if(ITYP.eq.BUFR_NEES) then
            write(*,*) 'ABORTING IN ODA_HZP: CANNOT ASSIMILATE ES!!!',ityp,obs_getfamily(lobsSpaceData,index_header),index_header,index_body
            call abort3d('Aborting in oda_H')
          endif
          call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY,  &
              ZWB*col_getElem(LCOLUMN,IPB,INDEX_HEADER) + ZWT*col_getElem(LCOLUMN,IPT,INDEX_HEADER) +  &
              (col_getElem(lcolumng,IPB,INDEX_HEADER) - col_getElem(lcolumng,IPT,INDEX_HEADER))*  &
              (ZDA1*col_getHeight(LCOLUMN,IK,INDEX_HEADER,'NA')/RG + ZDA2*col_getHeight(LCOLUMN,IK+1,INDEX_HEADER,'NA')/RG))
        ENDIF
      ENDDO BODY
      RETURN
      END subroutine oda_Hzp


      SUBROUTINE oda_Hgp
!*
!***s/r  -oda_Hgp TL of DOBSGPSGB (Jo for GB-GPS ZTD observations)
!*
!*
!*Author  : S. Macpherson *ARMA December 2004
!*    -------------------
!**    Purpose: Compute H'dx for all GPS ZTD observations using TL of gpsztdop
!*

      REAL*8 ZLAT
      REAL*8 ZLON
      REAL*8, allocatable :: ZETA(:)
      REAL*8, allocatable :: ZTT(:)
      REAL*8, allocatable :: ZHU(:)
      REAL*8, allocatable :: ZGZ(:)
      REAL*8, allocatable :: ZTTB(:)
      REAL*8, allocatable :: ZHUB(:)
      REAL*8 ZP0
      REAL*8 ZP0B
      REAL*8 ZPT
      REAL*8 ZMT

      REAL*8 ZHX, ZLEV
      REAL*8 ZHXB

      INTEGER INDEX_HEADER
      INTEGER INDEX_BODY
      INTEGER JL

      LOGICAL  ASSIM, LLOK

!C
!C     * 1.  Initializations
!C     *     ---------------
!C
      allocate(ZETA(col_getNumLev(lcolumn)))
      allocate(ZTT(col_getNumLev(lcolumn)))
      allocate(ZHU(col_getNumLev(lcolumn)))
      allocate(ZGZ(col_getNumLev(lcolumn)))
      allocate(ZTTB(col_getNumLev(lcolumn)))
      allocate(ZHUB(col_getNumLev(lcolumn)))
!C
!C     *    .   1.1  Eta vector
!C     *    .        ----------
!C
      DO JL = 1, col_getNumLev(lcolumn)
         ZETA(JL) = vco_anl%dhyb_m(JL)
      ENDDO

      !write(*,fmt='(/,4x,A)') 'LVGPSZTD- Linear Version: GPS ZTD observations'

      ! loop over all header indices of the 'GP' family (GPS observations)
      call obs_set_current_header_list(lobsSpaceData,'GP')
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
!C
!C     *     Scan for ZTD assimilation at this location
!C
         ASSIM = .FALSE.
         ! loop over all body indices for this index_header
         call obs_set_current_body_list(lobsSpaceData, index_header)
         BODY: do 
            index_body = obs_getBodyIndex(lobsSpaceData)
            if (index_body < 0) exit BODY

            if (   (obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER).eq.189) &
             .and. (obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY).EQ.BUFR_NEZD) &
             .and. (obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1) ) then
               ZLEV = obs_bodyElem_r(lobsSpaceData,OBS_PPP,INDEX_BODY)
               ASSIM = .TRUE.
            ENDIF
         ENDDO BODY
!C
!C     * If ZTD assimilation, apply the TL observation operator
!C
         IF ( ASSIM ) THEN
!C
!C     *    LR background profile and increments at the observation location x :
!C
            ZLAT = obs_headElem_r(lobsSpaceData,OBS_LAT,INDEX_HEADER) &
                                         * MPC_DEGREES_PER_RADIAN_R8
            ZLON = obs_headElem_r(lobsSpaceData,OBS_LON,INDEX_HEADER) &
                                         * MPC_DEGREES_PER_RADIAN_R8
            DO JL = 1, col_getNumLev(lcolumn)
              ZTTB(JL) = col_getElem(lcolumng,JL,INDEX_HEADER,'TT')
              ZTT(JL)  = col_getElem(LCOLUMN,JL,INDEX_HEADER,'TT')
              ZHUB(JL) = EXP(col_getElem(lcolumng,JL,INDEX_HEADER,'HU'))
!C     *      dq from d(ln q)
              ZHU(JL)  = ZHUB(JL) * col_getElem(LCOLUMN,JL,INDEX_HEADER,'HU')
              ZGZ(JL)  = col_getHeight(lcolumng,JL,INDEX_HEADER,'NA')
            ENDDO
            ZP0B = col_getElem(lcolumng,1,INDEX_HEADER,'P0')
            ZP0  = col_getElem(LCOLUMN,1,INDEX_HEADER,'P0')
            ZPT  = col_getPressure(LCOLUMNG,1,INDEX_HEADER,'NA')
            ZMT  = ZGZ(col_getNumLev(lcolumn))/GRAV
!C
!C     *    Call TL of ZTD observation operator ZHXB = H(Xb), ZHX = H'*dX
!C
            ZHX = 0.0
            ZHXB = 0.0
            CALL GPSZTDOPTL(ZLAT,ZLON,ZLEV,ZETA,ZTTB,ZHUB,  &
               ZP0B,ZPT,ZMT,ZGZ,ZHXB,ZTT,ZHU,ZP0,ZHX,col_getNumLev(lcolumn))
!C
!C     *    Store ZHX = H'dx in OBS_OMA
!C
            ! loop over all body indices for this index_header
            call obs_set_current_body_list(lobsSpaceData, index_header)
            BODY_2: do 
               index_body = obs_getBodyIndex(lobsSpaceData)
               if (index_body < 0) exit BODY_2

               IF (   (obs_headElem_i(lobsSpaceData,OBS_ITY,INDEX_HEADER).eq.189) &
                .and. (obs_bodyElem_i(lobsSpaceData,OBS_VNM,INDEX_BODY).EQ.BUFR_NEZD) &
                .and. (obs_bodyElem_i(lobsSpaceData,OBS_ASS,INDEX_BODY).EQ.1) ) then
                  call obs_bodySet_r(lobsSpaceData,OBS_OMA,INDEX_BODY, ZHX)
               ENDIF
            ENDDO BODY_2

         ENDIF ! ASSIM

      ENDDO HEADER

      deallocate(ZETA)
      deallocate(ZTT)
      deallocate(ZHU)
      deallocate(ZGZ)
      deallocate(ZTTB)
      deallocate(ZHUB)

      RETURN
      END subroutine oda_Hgp


end subroutine oda_H
