!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine suobsgid
#if defined (DOC)
*
***s/r suobsgid  initialize observation Y grid handle.
*
*Author  : S. Pellerin *ARMA/AES  Nov., 1999
*
*Revision:
*         JM Belanger CMDA/SMC  Aug 2000
*                   . 32 bits conversion
*         S. Pellerin *ARMA/SMC Nov. 2001
*                   . Management of first guess at appropriate time
*         S. Pellerin *ARMA/SMC Feb. 2002
*                   . Writing of PRM_STOB in lalo.prof file
*         M. Buehner *ARMA/SMC Aug. 2002
*                   . Changed filename from lalo.prof to init.prof
*                   . Added simulation number to init.prof (for restart)
*                   . Write numseg for SV job
*         L. Fillion ARMA/EC May 2006: LAM4d upgrade to v10_0_0.
*         L. Fillion ARMA/EC 15 Aug 2007: LAM4d upgrade to v10_0_3.
*         Bin He     *ARMA/MRB  May,2009 
*                   . Implementation of MPI Parallelization  
*         L. Fillion ARMA/EC 4 May 2010: Upgrade on v_11_01_2b.
*Arguments: none
*
#endif
      use modfgat
      use mod4dv, only : mvar, l4dvar
      use minimization_mod
      use mpi
      use obsSpaceData_mod
      IMPLICIT NONE
*implicits
#include "comdim.cdk"
#include "comdimo.cdk"
#include "comlun.cdk"
#include "comcst.cdk"
#include "comgdpar.cdk"
#include "cvcord.cdk"
#include "comfilt.cdk"
#include "comct0.cdk"
#include "comvfiles.cdk"
#include "comcva.cdk"
#include <prof_f.h>
*
      integer jobs, ig1obs, ig2obs, ig3obs, ig4obs, newdate
      integer vezgdef, ierr,istepstamp,jstep,istat,ihdl
      integer :: prof_wrrec,icode,jvar,getprofcode, istepobs, ireslun
      integer :: idate, itime, idata,idatend, jdata,itimeout,iobs,fnom
      integer :: fclos
      real*8 zig1,zig2,zig3,zig4,deltastepobs
*
      real*8, allocatable, dimension(:,:) ::  dlatfld, dlonfld
      character (len=512) :: clprof
      logical llflag,lltimein

      write(nulout,*) ' '
      write(nulout,*) '-------- ENTERING SUOBSGID ---------'
      write(nulout,*) ' '
      write(nulout,*) 'SUOBSGID: Step obs      : ',dstepobs,' hours'
      write(nulout,*) 'SUOBSGID: Step obs inc : ',dstepobsinc,' hours'

* Computute the number of step obs over a 6 hours assimilation window
      nstepobs    = 2*nint((3.d0 - dstepobs/2.d0)/dstepobs) + 1
      nstepobsinc = 2*nint((3.d0 - dstepobsinc/2.d0)/dstepobsinc) + 1
      write(nulout,*) 'SUOBSGID: Number of step obs     : ',nstepobs
      write(nulout,*) 'SUOBSGID: Number of step obs inc : ',nstepobsinc

      allocate(nstamplist(nstepobs))
      allocate(nobs(nstepobs))
      allocate(nobsgid(nstepobs))
      allocate(notag(nobtot,nstepobs),stat=ierr)
      allocate(nstamplistinc(nstepobsinc))
      allocate(nobsinc(nstepobsinc))
      allocate(nobsgidinc(nstepobsinc))
      allocate(notaginc(nobtot,nstepobsinc),stat=ierr)

      allocate(dlatfld(nobtot,nstepobs))
      allocate(dlonfld(nobtot,nstepobs))

      call getstamplist(NSTAMPLIST   ,nstepobs   ,nbrpstamp,dstepobs)
      call getstamplist(NSTAMPLISTINC,nstepobsinc,nbrpstamp,dstepobsinc)
!
      do jstep = 1,nstepobs
        write(nulout,*) 'suobsgid: jstep,nstamplist=',jstep,nstamplist(jstep)
      enddo
!
      do jstep = 1,nstepobsinc
        write(nulout,*) 'suobsgid: jstep,nstamplistinc=',jstep,nstamplistinc(jstep)
      enddo
C
C DO THE WORK FOR THE INCREMENT ONLY 
C
* Find out lower and upper assimilation window index in nstamplist
      if (nlwrbin == -1) nlwrbin = 1
      if (nuprbin == -1) nuprbin = nstepobsinc

! CMC date time stamp of the step obs time
      do jstep = 1, jpfiles
        ntimeout(jstep) = 0
      enddo

      do jstep = 1, nstepobsinc
        nobsinc(jstep) = 0
      enddo

      do jobs=1, nobtot
! return the step stamp associated whit date and time of the observation

        call stepobs(ISTEPSTAMP,nbrpstamp,obs_elem_i(obsSpaceData,'DAT ',jobs)
     &       ,obs_elem_i(obsSpaceData,'ETM ',jobs),dstepobsinc)
        call stepobs2(deltastepobs,nbrpstamp,obs_elem_i(obsSpaceData,'DAT ',jobs)
     &       ,obs_elem_i(obsSpaceData,'ETM ',jobs),dstepobsinc)
! building the list of step stamp and counting number of obs in each step
        lltimein = .false.
        if(nstepobsinc.eq.1) then
          stepinc1 : do jstep = nlwrbin,nuprbin
            if (nstamplistinc(jstep) == istepstamp) then
              nobsinc(jstep) = nobsinc(jstep) + 1
              call obs_setTimeInterpWeight(obsSpaceData,1.0d0,jobs,jstep)
              lltimein = .true.
              exit stepinc1
            endif
          enddo stepinc1
        else
          stepinc : do jstep = nlwrbin,nuprbin
            istepobs=floor(deltastepobs)+((nstepobsinc+1)/2)
            if (istepobs == jstep) then
              call obs_setTimeInterpWeight(obsSpaceData,
     &           1.0d0-(deltastepobs-floor(deltastepobs)),jobs,jstep)
            elseif((istepobs+1)==jstep) then
              call obs_setTimeInterpWeight(obsSpaceData,
     &           deltastepobs-floor(deltastepobs),jobs,jstep)
              if(obs_getTimeInterpWeight(obsSpaceData,jobs,jstep)>=0.5) then
                nobsinc(jstep) = nobsinc(jstep) + 1
              elseif(obs_getTimeInterpWeight(obsSpaceData,jobs,jstep-1)>0.5) then
                nobsinc(jstep-1) = nobsinc(jstep-1) + 1
              endif
              lltimein = .true.
              exit stepinc
            endif
          enddo stepinc
        endif

        if (.not. lltimein) then
          ntimeout(obs_elem_i(obsSpaceData,'OTP ',jobs))=
     &      ntimeout(obs_elem_i(obsSpaceData,'OTP ',jobs))+1

! Put put the wrong data in the central bin
          jstep = (nstepobsinc + 1) / 2
          nobsinc(jstep) = nobsinc(jstep) + 1

! .. flag it as out of (time) domain (bit #5 of header flag
! .. and turn off its assimilation flag

          idata = obs_elem_i(obsSpaceData,'RLN ',jobs)
          idatend = obs_elem_i(obsSpaceData,'NLV ',jobs) + idata -1
          do jdata = idata, idatend
            call obs_set_i(obsSpaceData,'ASS ',JDATA, 0)
          enddo
          call obs_set_i(obsSpaceData,'ST1 ',jobs, 
     &      ibset( obs_elem_i(obsSpaceData,'ST1 ',jobs), 05))
        endif
! building the lat, long and tag vectors for each step

        dlatfld(nobsinc(jstep),jstep) = obs_elem_r4(obsSpaceData,'LAT ',jobs)
        dlonfld(nobsinc(jstep),jstep) = obs_elem_r4(obsSpaceData,'LON ',jobs)
        notaginc(nobsinc(jstep),jstep) = jobs

! Converting lat long to radian units

        if(dlonfld(nobsinc(jstep),jstep).lt.0)
     &       dlonfld(nobsinc(jstep),jstep) = dlonfld(nobsinc(jstep),jstep) +
     &       2*rpi
        if(dlonfld(nobsinc(jstep),jstep).ge.2.*rpi)
     &       dlonfld(nobsinc(jstep),jstep) =dlonfld(nobsinc(jstep),jstep) -
     &       2*rpi
        dlatfld(nobsinc(jstep),jstep)=dlatfld(nobsinc(jstep),jstep)*180./rpi
        dlonfld(nobsinc(jstep),jstep)=dlonfld(nobsinc(jstep),jstep)*180./rpi
      enddo

      itimeout = 0
      do jstep = 1,nfiles
        itimeout = ntimeout(jstep) + itimeout
      enddo

      if(itimeout > 0) then
        write(nulout,*) 'Number of reports with time out of range (increment):',
     &       itimeout
        write(nulout,*) '  FAMILY       No. of reports'
        do jstep = 1,nfiles
          write(nulout,'(4x,a2,11x,i10)') CFAMTYP(jstep),ntimeout(jstep)
        enddo
      endif
c
      write(nulout,*) 'STEP OBS NO. -  DATE -  TIME -  Nbr. of obs.'
      do jstep = 1,nstepobsinc
        if (jstep == (nstepobsinc+1)/2) then
          iobs = nobsinc(jstep) - itimeout
        else
          iobs = nobsinc(jstep)
        endif

        ierr = newdate(nstamplistinc(jstep),idate,itime,-3)
        write(nulout,'(6x,i3,5x,i10,2x,i4.4,5x,i10)') jstep,idate,itime
     &       /10000,iobs
      enddo
C
C NOW DO FROM INNOVATIONS (original code)
C
* Find out lower and upper assimilation window index in nstamplist
CBUE      if (nlwrbin == -1) nlwrbin = 1
CBUE      if (nuprbin == -1) nuprbin = nstepobs
      nlwrbin = 1
      nuprbin = nstepobs

! CMC date time stamp of the step obs time

      do jstep = 1, jpfiles
        ntimeout(jstep) = 0
      enddo

      do jstep = 1, nstepobs
        nobs(jstep) = 0
      enddo

      do jobs=1, nobtot
!
!       return the step stamp associated whit date and time of the observation

        call stepobs(ISTEPSTAMP,nbrpstamp,obs_elem_i(obsSpaceData,'DAT ',jobs)
     &       ,obs_elem_i(obsSpaceData,'ETM ',jobs),dstepobs)
!
! building the list of step stamp and counting number of obs in each step
        lltimein = .false.
        step : do jstep = nlwrbin,nuprbin
          if (nstamplist(jstep) == istepstamp) then
            nobs(jstep) = nobs(jstep) + 1
            lltimein = .true.
            exit step
          endif
        enddo step

        if (.not. lltimein) then
          ntimeout(obs_elem_i(obsSpaceData,'OTP ',jobs))=
     &                  ntimeout(obs_elem_i(obsSpaceData,'OTP ',jobs))+1
C          write(nulout,*) 'Report time for obs no. ',jobs
C     &         ,' out of range : ', obs_elem_i(obsSpaceData,'DAT ',jobs),
C     &         obs_elem_i(obsSpaceData,'ETM ',jobs)

! Put the wrong data in the central bin
          jstep = (nstepobs + 1) / 2
          nobs(jstep) = nobs(jstep) + 1

! .. flag it as out of (time) domain (bit #5 of header flag
! .. and turn off its assimilation flag

          idata = obs_elem_i(obsSpaceData,'RLN ',jobs)
          idatend = obs_elem_i(obsSpaceData,'NLV ',jobs) + idata -1
          do jdata = idata, idatend
            call obs_set_i(obsSpaceData,'ASS ',JDATA, 0)
          enddo
          call obs_set_i(obsSpaceData,'ST1 ',jobs, 
     &      ibset( obs_elem_i(obsSpaceData,'ST1 ',jobs), 05))
        endif
! building the lat, long and tag vectors for each step

        dlatfld(nobs(jstep),jstep) = obs_elem_r4(obsSpaceData,'LAT ',jobs)
        dlonfld(nobs(jstep),jstep) = obs_elem_r4(obsSpaceData,'LON ',jobs)
        notag(nobs(jstep),jstep) = jobs

! Converting lat long to radian units

        if(dlonfld(nobs(jstep),jstep).lt.0)
     &       dlonfld(nobs(jstep),jstep) = dlonfld(nobs(jstep),jstep) +
     &       2*rpi
        if(dlonfld(nobs(jstep),jstep).ge.2.*rpi)
     &       dlonfld(nobs(jstep),jstep) =dlonfld(nobs(jstep),jstep) -
     &       2*rpi
        dlatfld(nobs(jstep),jstep)=dlatfld(nobs(jstep),jstep)*180./rpi
        dlonfld(nobs(jstep),jstep)=dlonfld(nobs(jstep),jstep)*180./rpi
      enddo

      itimeout = 0
      do jstep = 1,nfiles
        itimeout = ntimeout(jstep) + itimeout
      enddo

      if(itimeout > 0) then
        write(nulout,*) 'Number of reports with time out of range (innovation):',
     &       itimeout
        write(nulout,*) '  FAMILY       No. of reports'
        do jstep = 1,nfiles
          write(nulout,'(4x,a2,11x,i10)') CFAMTYP(jstep),ntimeout(jstep)
        enddo
      endif

      zig1 = 0.0D0
      zig2 = 0.0D0
      zig3 = 1.0D0
      zig4 = 1.0D0

      call vcxgaig('L',ig1obs, ig2obs, ig3obs, ig4obs,
     .             zig1, zig2, zig3, zig4)
c
      write(nulout,*) 'STEP OBS NO. -  DATE -  TIME -  Nbr. of obs.'
      do jstep = 1,nstepobs
        if (jstep == (nstepobs+1)/2) then
          iobs = nobs(jstep) - itimeout
        else
          iobs = nobs(jstep)
        endif

        ierr = newdate(nstamplist(jstep),idate,itime,-3)
        write(nulout,'(6x,i3,5x,i10,2x,i4.4,5x,i10)') jstep,idate,itime
     &       /10000,iobs
        if (nobs(jstep) .gt. 0) then
          nobsgid(jstep) = vezgdef(nobs(jstep),1,'Y','L',ig1obs,ig2obs,
     &         ig3obs,ig4obs,dlonfld(1:nobs(jstep),jstep)
     &         ,dlatfld(1:nobs(jstep),jstep))
        else
          nobsgid(jstep) = -999
        endif
      enddo
c Write lalo prof file:
      mvar = 0
      do jvar=1, nfstvar2d
        icode = getprofcode(cfstvar2d(jvar))
        mvar = ibset(mvar,icode)
      enddo

c      mvar = ibset(mvar,v3d_pres)
c      mvar = ibset(mvar,v2d_geop) ! Geopotential at surface
c      mvar = ibset(mvar,v2d_ptop) ! Pressure at model top

      do jvar=1, nfstvar
        icode = getprofcode(cfstvar(jvar))
        mvar = ibset(mvar,icode)
      enddo

      if (l4dvar .and. (mpi_myid == 0)) then
        istepobs = nint(dstepobs * 60.)
        clprof = trim(CEXC4DV) // '/init.prof'
        ihdl = prof_open(clprof,'WRITE','FILE')
c
c Get simulation number if this is a restart job
c
        if(niterjob /= -1 .and. lrestart) then
          ireslun=0
          ierr = fnom(ireslun,crestart,'FTN+SEQ+UNF+OLD+R/O',0)
          read(ireslun) nsim3d
          ierr = fclos(ireslun)
        else
          nsim3d = 0
        endif
c
          do jstep = 1,nstepobs
            if(nobs(jstep) /= 0) then
              istat = prof_pvar(ihdl,istepobs,prm_stob)
              istat = prof_pvar(ihdl,nstamplist(jstep),prm_dtst)
              istat = prof_pvar(ihdl,nsim3d,prm_rstr)
              istat = prof_pvar(ihdl,mvar,prm_mvar)
              istat = prof_pvar(ihdl,notag(1:nobs(jstep),jstep),v2d_otag)
              istat = prof_pvar(ihdl,dlatfld(1:nobs(jstep),jstep),
     &                          v2d_lati)
              istat = prof_pvar(ihdl,dlonfld(1:nobs(jstep),jstep),
     &                          v2d_long)

              istat = prof_wrrec(ihdl)
            endif
          enddo
        istat = prof_close(ihdl)
      endif

      deallocate(dlatfld)
      deallocate(dlonfld)
c
      write(nulout,*) ' '
      write(nulout,*) '-------- END OF SUOBSGID ---------'
      write(nulout,*) ' '
c
      return
      end

