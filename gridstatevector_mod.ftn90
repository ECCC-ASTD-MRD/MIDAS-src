!--------------------------------------------------------------------------
! MODULE gridStateVector (The grid-point state vector and related information.  prefix="gsv")
!
! Purpose: 
!
! Type definitions:
!    struct_gsv
!
! Subroutines:
!    (see "public" statements for publicly accessible subroutines and functions)
!
! Dependencies:
!    varNameList_mod
!    verticalCoord_mod
!    MathPhysConstants_mod
!    getStampList
!
!--------------------------------------------------------------------------
MODULE gridStateVector_mod
  use mpi
  use varNameList_mod
  use verticalCoord_mod
  use horizontalCoord_mod
  use MathPhysConstants_mod
  implicit none
  save
  private

  ! public structure definition
  public :: struct_gsv

  ! public subroutines and functions
  public :: gsv_setup, gsv_allocate, gsv_deallocate, gsv_zero, gsv_3dto4d, gsv_3dto4dAdj, gsv_varExist, gsv_getOffsetFromVarName
  public :: gsv_getField, gsv_getField3D, gsv_getDateStamp, gsv_getNumLev, gsv_add
  public :: gsv_getVco, gsv_setVco, gsv_getHco, gsv_setHco
  public :: gsv_commLat, gsv_commLatAd, gsv_commMPIGlobal, gsv_commMPIGlobal3D

  ! public entities accessed through inheritance
  public :: struct_vco, vco_SetupFromFile
  public :: vnl_varnameFromVarnum, vnl_vartypeFromVarnum, vnl_vartypeFromVarname
  public :: vnl_numvarmax2d, vnl_numvarmax3d,vnl_numvarmax
  public :: varNameList2d, varNameList3d, varNameList

  type struct_gsv
    real*8,pointer      :: gd(:,:,:,:)
    real*8,pointer      :: gd3d(:,:,:)
    integer             :: nlev,nlev_T,nlev_M
    integer             :: ni,nj,nk,numStep,anltime
    integer             :: latPerPE,myLatBeg,myLatEnd
    integer, pointer    :: dateStampList(:)
    integer, pointer    :: dateStamp3d
    logical             :: allocated=.false.
    type(struct_vco),pointer   :: vco => null()
    type(struct_hco),pointer   :: hco => null()
    integer,pointer     :: varOffset(:),varNumLev(:)
    logical             :: mpi_local=.false.
  end type struct_gsv  

  logical :: NGEXIST(VNL_NUMVARMAX)
  character(len=8) :: ANLTIME_BIN

  CONTAINS

    function gsv_getOffsetFromVarName(statevector,varName) result(offset)
      implicit none
      type(struct_gsv)             :: statevector
      character(len=*), intent(in) :: varName
      integer                      :: offset

      offset=statevector%varOffset(vnl_varListIndex(varName))

    end function gsv_getOffsetFromVarName

    function gsv_varExist(varName) result(varExist)
      implicit none
      character(len=*), intent(in) :: varName
      logical                      :: varExist 

      if(ngexist(vnl_varListIndex(varName))) then
        varExist = .true.
      else
        varExist = .false.
      endif

    end function gsv_varExist

  function gsv_getNumLev(statevector,varType) result(nlev)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varType
    integer                                :: nlev

    if(present(varType)) then
      if(varType.eq.'MM') then
        nlev = statevector%nlev_m
      elseif(varType.eq.'TH') then
        nlev = statevector%nlev_t
      elseif(varType.eq.'SF') then
        nlev = 1
      else
        call abort3d('gsv_getNumLev: Unknown variable type! ' // varType)
      endif
    else
      nlev = statevector%nlev
    endif

  end function gsv_getNumLev


  SUBROUTINE gsv_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER(len=4) :: CGNEED(VNL_NUMVARMAX)
      NAMELIST /NAMSTATE/CGNEED,ANLTIME_BIN

      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: List of known (valid) variable names'
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList3D=',varNameList3D
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList2D=',varNameList2D
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList  =',varNameList

!     Read NAMELIST NAMSTATE to find which fields are needed

      cgneed(1:vnl_numvarmax) = '    '
      ANLTIME_BIN = 'MIDDLE'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstate,iostat=ierr)
      if(ierr.ne.0) call abort3d('gsv_setup: Error reading namelist')
      if(mpi_myid.eq.0) write(*,nml=namstate)
      ierr=fclos(nulnam)

      do jvar = 1, vnl_numvarmax3D
        if (varneed(varNameList3D(jvar))) then
          ngexist(jvar) = .true.
        else
          ngexist(jvar) = .false.
        endif
      enddo

      do jvar = 1, vnl_numvarmax2D
        if (varneed(varNameList2D(jvar))) then
          ngexist(jvar+vnl_numvarmax3D) = .true.
        else
          ngexist(jvar+vnl_numvarmax3D) = .false.
        endif
      enddo

      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: ngexist =',ngexist

!
!     Check value for ANLTIME_BIN
!
      if (ANLTIME_BIN .ne. 'MIDDLE' .and. ANLTIME_BIN .ne. 'FIRST' .and.  ANLTIME_BIN .ne. 'LAST') then
         call abort3d('gsv_setup: Problem setting ANLTIME_BIN. Verify NAMSTATE namelist. Aborting!')
      endif

      RETURN

      CONTAINS

        LOGICAL FUNCTION VARNEED(varName)
          character(len=*) :: varName
          integer :: jvar
 
          varneed=.false.
          do jvar=1,VNL_NUMVARMAX
            if (trim(varName).eq.trim(cgneed(jvar))) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

  END SUBROUTINE gsv_setup


  SUBROUTINE gsv_allocate(statevector,numStep,nlev_M,nlev_T,dateStamp,mpi_local)
    implicit none

    type(struct_gsv)    :: statevector
    integer, intent(in) :: numStep
    integer, optional   :: nlev_M,nlev_T,dateStamp
    integer             :: ierr,iloc,jvar,jvar2,jstep,lat1
    integer             :: myLatHalfBeg,myLatHalfEnd
    logical, optional   :: mpi_local

    statevector%ni=statevector%hco%ni
    statevector%nj=statevector%hco%nj
    statevector%numStep=numStep
    if(present(mpi_local)) then
      statevector%mpi_local=mpi_local
    else
      statevector%mpi_local=.false.
    endif

    if(statevector%mpi_local) then
      call mpi_setup_latbands(statevector%hco%nj,statevector%latPerPE,statevector%myLatBeg, &
                              statevector%myLatEnd,myLatHalfBeg,myLatHalfEnd)
    else
      statevector%mpi_local=.false.
      statevector%latPerPE=statevector%hco%nj
      statevector%myLatBeg=1
      statevector%myLatEnd=statevector%hco%nj
    endif
    
    select case (ANLTIME_BIN)
    case ("FIRST")
       statevector%anltime=1
    case ("MIDDLE")
       statevector%anltime=nint((real(numStep)+1.0)/2.0)
    case ("LAST")
       statevector%anltime=numStep
    end select          

    !write(*,*) 'gsv_allocate: numStep,anltime=',statevector%numStep,statevector%anltime

    if( (.not.present(nlev_M)) .and. (.not.present(nlev_T)) ) then
        if(statevector%vco%initialized) then
          statevector%nlev = max(statevector%vco%nlev_M,statevector%vco%nlev_T)
          statevector%nlev_M = statevector%vco%nlev_M
          statevector%nlev_T = statevector%vco%nlev_T
        else
          call abort3d('statevector_allocate: VerticalCoord has not been initialized!')
        endif
    else
        statevector%nlev = max(nlev_M,nlev_T)
        statevector%nlev_M = nlev_M
        statevector%nlev_T = nlev_T
    endif

    if (statevector%allocated)then
      if(mpi_myid.eq.0) write(*,*) 'gridStateVector already allocated! Deallocating first.'
      call gsv_deallocate(statevector)
      statevector%allocated=.false.
    end if

    if(present(dateStamp)) then
      allocate(statevector%dateStampList(numStep))
      call getstamplist(statevector%dateStampList,numStep,dateStamp)
      !do jstep = 1,numStep
      !  write(*,*) 'gsv_allocate: jstep,dateStampList=',jstep,statevector%dateStampList(jstep)
      !enddo
      statevector%dateStamp3d => statevector%dateStampList(statevector%anltime)
      !write(*,*) 'gsv_allocate: dateStamp3d=',statevector%dateStamp3d
    else
      nullify(statevector%dateStamplist)
      !write(*,*) 'gsv_allocate: no date stamp supplied, dateStampList not available!'
    endif

    allocate(statevector%varOffset(vnl_numvarmax))
    statevector%varOffset(:)=0
    allocate(statevector%varNumLev(vnl_numvarmax))
    statevector%varNumLev(:)=0

    iloc=0
    do jvar = 1, vnl_numvarmax3d
        if(ngexist(jvar)) then
          statevector%varOffset(jvar)=iloc
          statevector%varNumLev(jvar)=gsv_getNumLev(statevector,vnl_vartypeFromVarname(varNameList(jvar)))
          iloc = iloc + statevector%varNumLev(jvar)
        endif
    enddo
    do jvar2 = 1, vnl_numvarmax2d
        jvar=jvar2+vnl_numvarmax3d
        if(ngexist(jvar)) then
          statevector%varOffset(jvar)=iloc
          statevector%varNumLev(jvar)=1
          iloc = iloc + 1
        endif
    enddo
    statevector%nk=iloc

    !write(*,*) 'gsv_allocate: varNames =',varNameList(:)
    !write(*,*) 'gsv_allocate: varNumLev=',statevector%varNumLev(:)

    if(statevector%mpi_local) then
      allocate(statevector%gd(statevector%hco%ni,statevector%nk,statevector%myLatBeg:(statevector%myLatEnd+1),numStep),stat=ierr)
    else
      allocate(statevector%gd(statevector%hco%ni,statevector%nk,statevector%hco%nj,numStep),stat=ierr)
    endif
    if(ierr.ne.0) then
      write(*,*) 'gridStateVector: Problem allocating memory! id=1',ierr
      call abort3d('aborting in gsv_allocate')
    endif
    statevector%allocated=.true.

    lat1=statevector%myLatBeg
    statevector%gd3d(1:,1:,lat1:) => statevector%gd(:,:,:,statevector%anltime)

  END SUBROUTINE GSV_allocate


  SUBROUTINE GSV_zero(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lat1,lat2

    if(.not.statevector%allocated) then
      call abort3d('gridStateVector not yet allocated! Aborting.')
    endif

    lat1=statevector%myLatBeg
    lat2=min(statevector%myLatEnd+1,statevector%nj)

!$OMP PARALLEL
!$OMP DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jstep=1,statevector%numStep
        do jlev=1,statevector%nk
          do jlon=1,statevector%ni
            statevector%gd(jlon,jlev,jlat,jstep)= 0.0d0
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE GSV_zero

  
  SUBROUTINE GSV_commLat(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,status

    nsize=statevector_in%ni*statevector_in%nk*statevector_in%numStep

    if(mpi_myid.eq.(mpi_nprocs-1)) then
      call rpn_comm_send(statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatBeg,:),nsize, &
        "mpi_double_precision",mpi_myid-1,mpi_myid*500+(mpi_myid-1),"GRID",ierr)
    endif

    if(mpi_myid.ne.0.and.mpi_myid.ne.(mpi_nprocs-1)) then
      call rpn_comm_sendrecv(statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatBeg,:), &
                             nsize,"mpi_double_precision",mpi_myid-1,mpi_myid*500+(mpi_myid-1), &
                             statevector_in%gd(:,:,(statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                             nsize,"mpi_double_precision",mpi_myid+1,(mpi_myid+1)*500+mpi_myid, &
                             "GRID",status,ierr)
    endif

    if(mpi_myid.eq.0) then
      call rpn_comm_recv(statevector_in%gd(:,:,(statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:),nsize, &
        "mpi_double_precision",mpi_myid+1,(mpi_myid+1)*500+mpi_myid,"GRID",status,ierr)
    endif

  END SUBROUTINE GSV_commLat


  SUBROUTINE GSV_commLatAd(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,status
    real*8 :: latCircle(statevector_in%ni,statevector_in%nk,1,statevector_in%numStep)

    nsize=statevector_in%ni*statevector_in%nk*statevector_in%numStep

    if(mpi_myid.eq.0) then
      call rpn_comm_send(statevector_in%gd(:,:,(statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                         nsize,"mpi_double_precision",mpi_myid+1,(mpi_myid+1)*500+mpi_myid, &
                         "GRID",ierr)
    endif

    if(mpi_myid.ne.0.and.mpi_myid.ne.(mpi_nprocs-1)) then
      call rpn_comm_sendrecv(statevector_in%gd(:,:,(statevector_in%myLatEnd+1):(statevector_in%myLatEnd+1),:), &
                             nsize,"mpi_double_precision",mpi_myid+1,(mpi_myid+1)*500+mpi_myid, &
                             latCircle, &
                             nsize,"mpi_double_precision",mpi_myid-1,mpi_myid*500+(mpi_myid-1), &
                             "GRID",status,ierr)
    endif

    if(mpi_myid.eq.(mpi_nprocs-1)) then
      call rpn_comm_recv(latCircle, &
                         nsize,"mpi_double_precision",mpi_myid-1,mpi_myid*500+(mpi_myid-1), &
                         "GRID",status,ierr)
    endif

    if(mpi_myid.ne.0) then
      statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatBeg,:) = &
        statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatBeg,:) + latCircle(:,:,:,:)
    endif

    if(mpi_myid.ne.(mpi_nprocs-1)) then
      statevector_in%gd(:,:,statevector_in%myLatEnd+1,:)=0.0d0
    endif

  END SUBROUTINE GSV_commLatAd


  SUBROUTINE GSV_commMPIGlobal(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,jlat,jstep,jlev,jlon
    real*8, pointer :: gd_mpiglobal(:,:,:,:)

    if(.not.statevector_in%mpi_local) then
      call abort3d('gsv_commMPIGlobal: statevector already global!')
    endif

    ! only allocate a single 3D mpiglobal statevector
    allocate(gd_mpiglobal(statevector_in%ni,statevector_in%nk,statevector_in%nj,1))

    nsize=statevector_in%ni*statevector_in%nk*statevector_in%latPerPE

    ! NOTE: result of mpiglobal 3D statevector for timestep jstep is sent to proc jstep-1
    do jstep=1,statevector_in%numStep

      call rpn_comm_gather(statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatEnd,jstep), &
        nsize,"mpi_double_precision", &
        gd_mpiglobal(:,:,:,1), &
        nsize,"mpi_double_precision", &
        jstep-1,"GRID",ierr)

    enddo

    deallocate(statevector_in%gd)
    statevector_in%gd => gd_mpiglobal
    statevector_in%gd3d => statevector_in%gd(:,:,:,1)
    statevector_in%myLatBeg=1
    statevector_in%myLatEnd=statevector_in%nj
    statevector_in%latPerPE=statevector_in%nj
    statevector_in%mpi_local=.false.

  END SUBROUTINE GSV_commMPIGlobal


  SUBROUTINE GSV_commMPIGlobal3D(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,jlat,jstep,jlev,jlon
    real*8, pointer :: gd_mpiglobal(:,:,:,:)

    if(.not.statevector_in%mpi_local) then
      call abort3d('gsv_commMPIGlobal: statevector already global!')
    endif

    ! only allocate a single 3D mpiglobal statevector
    allocate(gd_mpiglobal(statevector_in%ni,statevector_in%nk,statevector_in%nj,1))

    nsize=statevector_in%ni*statevector_in%nk*statevector_in%latPerPE

    ! NOTE: result of mpiglobal 3D statevector for timestep anltime is sent to proc 0
    jstep=statevector_in%anltime

    call rpn_comm_gather(statevector_in%gd(:,:,statevector_in%myLatBeg:statevector_in%myLatEnd,jstep), &
      nsize,"mpi_double_precision", &
      gd_mpiglobal(:,:,:,1), &
      nsize,"mpi_double_precision", &
      0,"GRID",ierr)

    deallocate(statevector_in%gd)
    statevector_in%gd => gd_mpiglobal
    statevector_in%gd3d => statevector_in%gd(:,:,:,1)
    statevector_in%myLatBeg=1
    statevector_in%myLatEnd=statevector_in%nj
    statevector_in%latPerPE=statevector_in%nj
    statevector_in%mpi_local=.false.

  END SUBROUTINE GSV_commMPIGlobal3D


  SUBROUTINE GSV_add(statevector_in,statevector_inout)
    implicit none
    type(struct_gsv) :: statevector_in,statevector_inout
    integer          :: jstep,jlon,jlev,jlat,lat1,lat2

    if(.not.statevector_in%allocated) then
      call abort3d('gridStateVector_in not yet allocated! Aborting.')
    endif
    if(.not.statevector_inout%allocated) then
      call abort3d('gridStateVector_inout not yet allocated! Aborting.')
    endif

    lat1=statevector_in%myLatBeg
    lat2=min(statevector_in%myLatEnd+1,statevector_inout%nj)

!$OMP PARALLEL
!$OMP DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jstep=1,statevector_inout%numStep
        do jlev=1,statevector_inout%nk
          do jlon=1,statevector_inout%ni
            statevector_inout%gd(jlon,jlev,jlat,jstep)= statevector_inout%gd(jlon,jlev,jlat,jstep) +  &
                                                        statevector_in%gd(jlon,jlev,jlat,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE GSV_add


  SUBROUTINE GSV_3dto4d(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lat1,lat2

    if(.not.statevector%allocated) then
      call abort3d('gridStateVector not yet allocated! Aborting.')
    endif

    lat1=statevector%myLatBeg
    lat2=min(statevector%myLatEnd+1,statevector%nj)

    if(statevector%numStep.eq.1) return

!$OMP PARALLEL
!$OMP DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jstep=1,statevector%numStep
        if(jstep.ne.statevector%anltime) then
          do jlev=1,statevector%nk
            do jlon=1,statevector%ni
              statevector%gd(jlon,jlev,jlat,jstep)= statevector%gd3d(jlon,jlev,jlat)
            enddo
          enddo
        endif
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE GSV_3dto4d


  SUBROUTINE GSV_3dto4dAdj(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lat1,lat2
    real(8)          :: gd3d_tmp(statevector%ni,statevector%nk,statevector%myLatBeg:(statevector%myLatEnd+1))

    if(.not.statevector%allocated) then
      call abort3d('gridStateVector not yet allocated! Aborting.')
    endif

    lat1=statevector%myLatBeg
    lat2=min(statevector%myLatEnd+1,statevector%nj)

    if(statevector%numStep.eq.1) return

!$OMP PARALLEL
!$OMP DO PRIVATE (jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jlev=1,statevector%nk
        do jlon=1,statevector%ni
          gd3d_tmp(jlon,jlev,jlat) = 0.0d0
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jstep=1,statevector%numStep
        do jlev=1,statevector%nk
          do jlon=1,statevector%ni
            gd3d_tmp(jlon,jlev,jlat) = gd3d_tmp(jlon,jlev,jlat) +   &
                                       statevector%gd(jlon,jlev,jlat,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP DO PRIVATE (jlat,jlev,jlon)    
    do jlat=lat1,lat2
      do jlev=1,statevector%nk
        do jlon=1,statevector%ni
          statevector%gd3d(jlon,jlev,jlat) = gd3d_tmp(jlon,jlev,jlat)
        enddo
      enddo
    enddo
!$OMP END DO
!$OMP END PARALLEL

  END SUBROUTINE GSV_3dto4dAdj


  SUBROUTINE GSV_deallocate(statevector)
    implicit none

    type(struct_gsv) :: statevector
    integer        :: ierr

    if(.not.statevector%allocated) then
      call abort3d('gridStateVector not yet allocated! Aborting.')
    endif

    statevector%allocated=.false.

    deallocate(statevector%gd,stat=ierr)
    nullify(statevector%gd)
    if(ierr.ne.0) then
        write(*,*) 'Problem detected in gridStateVector. IERR =',ierr
    endif

    if(associated(statevector%dateStampList)) deallocate(statevector%dateStampList)
    deallocate(statevector%varOffset)
    deallocate(statevector%varNumLev)
    
  END SUBROUTINE GSV_deallocate


  function gsv_getField(statevector,varName) result(field)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    real*8,pointer                         :: field(:,:,:,:)
    integer                                :: ilev1,ilev2,lat1

    lat1=statevector%myLatBeg

    if(present(varName)) then
      if(gsv_varExist(varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        field(1:,1:,lat1:,1:) => statevector%gd(:,ilev1:ilev2,:,:)
      else
        call abort3d('gsv_getField: Unknown variable name! ' // varName)
      endif
    else
      field(1:,1:,lat1:,1:) => statevector%gd(:,:,:,:)
    endif

  end function gsv_getField


  function gsv_getField3D(statevector,varName) result(field3D)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    real*8,pointer                         :: field3D(:,:,:)
    integer                                :: ilev1,ilev2,lat1

    lat1=statevector%myLatBeg

    if(present(varName)) then
      if(gsv_varExist(varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        field3D(1:,1:,lat1:) => statevector%gd3d(:,ilev1:ilev2,:)
      else
        call abort3d('gsv_getField: Unknown variable name! ' // varName)
      endif
    else
      field3D(1:,1:,lat1:) => statevector%gd3d(:,:,:)
    endif

  end function gsv_getField3D


  function gsv_getDateStamp(statevector,step) result(dateStamp)
    implicit none
    type(struct_gsv), intent(in)   :: statevector
    integer, intent(in), optional  :: step 
    integer                        :: dateStamp

    if(associated(statevector%dateStampList)) then
      if(present(step)) then
        if(step.gt.0.and.step.le.statevector%numStep) then
          dateStamp=statevector%dateStampList(step)
        else
          write(*,*) 'gsv_getDateStamp: requested step is out of range! Step,numStep=',step,statevector%numStep
          call abort3d('aborting in gsv_getDateStamp')
        endif    
      else
        dateStamp=statevector%dateStamp3D
      endif
    else
      call abort3d('gsv_getDateStamp: dateStampList was not created during allocation!')
    endif

  end function gsv_getDateStamp


  function gsv_getVco(statevector) result(vco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_vco), pointer :: vco_ptr

    vco_ptr => statevector%vco

  end function gsv_getVco


  subroutine gsv_setVco(statevector,vco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_vco), pointer :: vco_ptr

    statevector%vco => vco_ptr

  end subroutine gsv_setVco

  function gsv_getHco(statevector) result(hco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_hco), pointer :: hco_ptr

    hco_ptr => statevector%hco

  end function gsv_getHco

  subroutine gsv_setHco(statevector,hco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_hco), pointer :: hco_ptr

    statevector%hco => hco_ptr

  end subroutine gsv_setHco

END MODULE gridStateVector_mod
