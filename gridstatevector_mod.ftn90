!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!! MODULE gridStateVector (prefix="gsv")
!!
!! *Purpose*: The grid-point state vector and related information.
!!
!--------------------------------------------------------------------------
MODULE gridStateVector_mod
  use topLevelControl_mod
  use mpivar_mod
  use varNameList_mod
  use verticalCoord_mod
  use horizontalCoord_mod
  use MathPhysConstants_mod
  use timeCoord_mod
  use utilities_mod
  implicit none
  save
  private

  ! public structure definition
  public :: struct_gsv

  ! public subroutines and functions
  public :: gsv_setup, gsv_allocate, gsv_deallocate, gsv_zero, gsv_3dto4d, gsv_3dto4dAdj, gsv_varExist
  public :: gsv_getOffsetFromVarName, gsv_writeToFileMpi, gsv_readFromFile
  public :: gsv_getField_r8, gsv_getField3D_r8, gsv_getField_r4, gsv_getField3D_r4
  public :: gsv_getDateStamp, gsv_getNumLev
  public :: gsv_add, gsv_power, gsv_scale, gsv_scaleVertical, gsv_copy, gsv_stddev
  public :: gsv_getVco, gsv_setVco, gsv_getHco, gsv_setHco
  public :: gsv_commMPIGlobal, gsv_commMPIGlobal3D
  public :: gsv_horizSubSample

  ! public entities accessed through inheritance
  public :: struct_vco, vco_SetupFromFile
  public :: vnl_varnameFromVarnum, vnl_varLevelFromVarnum, vnl_varLevelFromVarname
  public :: vnl_numvarmax2d, vnl_numvarmax3d,vnl_numvarmax
  public :: vnl_varNameList2d, vnl_varNameList3d, vnl_varNameList
  public :: vgd_get,vgd_levels,vgd_ok,vgd_dpidpis,vgd_write


  type struct_gsv
    integer         :: dataKind = 8
    real(8),pointer :: gd_r8(:,:,:,:) => null()
    real(8),pointer :: gd3d_r8(:,:,:) => null()
    real(4),pointer :: gd_r4(:,:,:,:) => null()
    real(4),pointer :: gd3d_r4(:,:,:) => null()
    integer             :: ni,nj,nk,numStep,anltime
    integer             :: latPerPE,myLatBeg,myLatEnd
    integer             :: lonPerPE,myLonBeg,myLonEnd
    integer, pointer    :: allLatBeg(:), allLatEnd(:)
    integer, pointer    :: allLonBeg(:), allLonEnd(:)
    integer, pointer    :: dateStampList(:)
    integer, pointer    :: dateStamp3d
    logical             :: allocated=.false.
    type(struct_vco),pointer   :: vco => null()
    type(struct_hco),pointer   :: hco => null()
    integer,pointer     :: varOffset(:),varNumLev(:)
    logical             :: mpi_local=.false.
    integer             :: horizSubSample
    logical             :: varExistList(vnl_numVarMax)
  end type struct_gsv  

  logical :: varExistList(vnl_numVarMax)
  character(len=8) :: ANLTIME_BIN

  ! define interfaces for generic procedures
!  interface gsv_getField
!    module procedure gsv_getField_r4
!    module procedure gsv_getField_r8
!  end interface

  CONTAINS

    function gsv_getOffsetFromVarName(statevector,varName) result(offset)
      implicit none
      type(struct_gsv)             :: statevector
      character(len=*), intent(in) :: varName
      integer                      :: offset

      offset=statevector%varOffset(vnl_varListIndex(varName))

    end function gsv_getOffsetFromVarName


  FUNCTION gsv_varExist(statevector,varName) result(varExist)
      implicit none
    type(struct_gsv), optional     :: statevector
      character(len=*), intent(in) :: varName
      logical                      :: varExist 

    if( present(statevector) ) then
      if( statevector%varExistList(vnl_varListIndex(varName)) ) then
        varExist = .true.
      else
        varExist = .false.
      endif
    else
      if( varExistList(vnl_varListIndex(varName)) ) then
        varExist = .true.
      else
        varExist = .false.
      endif
    endif

    end function gsv_varExist


  function gsv_getNumLev(statevector,varLevel) result(nlev)
    implicit none
    type(struct_gsv), intent(in)  :: statevector
    character(len=*), intent(in)  :: varLevel
    integer                       :: nlev

    nlev = vco_getNumLev(statevector%vco,varLevel)

  end function gsv_getNumLev


  SUBROUTINE gsv_setup
      implicit none
      INTEGER JVAR, IPOS
      integer :: fnom,fclos,nulnam,ierr
      CHARACTER(len=4) :: ANLVAR(VNL_NUMVARMAX)
      real*8 :: rhumin
      logical          :: AddGZSfcOffset = .false. ! controls adding non-zero GZ offset to diag levels
      NAMELIST /NAMSTATE/ANLVAR,rhumin,ANLTIME_BIN,AddGZSfcOffset

      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: List of known (valid) variable names'
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList3D=',vnl_varNameList3D
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList2D=',vnl_varNameList2D
      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: varNameList  =',vnl_varNameList

!     Read NAMELIST NAMSTATE to find which fields are needed

      ANLVAR(1:vnl_numvarmax) = '    '
      ANLTIME_BIN = 'MIDDLE'

      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=namstate,iostat=ierr)
      if(ierr.ne.0) call utl_abort('gsv_setup: Error reading namelist')
      if(mpi_myid.eq.0) write(*,nml=namstate)
      ierr=fclos(nulnam)

      if(varneed('GZ')) call utl_abort('gsv_setup: GZ can no longer be included as a variable in gridStateVector!')

      do jvar = 1, vnl_numvarmax3D
        if (varneed(vnl_varNameList3D(jvar))) then
          varExistList(jvar) = .true.
        else
          varExistList(jvar) = .false.
        endif
      enddo

      do jvar = 1, vnl_numvarmax2D
        if (varneed(vnl_varNameList2D(jvar))) then
          varExistList(jvar+vnl_numVarMax3D) = .true.
        else
          varExistList(jvar+vnl_numVarMax3D) = .false.
        endif
      enddo

      if(mpi_myid.eq.0) write(*,*) 'gsv_setup: global varExistList =',varExistList

!
!     Check value for ANLTIME_BIN
!
      if (ANLTIME_BIN .ne. 'MIDDLE' .and. ANLTIME_BIN .ne. 'FIRST' .and.  ANLTIME_BIN .ne. 'LAST') then
         call utl_abort('gsv_setup: Problem setting ANLTIME_BIN. Verify NAMSTATE namelist. Aborting!')
      endif

      RETURN

      CONTAINS

        LOGICAL FUNCTION VARNEED(varName)
          character(len=*) :: varName
          integer :: jvar
 
          varneed=.false.
          do jvar=1,VNL_NUMVARMAX
            if (trim(varName) == trim(anlvar(jvar))) then
              varneed=.true.
            endif
          enddo

        END FUNCTION VARNEED

  END SUBROUTINE gsv_setup


  SUBROUTINE gsv_allocate(statevector,numStep,dateStamp,mpi_local,horizSubSample,varName,dataKind_in)
    implicit none

    type(struct_gsv)    :: statevector
    integer, intent(in) :: numStep
    integer, optional   :: dateStamp
    logical, optional   :: mpi_local
    integer, optional   :: horizSubSample
    character(len=4), optional :: varName  ! allow specification of a single variable
    integer, optional   :: dataKind_in

    integer             :: ierr,iloc,jvar,jvar2,jstep,lon1,lat1

    if(.not.statevector%vco%initialized) then
       call utl_abort('statevector_allocate: VerticalCoord has not been initialized!')
    endif

    if (statevector%allocated)then
      if(mpi_myid.eq.0) write(*,*) 'gridStateVector already allocated! Deallocating first.'
      call gsv_deallocate(statevector)
      statevector%allocated=.false.
    end if

    if( present(dataKind_in) ) statevector%dataKind = dataKind_in

    if( present(varName) ) then
      do jvar = 1, vnl_numVarMax3D
        if ( trim(vnl_varNameList3D(jvar)) == trim(varName) ) then
          statevector%varExistList(jvar) = .true.
        else
          statevector%varExistList(jvar) = .false.
        endif
      enddo
      do jvar = 1, vnl_numVarMax2D
        if ( trim(vnl_varNameList2D(jvar)) == trim(varName) ) then
          statevector%varExistList(jvar+vnl_numVarMax3D) = .true.
        else
          statevector%varExistList(jvar+vnl_numVarMax3D) = .false.
        endif
      enddo
    else
      ! use the global variable list
      statevector%varExistList(:) = varExistList(:)
    endif

    if( present(horizSubSample) ) then
      ! user has chosen a coarser grid than specified in hco
      statevector%horizSubSample = horizSubSample
    else
      ! default is no sub-sampling
      statevector%horizSubSample = 1
    endif

    ! compute the number of global grid points for a given subSample level
    statevector%ni = ceiling(real(statevector%hco%ni,8) / real(statevector%horizSubSample,8))
    statevector%nj = ceiling(real(statevector%hco%nj,8) / real(statevector%horizSubSample,8))

    if( statevector%ni * statevector%horizSubSample /= statevector%hco%ni ) then
      write(*,*) 'gsv_allocate: number of longitudes is not evenly divisible at this subSample level'
      write(*,*) 'gsv_allocate: ni, horizSubSample = ', statevector%ni, statevector%horizSubSample
      call utl_abort('gsv_allocate')
    endif

    if( statevector%nj * statevector%horizSubSample /= statevector%hco%nj ) then
      write(*,*) 'gsv_allocate: number of latitudes is not evenly divisible at this subSample level'
      write(*,*) 'gsv_allocate: nj, horizSubSample = ', statevector%nj, statevector%horizSubSample
      call utl_abort('gsv_allocate')
    endif

    statevector%numStep=numStep
    if(present(mpi_local)) then
      statevector%mpi_local=mpi_local
    else
      statevector%mpi_local=.false.
    endif

    if(statevector%mpi_local) then
      call mpivar_setup_latbands(statevector%nj,statevector%latPerPE,statevector%myLatBeg, &
                                 statevector%myLatEnd)
      call mpivar_setup_lonbands(statevector%ni,statevector%lonPerPE,statevector%myLonBeg, &
                                 statevector%myLonEnd)
    else
      statevector%mpi_local=.false.
      statevector%latPerPE = statevector%nj
      statevector%myLatBeg=1
      statevector%myLatEnd = statevector%nj
      statevector%lonPerPE = statevector%ni
      statevector%myLonBeg=1
      statevector%myLonEnd = statevector%ni
    endif
    
    allocate(statevector%allLonBeg(mpi_npex))
    CALL rpn_comm_allgather(statevector%myLonBeg,1,"mpi_integer",       &
                            statevector%allLonBeg,1,"mpi_integer","EW",ierr)
    allocate(statevector%allLonEnd(mpi_npex))
    CALL rpn_comm_allgather(statevector%myLonEnd,1,"mpi_integer",       &
                            statevector%allLonEnd,1,"mpi_integer","EW",ierr)

    allocate(statevector%allLatBeg(mpi_npey))
    CALL rpn_comm_allgather(statevector%myLatBeg,1,"mpi_integer",       &
                            statevector%allLatBeg,1,"mpi_integer","NS",ierr)
    allocate(statevector%allLatEnd(mpi_npey))
    CALL rpn_comm_allgather(statevector%myLatEnd,1,"mpi_integer",       &
                            statevector%allLatEnd,1,"mpi_integer","NS",ierr)

    select case (ANLTIME_BIN)
    case ("FIRST")
       statevector%anltime=1
    case ("MIDDLE")
       statevector%anltime=nint((real(numStep,8)+1.0d0)/2.0d0)
    case ("LAST")
       statevector%anltime=numStep
    end select          

    if(present(dateStamp)) then
      allocate(statevector%dateStampList(numStep))
      call tim_getstamplist(statevector%dateStampList,numStep,dateStamp)
      statevector%dateStamp3d => statevector%dateStampList(statevector%anltime)
    else
      nullify(statevector%dateStamplist)
    endif

    allocate(statevector%varOffset(vnl_numvarmax))
    statevector%varOffset(:)=0
    allocate(statevector%varNumLev(vnl_numvarmax))
    statevector%varNumLev(:)=0

    iloc=0
    do jvar = 1, vnl_numvarmax3d
      if( statevector%varExistList(jvar) ) then
          statevector%varOffset(jvar)=iloc
          statevector%varNumLev(jvar)=gsv_getNumLev(statevector,vnl_varLevelFromVarname(vnl_varNameList(jvar)))
          iloc = iloc + statevector%varNumLev(jvar)
        endif
    enddo
    do jvar2 = 1, vnl_numvarmax2d
        jvar=jvar2+vnl_numvarmax3d
      if( statevector%varExistList(jvar) ) then
          statevector%varOffset(jvar)=iloc
          statevector%varNumLev(jvar)=1
          iloc = iloc + 1
        endif
    enddo
    statevector%nk=iloc

    if(statevector%mpi_local) then
      if(statevector%dataKind==8) then
        allocate(statevector%gd_r8(statevector%myLonBeg:statevector%myLonEnd,  &
                                   statevector%myLatBeg:statevector%myLatEnd,  &
                                   statevector%nk,numStep),stat=ierr)
      elseif(statevector%dataKind==4) then
        allocate(statevector%gd_r4(statevector%myLonBeg:statevector%myLonEnd,  &
                                   statevector%myLatBeg:statevector%myLatEnd,  &
                                   statevector%nk,numStep),stat=ierr)
      else
        call utl_abort('gsv_allocate: unknown value of datakind')
      endif
    else
      if(statevector%dataKind==8) then
        allocate(statevector%gd_r8(statevector%ni,statevector%nj,statevector%nk,numStep),stat=ierr)
      elseif(statevector%dataKind==4) then
        allocate(statevector%gd_r4(statevector%ni,statevector%nj,statevector%nk,numStep),stat=ierr)
      else
        call utl_abort('gsv_allocate: unknown value of datakind')
      endif
    endif
    if(ierr.ne.0) then
      write(*,*) 'gridStateVector: Problem allocating memory! id=1 ',ierr
      call utl_abort('aborting in gsv_allocate')
    endif

    lon1=statevector%myLonBeg
    lat1=statevector%myLatBeg
    if(statevector%dataKind==8) then
      statevector%gd3d_r8(lon1:,lat1:,1:) => statevector%gd_r8(:,:,:,statevector%anltime)
    elseif(statevector%dataKind==4) then
      statevector%gd3d_r4(lon1:,lat1:,1:) => statevector%gd_r4(:,:,:,statevector%anltime)
    endif

    statevector%allocated=.true.

  END SUBROUTINE GSV_allocate


  SUBROUTINE GSV_zero(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lat1,lat2,lon1,lon2

    if(.not.statevector%allocated) then
      call utl_abort('gridStateVector not yet allocated! Aborting.')
    endif

    lon1=statevector%myLonBeg
    lon2=statevector%myLonEnd
    lat1=statevector%myLatBeg
    lat2=statevector%myLatEnd

    if (statevector%dataKind==8 ) then

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
       do jlev = 1, statevector%nk
          do jstep = 1, statevector%numStep
             do jlat = lat1, lat2
                do jlon = lon1, lon2
                   statevector%gd_r8(jlon,jlat,jlev,jstep) = 0.0d0
                enddo
             enddo
          enddo
       enddo
!$OMP END PARALLEL DO

    elseif (statevector%dataKind==4) then

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)
       do jlev = 1, statevector%nk
          do jstep = 1, statevector%numStep
             do jlat = lat1, lat2
                do jlon = lon1, lon2
                   statevector%gd_r4(jlon,jlat,jlev,jstep) = 0.0
                enddo
             enddo
          enddo
       enddo
!$OMP END PARALLEL DO

    else
       call utl_abort('gsv_zero: unknown value of datakind')
    endif
    
  END SUBROUTINE GSV_zero


  SUBROUTINE GSV_commMPIGlobal(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,jlat,jstep,jlev,jlon
    integer :: IP, IP_x, IP_y
    real*8, pointer :: gd_mpiglobal(:,:,:,:) => null()
    real*8, allocatable :: gd_temp(:,:,:,:)

    if(.not.statevector_in%mpi_local) then
      call utl_abort('gsv_commMPIGlobal: statevector already global!')
    endif

    ! only allocate a single 3D mpiglobal statevector as an array of latlon tiles
    allocate(gd_temp(statevector_in%lonPerPE,statevector_in%latPerPE,statevector_in%nk,mpi_nprocs))

    nsize=statevector_in%lonPerPE*statevector_in%nk*statevector_in%latPerPE

    ! NOTE: result of mpiglobal 3D statevector for timestep jstep is sent to proc jstep-1
    do jstep=1,statevector_in%numStep

      call rpn_comm_gather(statevector_in%gd_r8(statevector_in%myLonBeg:statevector_in%myLonEnd,  &
                                             statevector_in%myLatBeg:statevector_in%myLatEnd,:,jstep), &
                           nsize,"mpi_double_precision", &
                           gd_temp, &
                           nsize,"mpi_double_precision", &
                           jstep-1,"GRID",ierr)

    enddo
    deallocate(statevector_in%gd_r8)

    if(mpi_myid.lt.statevector_in%numStep) then
      ! reorganize data into mpiglobal array
      allocate(gd_mpiglobal(statevector_in%ni,statevector_in%nj,statevector_in%nk,1))

      do IP_y = 0, (mpi_npey-1)
        do IP_x = 0, (mpi_npex-1)
          IP = IP_x + IP_y*mpi_npex
          gd_mpiglobal(statevector_in%allLonBeg(IP_x+1):statevector_in%allLonEnd(IP_x+1),  &
                       statevector_in%allLatBeg(IP_y+1):statevector_in%allLatEnd(IP_y+1),:,1) = &
              gd_temp(:,:,:,IP+1)        
        enddo
      enddo
    else
      allocate(gd_mpiglobal(1,1,1,1)) ! dummy allocation to avoid error when deallocating
    endif

    deallocate(gd_temp)

    ! reset values in statevector object for mpiglobal
    statevector_in%gd_r8 => gd_mpiglobal
    statevector_in%gd3d_r8 => statevector_in%gd_r8(:,:,:,1)
    statevector_in%myLonBeg=1
    statevector_in%myLonEnd = statevector_in%ni
    statevector_in%lonPerPE = statevector_in%ni
    statevector_in%myLatBeg=1
    statevector_in%myLatEnd = statevector_in%nj
    statevector_in%latPerPE = statevector_in%nj
    statevector_in%numStep=1
    statevector_in%mpi_local=.false.

  END SUBROUTINE GSV_commMPIGlobal


  SUBROUTINE GSV_commMPIGlobal3D(statevector_in)
    implicit none
    type(struct_gsv) :: statevector_in
    integer :: nsize,ierr,jlat,jstep,jlev,jlon
    integer :: IP, IP_x, IP_y
    real*8, pointer :: gd_mpiglobal(:,:,:,:) => null()
    real*8, allocatable :: gd_temp(:,:,:,:)

    if(.not.statevector_in%mpi_local) then
      call utl_abort('gsv_commMPIGlobal3D: statevector already global!')
    endif

    ! only allocate a single 3D mpiglobal statevector as an array of latlon tiles
    allocate(gd_temp(statevector_in%lonPerPE,statevector_in%latPerPE,statevector_in%nk,mpi_nprocs))

    nsize=statevector_in%lonPerPE*statevector_in%nk*statevector_in%latPerPE

    ! NOTE: result of mpiglobal 3D statevector for timestep anltime is sent to proc 0
    jstep=statevector_in%anltime

    call rpn_comm_gather(statevector_in%gd_r8(statevector_in%myLonBeg:statevector_in%myLonEnd,  &
                                           statevector_in%myLatBeg:statevector_in%myLatEnd,:,jstep), &
                         nsize,"mpi_double_precision", &
                         gd_temp, &
                         nsize,"mpi_double_precision", &
                         0,"GRID",ierr)

    deallocate(statevector_in%gd_r8)

    if(mpi_myid.eq.0) then
      ! reorganize data into mpiglobal array
      allocate(gd_mpiglobal(statevector_in%ni,statevector_in%nj,statevector_in%nk,1))

      do IP_y = 0, (mpi_npey-1)
        do IP_x = 0, (mpi_npex-1)
          IP = IP_x + IP_y*mpi_npex
          gd_mpiglobal(statevector_in%allLonBeg(IP_x+1):statevector_in%allLonEnd(IP_x+1),  &
                       statevector_in%allLatBeg(IP_y+1):statevector_in%allLatEnd(IP_y+1),:,1) = &
              gd_temp(:,:,:,IP+1)        
        enddo
      enddo
    else
      allocate(gd_mpiglobal(1,1,1,1)) ! dummy allocation to avoid error when deallocating
    endif

    deallocate(gd_temp)

    ! reset values in statevector object for mpiglobal
    statevector_in%gd_r8 => gd_mpiglobal
    statevector_in%gd3d_r8 => statevector_in%gd_r8(:,:,:,1)
    statevector_in%myLonBeg=1
    statevector_in%myLonEnd = statevector_in%ni
    statevector_in%lonPerPE = statevector_in%ni
    statevector_in%myLatBeg=1
    statevector_in%myLatEnd = statevector_in%nj
    statevector_in%latPerPE = statevector_in%nj
    statevector_in%numStep=1
    statevector_in%mpi_local=.false.

  END SUBROUTINE GSV_commMPIGlobal3D

  !--------------------------------------------------------------------------
  ! GSV_add
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_add(statevector_in,statevector_inout,scaleFactor)
    implicit none
    type(struct_gsv) :: statevector_in,statevector_inout
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2
    real(8), optional :: scaleFactor

    if(.not.statevector_in%allocated) then
      call utl_abort('gridStateVector_in not yet allocated! Aborting.')
    endif
    if(.not.statevector_inout%allocated) then
      call utl_abort('gridStateVector_inout not yet allocated! Aborting.')
    endif

    lon1=statevector_in%myLonBeg
    lon2=statevector_in%myLonEnd
    lat1=statevector_in%myLatBeg
    lat2=statevector_in%myLatEnd

    if(present(scaleFactor)) then
!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
      do jlev = 1, statevector_inout%nk
        do jstep = 1, statevector_inout%numStep
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = statevector_inout%gd_r8(jlon,jlat,jlev,jstep) +  &
                                             scaleFactor * statevector_in%gd_r8(jlon,jlat,jlev,jstep)
            enddo
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO
    else
!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
      do jlev = 1, statevector_inout%nk
        do jstep = 1, statevector_inout%numStep
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = statevector_inout%gd_r8(jlon,jlat,jlev,jstep) +  &
                                                           statevector_in%gd_r8(jlon,jlat,jlev,jstep)
            enddo
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO
    endif

  END SUBROUTINE GSV_add

  !--------------------------------------------------------------------------
  ! GSV_copy
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_copy(statevector_in,statevector_out,indexStep_in)
    implicit none
    type(struct_gsv)  :: statevector_in,statevector_out
    integer, optional :: indexStep_in
    integer           :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2

    if(.not.statevector_in%allocated) then
      call utl_abort('gridStateVector_in not yet allocated! Aborting.')
    endif
    if(.not.statevector_out%allocated) then
      call utl_abort('gridStateVector_out not yet allocated! Aborting.')
    endif

    lon1=statevector_in%myLonBeg
    lon2=statevector_in%myLonEnd
    lat1=statevector_in%myLatBeg
    lat2=statevector_in%myLatEnd

    ! NOTE: The step index should only be specified when copying 4D into 3D
    if(present(indexStep_in)) then

      ! adjust the datestamp to be consistent with the date of the specified step index
      statevector_out%dateStampList(1) = statevector_in%dateStampList(indexStep_in)

!$OMP PARALLEL DO PRIVATE (jlat,jlev,jlon)    
      do jlev = 1, statevector_out%nk
        do jlat = lat1, lat2
          do jlon = lon1, lon2
            statevector_out%gd_r8(jlon,jlat,jlev,1) = statevector_in%gd_r8(jlon,jlat,jlev,indexStep_in)
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO

    else

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
      do jlev = 1, statevector_out%nk
        do jstep = 1, statevector_out%numStep
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector_out%gd_r8(jlon,jlat,jlev,jstep) = statevector_in%gd_r8(jlon,jlat,jlev,jstep)
            enddo
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO

    endif

  END SUBROUTINE GSV_copy

  !--------------------------------------------------------------------------
  ! GSV_power
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_power(statevector_inout,power,scaleFactor)
    implicit none
    type(struct_gsv)    :: statevector_inout
    real(8), intent(in) :: power
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2
    real(8), optional :: scaleFactor

    if(.not.statevector_inout%allocated) then
      call utl_abort('gridStateVector_inout not yet allocated! Aborting.')
    endif

    lon1=statevector_inout%myLonBeg
    lon2=statevector_inout%myLonEnd
    lat1=statevector_inout%myLatBeg
    lat2=statevector_inout%myLatEnd

    if(present(scaleFactor)) then
!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
      do jlev = 1, statevector_inout%nk
        do jstep = 1, statevector_inout%numStep
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = &
                   scaleFactor * (statevector_inout%gd_r8(jlon,jlat,jlev,jstep))**power
            enddo
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO
    else
!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
      do jlev = 1, statevector_inout%nk
        do jstep = 1, statevector_inout%numStep
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = &
                   (statevector_inout%gd_r8(jlon,jlat,jlev,jstep))**power
            enddo
          enddo
        enddo
      enddo
!$OMP END PARALLEL DO
    endif

  END SUBROUTINE GSV_power

  !--------------------------------------------------------------------------
  ! GSV_stddev
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_stddev(statevector_in,stddev)
    implicit none
    type(struct_gsv) :: statevector_in
    real(8)          :: stddev(:)
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2

    if(.not.statevector_in%allocated) then
      call utl_abort('gridStateVector_in not yet allocated! Aborting.')
    endif

    lon1=statevector_in%myLonBeg
    lon2=statevector_in%myLonEnd
    lat1=statevector_in%myLatBeg
    lat2=statevector_in%myLatEnd

    stddev(:) = 0.0d0
    do jlev = 1, statevector_in%nk
      do jlat = lat1, lat2
        do jstep = 1, statevector_in%numStep
          do jlon = lon1, lon2
            stddev(jlev) = stddev(jlev) + statevector_in%gd_r8(jlon,jlat,jlev,jstep)**2
          enddo
        enddo
      enddo
      stddev(jlev) = stddev(jlev) / real(statevector_in%numStep,8)
      call mpi_allreduce_sumreal8scalar(stddev(jlev),"GRID")
      stddev(jlev) = stddev(jlev) / real(statevector_in%ni * statevector_in%nj,8)
      if(stddev(jlev).gt.0.0d0) stddev(jlev) = sqrt(stddev(jlev))
    enddo

  END SUBROUTINE GSV_stddev

  !--------------------------------------------------------------------------
  ! GSV_scale
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_scale(statevector_inout,scaleFactor)
    implicit none
    type(struct_gsv) :: statevector_inout
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2
    real(8)          :: scaleFactor

    if(.not.statevector_inout%allocated) then
      call utl_abort('gsv_Scale: gridStateVector_inout not yet allocated! Aborting.')
    endif

    lon1=statevector_inout%myLonBeg
    lon2=statevector_inout%myLonEnd
    lat1=statevector_inout%myLatBeg
    lat2=statevector_inout%myLatEnd

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlev = 1, statevector_inout%nk
      do jstep = 1, statevector_inout%numStep
        do jlat = lat1, lat2
          do jlon = lon1, lon2
            statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = &
                 scaleFactor * statevector_inout%gd_r8(jlon,jlat,jlev,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE GSV_scale

  !--------------------------------------------------------------------------
  ! GSV_scaleVertical
  !--------------------------------------------------------------------------
  SUBROUTINE GSV_scaleVertical(statevector_inout,scaleFactor)
    implicit none
    type(struct_gsv) :: statevector_inout
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2
    real(8)          :: scaleFactor(:)

    if(.not.statevector_inout%allocated) then
      call utl_abort('gsv_Scale: gridStateVector_inout not yet allocated! Aborting.')
    endif

    lon1=statevector_inout%myLonBeg
    lon2=statevector_inout%myLonEnd
    lat1=statevector_inout%myLatBeg
    lat2=statevector_inout%myLatEnd

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlev = 1, statevector_inout%nk
      do jstep = 1, statevector_inout%numStep
        do jlat = lat1, lat2
          do jlon = lon1, lon2
            statevector_inout%gd_r8(jlon,jlat,jlev,jstep) = &
                 scaleFactor(jlev) * statevector_inout%gd_r8(jlon,jlat,jlev,jstep)
          enddo
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE GSV_scaleVertical


  SUBROUTINE GSV_3dto4d(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2

    if(.not.statevector%allocated) then
      call utl_abort('gridStateVector not yet allocated! Aborting.')
    endif

    lon1=statevector%myLonBeg
    lon2=statevector%myLonEnd
    lat1=statevector%myLatBeg
    lat2=statevector%myLatEnd

    if(statevector%numStep.eq.1) return

!$OMP PARALLEL DO PRIVATE (jstep,jlat,jlev,jlon)    
    do jlev = 1, statevector%nk
      do jstep = 1, statevector%numStep
        if(jstep.ne.statevector%anltime) then
          do jlat = lat1, lat2
            do jlon = lon1, lon2
              statevector%gd_r8(jlon,jlat,jlev,jstep) = statevector%gd3d_r8(jlon,jlat,jlev)
            enddo
          enddo
        endif
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE GSV_3dto4d


  SUBROUTINE GSV_3dto4dAdj(statevector)
    implicit none
    type(struct_gsv) :: statevector
    integer          :: jstep,jlon,jlev,jlat,lon1,lon2,lat1,lat2
    real(8)          :: gd2d_tmp(statevector%myLonBeg:statevector%myLonEnd,  &
                                 statevector%myLatBeg:statevector%myLatEnd)

    if(.not.statevector%allocated) then
      call utl_abort('gridStateVector not yet allocated! Aborting.')
    endif

    lon1=statevector%myLonBeg
    lon2=statevector%myLonEnd
    lat1=statevector%myLatBeg
    lat2=statevector%myLatEnd

    if(statevector%numStep.eq.1) return

!$OMP PARALLEL DO PRIVATE (jlat,jlev,jlon,jstep,gd2d_tmp)
    do jlev = 1, statevector%nk
      do jlat = lat1, lat2
        do jlon = lon1, lon2
          gd2d_tmp(jlon,jlat) = 0.0d0
      enddo
    enddo
      do jstep = 1, statevector%numStep
        do jlat = lat1, lat2
          do jlon = lon1, lon2
            gd2d_tmp(jlon,jlat) = gd2d_tmp(jlon,jlat) +   &
                                  statevector%gd_r8(jlon,jlat,jlev,jstep)
        enddo
      enddo
    enddo
    do jlat = lat1, lat2
        do jlon = lon1, lon2
          statevector%gd3d_r8(jlon,jlat,jlev) = gd2d_tmp(jlon,jlat)
        enddo
      enddo
    enddo
!$OMP END PARALLEL DO

  END SUBROUTINE GSV_3dto4dAdj


  SUBROUTINE GSV_deallocate(statevector)
    implicit none

    type(struct_gsv) :: statevector
    integer        :: ierr

    if(.not.statevector%allocated) then
      call utl_abort('gridStateVector not yet allocated! Aborting.')
    endif

    statevector%allocated=.false.

    deallocate(statevector%allLonBeg)
    deallocate(statevector%allLonEnd)
    deallocate(statevector%allLatBeg)
    deallocate(statevector%allLatEnd)

    if(statevector%dataKind==8) then
      deallocate(statevector%gd_r8,stat=ierr)
      nullify(statevector%gd_r8)
    elseif(statevector%dataKind==4) then
      deallocate(statevector%gd_r4,stat=ierr)
      nullify(statevector%gd_r4)
    endif
    if(ierr.ne.0) then
      write(*,*) 'gsv_deallocate: Problem detected. IERR =',ierr
    endif

    if(associated(statevector%dateStampList)) deallocate(statevector%dateStampList)
    deallocate(statevector%varOffset)
    deallocate(statevector%varNumLev)
    
  END SUBROUTINE GSV_deallocate


  function gsv_getField_r8(statevector,varName) result(field)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    real(8),pointer                        :: field(:,:,:,:)
    integer                                :: ilev1,ilev2,lon1,lat1

    lon1=statevector%myLonBeg
    lat1=statevector%myLatBeg

    if(.not. associated(statevector%gd_r8)) call utl_abort('gsv_getField_r8: data with type r8 not allocated')

    if(present(varName)) then
      if(gsv_varExist(statevector,varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        field(lon1:,lat1:,1:,1:) => statevector%gd_r8(:,:,ilev1:ilev2,:)
      else
        call utl_abort('gsv_getField_r8: Unknown variable name! ' // varName)
      endif
    else
      field(lon1:,lat1:,1:,1:) => statevector%gd_r8(:,:,:,:)
    endif

  end function gsv_getField_r8


  function gsv_getField3D_r8(statevector,varName,indexStep_in) result(field3D)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    integer, intent(in), optional          :: indexStep_in
    real(8),pointer                        :: field3D(:,:,:)
    integer                                :: ilev1,ilev2,lon1,lat1

    lon1=statevector%myLonBeg
    lat1=statevector%myLatBeg

    if(.not. associated(statevector%gd3d_r8)) call utl_abort('gsv_getField3D_r8: data with type r8 not allocated')

    if(present(varName)) then
      if(gsv_varExist(statevector,varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        if(present(indexStep_in)) then
          field3D(lon1:,lat1:,1:) => statevector%gd_r8(:,:,ilev1:ilev2,indexStep_in)
        else
          field3D(lon1:,lat1:,1:) => statevector%gd3d_r8(:,:,ilev1:ilev2)
        endif
      else
        call utl_abort('gsv_getField3D_r8: Unknown variable name! ' // varName)
      endif
    else
      if(present(indexStep_in)) then
        field3D(lon1:,lat1:,1:) => statevector%gd_r8(:,:,:,indexStep_in)
      else
        field3D(lon1:,lat1:,1:) => statevector%gd3d_r8(:,:,:)
      endif
    endif

  end function gsv_getField3D_r8


  function gsv_getField_r4(statevector,varName) result(field)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    real(4),pointer                        :: field(:,:,:,:)
    integer                                :: ilev1,ilev2,lon1,lat1

    lon1=statevector%myLonBeg
    lat1=statevector%myLatBeg

    if(.not. associated(statevector%gd_r4)) call utl_abort('gsv_getField_r4: data with type r4 not allocated')

    if(present(varName)) then
      if(gsv_varExist(statevector,varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        field(lon1:,lat1:,1:,1:) => statevector%gd_r4(:,:,ilev1:ilev2,:)
      else
        call utl_abort('gsv_getField_r4: Unknown variable name! ' // varName)
      endif
    else
      field(lon1:,lat1:,1:,1:) => statevector%gd_r4(:,:,:,:)
    endif

  end function gsv_getField_r4


  function gsv_getField3D_r4(statevector,varName,indexStep_in) result(field3D)
    implicit none
    type(struct_gsv), intent(in)           :: statevector
    character(len=*), intent(in), optional :: varName
    integer, intent(in), optional          :: indexStep_in
    real(4),pointer                        :: field3D(:,:,:)
    integer                                :: ilev1,ilev2,lon1,lat1

    lon1=statevector%myLonBeg
    lat1=statevector%myLatBeg

    if(.not. associated(statevector%gd3d_r4)) call utl_abort('gsv_getField3D_r4: data with type r4 not allocated')

    if(present(varName)) then
      if(gsv_varExist(statevector,varName)) then
        ilev1 = 1 + statevector%varOffset(vnl_varListIndex(varName))
        ilev2 = ilev1 - 1 + statevector%varNumLev(vnl_varListIndex(varName))
        if(present(indexStep_in)) then
          field3D(lon1:,lat1:,1:) => statevector%gd_r4(:,:,ilev1:ilev2,indexStep_in)
        else
          field3D(lon1:,lat1:,1:) => statevector%gd3d_r4(:,:,ilev1:ilev2)
        endif
      else
        call utl_abort('gsv_getField3D_r4: Unknown variable name! ' // varName)
      endif
    else
      if(present(indexStep_in)) then
        field3D(lon1:,lat1:,1:) => statevector%gd_r4(:,:,:,indexStep_in)
      else
        field3D(lon1:,lat1:,1:) => statevector%gd3d_r4(:,:,:)
      endif
    endif

  end function gsv_getField3D_r4


  function gsv_getDateStamp(statevector,step) result(dateStamp)
    implicit none
    type(struct_gsv), intent(in)   :: statevector
    integer, intent(in), optional  :: step 
    integer                        :: dateStamp

    if(associated(statevector%dateStampList)) then
      if(present(step)) then
        if(step.gt.0.and.step.le.statevector%numStep) then
          dateStamp=statevector%dateStampList(step)
        else
          write(*,*) 'gsv_getDateStamp: requested step is out of range! Step,numStep=',step,statevector%numStep
          call utl_abort('aborting in gsv_getDateStamp')
        endif    
      else
        dateStamp=statevector%dateStamp3D
      endif
    else
      call utl_abort('gsv_getDateStamp: dateStampList was not created during allocation!')
    endif

  end function gsv_getDateStamp


  function gsv_getVco(statevector) result(vco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_vco), pointer :: vco_ptr

    vco_ptr => statevector%vco

  end function gsv_getVco


  subroutine gsv_setVco(statevector,vco_ptr)
    implicit none
    type(struct_gsv) :: statevector
    type(struct_vco), pointer  :: vco_ptr

    statevector%vco => vco_ptr

  end subroutine gsv_setVco

  function gsv_getHco(statevector) result(hco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_hco), pointer :: hco_ptr

    hco_ptr => statevector%hco

  end function gsv_getHco

  subroutine gsv_setHco(statevector,hco_ptr)
    implicit none
    type(struct_gsv)          :: statevector
    type(struct_hco), pointer :: hco_ptr

    statevector%hco => hco_ptr

  end subroutine gsv_setHco

  !--------------------------------------------------------------------------
  ! gsv_readFromFile
  !--------------------------------------------------------------------------
  subroutine gsv_readFromFile(statevector,fileName,etiket_in,typvar_in,gridName,indexStep_in,unitconversion)
    implicit none
    ! Note this routine currently only works correctly for reading FULL FIELDS,
    ! not increments or perturbations... because of the HU -> LQ conversion

    ! arguments
    type(struct_gsv)              :: statevector
    character(len=*), intent(in)  :: fileName
    character(len=*), intent(in)  :: etiket_in
    character(len=*), intent(in)  :: typvar_in
    character(len=*), intent(in)  :: gridName
    integer, optional             :: indexStep_in
    logical, optional             :: unitconversion

    ! locals
    integer :: fnom, fstouv, fclos, fstfrm, fstlir
    integer :: ezdefset, ezsint, ezuvint, ezqkdef, ezgprm, ezsetopt
    integer :: nulfile
    real(4), allocatable :: field2d_file_r4(:,:),   field2d_interp_r4(:,:)
    real(4), allocatable :: field2dVV_file_r4(:,:), field2dVV_interp_r4(:,:)
    real(4), allocatable :: gd_send_r4(:,:,:), gd_recv_r4(:,:,:)
    real(8), pointer     :: field3d_tile(:,:,:), field3dVV_tile(:,:,:), psfc_tile(:,:) => null()
    real(4) :: factor_r4, temp_r4
    integer :: ierr, ni, nj, nk, batchnum, youridx, youridy, yourid, nsize
    integer :: jlon, jlev, jlat, nlev, nlev_gsv, jvar, jlev2, ip1, indexStep, target_gid
    integer :: readLevPE(500)
    integer :: ini,inj,ig1,ig2,ig3,ig4
    character(len=4)  :: varName
    character(len=2)  :: varLevel
    character(len=1)  :: clgrtyp
    logical :: doHorizInterp, doVertInterp, unitconversion2
    real(8), pointer :: field(:,:,:,:)
    type(struct_vco), pointer :: vco_file => null()
    type(struct_hco), pointer :: hco_file => null()

    write(*,*) 'gsv_readFromFile: START'
    call tmg_start(7,'READFROMFILE')

    if (present(indexStep_in)) then
      indexStep = indexStep_in
    else
      indexStep = statevector%anltime
    endif

    if(present(unitConversion)) then
      unitConversion2 = unitConversion
    else
      unitConversion2 = .true.
    endif

    ! set up vertical and horizontal coordinate for input file
    call vco_SetupFromFile(vco_file,trim(fileName),beSilent=.true.)
    if(associated(hco_Get(gridName))) then
      write(*,*) 'gsv_readFromFile: horiz grid already defined with name: ', gridName
      hco_file => hco_Get(gridName)
    else
      write(*,*) 'gsv_readFromFile: horiz grid will be defined with name: ', gridName
      call hco_SetupFromFile( trim(fileName), ' ', gridName)
      hco_file => hco_Get(gridName)
    endif

    ! test if horizontal and/or vertical interpolation needed for statevector grid
    doVertInterp = .not.vco_equal(vco_file,statevector%vco)
    doHorizInterp = .not.hco_equal(hco_file,statevector%hco)
    write(*,*) 'gsv_readFromFile: doVertInterp = ', doVertInterp, ', doHorizInterp = ', doHorizInterp

    ! possibly adjust target grid definition
    if ( trim(statevector % hco % grtyp) == 'G' .and. statevector % hco % ig2 == 1 ) then
      call utl_abort('gsv_readFromFile: ERROR: due to bug in ezsint, Gaussian grid with ig2=1 no longer supported')
    else 
      target_gid = statevector % hco % EZscintID
    end if

    !- Open input field
    nulfile = 0
    write(*,*) 'gsv_readFromFile: file name = ',trim(fileName)
    ierr    = fnom(nulfile,trim(fileName),'RND+OLD+R/O',0)
       
    if ( ierr >= 0 ) then
       write(*,*)'gsv_readFromFile: file opened with unit number ',nulfile
       ierr  =  fstouv(nulfile,'RND+OLD')
    else
       call utl_abort('gsv_readFromFile: problem opening input file, aborting!')
    end if

    if (nulfile == 0 ) then
       call utl_abort('gsv_readFromFile: unit number for input file not valid!')
    endif

    allocate(field2d_file_r4(hco_file%ni,hco_file%nj))
    allocate(field2dVV_file_r4(hco_file%ni,hco_file%nj))
    allocate(field2d_interp_r4(statevector%ni,statevector%nj))
    allocate(field2dVV_interp_r4(statevector%ni,statevector%nj))
    allocate(gd_send_r4(statevector%lonPerPE,statevector%latPerPE,mpi_nprocs))
    allocate(gd_recv_r4(statevector%lonPerPE,statevector%latPerPE,mpi_nprocs))
    field2d_interp_r4(:,:) = 0.0d0
    field2dVV_interp_r4(:,:) = 0.0d0

    VARNAME_LOOP: do jvar = 0, vnl_numvarmax 

      ! make sure that P0 is read first (needed for vertical interp)
      if(jvar == 0) then
        varName = 'P0'
      elseif(trim(vnl_varNameList(jvar)) == 'P0') then
        cycle VARNAME_LOOP
      else
        varName = trim(vnl_varNameList(jvar))
      endif

      ! do not try to read diagnostic variables
      if ( trim(vnl_varTypeFromVarname(varName)) == 'DIAG') cycle VARNAME_LOOP

      ! have to do UU and VV together when varName is UU
      if (trim(varName) == 'VV') cycle VARNAME_LOOP

      if (gsv_varExist(statevector,varName)) then

        varLevel = vnl_varLevelFromVarname(varName)
        nlev = vco_getNumLev(vco_file,varLevel)
        if ( unitConversion2 ) then
          if ( trim(varName) == 'UU' .or. trim(varName) == 'VV') then
            factor_r4 = MPC_M_PER_S_PER_KNOT_R4 ! knots -> m/s
          else if ( trim(varName) == 'P0' ) then
            factor_r4 = 100.0 ! hPa -> Pa
          else
            factor_r4 = 1.0 ! no conversion
          end if
        else
            factor_r4 = 1.0
        end if

        ! for each level determine which processor should do the reading
        do jlev = 1, nlev
          readLevPE(jlev) = mod(jlev-1,mpi_nprocs)
        enddo

        call rpn_comm_barrier("GRID",ierr)

        allocate(field3d_tile(statevector%myLonBeg:statevector%myLonEnd, &
                              statevector%myLatBeg:statevector%myLatEnd,nlev))
        if(trim(varName) == 'UU') then
          allocate(field3dVV_tile(statevector%myLonBeg:statevector%myLonEnd, &
                                  statevector%myLatBeg:statevector%myLatEnd,nlev))
        endif

        ! read all levels for one variable while interpolating and 
        ! distributing onto horizontal tiles as we go
        do jlev = 1, nlev
            
          if(mpi_myid == readLevPE(jlev)) then

            if(varLevel == 'MM') then
              ip1 = vco_file%ip1_M(jlev)
            elseif(varLevel == 'TH') then
              ip1 = vco_file%ip1_T(jlev)
            elseif(varLevel == 'SF') then
              ip1 = -1
            else
              call utl_abort('gsv_readFromFile: unknown varLevel')
            endif

            ierr=fstlir(field2d_file_r4(:,:),nulfile,ni,nj,nk,  &
                        statevector%datestamplist(indexStep),etiket_in,ip1,-1,-1,  &
                        typvar_in,varName)
            if(trim(varName) == 'UU') then
              ierr=fstlir(field2dVV_file_r4(:,:),nulfile,ni,nj,nk,  &
                          statevector%datestamplist(indexStep),etiket_in,ip1,-1,-1,  &
                          typvar_in,'VV')
            endif            

            if(ierr.lt.0)then
              write(*,*) varName,ip1,statevector%datestamplist(indexStep)
              call utl_abort('gsv_readFromFile: Problem with background file')
            end if

            if(doHorizInterp) then
              ! horizontal interpolation
              ierr = ezdefset(target_gid, hco_file%EZscintID)
              ierr = ezsetopt('INTERP_DEGREE', 'LINEAR')
              if(trim(varName) == 'UU') then
                ! interpolate both wind components
                ierr = ezuvint(field2d_interp_r4, field2dVV_interp_r4,   &
                               field2d_file_r4, field2dVV_file_r4) 
              else
                ! interpolate scalar variable
                ierr = ezsint (field2d_interp_r4, field2d_file_r4)
              endif
            else
              field2d_interp_r4(:,:) = field2d_file_r4(:,:)
              if(trim(varName) == 'UU') then
                field2dVV_interp_r4(:,:) = field2dVV_file_r4(:,:)
              endif
            endif

            ! Scale
            field2d_interp_r4(:,:) = factor_r4 * field2d_interp_r4(:,:)
            if(trim(varName).eq.'UU') then
              field2dVV_interp_r4(:,:) = factor_r4 * field2dVV_interp_r4(:,:)
            endif

          endif ! if readLevel

          ! do mpi communication
          if(readLevPE(jlev) == (mpi_nprocs-1) .or. jlev == nlev) then
            batchnum = ceiling(dble(jlev)/dble(mpi_nprocs))

!$OMP PARALLEL DO PRIVATE(youridy,youridx,yourid)
            do youridy = 0, (mpi_npey-1)
              do youridx = 0, (mpi_npex-1)
                yourid = youridx + youridy*mpi_npex
                gd_send_r4(:,:,yourid+1) =  &
                  field2d_interp_r4(statevector%allLonBeg(youridx+1):statevector%allLonEnd(youridx+1),  &
                                    statevector%allLatBeg(youridy+1):statevector%allLatEnd(youridy+1))
              enddo
            enddo
!$OMP END PARALLEL DO

            nsize = statevector%lonPerPE*statevector%latPerPE
            if(mpi_nprocs.gt.1) then
              call rpn_comm_alltoall(gd_send_r4,nsize,"mpi_real4",  &
                                     gd_recv_r4,nsize,"mpi_real4","GRID",ierr)
            else
              gd_recv_r4(:,:,1) = gd_send_r4(:,:,1)
            endif

!$OMP PARALLEL DO PRIVATE(jlev2,yourid)
            do jlev2 = 1+(batchnum-1)*mpi_nprocs, jlev
              yourid = readLevPE(jlev2)
              field3d_tile(statevector%myLonBeg:statevector%myLonEnd, &
                           statevector%myLatBeg:statevector%myLatEnd,jlev2) =   &
                    real(gd_recv_r4(:,:,yourid+1),8)
            enddo
!$OMP END PARALLEL DO

            if(trim(varName) == 'UU') then

!$OMP PARALLEL DO PRIVATE(youridy,youridx,yourid)
              do youridy = 0, (mpi_npey-1)
                do youridx = 0, (mpi_npex-1)
                  yourid = youridx + youridy*mpi_npex
                  gd_send_r4(:,:,yourid+1) =  &
                    field2dVV_interp_r4(statevector%allLonBeg(youridx+1):statevector%allLonEnd(youridx+1),  &
                                        statevector%allLatBeg(youridy+1):statevector%allLatEnd(youridy+1))
                enddo
              enddo
!$OMP END PARALLEL DO

              nsize = statevector%lonPerPE*statevector%latPerPE
              if(mpi_nprocs.gt.1) then
                call rpn_comm_alltoall(gd_send_r4,nsize,"mpi_real4",  &
                                       gd_recv_r4,nsize,"mpi_real4","GRID",ierr)
              else
                gd_recv_r4(:,:,1) = gd_send_r4(:,:,1)
              endif

!$OMP PARALLEL DO PRIVATE(jlev2,yourid)
              do jlev2 = 1+(batchnum-1)*mpi_nprocs, jlev
                yourid = readLevPE(jlev2)
                field3dVV_tile(statevector%myLonBeg:statevector%myLonEnd, &
                               statevector%myLatBeg:statevector%myLatEnd,jlev2) =   &
                      real(gd_recv_r4(:,:,yourid+1),8)
              enddo
!$OMP END PARALLEL DO
            endif ! if UU

          endif ! do communication

        enddo ! jlev (now all levels read and distributed onto tiles)

        if (trim(varName) == 'P0') then
          allocate(psfc_tile(statevector%myLonBeg:statevector%myLonEnd, &
                              statevector%myLatBeg:statevector%myLatEnd))
          psfc_tile(:,:) = field3d_tile(:,:,1)
        endif

        ! Now do vertical interpolation and put result in statevector
        if (nlev.gt.1) then
          ! 3D fields
          if (doVertInterp) then
            if(associated(psfc_tile)) then
              call gsv_vint(vco_file,field3d_tile,psfc_tile,statevector,varName,indexStep)
              if(trim(varName) == 'UU') then
                call gsv_vint(vco_file,field3dVV_tile,psfc_tile,statevector,'VV',indexStep)
                deallocate(field3dVV_tile)
              endif
            else
              call utl_abort('gsv_readFromFile: surface pressure not yet read, cannot call gsv_vint')
            endif
          else
            field => gsv_getField_r8(statevector,varName)
            field(:,:,:,indexStep) = 0.0d0
            field(statevector%myLonBeg:statevector%myLonEnd, &
                  statevector%myLatBeg:statevector%myLatEnd,1:nlev,indexStep) =  &
                                            field3d_tile(:,:,1:nlev)
            if(trim(varName) == 'UU') then
              field => gsv_getField_r8(statevector,'VV')
              field(:,:,:,indexStep) = 0.0d0
              field(statevector%myLonBeg:statevector%myLonEnd, &
                    statevector%myLatBeg:statevector%myLatEnd,1:nlev,indexStep) =  &
                                              field3dVV_tile(:,:,1:nlev)
              deallocate(field3dVV_tile)
            endif
          endif
        else
          ! 2D fields
          field => gsv_getField_r8(statevector,varName)
          field(:,:,:,indexStep) = 0.0d0
          field(statevector%myLonBeg:statevector%myLonEnd, &
                statevector%myLatBeg:statevector%myLatEnd,1,indexStep) =  &
                                          field3d_tile(:,:,1)
        endif
        deallocate(field3d_tile)

        ! convert humidity into LQ
        if(trim(varName) == 'HU') then
          nlev_gsv = gsv_getNumLev(statevector,'TH')
          field => gsv_getField_r8(statevector,varName)
!$OMP PARALLEL DO PRIVATE (jlat,jlev,jlon)
          do jlat = statevector%myLatBeg, statevector%myLatEnd
            do jlev = 1, nlev_gsv
              do jlon = statevector%myLonBeg, statevector%myLonEnd
                field(jlon,jlat,jlev,indexStep) = log(max(field(jlon,jlat,jlev,indexStep),MPC_MINIMUM_HU_R8))
              end do
            end do
          end do
!$OMP END PARALLEL DO
        endif

      endif ! if varExist

    enddo VARNAME_LOOP ! jvar

    deallocate(field2d_file_r4)
    deallocate(field2dVV_file_r4)
    deallocate(field2d_interp_r4)
    deallocate(field2dVV_interp_r4)

    ierr = fstfrm(nulfile)
    ierr = fclos(nulfile)        

    call tmg_stop(7)
    write(*,*) 'gsv_readFromFile: END'

  end subroutine gsv_readFromFile


  subroutine gsv_vint(vco_in,field_in,psfc_in,statevector_out,varName,indexStep)
    ! s/r gsv_vint  - Vertical interpolation of pressure defined fields
    implicit none

    ! arguments
    type(struct_vco), pointer :: vco_in
    real(8), pointer :: field_in(:,:,:), psfc_in(:,:)
    type(struct_gsv) :: statevector_out
    character(len=*) :: varName
    integer :: indexStep

    ! locals
    integer :: nlev_out, nlev_in, jlev_out, jlev_in, jlat, jlon, status, jlat2, jlon2
    real(8) :: zwb, zwt
    real(8), pointer  :: pres_out(:,:,:), pres_in(:,:,:), field_out(:,:,:,:)

    nullify(pres_out,pres_in,field_out)

    ! define pressures on input and output levels
    ! NOTE: order of arguments for pres_in/out is (lon,lat,lev)
    if(vnl_varLevelFromVarname(varName) == 'TH') then
      status=vgd_levels(vco_in%vgrid,           &
                        ip1_list=vco_in%ip1_T,  &
                        levels=pres_in,         &
                        sfc_field=psfc_in,      &
                        in_log=.false.)
      status=vgd_levels(statevector_out%vco%vgrid,           &
                        ip1_list=statevector_out%vco%ip1_T,  &
                        levels=pres_out,                     &
                        sfc_field=psfc_in,                   &
                        in_log=.false.)
    else
      status=vgd_levels(vco_in%vgrid,           &
                        ip1_list=vco_in%ip1_M,  &
                        levels=pres_in,         &
                        sfc_field=psfc_in,      &
                        in_log=.false.)
      status=vgd_levels(statevector_out%vco%vgrid,           &
                        ip1_list=statevector_out%vco%ip1_M,  &
                        levels=pres_out,                     &
                        sfc_field=psfc_in,                   &
                        in_log=.false.)
    endif

    ! do the vertical interpolation
    field_out => gsv_getField_r8(statevector_out,varName)
    field_out(:,:,:,indexStep) = 0.0d0
    nlev_out = vco_getNumLev(statevector_out%vco, vnl_varLevelFromVarname(varName))
    nlev_in  = vco_getNumLev(vco_in,              vnl_varLevelFromVarname(varName))
    do jlat = statevector_out%myLatBeg, statevector_out%myLatEnd
      jlat2 = jlat - statevector_out%myLatBeg + 1
      do jlon = statevector_out%myLonBeg, statevector_out%myLonEnd
        jlon2 = jlon - statevector_out%myLonBeg + 1
        jlev_in = 1
        do jlev_out = 1, nlev_out
          jlev_in = jlev_in + 1
          do while(pres_out(jlon2,jlat2,jlev_out).gt.pres_in(jlon2,jlat2,jlev_in)  &
                   .and.jlev_in.lt.nlev_in)
            jlev_in = jlev_in + 1
          enddo
          jlev_in = jlev_in - 1
          zwb = log(pres_out(jlon2,jlat2,jlev_out)/pres_in(jlon2,jlat2,jlev_in))  &
               /log(pres_in(jlon2,jlat2,jlev_in+1)/pres_in(jlon2,jlat2,jlev_in))
          zwt = 1.d0 - zwb
          field_out(jlon,jlat,jlev_out,indexStep) =   &
                             zwb*field_in(jlon,jlat,jlev_in+1) &
                           + zwt*field_in(jlon,jlat,jlev_in)
        enddo
      enddo
    enddo

    deallocate(pres_out)
    deallocate(pres_in)

  end subroutine gsv_vint

  !--------------------------------------------------------------------------
  ! gsv_writeToFileMpi
  !--------------------------------------------------------------------------
  subroutine gsv_writeToFileMpi(statevector, fileName, etiket_in, scaleFactor, ip3_in, &
       indexStep_in, HUcontainsLQ, unitconversion)
    implicit none

    ! arguments
    type(struct_gsv)             :: statevector
    character(len=*), intent(in) :: fileName
    character(len=*), intent(in) :: etiket_in
    real(8), optional,intent(in) :: scaleFactor
    integer, optional,intent(in) :: ip3_in, indexStep_in
    logical, optional,intent(in) :: HUcontainsLQ
    logical, optional,intent(in) :: unitconversion

    ! locals
    integer :: fclos, fnom, fstouv, fstfrm
    integer :: nulfile, indexStep
    real(4), allocatable :: work2d_r4(:,:), gd_send_r4(:,:,:), gd_recv_r4(:,:,:)
    real(4)   :: factor_r4, work_r4
    integer   :: ierr, fstecr
    integer   :: var, k, kgdim
    integer :: ni, nj, nk
    integer :: dateo, npak, ji, jj, jlev, jlev_last, nlev, jvar
    integer :: ip1, ip2, ip3, deet, npas, datyp
    integer :: ig1 ,ig2 ,ig3 ,ig4
    integer :: batchnum, jlev2, yourid, nsize, youridy, youridx
    integer :: writeLevPE(500)
    character(len=1)  :: grtyp
    character(len=4)  :: nomvar
    character(len=2)  :: typvar
    character(len=12) :: etiket
    character(len=3)  :: charprocid
    character(len=128) :: fileName_full
    logical :: iDoWriting,unitconversion2
    real(8), pointer :: field(:,:,:,:),field_ref(:,:,:,:)
    real(8), allocatable :: work3d(:,:,:)

    write(*,*) 'gsv_writeToFileMpi: START'

    if ( .not. statevector%mpi_local ) then
      call utl_abort('gsv_writeToFileMpi: cannot use this subroutine for mpiglobal data!')
    endif

    call tmg_start(5,'WRITETOFILE')

    if(present(ip3_in)) then
      ip3 = ip3_in
    else
      ip3 = 0
    endif

    if(present(unitConversion)) then
      unitConversion2 = unitConversion
    else
      unitConversion2 = .true.
    endif

    ! if step index not specified, choose anltime (usually center of window)
    if(present(indexStep_in)) then
      indexStep = indexStep_in
    else
      indexStep = statevector%anltime
    endif

    ! initialization of parameters for writing to file
    npak   = -32
    dateo  = statevector%dateStampList(indexStep)
    deet   = 0
    npas   = 0
    ni     = statevector%ni
    nj     = statevector%nj
    nk     = 1
    ip2    = 0
    typvar = 'R'
    etiket = trim(Etiket_in)
    grtyp  = statevector%hco%grtyp
    ig1    = statevector%hco%ig1
    ig2    = statevector%hco%ig2
    ig3    = statevector%hco%ig3
    ig4    = statevector%hco%ig4
    datyp  = 1

    nlev = max(gsv_getNumLev(statevector,'MM'),gsv_getNumLev(statevector,'TH'))
    ! for each level determine which processor should do the reading
    do jlev = 1, nlev
      writeLevPE(jlev) = mod(jlev-1,mpi_nprocs)
    enddo
    iDoWriting = (mpi_myid+1).le.nlev

    !
    !- Write the global StateVector
    !
    if (iDoWriting) then

      write(*,*) 'gsv_writeToFileMpi: START of writing to file'

      !- Open output field
      nulfile = 0
      write(charProcId,'(i3.3)') mpi_myid
      fileName_full = trim(fileName)//'_proc'//charProcId
      write(*,*) 'gsv_writeToFileMpi: file name = ',trim(fileName_full)
      ierr = fnom(nulfile,trim(fileName_full),'RND',0)
       
      if ( ierr >= 0 ) then
        write(*,*)'gsv_writeToFileMpi: increment file opened with unit number ',nulfile
        ierr  =  fstouv(nulfile,'RND')
      else
        call utl_abort('gsv_writeToFileMpi: problem opening output file, aborting!')
      end if

      if (nulfile == 0 ) then
        call utl_abort('gsv_writeToFileMpi: unit number for output file not valid!')
      endif

      !- Write TicTacToc
      if(mpi_myid == 0) call WriteTicTacToc(statevector,nulfile) ! IN

    endif

    allocate(work2d_r4(statevector%ni,statevector%nj))
    allocate(gd_send_r4(statevector%lonPerPE,statevector%latPerPE,mpi_nprocs))
    allocate(gd_recv_r4(statevector%lonPerPE,statevector%latPerPE,mpi_nprocs))

    do jvar = 1, vnl_numvarmax 
 
      if (gsv_varExist(statevector,vnl_varNameList(jvar)) ) then
        field => gsv_getField_r8(statevector,vnl_varNameList(jvar))

        nlev = gsv_getNumLev(statevector,vnl_varLevelFromVarname(vnl_varNameList(jvar)))

        allocate(work3d(statevector%myLonBeg:statevector%myLonEnd, &
                        statevector%myLatBeg:statevector%myLatEnd,nlev))
        work3d(:,:,:) = field(statevector%myLonBeg:statevector%myLonEnd, &
                              statevector%myLatBeg:statevector%myLatEnd,1:nlev,indexStep)

        do batchnum = 1, ceiling(dble(nlev)/dble(mpi_nprocs))

          jlev      = (batchnum-1)*mpi_nprocs + mpi_myid + 1
          jlev_last = min(nlev,batchnum*mpi_nprocs)

!$OMP PARALLEL DO PRIVATE(jlev2,yourid)
          do jlev2 = 1+(batchnum-1)*mpi_nprocs, jlev_last
            yourid = writeLevPE(jlev2)
            gd_send_r4(:,:,yourid+1) =  &
                real(work3d(statevector%myLonBeg:statevector%myLonEnd, &
                            statevector%myLatBeg:statevector%myLatEnd,jlev2),4)
          enddo
!$OMP END PARALLEL DO

          nsize = statevector%lonPerPE*statevector%latPerPE
          if(mpi_nprocs.gt.1) then
            call rpn_comm_alltoall(gd_send_r4,nsize,"mpi_real4",  &
                                   gd_recv_r4,nsize,"mpi_real4","GRID",ierr)
          else
            gd_recv_r4(:,:,1) = gd_send_r4(:,:,1)
          endif

!$OMP PARALLEL DO PRIVATE(youridy,youridx,yourid)
          do youridy = 0, (mpi_npey-1)
            do youridx = 0, (mpi_npex-1)
              yourid = youridx + youridy*mpi_npex
                work2d_r4(statevector%allLonBeg(youridx+1):statevector%allLonEnd(youridx+1),  &
                          statevector%allLatBeg(youridy+1):statevector%allLatEnd(youridy+1)) = &
                  gd_recv_r4(:,:,yourid+1)
            enddo
          enddo
!$OMP END PARALLEL DO

          ! now do writing
          if (iDoWriting.and.jlev.le.nlev) then

            ! Set the ip1 value
            if (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'MM') then
               ip1 = statevector%vco%ip1_M(jlev)
            elseif (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'TH') then
               ip1 = statevector%vco%ip1_T(jlev)
            elseif (vnl_varLevelFromVarname(vnl_varNameList(jvar)) == 'SF') then
               ip1 = 0
            else
               write(*,*) 'gsv_writeToFileMpi: unknown type of vertical level: ',  &
                          vnl_varLevelFromVarname(vnl_varNameList(jvar))
               call utl_abort('gsv_writeToFileMpi')
            end if

            ! Set the output variable name
            nomvar = trim(vnl_varNameList(jvar))
            if ( trim(nomvar) == 'HU' .and. present(HUcontainsLQ) ) then
               if ( HUcontainsLQ ) nomvar = 'LQ'
            end if

            ! Set the conversion factor
            if ( unitConversion2 ) then
              if ( trim(nomvar) == 'UU' .or. trim(nomvar) == 'VV') then
                factor_r4 = MPC_KNOTS_PER_M_PER_S_R4 ! m/s -> knots
              else if ( trim(nomvar) == 'P0' ) then
                factor_r4 = 0.01 ! Pa -> hPa
              else
                factor_r4 = 1.0
              end if
            else
              factor_r4 = 1.0
            end if

            if (present(scaleFactor)) factor_r4 = factor_r4 * real(scaleFactor,4)

            !- Scale
            work2d_r4(:,:) = factor_r4 * work2d_r4(:,:)

            !- Writing to file
            ierr = fstecr(work2d_r4, work_r4, npak, nulfile, dateo, deet, npas, ni, nj, &
                          nk, ip1, ip2, ip3, typvar, nomvar, etiket, grtyp,      &
                          ig1, ig2, ig3, ig4, datyp, .true.)

          endif ! iDoWriting

        enddo ! batchnum

        deallocate(work3d)

      end if ! varExist

    enddo ! jvar

    deallocate(work2d_r4)
    deallocate(gd_send_r4)
    deallocate(gd_recv_r4)

    if(iDoWriting) then
      ierr = fstfrm(nulfile)
      ierr = fclos(nulfile)        
    endif
       
    call tmg_stop(5)
    write(*,*) 'gsv_writeToFileMpi: END'

  end subroutine gsv_writeToFileMpi

  !--------------------------------------------------------------------------
  ! WriteTicTacToc
  !--------------------------------------------------------------------------
  subroutine WriteTicTacToc(statevector,iun)
    use vGrid_Descriptors , only: vgrid_descriptor, vgd_write, VGD_OK
    use MathPhysConstants_mod, only : MPC_DEGREES_PER_RADIAN_R8
    implicit none

    type(struct_gsv)    :: statevector
    integer, intent(in) :: iun

    integer :: ier

    integer :: dateo,npak, status
    integer :: ip1,ip2,ip3,deet,npas,datyp,ig1,ig2,ig3,ig4
    integer :: ig1_tictac,ig2_tictac,ig3_tictac,ig4_tictac

    character(len=1)  :: grtyp
    character(len=2)  :: typvar
    character(len=12) :: etiket

    !
    !- 1.  Writing Tic-Tac
    !
    if ( statevector % hco % grtyp == 'Z' ) then
       npak     = -32
       deet     =  0
       ip1      =  statevector%hco%ig1
       ip2      =  statevector%hco%ig2
       ip3      =  0
       npas     =  0
       datyp    =  1
       grtyp    = 'E'
       typvar   = 'X'
       etiket   = 'TICTICTACTAC'
       dateo =  0

       call cxgaig ( grtyp,                                          & ! IN
                     ig1_tictac, ig2_tictac, ig3_tictac, ig4_tictac, & ! OUT
                     real(statevector%hco%xlat1), real(statevector%hco%xlon1),   & ! IN
                     real(statevector%hco%xlat2), real(statevector%hco%xlon2)  )   ! IN

       ig1      =  ig1_tictac
       ig2      =  ig2_tictac
       ig3      =  ig3_tictac
       ig4      =  ig4_tictac

       ier = utl_fstecr(statevector%hco%lon*MPC_DEGREES_PER_RADIAN_R8, npak, &
                        iun, dateo, deet, npas, statevector%ni, 1, 1, ip1,    &
                        ip2, ip3, typvar, '>>', etiket, grtyp, ig1,          &
                        ig2, ig3, ig4, datyp, .true.)

       ier = utl_fstecr(statevector%hco%lat*MPC_DEGREES_PER_RADIAN_R8, npak, &
                        iun, dateo, deet, npas, 1, statevector%nj, 1, ip1,    &
                        ip2, ip3, typvar, '^^', etiket, grtyp, ig1,          &
                        ig2, ig3, ig4, datyp, .true.)
    end if

    !
    !- Writing Toc-Toc
    !
    if ( trim(statevector%vco%setupType) == 'FromFile' ) then 
       status = vgd_write(statevector%vco%vgrid,iun,'fst')
       if ( status /= VGD_OK ) then
          call utl_abort('WriteTicTacToc: ERROR with vgd_write')
       end if
    end if

  end subroutine WriteTicTacToc


  SUBROUTINE gsv_horizSubSample(statevector_in,statevector_out,horizSubSample)
    implicit none
    type(struct_gsv)    :: statevector_in, statevector_out
    integer, intent(in) :: horizSubSample
    integer             :: relativeFactor, middleStep
    real(8)             :: ratio_r8
    integer             :: jstep, jlon, jlat, ilon_in, ilon_out, ilat_in, ilat_out
    integer             :: ilon_in1, ilon_in2, jlon_in, ilat_in1, ilat_in2, jlat_in

    if( statevector_out%allocated ) then
      call gsv_deallocate(statevector_out)
    endif

    ! allocate the output statevector
    statevector_out%hco => statevector_in%hco
    statevector_out%vco => statevector_in%vco
    if( associated(statevector_in%dateStampList) ) then
      middleStep = nint((real(statevector_in%numStep,8)+1.0d0)/2.0d0)
      call gsv_allocate(statevector_out,  &
                        statevector_in%numStep,  &
                        datestamp = statevector_in%dateStampList(middleStep),  &
                        mpi_local = statevector_in%mpi_local,  &
                        horizSubSample = horizSubSample)
    else
      call gsv_allocate(statevector_out,  &
                        statevector_in%numStep,  &
                        mpi_local = statevector_in%mpi_local, &
                        horizSubSample = horizSubSample)
    endif

    if( statevector_out%horizSubSample == statevector_in%horizSubSample ) then
      if( mpi_myid == 0 ) write(*,*) 'gsv_horizSubSample: already at the selected subsample level: ', &
                                     statevector_out%horizSubSample
      call gsv_copy(statevector_in,statevector_out)
      return
    endif

    if( statevector_out%horizSubSample > statevector_in%horizSubSample ) then

      ! simple averaging onto a coarser grid
      if( mpi_myid == 0 ) write(*,*) 'gsv_horizSubSample: increasing subsample level from ',  &
                                     statevector_in%horizSubSample, ' to ',  &
                                     statevector_out%horizSubSample

      ratio_r8 = real(statevector_out%horizSubSample,8)/real(statevector_in%horizSubSample,8)
      if( abs(ratio_r8 - real(nint(ratio_r8),8)) > 1.0d-5 ) then
        write(*,*) 'gsv_horizSubSample: original subsample level=', statevector_in%horizSubSample
        write(*,*) 'gsv_horizSubSample: new      subsample level=', statevector_out%horizSubSample
        call utl_abort('gsv_horizSubSample: relative change of subsample level not an integer!')
      endif
      relativeFactor = nint(ratio_r8)

      call gsv_zero(statevector_out)
!$OMP PARALLEL DO PRIVATE(jstep, jlat, ilat_out, ilat_in1, ilat_in2, jlat_in, &
!$OMP                     jlon, ilon_out, ilon_in1, ilon_in2, jlon_in)
      do jstep = 1, statevector_out%numStep

        do jlat = 1, statevector_out%latPerPE
          ilat_out = jlat + statevector_out%myLatBeg - 1
          ilat_in1 = relativeFactor*(jlat-1) + statevector_in%myLatBeg
          ilat_in2 = ilat_in1 + relativeFactor - 1
          do jlat_in = ilat_in1, ilat_in2

            do jlon = 1, statevector_out%lonPerPE
              ilon_out = jlon + statevector_out%myLonBeg - 1
              ilon_in1 = relativeFactor*(jlon-1) + statevector_in%myLonBeg
              ilon_in2 = ilon_in1 + relativeFactor - 1
              do jlon_in = ilon_in1, ilon_in2

                statevector_out%gd_r8(ilon_out, ilat_out, :, jstep) =  &
                  statevector_out%gd_r8(ilon_out, ilat_out, :, jstep) +  &
                  statevector_in%gd_r8(jlon_in, ilat_in, :, jstep)

              enddo ! jlon_in
            enddo ! jlon

          enddo ! jlat_in
        enddo ! jlat

      enddo ! jstep
!$OMP END PARALLEL DO 

    else

      ! interpolate to a finer grid
      if( mpi_myid == 0 ) write(*,*) 'gsv_horizSubSample: decreasing subsample level from ',  &
                                     statevector_in%horizSubSample, ' to ',  &
                                     statevector_out%horizSubSample

      ratio_r8 = real(statevector_in%horizSubSample)/real(statevector_out%horizSubSample)
      if( abs(ratio_r8 - real(nint(ratio_r8),8)) > 1.0d-5 ) then
        write(*,*) 'gsv_horizSubSample: original subsample level=', statevector_in%horizSubSample
        write(*,*) 'gsv_horizSubSample: new      subsample level=', statevector_out%horizSubSample
        call utl_abort('gsv_horizSubSample: relative change of subsample level not an integer!')
      endif
      relativeFactor = nint(ratio_r8)

      ! copy each input grid point to multiple output grid points
!$OMP PARALLEL DO PRIVATE(jstep, jlat, ilat_out, ilat_in, jlon, ilon_out, ilon_in)
      do jstep = 1, statevector_out%numStep

        do jlat = 1, statevector_out%latPerPE
          ilat_out = jlat + statevector_out%myLatBeg - 1
          ilat_in  = floor(real(jlat-1,8)/real(relativeFactor,8)) + statevector_in%myLatBeg
          do jlon = 1, statevector_out%lonPerPE
            ilon_out = jlon + statevector_in%myLonBeg - 1
            ilon_in  = floor(real(jlon-1,8)/real(relativeFactor,8)) + statevector_in%myLonBeg
            statevector_out%gd_r8(ilon_out, ilat_out, :, jstep) =  &
              statevector_in%gd_r8(ilon_in, ilat_in, :, jstep)
          enddo ! jlon
        enddo ! jlat

      enddo ! jstep
!$OMP END PARALLEL DO 

    endif

  END SUBROUTINE gsv_horizSubSample


END MODULE gridStateVector_mod
