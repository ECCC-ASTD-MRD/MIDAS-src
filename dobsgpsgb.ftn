!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      SUBROUTINE DOBSGPSGB(PJO,lcolumnhr,lobsSpaceData)
#if defined (DOC)
*
***s/r DOBSGPSGB - Computation of Jo and the residuals to the GPSGB observations
*
*
*Author  : S. Macpherson *ARMA March 2004
*    -------------------
**    Purpose: Compute Jo and norm. innovations for all GPS ZTD observations
*
*Arguments
*     PJO: (returned) total value of Jo for GPSGB (on input = 0.0)
*
*Revision:
*       S. Macpherson *ARMA  December 2008
*         -- modified continuation of first/single site data printout statement
*           (was not printing anything)
*
* Note: JPNFLEV=100 = maximum number of levels (set in pardim.cdk) 
*       columnhr_NLEV = actual number of background levels (HR)

#endif
      use EarthConstants_mod
      use MathPhysConstants_mod
      use obsSpaceData_mod
      use columnData_mod 
      use bufr
      IMPLICIT NONE
*implicits
#include "comgpsgb.cdk"
*
      type(struct_columnData) :: lcolumnhr
      type(struct_obs) :: lobsSpaceData
      REAL*8 PJO
C
      type(struct_vco), pointer :: vco_trl
      REAL*8 ZLAT
      REAL*8 ZLON
      REAL*8, allocatable :: ZETA(:)
      REAL*8, allocatable :: ZTT (:)
      REAL*8, allocatable :: ZHU (:)
      REAL*8, allocatable :: ZGZ (:)
      REAL*8 ZP0
      REAL*8 ZPT
      REAL*8 ZMT
C
      REAL*8 ZOBS, ZOER, ZINC, ZHX, ZLEV, ZDZ
C
      INTEGER INDEX_HEADER,INDEX_BODY
      INTEGER IDATYP, ITYP
      INTEGER JL, nlev_T
C
      LOGICAL  ASSIM, LLOK, FIRSTHEADER

      INTEGER NH, NH1
      
C
C     * 1.  Initializations
C     *     ---------------
C
      firstheader=.true.
      nlev_T=col_getNumLev(lcolumnhr,'TH')
      allocate(zeta(nlev_T))
      allocate(ztt(nlev_T))
      allocate(zhu(nlev_T))
      allocate(zgz(nlev_T))
C
C     *    .   1.1  Eta vector
C     *    .        ----------
C      
      vco_trl => col_getVco(lcolumnhr)
      DO JL = 1, nlev_T
         ZETA(JL) = vco_trl%dhyb_T(JL)
      ENDDO
C
C     Loop over all observation files (all observation types)
C
      WRITE(*, *) ' '
      WRITE(*, *) ' '
      WRITE(*,'(A11,A9,3A8,A9,4A8,A10)')
     +     'DOBSGPSGB','CSTNID','ZLAT','ZLON',
     +     'ZLEV','ZDZ','ZOBS','ZOER','ZHX','O-P','PJO'
C
      ! loop over all header indices of the 'GP' family (GPS observations)
      call obs_set_current_header_list(lobsSpaceData,'GP')
      HEADER: do
         index_header = obs_getHeaderIndex(lobsSpaceData)
         if (index_header < 0) exit HEADER
C     
C     *  Process only zenith delay data (codtyp 189)
C
         IDATYP = obs_elem_i(lobsSpaceData,'ITY ',INDEX_HEADER)
         IF ( IDATYP .EQ. 189 ) THEN
C
            ASSIM = .FALSE.
C
C           Scan for requested assimilations, and count them.
C           Get station height ZLEV
C
            NH = 0
            ! loop over all body indices for this index_header
            call obs_set_current_body_list(lobsSpaceData, index_header)
            BODY: do 
               index_body = obs_getBodyIndex(lobsSpaceData)
               if (index_body < 0) exit BODY

               ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
               LLOK = ( (ITYP .EQ. BUFR_NEZD) .AND. 
     &                (obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1) )
               IF ( LLOK ) THEN
                  ZLEV = obs_elem_r(lobsSpaceData,'PPP ',INDEX_BODY)
                  ASSIM = .TRUE.
                  NH = NH + 1
               ENDIF
            ENDDO BODY
C
C     *     If assimilations are requested, apply the observation operator
C
            IF (ASSIM) THEN
C     
C     *        Profile at the observation location x :
C
               ZLAT = obs_elem_r(lobsSpaceData,'LAT ',INDEX_HEADER) * MPC_DEGREES_PER_RADIAN_R8
               ZLON = obs_elem_r(lobsSpaceData,'LON ',INDEX_HEADER) * MPC_DEGREES_PER_RADIAN_R8
               DO JL = 1, nlev_T
                  ZTT(JL) =     col_getElem(lcolumnhr,JL,INDEX_HEADER,'TT')
                  ZHU(JL) = EXP(col_getElem(lcolumnhr,JL,INDEX_HEADER,'HU'))
                  ! BUE: ORIGINALLY GZ, SHOULD PROBABLY BY GZ_T???
                  ZGZ(JL) = col_getHeight(lcolumnhr,JL,INDEX_HEADER,'TH') 
               ENDDO
               ZP0 =  col_getElem(lcolumnhr,1,INDEX_HEADER,'P0')
               ! BUE: ORIGINALLY RPPOBS, SHOULD PROBABLY BY RPPOBS_T???
               ZPT = col_getPressure(LCOLUMNHR,1,INDEX_HEADER,'TH')
               ZMT = ZGZ(nlev_T)/GRAV
C
C     *        Apply the ZTD observation operator ZHX = H(x)
C 
C
               ZHX = 0.0
               ZDZ = ZLEV - ZMT
               CALL GPSZTDOP(ZLAT,ZLON,ZLEV,ZETA,ZTT,ZHU,ZP0,ZPT,
     +              ZMT,ZGZ,ZHX,LCOLUMNHR)
C
C     *        Perform the (H(x)-Y)/SDERR operation
C
               NH1 = 0
               ! loop over all body indices for this index_header
               call obs_set_current_body_list(lobsSpaceData, index_header)
               BODY_2: do 
                  index_body = obs_getBodyIndex(lobsSpaceData)
                  if (index_body < 0) exit BODY_2

                  ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
                  IF ( obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1 .AND. 
     +               ITYP .EQ. BUFR_NEZD ) THEN
                     NH1 = NH1 + 1
C
C     *              Observation value    Y
C
                     ZOBS = obs_elem_r(lobsSpaceData,'VAR ',INDEX_BODY)
C
C     *              Observation error    SDERR
C
                     ZOER = obs_elem_r(lobsSpaceData,'OER ',INDEX_BODY)
C
C     *              Observation height (m)
C
                     ZLEV = obs_elem_r(lobsSpaceData,'PPP ',INDEX_BODY)
C
C     *              Normalized increment
C
                     ZINC = (ZHX - ZOBS) / ZOER
                     call obs_set_r(lobsSpaceData,'OMA ',INDEX_BODY, ZINC)
C
C     *              Contribution to the cost function
C
                     PJO = PJO + ZINC * ZINC
C     
C     *              Print data for first observation or single site
                     IF (L1GPSOBS) THEN
                        IF (obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER) .EQ. CGPSSTN) THEN
                           WRITE(*,
     +                      '(A11,A9,3(1x,f7.2),1x,f8.2,4(1x,f7.5),1x,f9.2)')
     +                      'DOBSGPSGB: ',obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER),
     +                      ZLAT,ZLON,ZLEV,ZDZ,
     +                      ZOBS,ZOER/YZDERRWGT,ZHX,-ZINC*ZOER,PJO
                        ENDIF
                     ELSE
                        IF (FIRSTHEADER .AND. NH1 .EQ. 1) THEN
                           WRITE(*,
     +                      '(A11,A9,3(1x,f7.2),1x,f8.2,4(1x,f7.5),1x,f9.2)')
     +                      'DOBSGPSGB: ',obs_elem_c(lobsSpaceData,'STID',INDEX_HEADER),
     +                      ZLAT,ZLON,ZLEV,ZDZ,
     +                      ZOBS,ZOER/YZDERRWGT,ZHX,-ZINC*ZOER,PJO
                        ENDIF
                     ENDIF
C
                  ENDIF
               ENDDO BODY_2

            ENDIF
         ENDIF

         firstheader = .false.

      ENDDO HEADER
C
      deallocate(zeta)
      deallocate(ztt)
      deallocate(zhu)
      deallocate(zgz)

      WRITE(*, *) ' '
      RETURN
      END
