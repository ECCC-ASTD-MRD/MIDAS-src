module topLevelControl_mod
!
! ***NOTE:*** The compilation script will automatically create topLevelControl_mod.ftn90 from this file
!
!     Control variables for the job - constant within job
!
!     TOP_CREVISION : string parameter that will be replaced by the compilation
!                     script to contain the latest SVN global revision number 
!                     (trailing "M" indicates working directory is "modified" 
!                     relative to the repository version)
!     TOP_NCONF     : configuration of the job
!
  use utilities_mod
  implicit none
  save
  private

  ! public variables
  public :: top_crevision
  ! public procedures
  public :: top_setup, top_AnalysisMode, top_BgckIrMode, top_BgckConvMode, top_OmpMode
  public :: top_BurpSplit, top_BurpSplitMode
  public :: top_fullWorkingPath, top_ramDiskRemove

  character(len=len('XXXXX')),parameter :: top_crevision='XXXXX'
  integer :: top_nconf

  character(len=256) :: burp_split_mode
  logical :: burp_split_L
  character(len=256) :: ram_disk_dir
  logical :: ram_disk_dir_exists

  contains

!--------------------------------------------------------------------------
! top_setup
!--------------------------------------------------------------------------
    subroutine top_setup
      implicit none
      integer :: nconf

      NAMELIST /NAMCT0/NCONF
      integer nulnam,ierr,fnom,fclos 

      integer :: length_burp_split, length_ram_disk_dir, status

      ! Set the default values
      nconf             = 141

      ! Read the NAMELIST to modify these values
      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      if(ierr.ne.0) call utl_abort('top_setup: Error opening file flnml')
      read(nulnam,nml=namct0,iostat=ierr)
      if(ierr.ne.0) call utl_abort('top_setup: Error reading namelist')
      write(*,nml=namct0)
      ierr=fclos(nulnam)

      top_nconf              = nconf

      !
      !- Determine if the observation files are already split by subdomain
      !
      status = 0
      call get_environment_variable('OAVAR_BURP_SPLIT',burp_split_mode,length_burp_split,status,.true.)

      if (status.gt.1) then
        write(*,*) 'top_setup: Problem when getting the environment variable OAVAR_BURP_SPLIT'
      end if
      if (status.eq.1) then
        write(*,*) 'top_setup: The environment variable OAVAR_BURP_SPLIT has not been detected!'
	write(*,*) '           The observation files are NOT split'
	burp_split_L = .false.  
	burp_split_mode = 'DEFAULT'
        ! At this point the code only supports split files
        write(*,*) 'top_setup: Expecting split burp files!'
        call utl_abort('top_setup')
      else
        write(*,*)
        write(*,*) 'top_setup: The environment variable OAVAR_BURP_SPLIT has correctly been detected'
	select case ( trim(burp_split_mode) )
	case ('yes')
	   write(*,*) 'top_setup: The observation files ARE split. Assuming ROUNDROBIN strategy'
	   burp_split_L = .true.
	   burp_split_mode = 'ROUNDROBIN'
        case ('no')
	   write(*,*) 'top_setup: The observation files are NOT split'
	   burp_split_L = .false.
	   burp_split_mode = 'DEFAULT'
           ! At this point the code only supports split files
           write(*,*) 'top_setup: Expecting split burp files!'
           call utl_abort('top_setup')
        case ('ROUNDROBIN')
	   write(*,*) 'top_setup: The observation files	ARE split using the ROUNDROBIN strategy'
	   burp_split_L = .true.
	case ('LATLONTILES')
	   write(*,*) 'top_setup: The observation files	ARE split by LAT-LON tiles'
           write(*,*) 'top_setup: LAT-LON TILES NO LONGER PERMITTED, USE ROUND ROBIN!'
           call utl_abort('top_setup')
        case default
           write(*,*) 'top_setup: Unknown burp_split_mode ', trim(burp_split_mode)
           call utl_abort('top_setup')
        end select
      end if

      !
      !- Determine the ramdisk directory, if available
      !
      status = 0
      call get_environment_variable('OAVAR_RAM_DISK_DIR',ram_disk_dir,length_ram_disk_dir,status,.true.)

      if (status.gt.1) then
        write(*,*) 'top_setup: Problem when getting the environment variable OAVAR_RAM_DISK_DIR'
      end if
      if (status.eq.1) then
        write(*,*) 'top_setup: The environment variable OAVAR_RAM_DISK_DIR has not been detected!'
	write(*,*) '           Assume all files in current working directory'
	ram_disk_dir_exists = .false.  
	ram_disk_dir = 'DOES_NOT_EXIST'
      else
        write(*,*)
        write(*,*) 'top_setup: The environment variable OAVAR_RAM_DISK_DIR has correctly been detected'
        write(*,*) 'top_setup: Files will first be opened from directory: ', trim(ram_disk_dir)
	ram_disk_dir_exists = .true.
      end if

    end subroutine top_setup

!--------------------------------------------------------------------------
! top_AnalysisMode
!--------------------------------------------------------------------------
    function top_AnalysisMode() result(analysisMode)
      implicit none
      logical :: analysisMode

      analysisMode= (top_nconf.eq.141)
        
    end function top_AnalysisMode

!--------------------------------------------------------------------------
! top_OmpMode
!--------------------------------------------------------------------------
    function top_OmpMode() result(ompMode)
      implicit none
      logical :: ompMode

      ompMode= (top_nconf.eq.121)
        
    end function top_OmpMode

!--------------------------------------------------------------------------
! top_BgckIrMode
!--------------------------------------------------------------------------
    function top_BgckIrMode() result(bgckMode)
      implicit none
      logical :: bgckMode

      bgckMode= (top_nconf.eq.111)
        
    end function top_BgckIrMode

!--------------------------------------------------------------------------
! top_BgckConvMode
!--------------------------------------------------------------------------
    function top_BgckConvMode() result(bgckMode)
      implicit none
      logical :: bgckMode

      bgckMode= (top_nconf.eq.101)
        
    end function top_BgckConvMode

!--------------------------------------------------------------------------
! top_BurpSplitMode
!--------------------------------------------------------------------------
    function top_BurpSplitMode() result(BurpSplitMode)
      implicit none
      character(len=48) :: BurpSplitMode

      BurpSplitMode = trim(burp_split_mode)
        
    end function top_BurpSplitMode

!--------------------------------------------------------------------------
! top_BurpSplit
!--------------------------------------------------------------------------
    function top_BurpSplit() result(BurpSplit)
      implicit none
      logical :: BurpSplit

      BurpSplit = burp_split_L
        
    end function top_BurpSplit

!--------------------------------------------------------------------------
! top_fullWorkingPath - given a filename, return the full path by either
!                       adding the current working directory or the ram disk
!                       directory
!--------------------------------------------------------------------------
    function top_fullWorkingPath(fileName, noAbort) result(fullWorkingPath)
      implicit none
      character(len=512) :: fullWorkingPath
      logical, optional  :: noAbort
      character(len=*)   :: fileName

      logical            :: fileExists, noAbort2
      character(len=256) :: fileName2

      if ( present(noAbort) ) then
        noAbort2 = noAbort
      else
        noAbort2 = .false.
      endif

      ! this should make it safe for calls where input and output are the same variable
      fileName2 = trim(fileName)

      ! first look for file in the ram disk directory
      fullWorkingPath = trim(ram_disk_dir) // '/' // trim(fileName2)
      inquire(file=trim(fullWorkingPath),exist=fileExists)

      if ( fileExists ) then
        write(*,*) 'top_fullWorkingPath: this file found on ram disk: ', trim(fileName2)
      else
        ! now look in working directory
        fullWorkingPath = './' // trim(fileName2)
        inquire(file=trim(fullWorkingPath),exist=fileExists)

        if ( .not. fileExists ) then
          if ( noAbort2 ) then
            fullWorkingPath = ' '
          else
            write(*,*) 'top_fullWorkingPath: file name          = ', trim(fileName2)
            write(*,*) 'top_fullWorkingPath: ram disk directory = ', trim(ram_disk_dir)
            call utl_abort('top_fullWorkingPath: this file cannot be found.')
          endif
        endif

      endif
       
    end function top_fullWorkingPath


!--------------------------------------------------------------------------
! top_ramDiskRemove - given the full path+filename, remove the file only if 
!                     it is located on the ram disk (to free up memory)
!--------------------------------------------------------------------------
    function top_ramDiskRemove(fullWorkingPath) result(returnCode)
      implicit none
#include <clib_interface.cdk>
      character(len=*) :: fullWorkingPath
      integer          :: returnCode
      logical          :: fileExists

      inquire(file=trim(fullWorkingPath),exist=fileExists)
      if ( .not. fileExists) then
        write(*,*) 'top_ramDiskRemove: file does not exist: ',trim(fullWorkingPath)
        returnCode = 0
        return
      endif

      if ( .not. ram_disk_dir_exists ) then
        write(*,*) 'top_ramDiskRemove: no ram disk in use.'
        returnCode = 0
        return
      endif

      if ( index(trim(fullWorkingPath), trim(ram_disk_dir)) == 1 ) then
        write(*,*) 'top_ramDiskRemove: removing file that is on the ram disk: ', trim(fullWorkingPath)
        returnCode = clib_remove(fullWorkingPath)
      else
        write(*,*) 'top_ramDiskRemove: this file not on ram disk: ', trim(fullWorkingPath)
        returnCode = 0
      endif

    end function top_ramDiskRemove

end module topLevelControl_mod
