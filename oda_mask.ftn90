!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
subroutine oda_mask(lobsSpaceData)
  use MathPhysConstants_mod
  use obsSpaceData_mod
  use bufr
  implicit none
  #include "comct0.cdk"
  #include "comdimo.cdk"
  #include "cvcord.cdk"
  #include "comlun.cdk"
  #include "comfilt.cdk"
  type(struct_obs) :: lobsSpaceData

  integer, dimension(:), allocatable :: list_header, list_body
  allocate(list_header( obs_num_stn     (lobsSpaceData) ))
  allocate(list_body  ( obs_num_obstotal(lobsSpaceData) ))

  call oda_masksf('UA')
  call oda_masksf('SF')
  call oda_masksf('SC')
  call oda_masksf('GP')
  call oda_maskpp('UA')
  call oda_maskpp('AI')
  call oda_maskpp('SW')
  call oda_maskto
  call oda_maskro
  call oda_maskzp('PR')
  call oda_maskgp

  !restore Global Masks. 
  IF(NCONF == 141) CALL restoreMasks  

  CONTAINS

      SUBROUTINE oda_masksf(CDFAM)
      use modmask, only : lmasksf_in, lmasksf_out, lmask, ldiagsf, ldiag
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          P. Koclas *CMC/AES in September 1994
!
      CHARACTER(len=2) :: CDFAM
      INTEGER ITYP
      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body
!C
!C     Temperature lapse rate for extrapolation of gz below model surface
!C

      ! loop over all header indices of the CDFAM family
      call obs_getHeaderIndices(lobsSpaceData, CDFAM, list_header, &
                                size_list_header)
      do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)
!C
!C     Process all data within the domain of the model
!C
         ! loop over all body indices (still in the CDFAM family)
         call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                 size_list_body)
         BODY_INDEX: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)

            IF ( obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 1 ) THEN
               ITYP = obs_elem_i(lobsSpaceData,'VNM ',index_body)
                IF (ITYP.EQ.BUFR_NETS .OR. ITYP.EQ.BUFR_NEPS  &
                     .OR.ITYP.EQ.BUFR_NEPN .OR. ITYP.EQ.BUFR_NESS  &
                     .OR.ITYP.EQ.BUFR_NEUS .OR. ITYP.EQ.BUFR_NEVS) THEN
                  LMASKSF_IN(index_body)=(obs_elem_i(lobsSpaceData,'ASS ', &
                                                     index_body) &
                                          .EQ. 1)
                ELSE IF (ITYP.EQ.BUFR_NEZD .OR. ITYP.EQ.BUFR_NEFE) THEN
                  LMASKSF_IN(index_body)= .false.
                ELSE
                  LMASKSF_IN(index_body)= &
                       (      obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1&
                        .AND. obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 0)
                ENDIF

               IF(obs_elem_i(lobsSpaceData,'VNM ',index_body) .EQ. BUFR_NEHS)then
                  ldiagsf(index_body) = .true.
                endif
            ENDIF ! VC0 .EQ. 1
         end do BODY_INDEX

!C
!C     Process all geopotential data below model's orography
!C
         BODY_INDEX_2: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            lmasksf_out(index_body)= &
                           (obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1) &
                     .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 2) &
                     .AND. (obs_elem_i(lobsSpaceData,'VNM ',index_body) &
                                                               .EQ. BUFR_NEGZ ) &
                     .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 1)
         enddo BODY_INDEX_2

      END DO

      lmask = lmask .or. lmasksf_in
      lmask = lmask .or. lmasksf_out
      ldiag = ldiag .or. ldiagsf
!C--------------------------------------------------------------------
      RETURN
      END subroutine oda_masksf


      SUBROUTINE oda_maskpp(CDFAM)
      use modmask, only : lmaskpp_in, lmaskpp_out, lmask,ldiagpp, ldiag
!* Argument declarations
      CHARACTER *2 CDFAM ! Family code to process (UA,SW,AI)
!*
!*Purpose : Defines a mask of assimilated and diagnosed data inside
!*          and outside the vertical domain
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          P. Koclas *CMC/AES in September 1994
!*
!* Local declarations
      INTEGER IDBURP
      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body
      REAL(8) :: ZLAT,ZLON,ZTORAD
      LOGICAL LLNOXTR
      LLNOXTR   = .false.

      ! loop over all header indices of the CDFAM family
      call obs_getHeaderIndices(lobsSpaceData, CDFAM, list_header, size_list_header)
      HEADER_INDEX: do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)
!C
!C     Process all data within the domain of the model
!C
         ! loop over all body indices (still in the CDFAM family)
         call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                 size_list_body)
         BODY_INDEX: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            lmaskpp_in(index_body)= &
                           (obs_elem_i(lobsSpaceData,'ASS ',index_body) .EQ. 1) &
                     .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_body) .EQ. 0) &
                     .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 2)

            IF(      obs_elem_i(lobsSpaceData,'VNM ',index_body) .EQ. BUFR_NEHU &
               .AND. obs_elem_i(lobsSpaceData,'VCO ',index_body) .EQ. 2) THEN
               IF (     NINT(obs_elem_r8(lobsSpaceData,'PPP ',index_body)) &
                   .GE. NINT(RLIMLVHU *100) ) THEN
                  ldiagpp(index_body) = .true.
                ENDIF
              endif

         END DO BODY_INDEX

         BODY_INDEX_2: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            lmaskpp_out(index_body)= &
                         (obs_elem_i(lobsSpaceData,'ASS ',index_header) .EQ. 1) &
                   .AND. (obs_elem_i(lobsSpaceData,'XTR ',index_header) .EQ. 2) &
                   .AND. (obs_elem_i(lobsSpaceData,'VCO ',index_header) .EQ. 2)

            if (lmaskpp_out(index_body) .and. &
                obs_elem_i(lobsSpaceData,'VNM ',index_header) .NE.BUFR_NEGZ) then
               lmaskpp_out(index_body) = .false.
              LLNOXTR   = .true.
              ZTORAD    = 1.D0/(RPI/180.D0)
               ZLAT     = obs_elem_r4(lobsSpaceData,'LAT ',index_header)*ZTORAD
               ZLON     = obs_elem_r4(lobsSpaceData,'LON ',index_header)*ZTORAD
               IDBURP   = MOD(obs_elem_i(lobsSpaceData,'ITY ',index_header),1000)

              WRITE(NULOUT,*)' ODA_MASKPP: NO EXTRAPOLATION ALLOWED '  &
                   ,' OBS ',obs_elem_c9(lobsSpaceData,'STID',index_header) &
                   ,' TYPE ',IDBURP, ' ELM ' &
                   , obs_elem_i(lobsSpaceData,'VNM ',index_header),' LAT ' &
                   , ZLAT,  ' LON ', ZLON
            endif
         END DO BODY_INDEX_2
      END DO HEADER_INDEX
      lmask = lmask .or. lmaskpp_in
      lmask = lmask .or. lmaskpp_out
      ldiag = ldiag .or. ldiagpp
!C--------------------------------------------------------------------
      IF(LLNOXTR) THEN
        WRITE(NULOUT,*)'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        WRITE(NULOUT,*)' Warning - ODA_MASKPP: NO EXTRAPOLATION ALLOWED SEE LISTING FOR MORE DETAILS'
        WRITE(NULOUT,*)'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
      ENDIF

      RETURN
      END subroutine oda_maskpp


subroutine oda_maskto
  use modmask, only : lmaskto, lmask
  ! Purpose : Defines a mask of assimilated data
  !
  ! Author  : S. Pellerin, ARMA, January 2009
  !           Based on selection made in observation operator as written by
  !           j. halle *cmda/aes  in december 2005
  !
  !revision :      Sylvain Heilliette:
  !                 add IASI data (codtyp 186)
  use mod_tovs
#include "partov.cdk"
#include "comtov.cdk"

  integer :: isens, indxchn, indxtovs
  integer idatyp
  integer ichn
  integer :: size_list_header, index_list_header, index_header
  integer :: size_list_body,   index_list_body,   index_body
  integer  isrcheq
  external isrcheq
  external abort3d

  if(nobtov.eq.0) return    ! exit if there are not tovs data

  !     1.  Computation of (hx - z)/sigma for tovs data only
  !     .   ------------------------------------------------

  ! loop over all header indices of the 'TO' family
  call obs_getHeaderIndices(lobsSpaceData, 'TO', list_header, size_list_header)
  HEADER_INDEX: do index_list_header = 1, size_list_header
     index_header = list_header(index_list_header)

           !     .  1.1  Extract general information for this observation point
           !     .       ------------------------------------------------------

     !       process only radiance data to be assimilated?
     !       (data type=[164,168,180,181,182,183,185,186])

     idatyp = mod(obs_elem_i(lobsSpaceData,'ITY ',index_header),1000)
           if ( idatyp .ne. 164 .and.  &
                idatyp .ne. 168 .and.  &
                idatyp .ne. 180 .and.  &
                idatyp .ne. 181 .and.  &
                idatyp .ne. 182 .and.  &
                idatyp .ne. 183 .and.  &
                idatyp .ne. 185 .and.  &
                idatyp .ne. 186          ) then
        cycle                     ! Proceed to the next HEADER_INDEX
     end if

     indxtovs = ltovsno(index_header)
              if ( indxtovs .eq. 0 ) then
                 write(nulout,fmt=9203)
9203             format(' tovs_calc_jo_tl: error with indxtovs')
                 call abort3d(nulout,'tovs_calc_jo_tl ')
              endif

              if (rttov_errorstatus(indxtovs) .lt. 20   ) then
        ! loop over all body indices (still in the 'TO' family)
        call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                size_list_body)
                 isens = lsensor(indxtovs)
        BODY_INDEX: do index_list_body = 1, size_list_body
           index_body = list_body(index_list_body)
           if ( obs_elem_i(lobsSpaceData,'ASS ',index_body).eq.1 ) then
              ichn = nint(obs_elem_r8(lobsSpaceData,'PPP ',index_body))
                       ichn    = max(0,min(ichn,jpch+1))
                       if(idatyp.ne.183 .and. idatyp.ne.186) ichn=ichn-chanoffset(isens)
                       indxchn = isrcheq (ichan(:,isens),nchan(isens),ichn)
                       if ( indxchn .eq. 0 ) then
                          write(nulout,fmt=9202)
9202                      format(' tovs_calc_jo_tl: error with channel number')
                          call abort3d(nulout,'tovs_calc_jo_tl  ')
                       endif
!              print *,"maskto",index_body!,shape(lmaskto(:))
              lmaskto(index_body) = .true.
           endif
        enddo BODY_INDEX
!    else
!       kfailtot = kfailtot + 1
     endif
  enddo HEADER_INDEX
  lmask = lmask .or. lmaskto
end subroutine oda_maskto


      SUBROUTINE oda_maskro
      use modmask, only : lmaskro, lmask
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          J. M. Aparicio in Jan 2004
!*
      INTEGER IDATYP

      LOGICAL  LUSE

      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body

      ! loop over all header indices of the 'RO' family (Radio Occultation)
      call obs_getHeaderIndices(lobsSpaceData, 'RO', list_header, &
                                size_list_header)
      HEADER_INDEX: do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)
         IDATYP = MOD(obs_elem_i(lobsSpaceData,'ITY ',index_header),1000)
         IF ( IDATYP .NE. 169 ) THEN
            cycle                       ! Proceed to the next HEADER_INDEX
            ENDIF

         ! loop over all body indices (still in the 'RO' family)
         call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                 size_list_body)
         BODY_INDEX: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            LUSE=( obs_elem_i(lobsSpaceData,'ASS ',index_body).EQ.1 )
            IF ( LUSE ) THEN
              lmaskro(index_body) = .true.
        ENDIF
         ENDDO BODY_INDEX
      ENDDO HEADER_INDEX
      lmask = lmask .or. lmaskro
      RETURN
      END subroutine oda_maskro


      SUBROUTINE oda_maskzp(CDFAM)
      use modmask, only : lmaskzp, lmask
!*
!*Purpose : Defines a mask of assimilated data
!*
!*Author  : S. Pellerin, ARMA, January 2009
!*          Based on selection made in observation operator as written by
!*          J. St-James, CMDA/SMC in July 2003
!*
      CHARACTER *2 CDFAM

      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body
      LOGICAL LLOK

      ! loop over all header indices of the CDFAM family
      call obs_getHeaderIndices(lobsSpaceData, CDFAM, list_header, &
                                size_list_header)
      HEADER_INDEX: do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)

         ! loop over all body indices (still in the CDFAM family)
         call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                 size_list_body)
         BODY_INDEX: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            LLOK=       (obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1)  &
                  .AND. (obs_elem_i(lobsSpaceData,'XTR ',INDEX_BODY) .EQ. 0) &
                  .AND. (obs_elem_i(lobsSpaceData,'VCO ',INDEX_BODY) .EQ. 1)
              IF ( LLOK ) THEN
               lmaskzp(index_body) = .true.
              ENDIF
         END DO BODY_INDEX
      END DO HEADER_INDEX
      lmask = lmask .or. lmaskzp
      RETURN
      END subroutine oda_maskzp


      SUBROUTINE oda_maskgp
      use modmask, only : lmaskgp, lmask
!*
!*Purpose : Defines a mask of assimilated data for GP family ZTD data
!*
!*Author  : S. Macpherson, ARMA, March 2009
!*

      INTEGER ITYP,IDATYP
      integer :: size_list_header, index_list_header, index_header
      integer :: size_list_body,   index_list_body,   index_body
      LOGICAL LLOK

      ! loop over all header indices of the 'GP' family
      call obs_getHeaderIndices(lobsSpaceData, 'GP', list_header, &
                                size_list_header)
      HEADER_INDEX: do index_list_header = 1, size_list_header
         index_header = list_header(index_list_header)
         IDATYP    = MOD(obs_elem_i(lobsSpaceData,'ITY ',INDEX_HEADER),1000)
            IF ( IDATYP .NE. 189 ) THEN
            cycle                       ! Proceed to the next HEADER_INDEX
         ENDIF

         ! loop over all body indices (still in the 'GP' family)
         call obs_getBodyIndices(lobsSpaceData, index_header, list_body, &
                                 size_list_body)
         BODY_INDEX: do index_list_body = 1, size_list_body
            index_body = list_body(index_list_body)
            ITYP = obs_elem_i(lobsSpaceData,'VNM ',INDEX_BODY)
                LLOK = ( (ITYP .EQ. BUFR_NEZD) .AND.  &
                     (obs_elem_i(lobsSpaceData,'ASS ',INDEX_BODY) .EQ. 1) )
                IF ( LLOK ) THEN
               lmaskgp(index_body) = .true.
        ENDIF
          ENDDO BODY_INDEX
      END DO HEADER_INDEX
      lmask = lmask .or. lmaskgp
      RETURN
      END subroutine oda_maskgp


      SUBROUTINE restoreMasks 
      use modmask
!
!c Purpose:
!c Compute the global masks such as lmaskpp_inout_g,lmasksf_inout_g,... 
!c
!c Author  : BIN HE  *ARMA/MRB MAY 2009
!c
! Define Local Variables. 
      INTEGER :: ierr
      INTEGER :: nobtot_l
      integer :: mask_dim
      LOGICAL,DIMENSION(:),pointer :: llmask_l  

       nobtot_l=nobtot 
       mask_dim = ubound(lmaskpp_in,1)  
         
       ALLOCATE(lmaskpp_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskpp_inout_g')
       ALLOCATE(lmasksf_inout_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmasksf_inout_g')
       ALLOCATE(lmaskto_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskto_g')

       ALLOCATE(lmaskro_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskro_g')

       ALLOCATE(lmaskzp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskzp_g')

       ALLOCATE(lmask_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmask_g')

       ALLOCATE(lmaskgp_g(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cannt Allocate Mem. to lmaskgp_g')

       ALLOCATE(llmask_l(mask_dim),STAT=ierr)
       IF(ierr /= 0 ) CALL ABORT3D(nulout,'Cant Allocate Mem. to llmask_l')

       CALL restore_mask(lmask_g,lobsSpaceData%mxobstotal,lmask,obs_num_obstotal(lobsSpaceData))  

       llmask_l = lmaskpp_in .or. lmaskpp_out
       CALL restore_mask(lmaskpp_inout_g,lobsSpaceData%mxobstotal,llmask_l,obs_num_obstotal(lobsSpaceData))  

       llmask_l =  lmasksf_in .or. lmasksf_out
       CALL restore_mask(lmasksf_inout_g,lobsSpaceData%mxobstotal,llmask_l,obs_num_obstotal(lobsSpaceData))  

       CALL restore_mask(lmaskto_g,lobsSpaceData%mxobstotal,lmaskto,obs_num_obstotal(lobsSpaceData))  

       CALL restore_mask(lmaskro_g,lobsSpaceData%mxobstotal,lmaskro,obs_num_obstotal(lobsSpaceData))  

       CALL restore_mask(lmaskzp_g,lobsSpaceData%mxobstotal,lmaskzp,obs_num_obstotal(lobsSpaceData))  

       CALL restore_mask(lmaskgp_g,lobsSpaceData%mxobstotal,lmaskgp,obs_num_obstotal(lobsSpaceData))  

      END SUBROUTINE restoreMasks     


      SUBROUTINE restore_mask(lmask_g,kdata_g,lmask_l,kdata_l)
        INTEGER :: kdata_l,kdata_g 
        Logical ,DIMENSION(kdata_g) :: lmask_g 
        Logical ,DIMENSION(kdata_l) :: lmask_l 

       INTEGER :: i,ii,j ,iobs,idata,idataend,ierr  

       lmask_g=.false.
       ii=0
       DO i=1,nobtot
         iobs=locObsTag(i)
         idata=obs_elem_mpiglobal_i(lobsSpaceData,'RLN ',iobs)
         idataend=obs_elem_mpiglobal_i(lobsSpaceData,'NLV ',iobs) + idata -1
         DO j=idata,idataend
           ii=ii+1
           lmask_g(j)=lmask_l(ii)
         ENDDO
       ENDDO  
       CALL rpn_comm_allreduce(lmask_g,lmask_g,kdata_g,"MPI_LOGICAL","MPI_LOR","GRID",ierr )
      END SUBROUTINE   restore_mask
 

end subroutine oda_mask
