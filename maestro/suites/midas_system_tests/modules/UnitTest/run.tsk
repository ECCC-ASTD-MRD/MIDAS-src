#!/bin/ksh

cp ${UnitTest_run_namelist} flnml
cp ${TASK_BIN}/pgm .
ln -s ${TASK_INPUT}/inputs/* .

if [[ "${ORDENV_PLAT}" = sles-*xc40 ]]; then
    export AFSISIO=/home/smco502/env_sles-11-broadwell-64-xc40
elif [[ "${ORDENV_PLAT}" = ubuntu-14.04* ]]; then
    export AFSISIO=/home/smco502/env_ubuntu-14.04-amd64-64
    ## loading OpenMPI 1.6.5 (the binaries must be compiled with too)
    . ssmuse-sh -d hpco/tmp/eccc/201402/05/base
    . ssmuse-sh -d main/opt/intelcomp/intelcomp-2016.1.156
    . ssmuse-sh -d main/opt/openmpi/openmpi-1.6.5/intelcomp-2016.1.156
    ## those variables are necessary on PPP
    export OMPI_MCA_orte_tmpdir_base=/run/shm
    export OMPI_MCA_btl_openib_if_include=mlx5_0
else
    echo "The plateform ORDENV_PLAT=${ORDENV_PLAT} is not supported"
    exit 1
fi

export TMG_ON=YES
export OMP_STACKSIZE=4G

for __envvar__ in ${UnitTest_run_environment_variables}; do
    eval "export ${__envvar__}"
done
unset __envvar__

cat << EOF > ptopo_nml
 &ptopo
  npex=${SEQ_NPEX}
  npey=${SEQ_NPEY}
/
EOF

if [ "${UnitTest_run_debug}" = ddt ]; then
    if [[ "${ORDENV_PLAT}" = sles-*xc40 ]]; then
        run_in_parallel_extra_args=-ddt
        RUN_PGM=./pgm
    else
        cat > run.sh <<EOF
#!/bin/ksh

/fs/home/fs1/ords/ssc/hpco/mib002/allinea/forge/bin/ddt-client --ddtsessionfile ${HOME}/.allinea/session/eccc1-ppp2-1 ./pgm
EOF
        RUN_PGM=./run.sh
    fi
elif [ "${UnitTest_run_debug}" = gdb ]; then
    cat > run.sh <<EOF
#!/bin/ksh
gdb -ex run -ex where ./pgm
EOF
    RUN_PGM=./run.sh
elif [ "${UnitTest_run_debug}" = no ]; then
    RUN_PGM=./pgm
else
    echo "The value of 'UnitTest_run_debug=${UnitTest_run_debug}' is not 'ddt', 'gdb' or 'no' so we will use 'no'."
    RUN_PGM=./pgm
fi

[ ! -x "${RUN_PGM}" ] && chmod u+x ${RUN_PGM}
ulimit -c unlimited

pgmpath=$(${TASK_BIN}/read_link ${TASK_BIN}/pgm)
${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "Launching ${pgmpath}"

if [ -L ${TASK_BIN}/mpiscript ]; then
    cp ${TASK_BIN}/mpiscript ./mpiscript
    chmod +x mpiscript
    cmd=./mpiscript
    export RUN_PGM
else
    cmd=${RUN_PGM}
fi

[ ! -d obs ] && mkdir obs
echo "Copy of observations starts at $(date +%Y%m%d:%H:%M:%S.%N)"
/bin/cp burpfiles_*/brp*_*_* ./obs || true

echo "Launching ${pgmpath} at $(date +%Y%m%d:%H:%M:%S.%N)"

SECONDS=0
${TASK_BIN}/r.run_in_parallel -pgm ${cmd} -npex ${SEQ_NPEX} -npey ${SEQ_NPEY} -processorder -tag -nocleanup -verbose -tmpdir ${PWD}/mpitmpdir ${run_in_parallel_extra_args} -args ${UnitTest_run_pgm_args}
RUNTIME=${SECONDS}

echo "End of ${pgmpath} at $(date +%Y%m%d:%H:%M:%S.%N)"

## If we will not check the runtime, then issue the message now
if [ -z "${UnitTest_mean_runtime}" ]; then
    ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "The runtime was ${RUNTIME} seconds."
fi

## remove inputs
for file in ${TASK_INPUT}/inputs/*; do
    bfile=$(basename ${file})
    ## habituellement, les fichiers 'brp' sont mis a jour alors on ne les efface pas pour les garder.
    if [[ "${bfile}" == brp* ]]; then
        continue
    fi
    rm -r ${bfile}
done

## remove other files created by the execution
rm -f flnml pgm ptopo_nml run.sh mpiscript VAR3D_STATUS.dot
rm -r mpitmpdir
[ -d obs ] && rm -r obs

## put all the rest in 'output'
mv * ${TASK_OUTPUT}

if (( $(echo "${RUNTIME} < 3" | bc -l) )); then
        ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "The runtime was ${RUNTIME} seconds which is really short."

    exit 1
fi

## Check runtime
if [ -n "${UnitTest_mean_runtime}" ]; then
    function parse_time {
        set -e
        __parse_time__=$1
        if [[ "${__parse_time__}" == *:*:* ]]; then
            __parse_time_seconds__=$(echo ${__parse_time__} | awk -F: '{print 3600*$1 + 60*$2 + $3}')
        elif [[ "${__parse_time__}" == *:* ]]; then
            __parse_time_seconds__=$(echo ${__parse_time__} | awk -F: '{print 60*$1 + $2}')
        else
            __parse_time_seconds__=${__parse_time__}
        fi
        unset __parse_time__

        echo ${__parse_time_seconds__}
        unset __parse_time_seconds__
    }

    expected_seconds=$(parse_time ${UnitTest_mean_runtime})
    max_seconds=$(echo "${expected_seconds}*(1+${UnitTest_max_runtime}/100)" | bc -l)

    if (( $(echo "${RUNTIME} > ${max_seconds}" | bc -l) )); then
    #if [[ ${RUNTIME} > ${max_seconds} ]]; then
        max_seconds=$(printf "%.2f" ${max_seconds})
        ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "The runtime was ${RUNTIME} seconds which is greater than the maximum allowed ${max_seconds} (${UnitTest_max_runtime}% more than ${UnitTest_mean_runtime})"
        if [ "${UnitTest_abort_runtime}" = abort ]; then
            exit 1
        fi
    else
        max_seconds=$(echo "${expected_seconds}*(1+${UnitTest_max_runtime}/100/2)" | bc -l)
        if (( $(echo "${RUNTIME} > ${max_seconds}" | bc -l) )); then
            #if [[ ${RUNTIME} > ${max_seconds} ]]; then
            max_seconds=$(printf "%.2f" ${max_seconds})
            max_runtime=$(printf "%.2f" $(echo "${UnitTest_max_runtime}/2" | bc -l))
            ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "The runtime was ${RUNTIME} seconds which is greater than the maximum allowed ${max_seconds} (${max_runtime}% more than ${UnitTest_mean_runtime})"
        else
            ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "The runtime was ${RUNTIME} seconds."
        fi
    fi
fi

