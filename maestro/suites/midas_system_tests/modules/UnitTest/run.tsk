#!/bin/ksh

cp ${UnitTest_run_namelist} flnml
cp ${TASK_BIN}/pgm .
ln -s ${TASK_INPUT}/inputs/* .

cat >> load_env.sh <<EOF
export AFSISIO=/home/smco502/env_${ORDENV_PLAT}
export TMG_ON=YES
export OMP_STACKSIZE=4G
EOF

if [[ "${ORDENV_PLAT}" = sles-*xc50 ]]; then
    #export TBB_MALLOC_USE_HUGE_PAGES=1
    echo module load craype-hugepages16M >> load_env.sh
    echo export FOR_DISABLE_KMP_MALLOC=0 >> load_env.sh
elif [[ "${ORDENV_PLAT}" = ubuntu-18.04* ]]; then
    ## loading OpenMPI 3.1.2 (the binaries must be compiled with too)
    cat >> load_env.sh <<EOF
. ssmuse-sh -d hpco/exp/intelpsxe-cluster-19.0.3.199
. ssmuse-sh -d hpco/exp/openmpi/openmpi-3.1.2--hpcx-2.2.0--ofed-4.4.2--intel-2019.0.045
. ssmuse-sh -d hpco/exp/openmpi-setup/openmpi-setup-0.2
EOF
else
    echo "The plateform ORDENV_PLAT=${ORDENV_PLAT} is not supported"
    exit 1
fi

for __envvar__ in ${UnitTest_run_environment_variables}; do
    echo export ${__envvar__} >> load_env.sh
done

echo ulimit -c unlimited >> load_env.sh

cat << EOF > ptopo_nml
 &ptopo
  npex=${SEQ_NPEX}
  npey=${SEQ_NPEY}
/
EOF

if [ "${UnitTest_run_debug}" = ddt ]; then
    cat > run.sh <<EOF
#!/bin/bash

$(which ddt-client) --ddtsessionfile $HOME/.allinea/session/${HOSTNAME}-[0-9]* \${RUN_PGM}
EOF
    chmod +x run.sh
    LAUNCH_CMD=./run.sh
elif [ "${UnitTest_run_debug}" = gdb ]; then
    cat > run.sh <<EOF
#!/bin/bash
gdb -ex run -ex where \${RUN_PGM}
EOF
    chmod +x run.sh
    LAUNCH_CMD=./run.sh
elif [ "${UnitTest_run_debug}" = no ]; then
    LAUNCH_CMD="\${RUN_PGM}"
else
    echo "The value of 'UnitTest_run_debug=${UnitTest_run_debug}' is not 'ddt', 'gdb' or 'no' so we will use 'no'."
    LAUNCH_CMD="\${RUN_PGM}"
fi

pgmpath=$(${TASK_BIN}/read_link ${TASK_BIN}/pgm)
${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "Launching ${pgmpath}"

if [ -L ${TASK_BIN}/mpiscript ]; then
    cp ${TASK_BIN}/mpiscript ./mpiscript
    chmod +x mpiscript
    LAUNCH_CMD=./mpiscript
fi

cat > launch_program.sh <<EOF
#!/bin/bash

run_pgm=\${1:?'You must provide a program to launch'}

export RUN_PGM=\${run_pgm}

[ ! -d obs ] && mkdir obs
echo "Copy of observations starts at \$(date +%Y%m%d:%H:%M:%S.%N)"
/bin/cp burpfiles_*/brp*_*_* ./obs || true
/bin/cp sqlfiles_*/obs*_*_* ./obs || true
/bin/cp obsfiles_*/obs*_*_* ./obs || true

[ -d mpitmpdir ] && rm -r mpitmpdir

echo "Launching ${pgmpath} at \$(date +%Y%m%d:%H:%M:%S.%N)"

SECONDS=0
$(readlink -f ${TASK_BIN}/r.run_in_parallel) -pgm ${LAUNCH_CMD} -npex ${SEQ_NPEX} -npey ${SEQ_NPEY} -processorder -tag -nocleanup -verbose -tmpdir ${PWD}/mpitmpdir ${run_in_parallel_extra_args} -args ${UnitTest_run_pgm_args}
RUNTIME=\${SECONDS}

echo "End of ${pgmpath} at \$(date +%Y%m%d:%H:%M:%S.%N)"

EOF
chmod +x launch_program.sh

. ./load_env.sh

./launch_program.sh ./pgm

## If we will not check the runtime, then issue the message now
if [ -z "${UnitTest_maximum_execution_time}" ]; then
    ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "The runtime was ${RUNTIME} seconds."
fi

## remove inputs
for file in ${TASK_INPUT}/inputs/*; do
    bfile=$(basename ${file})
    ## habituellement, les fichiers 'brp', 'sql' ou 'sqlfiles' sont mis a jour alors on ne les efface pas pour les garder
    if [[ "${bfile}" == brp* || "${bfile}" == sql* || "${bfile}" == obsfiles* ]]; then
        if [ -f "${file}" ]; then
            continue
        fi
    fi
    rm -r ${bfile}
done

## remove other files created by the execution
rm -f flnml pgm ptopo_nml run.sh mpiscript VAR3D_STATUS.dot
rm -f load_env.sh launch_program.sh
rm -r mpitmpdir
[ -d obs ] && rm -r obs
[ -d obsBeforeThinning ] && rm -r obsBeforeThinning

## put all the rest in 'output'
mv * ${TASK_OUTPUT}

if (( $(echo "${RUNTIME} < 3" | bc -l) )); then
    ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "The runtime was ${RUNTIME} seconds which is really short."
    exit 1
fi

## Check runtime
if [ -n "${UnitTest_maximum_execution_time}" ]; then
    function parse_time {
        set -e
        __parse_time__=$1
        if [[ "${__parse_time__}" == *:*:* ]]; then
            __parse_time_seconds__=$(echo ${__parse_time__} | awk -F: '{print 3600*$1 + 60*$2 + $3}')
        elif [[ "${__parse_time__}" == *:* ]]; then
            __parse_time_seconds__=$(echo ${__parse_time__} | awk -F: '{print 60*$1 + $2}')
        else
            __parse_time_seconds__=${__parse_time__}
        fi
        unset __parse_time__

        echo ${__parse_time_seconds__}
        unset __parse_time_seconds__
    }

    max_seconds=$(parse_time ${UnitTest_maximum_execution_time})

    if (( $(echo "${RUNTIME} > ${max_seconds}" | bc -l) )); then
        max_seconds=$(printf "%.2f" ${max_seconds})
        ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "The runtime was ${RUNTIME} seconds which is greater than the maximum allowed ${max_seconds}"
        if [ "${UnitTest_abort_when_over_maximum_exection_time}" = abort ]; then
            exit 1
        fi
    else
        ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s infox -m "The runtime was ${RUNTIME} seconds."
    fi
fi ## Fin du 'if [ -n "${UnitTest_maximum_execution_time}" ]'

if [ "${UnitTest_stop_for_interactive_work}" = yes ]; then
    ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "We stop here to let you continue to work interactively"
    ${SEQ_BIN}/nodelogger -n ${SEQ_NODE} -s info -m "You can use ${MIDAS_SRC_CODE}/maestro/suites/midas_system_tests/modules/UnitTest/scripts/launch_interactive.sh -exp ${SEQ_EXP_HOME} -node ${SEQ_NODE} -date ${SEQ_DATE}"
    SEQ_XFER=stop
fi

if [ "${UnitTest_run_relaunch}" = run ]; then
    SEQ_XFER=stop
    maestro -s submit -n ${SEQ_NODE} -d ${SEQ_DATE} -f stop
elif [ "${UnitTest_run_relaunch}" != check -a "${UnitTest_run_relaunch}" != no ]; then
    echo "The variable 'UnitTest_run_relaunch' can only be equal to 'run', 'check' or 'no' and not '${UnitTest_run_relaunch}'."
    exit 1
fi ## Fin du 'if [ "${UnitTest_run_relaunch}" = run ]'
