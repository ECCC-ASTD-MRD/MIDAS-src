ENVAR_CFG=${ENVAR_CFG:-${SEQ_EXP_HOME}/config/${SEQ_CURRENT_CONTAINER}.cfg}
if [[ -f ${ENVAR_CFG} ]]; then . ${DOT_CFG:-source_cfg.dot} ${ENVAR_CFG}; fi

ENVAR_mode=${ENVAR_mode:-"EnVar"}

## when '${ENVAR_mode}=EnVar', if no ensemble trials is available, then 'abort' or 'continue' in 3D-Var
ENVAR_fallback_mode=${ENVAR_fallback_mode:-'abort'}

## load SSM domain needed to run the EnVar
ENVAR_ssm=${ENVAR_ssm:-arma/envar/run/1.0}
for __envar_ssmdomain__ in ${ENVAR_ssm}; do
    . ssmuse-sh -d ${__envar_ssmdomain__}
done
unset __envar_ssmdomain__

## to access tools like editfst and editbrp, reflex, ...
ENVAR_rpn_utils_ssm=${ENVAR_rpn_utils_ssm:-rpn/utils/4.0}
for __envar_ssmdomain__ in ${ENVAR_rpn_utils_ssm}; do
    . ssmuse-sh -d ${__envar_ssmdomain__}
done
unset __envar_ssmdomain__

## Repertoire d'override pour specifier les elements pour cette execution
ENVAR_ovbin=${ENVAR_ovbin:-${SEQ_EXP_HOME}/config/${SEQ_CURRENT_CONTAINER}/ovbin}
export PATH=${ENVAR_ovbin}:${SEQ_EXP_HOME}/modules/${SEQ_MODULE}/scripts:${PATH}

## SSM domains to load to get access to math Intel compiler library and MPI environment (openmpi)
## This variable is used only if 'EC_ARCH=Linux_x86-64'
ENVAR_mpi_ssm=${ENVAR_mpi_ssm:-"hpcs/201402/01/base hpcs/201402/01/intel13sp1u2"}
## This value is set for 'OMP_STACKSIZE' before calling the 'oavar'
ENVAR_OMP_STACKSIZE=${ENVAR_OMP_STACKSIZE:-4G}
## If 'yes', then pass this option to 'oavar.launch' which activate the usage of the '/tmp' to manipulate BURP files
ENVAR_fasttmp=${ENVAR_fasttmp:-no}

## delay from which the trial date is computed (useful for mode O-P used with an analysis
ENVAR_trial_delay=${ENVAR_trial_delay:-6}

## Date for files into the module
ENVAR_DATE=${ENVAR_DATE:-${SEQ_SHORT_DATE}}

ENVAR_etiket=${ENVAR_etiket:-${EXP_ETIKET:-'ENVAR'}}

ENVAR_TRANSFER_COMMAND=${ENVAR_TRANSFER_COMMAND:-${FILE_TRANSFER_COMMAND:-r.srcp}}

## Script executed into Manip task
ENVAR_manip_script=${ENVAR_manip_script:-'<no value>'}

## Variable definissant un fichier standard contenant un champ dont la grille sera utilisee pour definir la grille
ENVAR_analysis_grid=${ENVAR_analysis_grid:-analysis_grid_prototype_glb_800x400}

## if ENVAR_observations_input is empty then that means that the inputs are coming from the cycle itself
ENVAR_observations_input=${ENVAR_observations_input:-${SEQ_EXP_HOME}/hub/${TRUE_HOST}/banco/bgckalt}
## prefix for input observations (e.g.  'banco.bgckalt.')
ENVAR_observations_prefix=${ENVAR_observations_prefix-''}
## suffix for input observations (e.g.  '_v3')
ENVAR_observations_suffix=${ENVAR_observations_suffix-''}
## on indique si les observations satellitaires doivent etre regroupees dans un seul fichier 'brptov'
## sinon, on les laisse separes mais il faut que le binaire du 3D-Var soit capable de lire des fichiers separes.
ENVAR_observations_brptov_grouping=${ENVAR_observations_brptov_grouping:-'yes'}
## split the observation input files according to latitude bands
##    if 'release' or 'yes', then use the program 'splitobs_${BASE_ARCH}.Abs' from SSM package
##    if 'no' or '<no value>', then no splitting is done
ENVAR_observations_splitobs=${ENVAR_observations_splitobs:-'<no value>'}
## variable qui sera utilisee par le programme de splitting pour identifier la grille de travail
ENVAR_observations_splitobs_nomvar=${ENVAR_observations_splitobs_nomvar:-'P0'}
## grille defaut pour faire le splitting
ENVAR_observations_splitobs_grid=${ENVAR_observations_splitobs_grid:-${ENVAR_analysis_grid}}
## programme qui sert a regrouper les enregistrements qui ont ete separes par la procedure de 'splitting'
ENVAR_observations_reunir=${ENVAR_observations_reunir:-""}

## if ENVAR_trials_input is empty then that means that the inputs are coming from the cycle itself
ENVAR_trials_input=${ENVAR_trials_input:-${SEQ_EXP_HOME}/hub/${TRUE_HOST}/gridpt/trial/hyb}

## prefix to get for trials (default: everything that * matches)
ENVAR_trial_prefix=${ENVAR_trial_prefix:-""}

## extensions to get for trials (default: everything that * matches)
ENVAR_trial_extension=${ENVAR_trial_extension:-""}

## delai en minutes qui indique que la tache 'wait4increments' doit
## etre resoumise avant qu'elle ne soit arrivee au bout de son temps
ENVAR_wait4increment_offset_minutes=${ENVAR_wait4increment_offset_minutes:-4}
## if this variable is 'yes', then we will check with 'md5sum' if the files have been correctly transferred
ENVAR_wait4increment_md5sum_rebm=${ENVAR_wait4increment_md5sum_rebm:-yes}

## if ENVAR_enstrials_input is empty then that means that the inputs are coming from the cycle itself
ENVAR_enstrials_input=${ENVAR_enstrials_input:-'<no value>'}
## This variable controls the size of the batches to download the ensemble trials
## by indicating the number of digits to consider to download files
## if 'ENVAR_enstrials_download_batch_size=0', then all files in one single batch will be downloaded
## if 'ENVAR_enstrials_download_batch_size=1', then files ending with '0' will be downloaded, followed by ones ending with '1' until '9'
## if 'ENVAR_enstrials_download_batch_size=2', then files ending with '00' will be downloaded, followed by ones ending with '01' until '99'
ENVAR_enstrials_download_batch_size=${ENVAR_enstrials_download_batch_size:-0}
## This variable is to specify the extension length of the ensemble trials.
##     if 3, the we will have extension like  001
##     if 4, the we will have extension like  0001
##     if 9, the we will have extension like  000000001
ENVAR_enstrials_extension_length=${ENVAR_enstrials_extension_length:-3}
## if this variable is 'yes', then it will interpolate with script stg2nonstg_cub_enkf_driver.ksh
ENVAR_enstrials_interpolation=${ENVAR_enstrials_interpolation:-'<no value>'}
## if this variable is 'yes', then it will do the interpolation in the 'VAR' task.
ENVAR_enstrials_interpolation_in_VAR=${ENVAR_enstrials_interpolation_in_VAR:-no}
## prototype given to the script 'interpEnsTrials_driver.ksh' to know the vertical coordinate description
ENVAR_enstrials_vertical_prototype=${ENVAR_enstrials_vertical_prototype:-${OAVAR_DATA}/data/nonstg_73N_top_2mb.fst}
## if this variable is 'yes', then 'interpEnsTrials' will transfer its output files using MPI
ENVAR_enstrials_transfer_with_mpi=${ENVAR_enstrials_transfer_with_mpi:-no}
## if this variable is 'yes', then erase the ensemble trials downloaded in the task 'getEnsTrials'
ENVAR_enstrials_erase_noninterpolated=${ENVAR_enstrials_erase_noninterpolated:-yes}
## if this variable is 'yes', then we will do a 'reflex -stats' on each each to be sure that all files are correct.
ENVAR_enstrials_check=${ENVAR_enstrials_check:-yes}
## Proportion minimale de membres pour tourner en mode EnVar s'il y avait des membres manquants
ENVAR_minimum_proportion_of_members=${ENVAR_minimum_proportion_of_members:-'0.5'}
## If 'yes', then it will go a split into subdomains along latitudes and longitudes
ENVAR_ens_subdomains=${ENVAR_ens_subdomains:-'no'}
## Path to the program 'write_subdomains_${BASE_ARCH}.Abs' if not defined it will get the default value in script ${ENVAR_enstrials_interpolation}
ENVAR_ens_subdomains_program=${ENVAR_ens_subdomains_program:-""}

## Variable to control the hessian use or recyling
#### If this is equal to 'yes' then will use ${SEQ_EXP_HOME}/hub/${TRUE_HOST}/gridpt/anal/hyb/${__ENVAR_DATE_m6}_precon
ENVAR_precon_input=${ENVAR_precon_input:-"<no value>"} ## ${SEQ_EXP_HOME}/hub/${TRUE_HOST}/gridpt/anal/hyb/${__ENVAR_DATE_m6}_precon

ENVAR_statsbg=${ENVAR_statsbg:-"__GLBSTRATO_NMC_T200_TAPER_FIX_THETA_TOCTOC__"}
ENVAR_obscov=${ENVAR_obscov:-"__STATOBS1__"}
ENVAR_coefsat=${ENVAR_coefsat:-pollux:/usr/local/env/armnlib/modeles/ANAL/cmda/bgck/development/Strato2Br/rt_sat}
ENVAR_statsat=${ENVAR_statsat:-pollux:/usr/local/env/armnlib/modeles/ANAL/cmda/bgck/development/Strato2Br/stats_sat}
ENVAR_biascoeff=${ENVAR_biascoeff:-'<no value>'}

ENVAR_sfc4hyperir_input=${ENVAR_sfc4hyperir_input:-'<no value>'}
ENVAR_sfc4hyperir_newalb_input=${ENVAR_sfc4hyperir_newalb_input:-'<no value>'}

ENVAR_obstyp=${ENVAR_obstyp:-"ua,ai,sw,sf,pr,sc,ro,to_amsua,to_amsub,csr,ssmis,airs,iasi"}
ENVAR_namelist=${ENVAR_namelist:-'<no value>'}
## Si c'est 'release' alors on va utiliser le binaire '3dvar_${BASE_ARCH}.abs'
## Si c'est 'release/nompi' alors on va utiliser le binaire '3dvar_${BASE_ARCH}_NOMPI.abs'
ENVAR_3dvar_abs=${ENVAR_3dvar_abs:-release}
ENVAR_mpi_mode=${ENVAR_mpi_mode:-'mpi'}

## Par defaut, on utilise le programme du domaine SSM 'arma/envar/run'
ENVAR_AAI_abs=${ENVAR_AAI_abs:-""}
## If this is 'yes', then AddAnalInc will compress its outputs
ENVAR_AAI_compression=${ENVAR_AAI_compression:-'yes'}
## number of mpi task used to run a single AAI instance
ENVAR_AAI_mpi_tasks=${ENVAR_AAI_mpi_tasks:-''}

ENVAR_addanalinc_limits=${ENVAR_addanalinc_limits:-rttov_h2o_limits.dat}

ENVAR_output_mode=${ENVAR_output_mode:-'tree'} ## or 'flat'
ENVAR_output=${ENVAR_output:-${SEQ_EXP_HOME}/hub/${TRUE_HOST}}
ENVAR_output_gridpt_name=${ENVAR_output_gridpt_name:-gridpt}
ENVAR_output_banco_name=${ENVAR_output_banco_name:-banco}
ENVAR_postalt_output_mode=${ENVAR_postalt_output_mode:-"one"}  ## if 'one', we will put all the postalt files into the same single with editbrp
ENVAR_increment_highres_output_mode=${ENVAR_increment_highres_output_mode:-"no"}  ## If 'yes', then the high resolution increment file will be produced
ENVAR_precon_output_mode=${ENVAR_precon_output_mode:-"yes"} ## if 'yes' will save the hessian with the name ${ENVAR_DATE}_precon
ENVAR_analysis_output_mode=${ENVAR_analysis_output_mode:-'center'} ## ou bien 'all' pour avoir les analyses a tous les pas de temps d'increments

## List of shell regular expressions to save files from the 'VAR' task work directory
##    For example, this could be '*.hpm' for TMG output files
ENVAR_other_output_list=${ENVAR_other_output_list:-""}

## If this variable is equal to 'yes', then the Transfer task will erase the working directory of the module when everything is done
ENVAR_Clean_WorkDir=${ENVAR_Clean_WorkDir:-''}

###### Variables 'locales' n'appartenant pas a l'interface
__ENVAR_DATE_m6=$(r.date ${ENVAR_DATE} -${ENVAR_trial_delay} | cut -c-10)

if [ "${ENVAR_mode}" != "EnVar" -a "${ENVAR_mode}" != "3D-Var" -a "${ENVAR_mode}" != "O-P" ]; then
    echo "\$ENVAR_mode variable in module 'EnVar' must be equal to"
    echo "     EnVar or 3D-Var or O-P"
    echo "exiting ..."
    exit 1
fi
if [ "${ENVAR_mode}" = "O-P" -a "${ENVAR_mpi_mode}" != "mpi" -a "${ENVAR_mpi_mode}" != "nompi" ]; then
    echo "When \$ENVAR_mode='O-P' then the"
    echo "\$ENVAR_mpi_mode variable in module 'EnVar' must be equal to"
    echo "     mpi or nompi"
    echo "exiting ..."
    exit 1
fi
if [ -z "${ENVAR_namelist}" ]; then
    echo "You must provide a namelist for 3D-Var with the variable '\${ENVAR_namelist}'"
    exit 1
fi

if [ -z "$(which oavar.launch || true)" ]; then
    echo "The script 'oavar.launch' is not available in the environment"
    echo "You are probably using an old ENVAR_ssm='${ENVAR_ssm}'"
    exit 1
fi

if [ -z "${OAVAR_DATA}" ]; then
    echo "The variable 'OAVAR_DATA' is empty and should not."
    echo "Please use a SSM domain that initialises this variable"
    exit 1
fi

function getVARresources {
    set -ex

    if [ "${1}" = host ]; then
	getVARresources_host=$(${SEQ_BIN}/nodeinfo -n ${SEQ_CONTAINER}/VAR -f res | grep node\.machine | cut -d'=' -f2)
    elif [ "${1}" = topo ]; then
	__getVARresources_topo__=$(${SEQ_BIN}/nodeinfo -n ${SEQ_CONTAINER}/VAR -f res | grep node\.cpu | cut -d'=' -f2)
	if [[ "${__getVARresources_topo__}" = *x*x* ]]; then
	    getVARresources_npex=`echo ${__getVARresources_topo__} | awk -Fx '{print $1}'`
	    getVARresources_npey=`echo ${__getVARresources_topo__} | awk -Fx '{print $2}'`
	elif [[ "${__getVARresources_topo__}" = *x* ]]; then
	    getVARresources_npex=1
	    getVARresources_npey=`echo ${__getVARresources_topo__} | awk -Fx '{print $1}'`
	else
	    echo "Cannot determine the split array from cpu info from task ${SEQ_CONTAINER}/VAR (topo=${__getVARresources_topo__})"
	    exit 1
	fi
	unset __getVARresources_topo__
    else
	getVARresources host
	getVARresources topo
    fi
} ## End of 'function getVARresources'

function check_do_ssh_as_remote_copy {
    set -ex

    ## il s'agit de verifier si on est sur 'FRONTEND=eccc-ppp1' et 'hare' ou bien 'eccc-ppp2' et 'brooks'

    if [ $# -lt 1 ]; then
	getVARresources host
	__check_do_ssh_as_remote_copy_host__=${getVARresources_host}
    else
	__check_do_ssh_as_remote_copy_host__=$1
    fi

    do_ssh_as_remote_copy=no
    if [ "${TRUE_HOST}" = eccc-ppp1 ]; then
	if [ "${__check_do_ssh_as_remote_copy_host__}" = hare ]; then
	    do_ssh_as_remote_copy=yes
	fi
    elif [ "${TRUE_HOST}" = eccc-ppp2 ]; then
	if [ "${__check_do_ssh_as_remote_copy_host__}" = brooks ]; then
	    do_ssh_as_remote_copy=yes
	fi
    fi

    unset __check_do_ssh_as_remote_copy_host__
} ## End of 'function check_do_ssh_as_remote_copy'

function prepare_destination_directory {
    set -ex

    #__setstripe_count__=${1:-8}
    __host__=${1:-${getVARresources_host}}
    __output__=${2:-${SEQ_EXP_HOME}/hub/${__host__}/work/${SEQ_DATE}/${SEQ_NODE}/output}

    ssh ${__host__} "[ ! -d ${__output__} ] || rm -rf ${__output__}"
    ssh ${__host__} "mkdir -p ${__output__}"
    ## if [ "${__host__}" = hare -o "${__host__}" = brooks ]; then
    ## 	if [ "${__setstripe_count__}" -ne 0 ]; then
    ## 	    ssh ${__host__} "lfs setstripe --count ${__setstripe_count__} ${__output__}"
    ## 	fi
    ## fi
    output=${__host__}:${__output__}

    ## unset __setstripe_count__ __host__ __output__
    unset __host__ __output__
}  ## End of 'function prepare_destination_directory'

function envar_cp_command {
    set -ex

    __envar_cp_command_file__=$1
    __envar_cp_command_destination__=$2

    if [ -d "${__envar_cp_command_destination__}" ]; then
	__envar_cp_command_dfile__=${__envar_cp_command_destination__}/${__envar_cp_command_file__##*/}
    else
	__envar_cp_command_dfile__=${__envar_cp_command_destination__}
    fi

    __envar_cp_command_is_cross_device__=0
    ln ${__envar_cp_command_file__} ${__envar_cp_command_dfile__} 2>/dev/null || __envar_cp_command_is_cross_device__=1

    if [ "${__envar_cp_command_is_cross_device__}" -eq 0 ]; then
	## Si la command 'ln ...' ci-haut a fonctionne, cela signifie
	## que l'on est sur le meme device
	## (__envar_cp_command_is_cross_device__=0' et donc que l'on peut
	## faire un lien symbolique tout a fait surement.

	## On doit alors premierement, effacer le fichier
	## '${__envar_cp_command_dfile__}' qui est un 'hard-link' avant d'en
	## faire un lien symbolique.
	rm    ${__envar_cp_command_dfile__}
	ln -s ${__envar_cp_command_file__} ${__envar_cp_command_dfile__}
    else
	cp ${__envar_cp_command_file__} ${__envar_cp_command_dfile__}
    fi

    unset __envar_cp_command_file__ __envar_cp_command_dfile__
    unset __envar_cp_command_destination__ __envar_cp_command_is_cross_device__
}
