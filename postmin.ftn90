!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine postmin(lcolumng,lcolumnhr,lobsSpaceData)
!
!  s/r postmin  - Post-minimization control of the 3Dvar
!
!Author  : S. Pellerin *ARMA/SMC  May 2000
!
      use MathPhysConstants_mod
      use obsSpaceData_mod
      use controlVector_mod
      use columnData_mod
      use minimization_mod
      use bmatrix_mod
      use mpi
      use gridStateVector_mod
      use gaussGrid_mod
      IMPLICIT NONE
#include "comvfiles.cdk"
#include "comfilt.cdk"
      type(struct_obs),target :: lobsSpaceData
      type(struct_columnData),target :: lcolumng,lcolumnhr

      type(struct_vco), pointer :: vco_anl
      type(struct_gsv) :: statevector,statevectorg
      integer jk,jj,ji,nulfile,ierr,fnom,fstouv,fstfrm,fclos
      real*8 ztemp
      real*8, allocatable :: zes(:,:,:)
      real*8, allocatable :: ztv(:,:,:)
      real*8, allocatable :: zgz(:,:,:)
      real*8, allocatable :: zhu(:,:,:)
      real*8, pointer :: hu3d_inc_ptr(:,:,:),hu3d_trl_ptr(:,:,:)
!
!     if a restart file was writen at the end of minimize.ftn,
!     lrestart was turn to .true. to avoid postmin exection
!
      if (lrestart) return

      write(*,*) '-------------------------------'
      write(*,*) '--Starting subroutine postmin--'
      write(*,*) '-------------------------------'
!
!     Compute the analysis increment (mpiglobal result only on myid=0)
!
      call tmg_start(91,'POST_COMPUTEDX')
      vco_anl => col_getVco(lcolumng)
      call gsv_setVco(statevector,vco_anl)
      call gsv_allocate(statevector,gaus_ni,gaus_nj,nstepobsinc,datestamp=min_get_datestamp(),mpi_local=.true.)
      call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)
      call gsv_commMPIGlobal(statevector)
      call tmg_stop(91)
      
      ! free up some memory now that B isn't needed
      call bmat_finalize(cvm_vazx)
      call cvm_deallocate

      WRITE(*,*)' postmin: Transform analysis variables to model variables -'

      call tmg_start(92,'POST_DIAG')
!
!     Prepare background fields (only P0, TT, HU) at the analysis time for flow-dependent 
!     control variables (NOTE: mpiglobal result only on myid=0)
!
      call gsv_setVco(statevectorg,vco_anl)
      call gsv_allocate(statevectorg,gaus_ni,gaus_nj,nstepobs,datestamp=min_get_datestamp(),mpi_local=.false.)

      call tmg_start(93,'SUBASIC_GD')
      call subasic_gd(statevectorg,lcolumnhr)
      call tmg_stop(93)

      call tmg_stop(92)

      ! background fields only on myid=0, so only do calculations for myid=0
      if(mpi_myid == 0 ) then
        call tmg_start(92,'POST_DIAG')

        allocate(zes(gaus_ni,vco_anl%nlev_M,gaus_nj))
        allocate(ztv(gaus_ni,vco_anl%nlev_M,gaus_nj))
        allocate(zgz(gaus_ni,vco_anl%nlev_M,gaus_nj))
        allocate(zhu(gaus_ni,vco_anl%nlev_M,gaus_nj)) 
!
!       *** Compute increment HU from LQ increment ***
!
        hu3d_trl_ptr => gsv_getField3D(statevectorg,'HU')
        hu3d_inc_ptr => gsv_getField3D(statevector ,'HU')
!$OMP PARALLEL DO PRIVATE(jk,jj,ji,ztemp)
        do jj = 1,statevectorg%nj
          do jk = 1,statevectorg%vco%nlev_M
            do ji = 1,statevectorg%ni
              ZTEMP = log(hu3d_trl_ptr(ji,jk,jj)) + hu3d_inc_ptr(ji,jk,jj)
              zhu(ji,jk,jj) = EXP(ZTEMP) - hu3d_trl_ptr(ji,jk,jj)
            enddo
          enddo
        enddo
!$OMP END PARALLEL DO
!
!       *** ES ***
!
        call lq2esgd(zes,statevector,statevectorg)
!
!       *** Total GZ ***
!
        call lt2tvgd(ztv,statevector,statevectorg)
        call ltt2phigd(zgz,ztv,statevectorg)

        call tmg_stop(92)
!
!       Now, write out the increment, including diagostic variables
!
        nulfile = 0
        ierr    = fnom(nulfile,'./rebm','RND',0)
        if(ierr.ge.0)then
          write(*,*)'postmin: rebm file opened with unit number ',nulfile
          ierr  =  fstouv(nulfile,'RND')
        else
          call abort3d('postmin: problem opening rebmh file, aborting!')
        end if

        call varout(nulfile,statevector,zes,ztv,zgz,zhu,min_niter)

        ierr =  fstfrm(nulfile)
        ierr =  fclos(nulfile)        

        deallocate(zes)
        deallocate(ztv)
        deallocate(zgz)
        deallocate(zhu)

      endif

      call gsv_deallocate(statevectorg)
      call gsv_deallocate(statevector)
!
!     Now write out the observation data:
!
      IF (LVARQC) CALL LISTREJ(lobsSpaceData)

      CALL VINT3DFD(OBS_OMA,lobsSpaceData)
      CALL VINT3DFD(OBS_OMF,lobsSpaceData)
      CALL SETASSFLG(lobsSpaceData)
      CALL FLAGUVTOFD_OBSDAT(lobsSpaceData)
      CALL UPDATE_BURPFILES(lobsSpaceData)

      call obs_finalize(lobsSpaceData)

      write(*,*) 'LEAVING POSTMIN'

      END SUBROUTINE POSTMIN
