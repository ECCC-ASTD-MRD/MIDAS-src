!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!
      subroutine postmin(lcolumng,lcolumnhr,indexAnalysis)
!
!  s/r postmin  - Post-minimization control of the 3Dvar
!
!Author  : S. Pellerin *ARMA/SMC  May 2000
!
      use MathPhysConstants_mod
      use controlVector_mod
      use columnData_mod
      use minimization_mod
      use bmatrix_mod
      use mpi
      use gridStateVector_mod
      use HorizontalCoord_mod
      use timeCoord_mod
      IMPLICIT NONE
      type(struct_columnData),target :: lcolumng,lcolumnhr

      type(struct_hco),      pointer :: hco_anl
      type(struct_vco), pointer :: vco_anl
      type(struct_gsv) :: statevector,statevectorg

      integer jk,jj,ji,jstep,nulfile,ierr,fnom,fstouv,fstfrm,fclos,indexAnalysis
      integer :: datestamplist(tim_nstepobsinc)
      real*8  :: hu_anl,deltaHours
      real*8, allocatable :: zes(:,:,:)
      real*8, allocatable :: ztv(:,:,:)
      real*8, allocatable :: zgz(:,:,:)
      real*8, allocatable :: zhu(:,:,:)
      real*8, pointer :: lq_inc_ptr(:,:,:,:),hu_trl_ptr(:,:,:,:)
      character(len=4) :: flnum 
      character(len=3) :: flnum2
      character(len=128) :: incFileName
      integer             :: get_max_rss
! previously from compost.cdk
      integer          NPPCVAR
      character(len=4)  :: CPPCVAR(20)
      character(len=12) :: CETIKINC
      logical :: write4dInc,useTL_LQtoHU
      logical lvtout,lgzout
!
      write(*,*) '-------------------------------'
      write(*,*) '--Starting subroutine postmin--'
      write(*,*) '-------------------------------'
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
!
!     Read namelist and do some setup
!
      call supost
!
!     Check that we have at least as many processors as increment timesteps
!
      if(mpi_nprocs .lt. tim_nstepobsinc) then
        write(*,*) 'mpi_nprocs=',mpi_nprocs,', nstepobsinc=',tim_nstepobsinc
        call abort3d('postmin: number of cpus < number of increment timesteps, aborting!')
      endif
!
!     Compute the analysis increment
!
      call tmg_start(91,'POST_COMPUTEDX')

      vco_anl => col_getVco(lcolumng)
      hco_anl => hco_Get('Analysis')
      call gsv_setVco(statevector,vco_anl)

      call gsv_setHco(statevector, hco_anl)

      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      call gsv_allocate(statevector,tim_nstepobsinc, &
           datestamp=tim_getDatestamp(),mpi_local=.true.)
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

      if(write4dInc) then
        ! mpiglobal result for 4D increment only on myid=(increment_time_step -1)
        call gsv_commMPIGlobal(statevector)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      else
        ! mpiglobal result for 3D increment only on myid=0 
        call gsv_commMPIGlobal3D(statevector)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
      endif
      call tmg_stop(91)

      WRITE(*,*)' postmin: Transform analysis variables to model variables -'

      call tmg_start(92,'POST_DIAG')
!
!     Prepare background fields (only P0, TT, HU) at each analysis time for flow-dependent 
!     control variables (NOTE: mpiglobal result only on myid=increment_time_step-1)
!
      call gsv_setVco(statevectorg,vco_anl)
      call gsv_setHco  ( statevectorg, hco_anl )
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      call gsv_allocate(statevectorg,1,datestamp=tim_getDatestamp(),mpi_local=.false.)

      do jstep=1,tim_nstepobsinc
        datestamplist(jstep)=gsv_getDateStamp(statevector,jstep)
      enddo
      if(write4dInc) then
        ! read in the background fields at all increment timesteps
        call subasic_gd(statevectorg,lcolumnhr,tim_nstepobsinc,datestamplist,indexAnalysis)
      else
        ! only read in the background fields at the "analysis" timestep (usually the middle)
        call subasic_gd(statevectorg,lcolumnhr,1,datestamplist(statevector%anltime),indexAnalysis)
      endif
      write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

      ! background fields only on myid=0, so only do calculations for myid=0
      if( (write4dInc      .and. mpi_myid .lt. tim_nstepobsinc) .or.  &
          (.not.write4dInc .and. mpi_myid .eq. 0          ) ) then

        if(write4dInc) then
          jstep=mpi_myid+1
        else
          jstep=statevector%anltime
        endif

        write(*,*) 'postmin: computing the diag variables for timestep:',jstep
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

        allocate( zes(hco_anl % ni, vco_anl % nlev_M, hco_anl % nj) )
        allocate( ztv(hco_anl % ni, vco_anl % nlev_M, hco_anl % nj) )
        allocate( zgz(hco_anl % ni, vco_anl % nlev_M, hco_anl % nj) )
        allocate( zhu(hco_anl % ni, vco_anl % nlev_M, hco_anl % nj) )

        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
!
!         *** Compute increment HU from LQ increment ***
!
        hu_trl_ptr => gsv_getField(statevectorg,'HU')  ! this is HU_b
        lq_inc_ptr => gsv_getField(statevector ,'HU')  ! this is delta LQ
!$OMP PARALLEL DO PRIVATE(jj,jk,ji,hu_anl)
        do jj = 1,statevectorg%nj
          do jk = 1,statevectorg%vco%nlev_M
            do ji = 1,statevectorg%ni
              ! choose either tangent linear or nonlinear operator for LQ to HU
              if(useTL_LQtoHU) then
                zhu(ji,jk,jj) = lq_inc_ptr(ji,jk,jj,1)*hu_trl_ptr(ji,jk,jj,1)
              else
                hu_anl = log(hu_trl_ptr(ji,jk,jj,1)) + lq_inc_ptr(ji,jk,jj,1)
                zhu(ji,jk,jj) = EXP(hu_anl) - hu_trl_ptr(ji,jk,jj,1)
              endif
            enddo
          enddo
        enddo
!$OMP END PARALLEL DO
!
!       *** ES ***
!
        call lq2esgd(zes,statevector,statevectorg)
!
!       *** Total GZ ***
!
        call lt2tvgd(ztv,statevector,statevectorg)
        call ltt2phigd(zgz,ztv,statevectorg)
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
!
!       Now, write out the increment, including diagostic variables
!
        nulfile = 0
        if(write4dInc) then
          call difdatr(datestamplist(jstep),tim_getDatestamp(),deltaHours)
          if(nint(deltaHours*60.0d0).lt.0) then
            write(flnum,'(I4.3)') nint(deltaHours*60.0d0)
          else
            write(flnum,'(I3.3)') nint(deltaHours*60.0d0)
          endif
          write(*,*) 'postmin: dates=',datestamplist(jstep),tim_getDatestamp(),deltaHours,nint(deltaHours*60.0d0)
          write(*,*) 'postmin: flnum=###',trim(flnum),'###'
          incFileName = './rebm_'//trim(flnum)//'m'
        else
          incFileName = './rebm'
        endif
        if(indexAnalysis.gt.0) then
          write(flnum2,'(I3.3)') indexAnalysis
          incFileName = trim(incFileName) // '_' // trim(flnum2)
        endif

        call varout
        write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'
 

        deallocate(zes)
        deallocate(ztv)
        deallocate(zgz)
        deallocate(zhu)

      endif

      ! free up some memory related to B and increment
      call gsv_deallocate(statevectorg)
      call gsv_deallocate(statevector)
! DO NOT DO THIS HERE, SINCE COULD BE IN ANALYSIS LOOP
!      call bmat_finalize(cvm_vazx)
!      call cvm_deallocate

      call tmg_stop(92)

      write(*,*) 'LEAVING POSTMIN'

      CONTAINS

      SUBROUTINE varout
!
!**s/r varout  - Transfert of the content of COMGD0 on a RPN
!     .          standard file
!
!Author  : S. Pellerin *ARMA/AES  April 2000
!
      IMPLICIT NONE
      real*8 :: field3d(statevector%ni,statevector%nlev,statevector%nj)
      real*8, pointer :: field_ptr(:,:,:,:)
      integer write_encode_hyb,vfstecr
      integer jvar,jlev,ierr,numlev
      integer datestamp,inpak_inc
      real*8 zwork
      real*8, allocatable :: zbuffer(:)
      real   zptop4, zpref4,zrcoef4,zdummy
      integer nip1,nip2,nip3,ndeet,npas,nidatyp,nig1,nig2,nig3,nig4
      character(len=1)  :: cgrtyp
      character(len=2)  :: cltypinc
      character(len=12) :: cletiket
      real*8 :: zlowvar(statevector%ni,statevector%nj)
      logical llimplemented,llvarout,FlipLatitude

      WRITE(*,FMT='(/,4X,"Starting VAROUT",//)')

      write(*,*)'varout: rebm file name = ',trim(incFileName)
      ierr    = fnom(nulfile,trim(incFileName),'RND',0)
      if(ierr.ge.0)then
        write(*,*)'varout: rebm file opened with unit number ',nulfile
        ierr  =  fstouv(nulfile,'RND')
      else
        call abort3d('varout: problem opening rebm file, aborting!')
      end if

      if(nulfile.eq.0) then
        write(*,*) 'varout: unit number for rebm file not valid!'
        return
      endif

      WRITE(*,FMT='(/,4X,''Transfer of the gridpoint model state on file at iteration No.'',I3)') min_niter

      !
      !-----Setup packing for each variable
      !
      inpak_inc  = -32                  ! 32 bits are needed by AAI
      write(*,*)'************************************** '
      write(*,*) 'PACKING for increments   is ',inpak_inc
      write(*,*)'************************************** '

      !     
      !- Write TIC-TAC if needed
      !
      if ( statevector % hco % grtyp == 'Z' ) then
        ndeet      =  0
        NIP1       =  statevector % hco % ig1
        NIP2       =  statevector % hco % ig2
        NIP3       =  0
        NPAS       =  0
        NIDATYP    =  1
        CGRTYP     = 'E'
        CLTYPINC   = 'X'
        cletiket   =  cetikinc
        datestamp  =  gsv_getDateStamp(statevector) 

        call cxgaig ( CGRTYP,   &                                     ! IN
                      NIG1, NIG2, NIG3, NIG4, &                       ! OUT
                      real(statevector % hco % xlat1), real(statevector % hco % xlon1), & ! IN
                      real(statevector % hco % xlat2), real(statevector % hco % xlon2) ) ! IN

        allocate(zbuffer(statevector % hco % ni))
        zbuffer(:)= statevector % hco % lon(:) * MPC_DEGREES_PER_RADIAN_R8
        IERR = VFSTECR(zbuffer,zwork,inpak_inc, &
               nulfile,datestamp,ndeet,npas,statevector%ni,1,1,nip1,  &
               nip2,nip3,cltypinc,'>>',cletiket,cgrtyp,nig1,          &
               nig2,nig3,nig4,nidatyp,.true.)
        deallocate(zbuffer)

        allocate(zbuffer(statevector % hco % nj))
        zbuffer(:)= statevector % hco % lat(:) * MPC_DEGREES_PER_RADIAN_R8
        IERR = VFSTECR(zbuffer,zwork,inpak_inc, &
               nulfile,datestamp,ndeet,npas,1,statevector%nj,1,nip1,  &
               nip2,nip3,cltypinc,'^^',cletiket,cgrtyp,nig1,          &
               nig2,nig3,nig4,nidatyp,.true.)
        deallocate(zbuffer)

      end if

      !
      !- Write analysis increments
      !
      ndeet=0
      NIP2       =  0
      NIP3       =  min_niter
      NPAS       =  0
      NIDATYP    =  1
      CGRTYP     = statevector % hco % grtyp
      CLTYPINC   = 'R'
      NIG1       =  statevector % hco % ig1
      if ( statevector % hco % grtyp == 'G' .and.  &
           statevector % hco % ig2   ==  1   ) then
        FlipLatitude  = .true. 
        NIG2          = 0
      else
        FlipLatitude  = .false.
        NIG2          =  statevector % hco % ig2
      end if
      NIG3       =  statevector % hco % ig3
      NIG4       =  statevector % hco % ig4
      cletiket=cetikinc
      datestamp=gsv_getDateStamp(statevector,jstep)

      write(*,*) 'Writing fields for datestamp= ',datestamp
!
! ****************************************************************
!
      write(*,*) 'Writing variable HY on analysis-increment file'

      zptop4 = statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8
      zpref4 = statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8
      zrcoef4 = statevector%vco%drcf1
      ierr    = write_encode_hyb(nulfile,'HY',nip2,nip3,cletiket,  &
                                 datestamp,zptop4,zpref4,zrcoef4)
!
!-----Analysis grid hybride vertical coordinate parameters
!

      write(*,*)' '
      write(*,*)'************************************** '
      write(*,*) ' The hybride coordinate parameters from increment', &
                 ' analysis  grid are:'
      write(*,*) ' PTOP = ',statevector%vco%dpt_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' PREF = ',statevector%vco%dprf_M*MPC_MBAR_PER_PA_R8,' MB'
      write(*,*) ' RCOEF= ',statevector%vco%drcf1
      write(*,*)'************************************** '
      write(*,*)' '

      do jvar = 1, nppcvar
!
! Some variable may be request for other to be computed but not
! necessaraly wanted as output..
!
        llimplemented = .true.

        write(*,*) 'Writing variable ',cppcvar(jvar)

        numlev = gsv_getNumLev(statevector,vnl_vartypeFromVarname(cppcvar(jvar)))
        write(*,*) 'numlev=',numlev

        if(cppcvar(jvar).ne.'ES'.and. &
           cppcvar(jvar).ne.'VT'.and. &
           cppcvar(jvar).ne.'GZ'.and. &
           cppcvar(jvar).ne.'HU') then

          if(cppcvar(jvar).eq.'LQ') then
            field_ptr => gsv_getField(statevector,'HU')
          else
            field_ptr => gsv_getField(statevector,cppcvar(jvar))
          endif
          field3d(:,1:numlev,:)=field_ptr(:,:,:,1)
        endif

        do jlev=1,numlev
          call gdout2(cppcvar(jvar),ZLOWVAR,jlev,  &
               llimplemented,nip1,FlipLatitude,statevector,field3d,zes(:,:,:),ztv(:,:,:),zgz(:,:,:),zhu(:,:,:))
          if(.not.llimplemented) exit

          IERR  = VFSTECR(ZLOWVAR,zwork,inpak_inc  &
             ,nulfile,datestamp,ndeet,npas,statevector%ni,statevector%nj,1,nip1  &
             ,nip2,nip3,cltypinc,cppcvar(jvar),cletiket,cgrtyp,nig1  &
             ,nig2,nig3,nig4,nidatyp,.true.)

          if(nip1.eq.0) exit

        enddo

      enddo

      ierr =  fstfrm(nulfile)
      ierr =  fclos(nulfile)        

      write(*,*) 'END of VAROUT'

      RETURN
      END SUBROUTINE VAROUT


      SUBROUTINE SUPOST
!
!**s/r SUPOST  - initialize the post-processing of the model state
!
      IMPLICIT NONE
      INTEGER IERR,jvar,ihu,itt,ivt,imin,igz,ip0,ilq
      integer :: nulnam,fnom,fclos
      NAMELIST /NAMPOST/NPPCVAR,CPPCVAR,CETIKINC,WRITE4DINC,useTL_LQtoHU

      write(*,*) '========================================='
      write(*,*) 'supost:  initialization of postprocessing'
      write(*,*) '========================================='
!
!*    1. Set default values
!
      CETIKINC = 'UNDEFINED***'
      NPPCVAR=6
      CPPCVAR(:) = '    '
      CPPCVAR(1) = 'UU'
      CPPCVAR(2) = 'VV'
      CPPCVAR(3) = 'TT'
      CPPCVAR(4) = 'LQ'
      CPPCVAR(5) = 'P0'
      CPPCVAR(6) = 'TG'
      WRITE4DINC = .false.
      useTL_LQtoHU = .false.
!
!*    2. Read the parameters from NAMPOST
!
      nulnam=0
      ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
      read(nulnam,nml=nampost,iostat=ierr)
      if(ierr.ne.0) call abort3d('varout: Error reading namelist')
      if(mpi_myid.eq.0) write(*,nml=nampost)
      ierr=fclos(nulnam)
!
! reordering cppcvar for dependent variables in varout.ftn
!
      ip0 = 0
      ihu = 0
      itt = 0
      ivt = 0
      lgzout = .false.

      do jvar = 1,nppcvar
        if(cppcvar(jvar).eq.'P0') then
          ip0 = jvar
        endif
        if(cppcvar(jvar).eq.'TT') then
          itt = jvar
        endif
        if(cppcvar(jvar).eq.'GZ') then
          igz = jvar
          lgzout = .true.
        endif
        if(cppcvar(jvar).eq.'HU') then
          ihu = jvar
        endif
        if(cppcvar(jvar).eq.'VT') then
          ivt = jvar
          lvtout = .true.
        endif
        if(cppcvar(jvar).eq.'LQ') then
          ilq = jvar
        endif
      enddo

      if((lgzout.or.lvtout).and.ihu.eq.0) then
! Make sure that HU is part of the list
        ihu = nppcvar+1
        cppcvar(ihu) = 'HU'
        nppcvar = ihu
      endif

      if(ihu.ne.0) then
! Make sure that TT is part of the list
        imin = min(itt,ihu)
        if (imin.eq.0) then
! TT is not requested: put it in the list before HU
          cppcvar(ihu) = 'TT'
          cppcvar(nppcvar+1) = 'HU'
          nppcvar = nppcvar + 1
        else
! TT is requested: make sure that TT is before HU in the list
          cppcvar(max(itt,ihu)) = 'HU'
          cppcvar(imin) = 'TT'
        endif
      endif

      if(ip0 .gt. 1) then
        do jvar = ip0, 2,-1
          cppcvar(jvar) = cppcvar(jvar -1)
        enddo
        cppcvar(1) = 'P0'
      endif
!
!*     4. Print the values
!
      DO jvar = 1, NPPCVAR
        if(mpi_myid.eq.0) WRITE(*,FMT='(4X,"VAR NO.",I3,":",2X,"CPPCVAR= ",A5)') jvar,CPPCVAR(jvar)
      ENDDO
      RETURN
      END SUBROUTINE SUPOST

      END SUBROUTINE POSTMIN
