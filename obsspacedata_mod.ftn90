! ObsSpaceData_mod:  the module, ObsSpaceData_mod, follows IndexListDepot_mod
#include "maincompileswitch.inc"
#include "compileswitches.inc"


module IndexListDepot_mod
   ! This is not a fully fledged module.  It is more like a structure definition
   ! with a couple of helpful methods.  It is intended that clients read/write
   ! directly from/to instances of these structures.  The intended client is
   ! obsSpaceData_mod.

   implicit none
   save
   public

   ! methods
   public :: ild_initialize, ild_get_empty_index_list, ild_get_next_index

   interface ild_get_next_index
      module procedure ild_get_next_index_depot
      module procedure ild_get_next_index_private
   end interface ild_get_next_index

                                        ! This dimension must accommodate the
                                        ! maximum number of OMP processors 
   integer, parameter :: NUMBER_OF_LISTS = 32

   type struct_index_list
      ! a list of integers, not to say indices into a struct_obs
      character(len=2) :: family        ! current_element's belong to this family
      ! Used only for a body list:
      integer :: header                 ! current_element's belong to this header
      integer :: current_element        ! the element that has just been returned

                                        ! the actual list of integers
                                        ! N.B.:  that which is an index to a
                                        !        client of this module is an
                                        !        element to this module
      integer, dimension(:), allocatable :: indices
   end type struct_index_list

   type struct_index_list_depot
      ! A collection of lists, either empty or populated
                                        ! the collection of lists
      type(struct_index_list), dimension(NUMBER_OF_LISTS) :: index_lists
      integer :: list_last_attributed   ! list that was populated most recently
                                        ! list that was   used    most recently
      type(struct_index_list), pointer :: current_list
   end type struct_index_list_depot


contains
   subroutine ild_initialize(depot, numHeaderBody_max)
      ! Initialize the indicated list depot
      implicit none
      type(struct_index_list_depot), intent(inout) :: depot
                                        ! max size of header or body of
                                        ! struct_obs & hence of depot
      integer, intent(in) :: numHeaderBody_max

      integer :: list                   ! an index

      ! Allocate each list
      do list = 1,NUMBER_OF_LISTS
         allocate(depot%index_lists(list)%indices(numHeaderBody_max))
         depot%index_lists(list)%header = 0
         depot%index_lists(list)%family = 'xx'
         depot%list_last_attributed = 0
      end do
   end subroutine ild_initialize


   function ild_get_empty_index_list(depot, private_list) &
                                                         result(empty_index_list)
      ! From the given depot, return an index-list structure that contains no
      ! data, as a pointer.
      !
      ! In other words, clear data from the (cyclicly) next (i.e. oldest) list
      ! and return a pointer to it.
      implicit none
      type(struct_index_list), pointer :: empty_index_list
      type(struct_index_list_depot), intent(inout), target :: depot
      type(struct_index_list), pointer, intent(inout), optional :: private_list

      nullify(empty_index_list)

      if(present(private_list)) then
         ! This is an OMP thread
         if(associated(private_list)) then
            ! Memory has already been assigned for that thread.  Re-use it.
            empty_index_list => private_list ! Set the return pointer
         end if
      end if

      if(.not. associated(empty_index_list)) then
!$omp critical
         ! Increment (cyclicly) the index to the next list
         depot%list_last_attributed = depot%list_last_attributed + 1
         if (depot%list_last_attributed > NUMBER_OF_LISTS) &
            depot%list_last_attributed = 1

         ! Set the return pointer
         empty_index_list => depot%index_lists(depot%list_last_attributed)
!         write(*,*) 'assigning memory from slot ',depot%list_last_attributed
!$omp end critical
      end if

      ! Initialize some values in the list
      ! empty_index_list%indices(:) = -1 --> No, the array is too big.
      empty_index_list%family = '  '
      empty_index_list%header = -1
      empty_index_list%current_element = 0

      return
   end function ild_get_empty_index_list


   function ild_get_next_index_depot(depot, no_advance) result(next_index)
      ! From the given depot, increment the index to the current element, and
      ! return the element itself, the new current element.
      implicit none
      integer :: next_index
      type(struct_index_list_depot), intent(inout), target :: depot
                                        ! Do not increment current_element,
                                        ! just return the next one
      logical, intent(in), optional :: no_advance

                                        ! current list of the depot
      type(struct_index_list), pointer :: current_list
      integer :: next_element           ! next element of the current list

      current_list => depot%current_list
!$omp critical
                                        ! Obtain the next element from the list
      next_element = current_list%current_element + 1
      next_index = current_list%indices(next_element)
! write(*,*) 'ild_get_next_index_depot: next_element,next_index=',next_element,next_index
      if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
         current_list%current_element = next_element
      end if
!$omp end critical
   end function ild_get_next_index_depot


   function ild_get_next_index_private(private_list, no_advance) &
                                                               result(next_index)
      ! From the given list, increment the index to the current element, and
      ! return the element itself, the new current element.
      implicit none
      integer :: next_index
      type(struct_index_list), pointer, intent(inout) :: private_list
                                        ! Do not increment current_element,
                                        ! just return the next one
      logical, intent(in), optional :: no_advance

      integer :: next_element           ! next element of the list

                                        ! Obtain the next element from the list
      next_element = private_list%current_element + 1
      next_index = private_list%indices(next_element)

      if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
         private_list%current_element = next_element
      end if
   end function ild_get_next_index_private

end module IndexListDepot_mod



module ObsDataColumn_mod
   ! This module is used exclusively by the obsSpaceData module which follows
   ! in this file. The derived type is used to represent a "column" of
   ! observation data in an instance of the struct_obs defined in obsSpaceData.
   ! It contains a pointer for each possible type of data stored in a column,
   ! but only one should be allocated at any time.

   implicit none
   save
   private

   ! methods
   public :: odc_allocate, odc_deallocate

   ! derived type for column data
   type, public :: struct_obsDataColumn
      logical          :: allocated = .false.
      character(len=4) :: name
      character(len=4) :: dataType   ! REAL or INT
      character(len=4) :: headOrBody ! HEAD or BODY
      logical          :: twoD = .false.
      real(kind=OBS_REAL),pointer :: value_r(:) => NULL()
      integer,pointer             :: value_i(:) => NULL()
      real(kind=OBS_REAL),pointer :: value2d_r(:,:) => NULL()
      integer,pointer             :: value2d_i(:,:) => NULL()
   end type struct_obsDataColumn

contains


   subroutine odc_abort(cdmessage)
      ! s/r ODC_ABORT  - Abort a job on error (same as OBS_ABORT)
      !
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !
      !Arguments
      !     i     CDMESSAGE: message to be printed

      implicit none
      character(len=*) cdmessage

      write(*,'(//,4X,"ABORTING IN ObsDataColumn_mod:-------",/,8X,A)')cdmessage
      call flush(6)

      call qqexit(1)

      stop
   end subroutine odc_abort


   subroutine odc_allocate(odc,numRows,name,dataType,headOrBody,numRowsTwoD)
      ! s/r ODC_ALLOCATE  - Allocate a single column of obs data according to 
      !                     specifications in input arguments
      !
      !Author  : M. Buehner September 27, 2012
      !
      !Arguments
      !     i/o     ODC: instance of the obsDataColumn type
      !     i       numRows: number of column rows to allocate
      !     i       name: character string name of column
      !     i       dataType: character string type of column data: REAL or INT
      !     i       headOrBody: character string indicating HEAD or BODY
      !     i (optional) numRowsTwoD: number of 2nd dimension rows for 2D column
      !                               data. This should not be used for standard
      !                               1D column data.

      implicit none
      type(struct_obsDataColumn) :: odc
      integer :: numRows
      character(len=*) :: name,dataType,headOrBody
      integer, optional :: numRowsTwoD

      if(odc%allocated) then
         call odc_abort('ODC_ALLOCATE: column is already allocated. name=' &
                        // name)
      endif

      odc%allocated=.true.
      odc%name=name
      odc%dataType=dataType
      odc%headOrBody=headOrBody
      if(present(numRowsTwoD)) then
         odc%twoD=.true.
      else
         odc%twoD=.false.
      endif

      if(.not.odc%twoD) then
         if(trim(dataType).eq.'INT') then
            allocate(odc%value_i(numRows))
            odc%value_i(:)=0
         elseif(trim(dataType).eq.'REAL') then
            allocate(odc%value_r(numRows))
            odc%value_r(:)=real(0.0D0, OBS_REAL)
         else
            call odc_abort('ODC_ALLOCATE: unknown data type. type=' // dataType)
         endif
      else
         call odc_abort('ODC_ALLOCATE: twoD columns not yet implemented!')
         if(trim(dataType).eq.'INT') then
            allocate(odc%value2d_i(numRows,numRowsTwoD))
            odc%value2d_i(:,:)=0
         elseif(trim(dataType).eq.'REAL') then
            allocate(odc%value2d_r(numRows,numRowsTwoD))
            odc%value2d_r(:,:)=real(0.0D0, OBS_REAL)
         else
            call odc_abort('ODC_ALLOCATE: unknown data type. type=' // dataType)
         endif
      endif
      write(*,*) 'ODC_ALLOCATE: name=',odc%name,', dataType=',odc%dataType, &
                 ', headOrBody=',odc%headOrBody,', twoD=',odc%twoD, &
                 ', &numRows=',numRows

   end subroutine odc_allocate


   subroutine odc_deallocate(odc)
      ! s/r ODC_DEALLOCATE  - Deallocate a single column of obs data
      !
      !Author  : M. Buehner September 27, 2012
      !
      !Arguments
      !     i/o     ODC: instance of the obsDataColumn type

      implicit none
      type(struct_obsDataColumn) :: odc

      if(.not.odc%allocated) then
         call odc_abort('ODC_DEALLOCATE: column is not already allocated.')
      endif

      odc%allocated=.false.
      if(associated(odc%value_i)) then
         deallocate(odc%value_i)
         nullify(odc%value_i)
      elseif(associated(odc%value_r)) then
         deallocate(odc%value_r)
         nullify(odc%value_r)
      elseif(associated(odc%value2d_i)) then
         deallocate(odc%value2d_i)
         nullify(odc%value2d_i)
      elseif(associated(odc%value2d_r)) then
         deallocate(odc%value2d_r)
         nullify(odc%value2d_r)
      endif
      write(*,*) 'ODC_DEALLOCATE: name=',odc%name,', dataType=',odc%dataType, &
                 ', headOrBody=',odc%headOrBody,', twoD=',odc%twoD

   end subroutine odc_deallocate

end module ObsDataColumn_mod



module obsSpaceData_mod
   use IndexListDepot_mod
   use ObsDataColumn_mod
   implicit none
   save
   private

   ! This module deals with operations involving the data structure for
   ! storing observational information.
   !   (this had evolved from the CMA structure, originated in work by
   !    D. Vasiljevic at ECMWF)
   !
   ! First creation of the module: February 2011 by Peter Houtekamer
   !

   ! PUBLIC METHODS:
   public obs_allocate   ! array allocation
   public obs_append     ! append an obsdat object to another obsdat object
   public obs_bdy        ! fill in the ObsSpaceData body from burp(3dvar version)
   public obs_bodyElem_i ! obtain an integer body element from observation object
   public obs_bodyElem_r ! obtain a real body element from the observation object
   public obs_bodyIndex_mpiglobal ! obtain mpiglobal body row index
   public obs_bodySet_i  ! set an integer body value in the observation object
   public obs_bodySet_r  ! set a real body value in the observation object
   public obs_clean      ! remove from obs data those that not to be assimilated
   public obs_columnIndexFromName_IH ! get the name from the index
   public obs_columnIndexFromName_RH ! get the name from the index
   public obs_columnIndexFromName_IB ! get the name from the index
   public obs_columnIndexFromName_RB ! get the name from the index
   public obs_comm       ! communicate header and body info between mpi processes
   public obs_copy       ! copy an obsdat object
   public obs_count_headers ! count the stations and observations in the object
   public obs_deallocate ! array de-allocation
   public obs_elem_c     ! obtain character element from the observation object
   public obs_enkf_bdy   ! fill in the ObsSpaceData body from burp(EnKF version)
   public obs_enkf_prntbdy! print all data records associated with an observation
   public obs_enkf_prnthdr! print the header of an observation record
   public obs_expandToMpiGlobal ! restore data for the mpi-global context
   public obs_finalize   ! object clean-up
   public obs_generate_header ! fill in observation-data header, from burp files
   public obs_get_datestamp ! get the object's date stamp
                         ! find the index into the variable types list of the
                         ! obsdat element that contains given BUFR element number
   public obs_get_obs_index_for_bufr_element
   public obs_getBodyIndex ! obtain an element from the current body list
   public obs_getFamily  ! return the family of a datum
   public obs_getHeaderIndex ! obtain an element from the current header list
   public obs_headElem_i ! obtain an integer header element from the obs'n object
   public obs_headElem_r ! obtain real header element from the observation object
   public obs_headerIndex_mpiglobal ! obtain mpiglobal header row index
   public obs_headSet_i  ! set an integer header value in the observation object
   public obs_headSet_r  ! set a real header value in the observation object
   public obs_initialize ! variable initialization
   public obs_mpiLocal   ! obtain the current mpi state of the observation object
   public obs_numBody    ! returns the number of observations recorded
   public obs_numBody_max! returns the dimensioned number of observations
   public obs_numHeader  ! returns the number of stations recorded
   public obs_numHeader_max ! returns the dimensioned number of stations
   public obs_order      ! put obs data in the order required for assimilation
   public obs_print      ! obs_enkf_prnthdr & obs_enkf_prntbdy for each station
   public obs_prnt_csv   ! call obs_tosqlhdr and obs_tosqlbdy for each station
   public obs_prntbdy    ! print the body data for one header
   public obs_prnthdr    ! print the data contained in one header
   public obs_read       ! read the observation data from binary files
   public obs_readstns   ! read stations for 1 analysis pass, store in obs object
   public obs_reduceToMpiLocal ! retain only data pertinent to the mpi-local PE
   public obs_select     ! select observations in a vertical range
   public obs_set_c      ! set a character value in the observation object
   public obs_set_current_body_list   ! set a body list for a family as current
   public obs_set_current_header_list ! set a header list for a family as current
   public obs_set_datestamp! set the object's date stamp
   public obs_setFamily  ! set the family of a datum
   public obs_status     ! returns the values of the object's status variables
   public obs_swapVarOmf ! exchange the values of OBS_VAR and OBS_OMF
   public obs_write      ! write the observation data to binary files
                         ! (calls obs_write_hdr, obs_write_bdy, obs_write_hx
                         !  for each station)

   ! PRIVATE METHODS:
   private obs_abort     ! abort a job on error
   private obs_exchange_stations    ! exchange the headers of stations j and k
   private obs_mpiDistributeIndices ! distribute header & body indices for mpi parallelization
   private obs_tosqlbdy  ! write the observation data in comma-separated format
   private obs_tosqlhdr  ! write the observation header in comma-separated format
   private obs_write_bdy ! write the observation data to binary files
   private obs_write_hdr ! write the observation header to binary files
   private obs_write_hx  ! write to binary files a station's interpolated values


   interface obs_getBodyIndex
      module procedure obs_getBodyIndex_depot
      module procedure obs_getBodyIndex_private
   end interface obs_getBodyIndex

   interface obs_set_current_body_list
      module procedure obs_set_current_body_list_from_family
      module procedure obs_set_current_body_list_from_header
   end interface obs_set_current_body_list


   ! observation-space fundamental parameters
   public           :: OBS_JPNBRELEM

   ! derived type and module variable declarations
   type, public :: struct_obs
      private
      type(struct_index_list_depot) :: header_index_list_depot
      type(struct_index_list_depot) :: body_index_list_depot
                                        ! For these arrays:
                                        !   1st dim'n:  row index
      character(len=12),  pointer, dimension(:)   :: cstnid
      character(len=2),   pointer, dimension(:)   :: cfamily
      type(struct_obsDataColumn),pointer, dimension(:) :: &
                             robhdr,  & ! real header columns
                             mobhdr,  & ! integer header columns
                             robdata, & ! real body columns
                             mobdata    ! integer body columns
      integer :: numHeader              ! Actual number of stations on record
      integer :: numHeader_max          ! maximum number of stations
      integer :: numBody                ! Actual total number of data on record
      integer :: numBody_max            ! maximum number observations (i.e. data)

                                        ! row indices of mpiglobal data, useful
                                        ! for transforming from mpiLocal back to
                                        ! mpiGlobal
                                        !    1st dim'n: row index, only in
                                        !               mpiLocal context
      integer, pointer, dimension(:) :: headerIndex_mpiglobal,bodyIndex_mpiglobal

      logical :: mpi_local       ! T: keep only data needed by this PE (mpilocal)
      integer :: datestamp
   end type struct_obs

   !
   ! INTEGER-HEADER COLUMN NUMBERS
   !  
   ! the first column index for integer header variables defined below
   integer, parameter :: NHDR_INT_BEG = 1 
   integer, parameter, public :: OBS_RLN = NHDR_INT_BEG ! report location
                                             ! unique(within obsdat), possibly
   integer, parameter, public :: OBS_ONM = OBS_RLN+1 ! ordered, station id number
   integer, parameter, public :: OBS_INS = OBS_ONM+1 ! instrument ID  
   integer, parameter, public :: OBS_OTP = OBS_INS+1 ! observation Type (file index)
   integer, parameter, public :: OBS_ITY = OBS_OTP+1 ! code: instrument & retrieval type
   integer, parameter, public :: OBS_SAT = OBS_ITY+1 ! satellite code 
   integer, parameter, public :: OBS_TEC = OBS_SAT+1 ! satellite processing technique
   integer, parameter, public :: OBS_DAT = OBS_TEC+1 ! date YYYYMMD
   integer, parameter, public :: OBS_ETM = OBS_DAT+1 ! time HHMM
   integer, parameter, public :: OBS_NLV = OBS_ETM+1 ! number of data at this location
   integer, parameter, public :: OBS_OFL = OBS_NLV+1 ! report status events
   integer, parameter, public :: OBS_PAS = OBS_OFL+1 ! batch no. in sequential analysis
   integer, parameter, public :: OBS_REG = OBS_PAS+1 ! region number in the batch
   integer, parameter, public :: OBS_IP  = OBS_REG+1 ! number of mpi processors
   integer, parameter, public :: OBS_AZA = OBS_IP +1 ! satellite azimuthal angle
   integer, parameter, public :: OBS_SZA = OBS_AZA+1 ! satellite zenith angle
   integer, parameter, public :: OBS_SUN = OBS_SZA+1 ! sun zenith angle
   integer, parameter, public :: OBS_CLF = OBS_SUN+1 ! cloud fraction
   integer, parameter, public :: OBS_ST1 = OBS_CLF+1 ! header level status/rejection flag
   integer, parameter, public :: OBS_IDO = OBS_ST1+1 ! (absolutely) unique station id no.
   integer, parameter, public :: OBS_IDF = OBS_IDO+1 ! id. no. of observation-source file
   ! the last column index for integer header variables defined just above
   integer, parameter :: NHDR_INT_END = OBS_IDF
   !
   ! INTEGER-HEADER COLUMN NAMES
   !  
   character(len=4), parameter :: obs_ColumnNameList_IH(NHDR_INT_BEG:NHDR_INT_END) = &
      (/ 'RLN ','ONM ','INS ','OTP ','ITY ','SAT ','TEC ','DAT ','ETM ', &  
         'NLV ','OFL ','PAS ','REG ','IP  ','AZA ','SZA ','SUN ','CLF ', &  
         'ST1 ','IDO ','IDF ' /)  

   !
   ! REAL-HEADER COLUMN NUMBERS
   !
   ! the first column index for real header variables defined below
   integer, parameter :: NHDR_REAL_BEG = 101
   integer, parameter, public :: OBS_LAT = NHDR_REAL_BEG ! latitude  in radians (N positive)
   integer, parameter, public :: OBS_LON = OBS_LAT+1 ! longitude in radians (E positive)
   integer, parameter, public :: OBS_ALT = OBS_LON+1 ! station altitude
   integer, parameter, public :: OBS_BX  = OBS_ALT+1 ! x-coordinate of block in R3
   integer, parameter, public :: OBS_BY  = OBS_BX +1 ! y-coordinate of block in R3
   integer, parameter, public :: OBS_BZ  = OBS_BY +1 ! z-coordinate of block in R3
   ! the last column index for real header variables defined just above
   integer, parameter :: NHDR_REAL_END = OBS_BZ
   !
   ! REAL-HEADER COLUMN NAMES
   !
   character(len=4), parameter :: obs_ColumnNameList_RH(NHDR_REAL_BEG:NHDR_REAL_END) =  &
      (/'LAT ','LON ','ALT ','BX  ','BY  ','BZ  '/)  

   !
   ! INTEGER-BODY COLUMN NUMBERS
   !
   ! the first column index for integer body variables defined below
   integer, parameter :: NBDY_INT_BEG = 201
   integer, parameter, public :: OBS_VNM = NBDY_INT_BEG ! variable number
   integer, parameter, public :: OBS_FLG = OBS_VNM+1  ! flags
   integer, parameter, public :: OBS_KFA = OBS_FLG+1  ! marker for forward interp problems
   integer, parameter, public :: OBS_ASS = OBS_KFA+1  ! flag to indicate if assimilated
   integer, parameter, public :: OBS_HIND= OBS_ASS+1  ! corresponding header row index
   integer, parameter, public :: OBS_VCO = OBS_HIND+1 ! type of vertical coordinate
   integer, parameter, public :: OBS_LYR = OBS_VCO+1  ! Index of anal level above observ'n
                                             ! Flag: extrapolation necessary of
   integer, parameter, public :: OBS_XTR = OBS_LYR+1  ! anal variables to obs'n location
   integer, parameter, public :: OBS_IDD = OBS_XTR+1  ! data id. no.
   ! the last column index for integer body variables defined just above
   integer, parameter :: NBDY_INT_END = OBS_IDD
   !
   ! INTEGER-BODY COLUMN NAMES
   !
   character(len=4), parameter :: obs_ColumnNameList_IB(NBDY_INT_BEG:NBDY_INT_END) = &
      (/ 'VNM ','FLG ','KFA ','ASS ','HIND','VCO ','LYR ','XTR ','IDD ' /)  

   !
   ! REAL-BODY COLUMN NUMBERS
   !
   ! the first column index for real body variables defined below
   integer, parameter :: NBDY_REAL_BEG = 301
   integer, parameter, public :: OBS_PPP = NBDY_REAL_BEG ! Pressure (vertical coordinate)
   integer, parameter, public :: OBS_SEM = OBS_PPP +1 ! surface emissivity
   integer, parameter, public :: OBS_VAR = OBS_SEM +1 ! value of the observation
   integer, parameter, public :: OBS_OMP = OBS_VAR +1 ! obs - H (trial field)
   integer, parameter, public :: OBS_OMA = OBS_OMP +1 ! obs - H (analysis)
   integer, parameter, public :: OBS_OER = OBS_OMA +1 ! sigma(obs)
   integer, parameter, public :: OBS_HPHT= OBS_OER +1 ! root of (hpht with hx scalar)
   integer, parameter, public :: OBS_ZHA = OBS_HPHT+1 ! vert coordinate for Schur product
   integer, parameter, public :: OBS_OMP6= OBS_ZHA +1 ! obs - H (6-h trial field)
                                              ! Initial value of "gamma" for
   integer, parameter, public :: OBS_POB = OBS_OMP6+1 ! variational QC 
   integer, parameter, public :: OBS_OMF = OBS_POB +1 ! observation minus forecast value
                                              ! Work space for use during
   integer, parameter, public :: OBS_OMI = OBS_OMF +1 ! variational minimization  
                                              ! Value from variational QC used
   integer, parameter, public :: OBS_OMN = OBS_OMI +1 ! to flag when rejected
                                              ! (Adjusted) observed value for
   integer, parameter, public :: OBS_PRM = OBS_OMN +1 ! tovs in variational assimilation
   ! the number of real body variables defined just above
   integer, parameter :: NBDY_REAL_END = OBS_PRM
   !
   ! REAL-BODY COLUMN NAMES
   !
   character(len=4), parameter :: obs_ColumnNameList_RB(NBDY_REAL_BEG:NBDY_REAL_END) = &
      (/ 'PPP ','SEM ','VAR ','OMP ','OMA ','OER ','HPHT','ZHA ','OMP6', &  
         'POB ','OMF ','OMI ','OMN ','PRM ' /)  

   ! These arrays store the status of the columns, an active column is 
   ! allocated (and can therefore be used) in any object that is instantiated
   logical :: obs_columnActive_IH(NHDR_INT_BEG :NHDR_INT_END ) = .false.
   logical :: obs_columnActive_RH(NHDR_REAL_BEG:NHDR_REAL_END) = .false.
   logical :: obs_columnActive_IB(NBDY_INT_BEG :NBDY_INT_END )  = .false.
   logical :: obs_columnActive_RB(NBDY_REAL_BEG:NBDY_REAL_END) = .false.

   integer, parameter :: OBS_JPNBRELEM = 57   ! obs variable-types table length


contains

   !---------------------------------------------------------!
   ! Private methods related to dynamic use of obsDataColumn !
   !---------------------------------------------------------!

   ! Four methods for activating a column:

   subroutine obs_activateColumn_IH(column_index)
      implicit none
      integer :: column_index,active_index

      if(.not.obs_columnActive_IH(column_index)) then
         obs_columnActive_IH(column_index) = .true.
      else
         write(*,*) 'column_index=',column_index
         call obs_abort('OBS_activateColumn_IH: column is already active!')
      endif

      ! force the recalculation of indices to go between activeColumnIndex and
      ! columnIndex
      active_index=obs_activeIndexFromColumnIndex_IH(column_index, &
                                                     recompute=.true.)
      column_index=obs_columnIndexFromActiveIndex_IH(active_index, &
                                                     recompute=.true.)

   end subroutine obs_activateColumn_IH


   subroutine obs_activateColumn_RH(column_index)
      implicit none
      integer :: column_index,active_index

      if(.not.obs_columnActive_RH(column_index)) then
         obs_columnActive_RH(column_index) = .true.
      else
         write(*,*) 'column_index=',column_index
         call obs_abort('OBS_activateColumn_RH: column is already active!')
      endif

      ! force the recalculation of indices to go between activeColumnIndex and
      ! columnIndex
      active_index=obs_activeIndexFromColumnIndex_RH(column_index, &
                                                     recompute=.true.)
      column_index=obs_columnIndexFromActiveIndex_RH(active_index, &
                                                     recompute=.true.)

   end subroutine obs_activateColumn_RH


   subroutine obs_activateColumn_IB(column_index)
      implicit none
      integer :: column_index,active_index

      if(.not.obs_columnActive_IB(column_index)) then
         obs_columnActive_IB(column_index) = .true.
      else
         write(*,*) 'column_index=',column_index
         call obs_abort('OBS_activateColumn_IB: column is already active!')
      endif

      ! force the recalculation of indices to go between activeColumnIndex and
      ! columnIndex
      active_index=obs_activeIndexFromColumnIndex_IB(column_index, &
                                                     recompute=.true.)
      column_index=obs_columnIndexFromActiveIndex_IB(active_index, &
                                                     recompute=.true.)

   end subroutine obs_activateColumn_IB


   subroutine obs_activateColumn_RB(column_index)
      implicit none
      integer :: column_index,active_index

      if(.not.obs_columnActive_RB(column_index)) then
         obs_columnActive_RB(column_index) = .true.
      else
         write(*,*) 'column_index=',column_index
         call obs_abort('OBS_activateColumn_RB: column is already active!')
      endif

      ! force the recalculation of indices to go between activeColumnIndex and
      ! columnIndex
      active_index=obs_activeIndexFromColumnIndex_RB(column_index, &
                                                     recompute=.true.)
      column_index=obs_columnIndexFromActiveIndex_RB(active_index, &
                                                     recompute=.true.)

   end subroutine obs_activateColumn_RB


   ! Four methods for obtaining the number of active columns:

   function obs_numActiveColumn_IH() result(numActiveColumn)
      implicit none
      integer :: numActiveColumn,column_index

      numActiveColumn=0
      do column_index=NHDR_INT_BEG,NHDR_INT_END
         if(obs_columnActive_IH(column_index))  &
            numActiveColumn=numActiveColumn+1
      enddo
      
   end function obs_numActiveColumn_IH


   function obs_numActiveColumn_RH() result(numActiveColumn)
      implicit none
      integer :: numActiveColumn,column_index

      numActiveColumn=0
      do column_index=NHDR_REAL_BEG,NHDR_REAL_END
         if(obs_columnActive_RH(column_index))  &
            numActiveColumn=numActiveColumn+1
      enddo
      
   end function obs_numActiveColumn_RH


   function obs_numActiveColumn_IB() result(numActiveColumn)
      implicit none
      integer :: numActiveColumn,column_index

      numActiveColumn=0
      do column_index=NBDY_INT_BEG,NBDY_INT_END
         if(obs_columnActive_IB(column_index))  &
            numActiveColumn=numActiveColumn+1
      enddo
      
   end function obs_numActiveColumn_IB


   function obs_numActiveColumn_RB() result(numActiveColumn)
      implicit none
      integer :: numActiveColumn,column_index

      numActiveColumn=0
      do column_index=NBDY_REAL_BEG,NBDY_REAL_END
         if(obs_columnActive_RB(column_index))  &
            numActiveColumn=numActiveColumn+1
      enddo
      
   end function obs_numActiveColumn_RB


   ! Four methods for obtaining the column index from the active index

   function obs_columnIndexFromActiveIndex_IH(active_index_in,recompute) &
                                                         result(column_index_out)
      implicit none
      integer :: active_index_in,active_index
      integer :: column_index_out,column_index
      logical, optional :: recompute
      logical, save :: firstTime=.true.
      integer, save :: columnIndexFromActiveIndex(NHDR_INT_END-NHDR_INT_BEG+1)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         do column_index=NHDR_INT_BEG,NHDR_INT_END
            if(obs_columnActive_IH(column_index)) then
               active_index=active_index+1
               columnIndexFromActiveIndex(active_index)=column_index
               !write(*,*) 'OBS_COLUMNINDEXFROMACTIVEINDEX_IH: test=', &
               !           column_index,active_index
            endif
         enddo
      endif

      column_index_out=columnIndexFromActiveIndex(active_index_in)

   end function obs_columnIndexFromActiveIndex_IH


   function obs_columnIndexFromActiveIndex_RH(active_index_in,recompute) &
                                                         result(column_index_out)
      implicit none
      integer :: active_index_in,active_index
      integer :: column_index_out,column_index
      logical, optional :: recompute
      logical, save :: firstTime=.true.
      integer, save :: columnIndexFromActiveIndex(NHDR_REAL_END-NHDR_REAL_BEG+1)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         do column_index=NHDR_REAL_BEG,NHDR_REAL_END
            if(obs_columnActive_RH(column_index)) then
               active_index=active_index+1
               columnIndexFromActiveIndex(active_index)=column_index
               !write(*,*) 'OBS_COLUMNINDEXFROMACTIVEINDEX_RH: test=', &
               !           column_index,active_index
            endif
         enddo
      endif

      column_index_out=columnIndexFromActiveIndex(active_index_in)

   end function obs_columnIndexFromActiveIndex_RH


   function obs_columnIndexFromActiveIndex_IB(active_index_in,recompute) &
                                                         result(column_index_out)
      implicit none
      integer :: active_index_in,active_index
      integer :: column_index_out,column_index
      logical, optional :: recompute
      logical, save :: firstTime=.true.
      integer, save :: columnIndexFromActiveIndex(NBDY_INT_END-NBDY_INT_BEG+1)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         do column_index=NBDY_INT_BEG,NBDY_INT_END
            if(obs_columnActive_IB(column_index)) then
               active_index=active_index+1
               columnIndexFromActiveIndex(active_index)=column_index
               !write(*,*) 'OBS_COLUMNINDEXFROMACTIVEINDEX_IB: test=', &
               !           column_index,active_index
            endif
         enddo
      endif

      column_index_out=columnIndexFromActiveIndex(active_index_in)

   end function obs_columnIndexFromActiveIndex_IB


   function obs_columnIndexFromActiveIndex_RB(active_index_in,recompute) &
                                                         result(column_index_out)
      implicit none
      integer :: active_index_in,active_index
      integer :: column_index_out,column_index
      logical, optional :: recompute
      logical, save :: firstTime=.true.
      integer, save :: columnIndexFromActiveIndex(NBDY_REAL_END-NBDY_REAL_BEG+1)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         do column_index=NBDY_REAL_BEG,NBDY_REAL_END
            if(obs_columnActive_RB(column_index)) then
               active_index=active_index+1
               columnIndexFromActiveIndex(active_index)=column_index
               !write(*,*) 'OBS_COLUMNINDEXFROMACTIVEINDEX_RB: test=', &
               !           column_index,active_index
            endif
         enddo
      endif

      column_index_out=columnIndexFromActiveIndex(active_index_in)

   end function obs_columnIndexFromActiveIndex_RB


   ! Four methods for obtaining the active index from the column index

   function obs_activeIndexFromColumnIndex_IH(column_index_in,recompute) &
                                                         result(active_index_out)
      implicit none
      integer :: active_index_out,active_index
      integer :: column_index_in,column_index
      logical, optional :: recompute
      logical :: lfound
      logical, save :: firstTime=.true.
      integer, save :: activeIndexFromColumnIndex(NHDR_INT_BEG:NHDR_INT_END)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         activeIndexFromColumnIndex(:)=-1
         do column_index=NHDR_INT_BEG,NHDR_INT_END
            if(obs_columnActive_IH(column_index)) then
               active_index=active_index+1
               activeIndexFromColumnIndex(column_index)=active_index
               !write(*,*) 'OBS_ACTIVEINDEXFROMCOLUMNINDEX_IH: test=', &
               !           active_index,column_index
            endif
         enddo
      endif

      active_index_out=activeIndexFromColumnIndex(column_index_in)
      if(active_index_out.eq.-1) call obs_abort( &
            'OBS_activeIndexFromColumnIndex_IH: requested column is not active!')

   end function obs_activeIndexFromColumnIndex_IH


   function obs_activeIndexFromColumnIndex_RH(column_index_in,recompute) &
                                                         result(active_index_out)
      implicit none
      integer :: active_index_out,active_index
      integer :: column_index_in,column_index
      logical, optional :: recompute
      logical :: lfound
      logical, save :: firstTime=.true.
      integer, save :: activeIndexFromColumnIndex(NHDR_REAL_BEG:NHDR_REAL_END)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         activeIndexFromColumnIndex(:)=-1
         do column_index=NHDR_REAL_BEG,NHDR_REAL_END
            if(obs_columnActive_RH(column_index)) then
               active_index=active_index+1
               activeIndexFromColumnIndex(column_index)=active_index
               !write(*,*) 'OBS_ACTIVEINDEXFROMCOLUMNINDEX_RH: test=', &
               !           active_index,column_index
            endif
         enddo
      endif

      active_index_out=activeIndexFromColumnIndex(column_index_in)
      if(active_index_out.eq.-1) call obs_abort( &
            'OBS_activeIndexFromColumnIndex_RH: requested column is not active!')

   end function obs_activeIndexFromColumnIndex_RH


   function obs_activeIndexFromColumnIndex_IB(column_index_in,recompute) &
                                                         result(active_index_out)
      implicit none
      integer :: active_index_out,active_index
      integer :: column_index_in,column_index
      logical, optional :: recompute
      logical :: lfound
      logical, save :: firstTime=.true.
      integer, save :: activeIndexFromColumnIndex(NBDY_INT_BEG:NBDY_INT_END)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         activeIndexFromColumnIndex(:)=-1
         do column_index=NBDY_INT_BEG,NBDY_INT_END
            if(obs_columnActive_IB(column_index)) then
               active_index=active_index+1
               activeIndexFromColumnIndex(column_index)=active_index
               !write(*,*) 'OBS_ACTIVEINDEXFROMCOLUMNINDEX_IB: test=', &
               !           active_index,column_index
            endif
         enddo
      endif

      active_index_out=activeIndexFromColumnIndex(column_index_in)
      if(active_index_out.eq.-1) call obs_abort( &
            'OBS_activeIndexFromColumnIndex_IB: requested column is not active!')

   end function obs_activeIndexFromColumnIndex_IB


   function obs_activeIndexFromColumnIndex_RB(column_index_in,recompute) &
                                                         result(active_index_out)
      implicit none
      integer :: active_index_out,active_index
      integer :: column_index_in,column_index
      logical, optional :: recompute
      logical :: lfound
      logical, save :: firstTime=.true.
      integer, save :: activeIndexFromColumnIndex(NBDY_REAL_BEG:NBDY_REAL_END)

      if(present(recompute)) then
         if(recompute) firstTime=.true.
      endif

      if(firstTime) then
         firstTime=.false.
         active_index=0
         activeIndexFromColumnIndex(:)=-1
         do column_index=NBDY_REAL_BEG,NBDY_REAL_END
            if(obs_columnActive_RB(column_index)) then
               active_index=active_index+1
               activeIndexFromColumnIndex(column_index)=active_index
               !write(*,*) 'OBS_ACTIVEINDEXFROMCOLUMNINDEX_RB: test=', &
               !           active_index,column_index
            endif
         enddo
      endif

      active_index_out=activeIndexFromColumnIndex(column_index_in)
      if(active_index_out.eq.-1) call obs_abort( &
            'OBS_activeIndexFromColumnIndex_RB: requested column is not active!')

   end function obs_activeIndexFromColumnIndex_RB

   !----------------------------------------------------------------!
   ! End of private methods related to dynamic use of obsDataColumn !
   !----------------------------------------------------------------!


   subroutine obs_abort(cdmessage)
      ! s/r OBS_ABORT  - Abort a job on error
      !
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES  January 29, 1996 
      !     . P. Koclas   CMC/CMSV   January  1997 
      !         -add call to abort
      !     . S. Pellerin ARMA/SMC   October 2000
      !         - replace call to abort for call to exit(1)
      !     . C. Charette ARMA/SMC   October 2001
      !         - replace SUTERM by SUTERMF to only close files
      !     . J. Blezius  import ABORT3D into obsspacedata_mod as OBS_ABORT
      !         - delete call to SUTERMF
      !    -------------------
      !     Purpose:
      !     To stop a job when an error occurred
      !
      !Arguments
      !     i     CDMESSAGE: message to be printed

      implicit none
      character(len=*) cdmessage
      integer :: initialized

      write(*,'(//,4X,"ABORTING IN ObsSpaceData_mod:-------",/,8X,A)')cdmessage
      call flush(6)

      call MPI_Initialized(initialized)
      if (initialized .eq. 1)then
         call mpi_finalize()
      end if

      call qqexit(13)

      stop
   end subroutine obs_abort


   subroutine obs_allocate(obsdat,numHeader_max,numBody_max)
      !s/r obs_allocate - Allocate the object's arrays.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  Allocate arrays according to the parameters, header_max and
      !              body_max.  This is a private method.
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer         , intent(in)  :: numHeader_max,numBody_max

      integer :: column_index

      allocate(obsdat%cfamily(numHeader_max))
      obsdat%cfamily(:)='XX'

      allocate(obsdat%cstnid(numHeader_max))
      obsdat%cstnid(:)='XXXXXXXXXXXX'

      allocate(obsdat%robhdr(NHDR_REAL_BEG:NHDR_REAL_END))
      do column_index=NHDR_REAL_BEG,NHDR_REAL_END
         if(obs_columnActive_RH(column_index))  &
            call odc_allocate(obsdat%robhdr(column_index),numHeader_max, &
                              obs_ColumnNameList_RH(column_index),'REAL','HEAD')
      enddo

      allocate(obsdat%mobhdr(NHDR_INT_BEG:NHDR_INT_END))
      do column_index=NHDR_INT_BEG,NHDR_INT_END
         if(obs_columnActive_IH(column_index))  &
            call odc_allocate(obsdat%mobhdr(column_index),numHeader_max, &
                              obs_ColumnNameList_IH(column_index),'INT ','HEAD')
      enddo

      allocate(obsdat%robdata(NBDY_REAL_BEG:NBDY_REAL_END))
      do column_index=NBDY_REAL_BEG,NBDY_REAL_END
         if(obs_columnActive_RB(column_index))  &
            call odc_allocate(obsdat%robdata(column_index),numBody_max, &
                              obs_ColumnNameList_RB(column_index),'REAL','BODY')
      enddo

      allocate(obsdat%mobdata(NBDY_INT_BEG:NBDY_INT_END))
      do column_index=NBDY_INT_BEG,NBDY_INT_END
         if(obs_columnActive_IB(column_index))  &
            call odc_allocate(obsdat%mobdata(column_index),numBody_max, &
                              obs_ColumnNameList_IB(column_index),'INT ','BODY')
      enddo

   end subroutine obs_allocate


   subroutine obs_append(obsdat,hx,obs_out,hx_out)
      !
      ! object: with a call of type obs_append(obs_1,obs_2) append obs_1 to obs_2
      !
      ! author  : Peter Houtekamer: May 2011

      type (struct_obs), intent(in)    :: obsdat
      type (struct_obs), intent(inout) :: obs_out

      real(8),           intent(in)    :: hx(:,:)
      real(8),           intent(inout) :: hx_out(:,:)

      integer :: i_data_read,i_data_read_first,i_data_read_last,i_data_write
      integer :: i_last,istation,i_station_write,nens,i_write_first
      integer :: loc,loc_last,column_index

      if (obsdat%numHeader.eq.0) then
         write(*,*) 'odd input for routine obs_append'
         write(*,*) 'no stations need to be added to the obsdat.'
         return
      endif

      nens=size(hx,1)
      if (obs_out%numHeader.ge.1) then 
         i_last=1
         loc_last=obs_out%mobhdr(OBS_RLN)%value_i(1)
         storedlast: do istation=2,obs_out%numHeader
            loc=obs_out%mobhdr(OBS_RLN)%value_i(istation)
            if (loc.gt.loc_last) then
               i_last=istation
               loc_last=loc
            endif
         enddo storedlast
         ! the first available locations in the output 
         i_station_write=obs_out%numHeader+1
         i_data_write=obs_out%mobhdr(OBS_RLN)%value_i(i_last) &
                     +obs_out%mobhdr(OBS_NLV)%value_i(i_last)
      else
         i_station_write=1
         i_data_write=1
      endif

      stations: do istation=1,obsdat%numHeader
         i_data_read_first=obsdat%mobhdr(OBS_RLN)%value_i(istation)
         i_data_read_last=i_data_read_first &
                         +obsdat%mobhdr(OBS_NLV)%value_i(istation) -1
         i_write_first=i_data_write
         observations: do i_data_read=i_data_read_first,i_data_read_last
            do column_index=NBDY_INT_BEG,NBDY_INT_END
               if(obs_columnActive_IB(column_index))  &
                  obs_out%mobdata(column_index)%value_i(i_data_write)=obsdat%mobdata(column_index)%value_i(i_data_read)
            enddo
            do column_index=NBDY_REAL_BEG,NBDY_REAL_END
               if(obs_columnActive_RB(column_index))  &
                  obs_out%robdata(column_index)%value_r(i_data_write)=obsdat%robdata(column_index)%value_r(i_data_read)
            enddo
            hx_out(1:nens,i_data_write)=hx(:,i_data_read)
                                        ! Make HIND point to new header index
            obs_out%mobdata(OBS_HIND)%value_i(i_data_write)=i_station_write
            i_data_write=i_data_write+1
         enddo observations

         do column_index=NHDR_INT_BEG,NHDR_INT_END
            if(obs_columnActive_IH(column_index))  &
               obs_out%mobhdr(column_index)%value_i(i_station_write)=obsdat%mobhdr(column_index)%value_i(istation)
         enddo
         obs_out%mobhdr(OBS_ONM)%value_i(i_station_write)=i_station_write
         obs_out%mobhdr(OBS_RLN)%value_i(i_station_write)=i_write_first

         if (obs_out%numHeader.gt.0) then
            obs_out%mobhdr(OBS_PAS)%value_i(i_station_write) &
               =   obs_out%mobhdr(OBS_PAS)%value_i(i_station_write) &
                 + obs_out%mobhdr(OBS_PAS)%value_i(obs_out%numHeader)
         end if

         do column_index=NHDR_REAL_BEG,NHDR_REAL_END
            if(obs_columnActive_RH(column_index))  &
               obs_out%robhdr(column_index)%value_r(i_station_write)=obsdat%robhdr(column_index)%value_r(istation)
         enddo
         obs_out%cstnid(  i_station_write)=obsdat%cstnid(  istation)
         obs_out%cfamily( i_station_write)=obsdat%cfamily( istation)

         i_station_write=i_station_write+1
      enddo stations

      obs_out%numHeader=obs_out%numHeader+obsdat%numHeader
   end subroutine obs_append


   SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                      LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                      n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                      KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                      vconv,nonelev)
      use EarthConstants_mod
      use MathPhysConstants_mod
      IMPLICIT NONE

      type(struct_obs), intent(inout) :: obsdat
      INTEGER, intent(out) :: KNDAT
      INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
      INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
      INTEGER, intent(in)  :: KLIST(n_elements_in_block)
      INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
      integer, intent(in)  :: nvcordtyp,nonelev

      REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
      REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
      REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
      REAL(kind=8),intent(in)::PPMIS
      real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
      real(kind=8),intent(in)::vcordsf(:,:)

      LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI

      !***********************************************************************
      !
      !***s/r OBS_BDY -FILL BODY OF OBSDAT REPORT
      !
      !Author    . P. KOCLAS(CMC TEL. 4665)
      !
      !Revision:
      !          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
      !          .   before insertion of U and V for consistency
      !          . P. Koclas *CMC/AES February  1995:
      !          .  New call sequence neccessary to :
      !          . -allow insertion of "grouped data" records in BURP files.
      !          . -allow data observed in various vertical coordinates
      !          . -observation errors no longer initialized
      !
      !          . P. Koclas *CMC/AES March     1995:
      !            -Additions for humsat and satem data
      !          .
      !          . C. Charette *ARMA Jan        2001
      !            -Max value for T-Td surface element(12203)
      !
      !           JM Belanger CMDA/SMC  Feb 2001
      !                   . 32 bits conversion
      !          . P. Koclas *CMC/CMDA Sept     2001:
      !            -set first-guess and observation errors to missing values
      !
      !          .N Wagneur CMDA/SMC  Jine 2002
      !                   . -Additions for goes data
      !          . P. Koclas *CMC/CMDA Dec      2003:
      !                -conversion for surface wind
      !          . C. Charette *ARMA/SMC Apr      2005:
      !                -Set flag bit #12(Element assimilated by analysis) to zero
      !                 (see banco-burp documentation for more detail)
      !          . A. Beaulne *CMDA/SMC  Aug 2006
      !                     -Additions for AIRS data
      !          . S. Heilliette
      !                     -Additions for IASI data
      !
      !
      !    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
      !              THE IN-CORE FORMAT (OBSDAT) OF THE 3-D VARIATIONAL ANALYSIS
      !
      !    ARGUMENTS:
      !     INPUT:
      !
      !           -PVALUES : DATA BLOCK
      !           -KLIST   : LIST OF BUFR ELEMENTS
      !           -KFLAGS  : QUALITY CONTROL FLAGS
      !
      !           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN OBSDAT
      !                      .FALSE. --> INSERT DUMMY VALUE(2**12)
      !           -LERR    :  .TRUE. --> INSERT OBS ERROR IN OBSDAT (HUMSAT DATA)
      !           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN OBSDAT (SATEMS)
      !           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (GOES RADIANCES)
      !           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (AIRS RADIANCES)
      !           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (IASI RADIANCES)
      !
      !           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
      !           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
      !           -KNT     :  THIRD DIMENSION OF DATA BLOCK
      !           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
      !           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
      !           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
      !           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
      !           -PPMIS   :  VALUE OF MISSING DATA
      !           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
      !
      !    OUTPUT:
      !           -KNDAT   : NUMBER OF DATA INSERTED IN OBSDAT FILE
      !
      !***********************************************************************

      INTEGER ILEM,IND,IIND,IP,IK
      INTEGER IBAD,IFLAG
      INTEGER ielement,ilevel
      INTEGER ZESMAX,ZES

      REAL(kind=8) ZFACT,padd,pmul,ZEMFACT,pvalue

      !***********************************************************************
      !     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
      !***********************************************************************

      IIND  =-1
      IBAD=2**11

      ZFACT=VCONV

      ZEMFACT=0.01
      ZESMAX=30.

      IP=obsdat%numBody + 1
      IND=0

      !***********************************************************************
      !     PUT ALL NON MISSING DATA IN OBSDAT FILE
      !     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO OBSDAT FILE
      !     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
      !***********************************************************************

      IK= KINDEX
      DO ielement=1,n_elements_in_block
         ILEM=obs_get_obs_index_for_bufr_element(KLIST(ielement))
         IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
            DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                  nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                  IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                     pvalue=PVALUES(ielement,ilevel,IK)
                     IF ( IP + IND .LE. obsdat%numBody_max ) THEN
                                        ! VERTICAL COORDINATE
                        obsdat%robdata(OBS_PPP)%value_r(IP+IND)=real(PVCORD(ilevel) &
                                           *ZFACT +vcordsf(ilem,kidtyp),OBS_REAL)

                                        !  FOR PNM HEIGHT IS SET TO 0
                                        ! ----------------------------
                        IF ( ILEM .EQ. 53 ) THEN
                           obsdat%robdata(OBS_PPP)%value_r(IP+IND)=real(0.D0,OBS_REAL)
                        ENDIF
                                        ! ----------------------------

                                        ! IF ( ILEM .EQ. 2 ) Units:  V
                                        ! CONVERT TO GZ
                        IF ( ILEM .EQ. 3 ) THEN
                           pvalue=RG*pvalue
                        ENDIF
                                        ! IF ( ILEM .EQ. 4 ) Units: METERS
                                        ! IF ( ILEM .EQ. 8 ) Units:  CELSIUS
                                        ! Max value T-Td upper air
                        IF ( ILEM .EQ. 9 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! Max value T-Td surface
                        IF ( ILEM .EQ. 11 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! CONVERT TO RADIANS
                        IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                           pvalue=MPC_RADIANS_PER_DEGREE_R8*pvalue
                        ENDIF
                                        ! FLAGS
                        IF  (LDFLAG) THEN
                                        ! SET BIT 12  TO ZERO
                                        ! (Element assim by 3dvar)
                           IFLAG = KFLAGS(ielement,ilevel,IK)
                           IFLAG = IBCLR(IFLAG,12)
                           obsdat%mobdata(OBS_FLG)%value_i(IP+IND)= IFLAG
                        ELSE
                           obsdat%mobdata(OBS_FLG)%value_i(IP+IND)= IBAD
                        ENDIF

                        obsdat%robdata(OBS_VAR)%value_r(IP+IND)=real(pvalue,OBS_REAL)
                        obsdat%mobdata(OBS_VNM)%value_i(IP+IND)=KLIST(ielement)
                        obsdat%mobdata(OBS_VCO)%value_i(IP+IND)=NVCORDTYP
                        obsdat%robdata(OBS_OMF)%value_r(IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(OBS_OMA)%value_r(IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(OBS_OMI)%value_r(IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(OBS_HPHT)%value_r(IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(OBS_OER)%value_r(IP+IND)=real(PPMIS,OBS_REAL)
                        !
                        ! OBS ERROR FOR HUMSAT
                        !
                        IF ( LDERR ) THEN
                           obsdat%robdata(OBS_OER)%value_r(IP+IND)=real(PROFIL(ilevel)&
                              ,OBS_REAL)
                        ENDIF
                        !
                        ! REFERENCE LEVEL FOR SATEMS
                        !
                        IF ( LDSAT ) THEN
                           obsdat%robdata(OBS_OER)%value_r(IP+IND)= &
                              real(PROFIL(ilevel)*ZFACT,OBS_REAL)
                           obsdat%robdata(OBS_OER)%value_r(IP+IND)=real(1.0D0,OBS_REAL)
                        ENDIF
                        !
                        ! SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
                        !
                        IF ( LDGO ) THEN
                           obsdat%robdata(OBS_SEM)%value_r(IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        ENDIF

                        IF ( LDAIRS ) THEN
                           obsdat%robdata(OBS_SEM)%value_r(IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        END IF

                        IF ( LDIASI ) THEN
                           obsdat%robdata(OBS_SEM)%value_r(IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        END IF

                        IND=IND + 1
                     ELSE
                        !==================================================
                        KNDAT = IND
                        obsdat%numBody = obsdat%numBody + KNDAT
                        !==================================================
                        RETURN
                     ENDIF
                  ENDIF
               ENDIF
            END DO
         ENDIF
      END DO
      !=============================
      KNDAT = IND
      obsdat%numBody = obsdat%numBody + KNDAT
      !=============================

      RETURN
   END SUBROUTINE obs_bdy


   function obs_bodyElem_i(obsdat,column_index,index) result(value)
      !func obs_bodyElem_i - Get an integer-valued body observation-data element
      !
      !Author    . M. Buehner
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (integer) value of the ObsData element with the indicated
      !              name and index from the "body".

      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: column_index
      integer         , intent(in)  :: index

      if(column_index.ge.NBDY_INT_BEG.and.column_index.le.NBDY_INT_END) then
         if(obs_columnActive_IB(column_index)) then
            value=obsdat%mobdata(column_index)%value_i(index)
         else
            write(*,*) 'obs_bodyElem_i: column not active: ', &
                       obs_ColumnNameList_IB(column_index)
            call obs_abort('abort in obs_bodyElem_i')
         endif
      else
         write(*,*) 'obs_bodyElem_i: column index out of range: ',column_index
         call obs_abort('abort in obs_bodyElem_i')
      endif

   end function obs_bodyElem_i


   function obs_bodyElem_r(obsdat,column_index,index) result(value)
      !func obs_bodyElem_r - Get a real-valued body observation-data element
      !
      !Author    . M. Buehner
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (real) value of the ObsData element with the indicated
      !              name and index from the "body".

      implicit none
      real(kind=OBS_REAL)           :: value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: column_index
      integer         , intent(in)  :: index

      if(column_index.ge.NBDY_REAL_BEG.and.column_index.le.NBDY_REAL_END) then
         if(obs_columnActive_RB(column_index)) then
            value=obsdat%robdata(column_index)%value_r(index)
         else
            write(*,*) 'obs_bodyElem_r: column not active: ', &
                       obs_ColumnNameList_RB(column_index)
            call obs_abort('abort in obs_bodyElem_r')
         endif
      else
         write(*,*) 'obs_bodyElem_r: column index out of range: ',column_index
         call obs_abort('abort in obs_bodyElem_r')
      endif

   end function obs_bodyElem_r


   function obs_bodyIndex_mpiglobal(obsdat,index) result(value)
      !func obs_bodyIndex_mpiglobal - Get the mpiglobal body index
      !
      !Author    . M. Buehner
      !
      !    PURPOSE:  to control access to the mpiglobal index into the "body".

      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: index

      value=obsdat%bodyIndex_mpiglobal(index)

   end function obs_bodyIndex_mpiglobal


   subroutine obs_bodySet_i(obsdat, column_index, index, value)
      !s/r obs_bodySet_i - set an integer body value in an observation object
      !
      !Author    . J.W. Blezius and M. Buehner
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      integer         , intent(in)     :: column_index
      integer         , intent(in)     :: index
      integer         , intent(in)     :: value

      if(column_index.ge.NBDY_INT_BEG.and.column_index.le.NBDY_INT_END) then
         if(obs_columnActive_IB(column_index)) then
            obsdat%mobdata(column_index)%value_i(index) = value
         else
            write(*,*) 'obs_bodySet_i: column not active: ', &
                       obs_ColumnNameList_IB(column_index)
            call obs_abort('abort in obs_bodySet_i')
         endif
      else
         write(*,*) 'obs_bodySet_i: column index out of range: ',column_index
         call obs_abort('abort in obs_bodySet_i')
      endif

      if(index == (obsdat%numBody+1)) obsdat%numBody = obsdat%numBody+1

   end subroutine obs_bodySet_i


   subroutine obs_bodySet_r(obsdat, column_index, index, value)
      !s/r obs_bodySet_r - set a real body value in an observation object
      !
      !Author    . J.W. Blezius and M. Buehner
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs)   , intent(inout)  :: obsdat
      integer            , intent(in)     :: column_index
      integer            , intent(in)     :: index
      real(kind=OBS_REAL), intent(in)     :: value

      if(column_index.ge.NBDY_REAL_BEG.and.column_index.le.NBDY_REAL_END) then
         if(obs_columnActive_RB(column_index)) then
            obsdat%robdata(column_index)%value_r(index) = value
         else
            write(*,*) 'obs_bodySet_r: column not active: ', &
                       obs_ColumnNameList_RB(column_index)
            call obs_abort('abort in obs_bodySet_r')
         endif
      else
         write(*,*) 'obs_bodySet_r: column index out of range: ',column_index
         call obs_abort('abort in obs_bodySet_r')
      endif

      if(index == (obsdat%numBody+1)) obsdat%numBody = obsdat%numBody+1

   end subroutine obs_bodySet_r


   subroutine obs_clean(obsdat,hx,nens,nobsout,qcvar)
      !
      ! object  - remove all observations from the obsdat  
      !         that will not be assimilated. 
      !
      !author  : Peter Houtekamer
      !     revision may 2005. Houtekamer and Mitchell. Addition of the
      !          hx and nens arguments
      !
      !arguments
      !     nobsout       : unit number for the ASCII output
      !     qcvar         : input logical indicating if the input obsdat 
      !                     data have benefited from a qc-var procedure
      !
      !the logic applied:
      !     A body (and its associated header)
      !     will be retained if these three conditions are all met:
      !        1) either of:
      !             1a) btest(obsdat%mobdata(OBS_FLG,jdata),12)
      !             1b) .not. qcvar (the 5th parameter of obs_clean)
      !        2) obsdat%mobdata(OBS_ASS,jdata) .eq. 1
      !        3) obsdat%robdata(OBS_ZHA,jdata) .ge. 0.0
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat

      real(8), intent(inout) :: hx(:,:)
      integer, intent(in)    :: nens, nobsout
      logical, intent(in)    :: qcvar

      integer :: iaccept,idata,ipnt,iwrite
      integer :: jdata,kobs,var3d,kobsout,column_index

      write(nobsout,'(1x,A,I7)') 'stations prior to cleanup: ', obsdat%numHeader
      write(*,*) 'enter obs_clean'

      kobsout=0 
      iwrite=0
      stations: do kobs=1,obsdat%numHeader
         ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kobs)
         idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)
         iaccept=0
         observations: do jdata = ipnt, ipnt + idata - 1
            if (     btest(obsdat%mobdata(OBS_FLG)%value_i(jdata),12) &
                .or. .not. qcvar) then 
               ! data will be accepted if they went through the variational
               ! system  including the qcvar. They will also be accepted if the
               ! qcvar procedure was not applied (i.e. when backalt files are
               ! used as input).
               var3d=1
            else
               var3d=0
            endif

            ! To remove channels assimilated by 4D_var but flagged to
            ! be 0 in stats_tovs (obs_zha=-1 in OBSDAT BDY)
            if (obsdat%robdata(OBS_ZHA)%value_r(jdata) .lt. 0.) then
               obsdat%mobdata(OBS_ASS)%value_i(jdata)=-1
            endif

            if (      (obsdat%mobdata(OBS_ASS)%value_i(jdata).eq.1) &
                 .and.(var3d.eq.1)) then 
               ! the observation will be used in the analysis
               iaccept=iaccept+1
               iwrite=iwrite+1
               do column_index=NBDY_INT_BEG,NBDY_INT_END
                  if(obs_columnActive_IB(column_index))  &
                     obsdat%mobdata(column_index)%value_i(iwrite)=obsdat%mobdata(column_index)%value_i(jdata)
               enddo
               do column_index=NBDY_REAL_BEG,NBDY_REAL_END
                  if(obs_columnActive_RB(column_index))  &
                     obsdat%robdata(column_index)%value_r(iwrite)=obsdat%robdata(column_index)%value_r(jdata)
               enddo
               hx(1:nens,iwrite)=hx(1:nens,jdata)
            endif
         enddo observations

         ! adjust obsdat%robhdr 
         if (iaccept.gt.0) then
            kobsout=kobsout+1
            do column_index=NHDR_INT_BEG,NHDR_INT_END
               obsdat%mobhdr(column_index)%value_i(kobsout) &
                                       =obsdat%mobhdr(column_index)%value_i(kobs)
            enddo
            do column_index=NHDR_REAL_BEG,NHDR_REAL_END
               obsdat%robhdr(column_index)%value_r(kobsout) &
                                       =obsdat%robhdr(column_index)%value_r(kobs)
            enddo
            obsdat%cstnid(kobsout)=obsdat%cstnid(kobs)
            obsdat%mobhdr(OBS_NLV)%value_i(kobsout)=iaccept
            obsdat%mobhdr(OBS_RLN)%value_i(kobsout)=iwrite-iaccept+1
         endif
      enddo stations
      obsdat%numHeader=kobsout
      obsdat%numBody = iwrite

      write(nobsout,*) 'after cleanup of the obsdat:'
      write(nobsout,'(1x,A,I7)') &
         'number of stations containing valid data      ',obsdat%numHeader
      write(nobsout,'(1x,A,I7)') & 
         'number of observations now in the obsdat file ',obsdat%numBody

   end subroutine obs_clean


   function obs_columnIndexFromName_IH(column_name) result(column_index)
      implicit none
      integer :: column_index
      character(len=*) :: column_name
      logical :: lfound

      lfound=.false.
      do column_index=NHDR_INT_BEG,NHDR_INT_END
         if(trim(column_name).eq.trim(obs_ColumnNameList_IH(column_index))) then
            lfound=.true.          
            exit
         endif
      enddo

      if(.not.lfound) &
         call obs_abort('obs_columnIndexFromName_IH: name not found=' &
                        // column_name)

   end function obs_columnIndexFromName_IH


   function obs_columnIndexFromName_RH(column_name) result(column_index)
      implicit none
      integer :: column_index
      character(len=*) :: column_name
      logical :: lfound

      lfound=.false.
      do column_index=NHDR_REAL_BEG,NHDR_REAL_END
         if(trim(column_name).eq.trim(obs_ColumnNameList_RH(column_index))) then
            lfound=.true.          
            exit
         endif
      enddo

      if(.not.lfound) &
         call obs_abort('obs_columnIndexFromName_RH: name not found=' &
                        // column_name)

   end function obs_columnIndexFromName_RH


   function obs_columnIndexFromName_IB(column_name) result(column_index)
      implicit none
      integer :: column_index
      character(len=*) :: column_name
      logical :: lfound

      lfound=.false.
      do column_index=NBDY_INT_BEG,NBDY_INT_END
         if(trim(column_name).eq.trim(obs_ColumnNameList_IB(column_index))) then
            lfound=.true.          
            exit
         endif
      enddo

      if(.not.lfound) &
         call obs_abort('obs_columnIndexFromName_IB: name not found=' &
                        // column_name)

   end function obs_columnIndexFromName_IB


   function obs_columnIndexFromName_RB(column_name) result(column_index)
      implicit none
      integer :: column_index
      character(len=*) :: column_name
      logical :: lfound

      lfound=.false.
      do column_index=NBDY_REAL_BEG,NBDY_REAL_END
         if(trim(column_name).eq.trim(obs_ColumnNameList_RB(column_index))) then
            lfound=.true.          
            exit
         endif
      enddo

      if(.not.lfound) &
         call obs_abort('obs_columnIndexFromName_RB: name not found=' &
                        // column_name)

   end function obs_columnIndexFromName_RB


   subroutine obs_comm(obsdat,myip,nens,nstncom,hx)
      !authors  Peter Houtekamer and Herschel Mitchell May 2005
      !     (this routine evolved from the earlier routine commstns that worked
      !      per analysis pass and did not consider hx).
      !
      !object: communicate information on the stations and the observations
      !        between the processes
      !
      !input variables:
      !     myip: number of the processor.
      !     nens: number of ensemble members for hx (may be zero)
      !     nstncom: we wish to exchange the obsdat for stations 1 ... nstncom
      !       (nstncom may be less than obsdat%numHeader_max).

      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,           intent(in)    :: myip,nens,nstncom
      real(8),           intent(inout), dimension(:,:) :: hx    

      integer :: column_index, active_index
      integer            , pointer :: mobhdr_tmp(:,:),mobdata_tmp(:,:)
      real(kind=OBS_REAL), pointer :: robhdr_tmp(:,:),robdata_tmp(:,:)
      integer :: ier,master,mxstn,ncomm,nobs
#if OBS_REAL==4
      character(len=*), parameter :: MPI_OBS_REAL="mpi_real"
#elif OBS_REAL==8
      character(len=*), parameter :: MPI_OBS_REAL="mpi_double_precision"
#endif

      ! broadcast relevant integers from master to all processes 

      master=0

      ! if nothing to communicate, return
      if (obsdat%numHeader_max.le.0) return

      if (nstncom.gt.obsdat%numHeader_max) then
         write(*,*) 'ERROR in obs_comm: nstncom ',nstncom, &
            ' may not exceed numHeader_max ',obsdat%numHeader_max
         call obs_abort('OBS_COMM: nstncom exceeds numHeader_max')
      endif
      if (nstncom.le.0) then
         call obs_abort('OBS_COMM: nstncom should be positive')
      endif

      ! Nonmaster processes need to know how many body elements they will receive
      nobs=obsdat%mobhdr(OBS_RLN)%value_i(nstncom) &
                                    + obsdat%mobhdr(OBS_NLV)%value_i(nstncom) - 1
      ncomm=1
      call rpn_comm_bcast(nobs,ncomm,"mpi_integer",master,"world",ier)

      if (nobs.gt.obsdat%numBody_max) then
         write(*,*) 'ERROR in obs_comm: nobs ',nobs, &
            ' may not exceed obsdat%numBody_max ',obsdat%numBody_max
         call obs_abort('OBS_COMM: nobs exceeds obsdat%numBody_max')
      endif
      if (nobs.le.0) then
         write(*,*) 'ERROR in obs_comm: nobs ',nobs,' should be positive. '
         call obs_abort('OBS_COMM: nobs should be positive')
      endif

      ! extract data from active columns before broadcasting them
      ncomm=nstncom*obs_numActiveColumn_IH() 
      allocate(mobhdr_tmp(obs_numActiveColumn_IH(),nobs))
      do active_index=1,obs_numActiveColumn_IH()
         column_index=obs_columnIndexFromActiveIndex_IH(active_index)
         mobhdr_tmp(active_index,1:nstncom) &
                                  =obsdat%mobhdr(column_index)%value_i(1:nstncom)
      enddo
      call rpn_comm_bcast(mobhdr_tmp,ncomm,"mpi_integer",master,"world",ier)
      ! put data from active columns back into object
      do active_index=1,obs_numActiveColumn_IH()
         column_index=obs_columnIndexFromActiveIndex_IH(active_index)
         obsdat%mobhdr(column_index)%value_i(1:nstncom) &
                                              =mobhdr_tmp(active_index,1:nstncom)
      enddo
      deallocate(mobhdr_tmp)

      ! extract data from active columns before broadcasting them
      ncomm=nstncom*obs_numActiveColumn_RH()
      allocate(robhdr_tmp(obs_numActiveColumn_RH(),nobs))
      do active_index=1,obs_numActiveColumn_RH()
         column_index=obs_columnIndexFromActiveIndex_RH(active_index)
         robhdr_tmp(active_index,1:nstncom) &
                                  =obsdat%robhdr(column_index)%value_r(1:nstncom)
      enddo
      call rpn_comm_bcast(robhdr_tmp,ncomm,MPI_OBS_REAL,master,"world",ier)
      ! put data from active columns back into object
      do active_index=1,obs_numActiveColumn_RH()
         column_index=obs_columnIndexFromActiveIndex_RH(active_index)
         obsdat%robhdr(column_index)%value_r(1:nstncom) &
                                              =robhdr_tmp(active_index,1:nstncom)
      enddo
      deallocate(robhdr_tmp)

      ncomm=nstncom*len(obsdat%cstnid(0))
      call rpn_comm_bcastc(obsdat%cstnid,ncomm,"mpi_character",master,"world", &
                                                                             ier)
      ncomm=nstncom*len(obsdat%cfamily(0))
      call rpn_comm_bcastc(obsdat%cfamily,ncomm,"mpi_character",master,"world", &
                                                                             ier)

      ! extract data from active columns before broadcasting them
      ncomm=nobs*obs_numActiveColumn_IB()
      allocate(mobdata_tmp(obs_numActiveColumn_IB(),nobs))
      do active_index=1,obs_numActiveColumn_IB()
         column_index=obs_columnIndexFromActiveIndex_IB(active_index)
         mobdata_tmp(active_index,1:nobs) &
                                    =obsdat%mobdata(column_index)%value_i(1:nobs)
      enddo
      call rpn_comm_bcast(mobdata_tmp,ncomm,"mpi_integer",master,"world",ier)
      ! put data from active columns back into object
      do active_index=1,obs_numActiveColumn_IB()
         column_index=obs_columnIndexFromActiveIndex_IB(active_index)
         obsdat%mobdata(column_index)%value_i(1:nobs) &
                                                =mobdata_tmp(active_index,1:nobs)
      enddo
      deallocate(mobdata_tmp)

      ! extract data from active columns before broadcasting them
      ncomm=nobs*obs_numActiveColumn_RB()
      allocate(robdata_tmp(obs_numActiveColumn_RB(),nobs))
      do active_index=1,obs_numActiveColumn_RB()
         column_index=obs_columnIndexFromActiveIndex_RB(active_index)
         robdata_tmp(active_index,1:nobs) &
                                    =obsdat%robdata(column_index)%value_r(1:nobs)
      enddo
      call rpn_comm_bcast(robdata_tmp,ncomm,MPI_OBS_REAL,master,"world",ier)
      ! put data from active columns back into object
      do active_index=1,obs_numActiveColumn_RB()
         column_index=obs_columnIndexFromActiveIndex_RB(active_index)
         obsdat%robdata(column_index)%value_r(1:nobs) &
                                                =robdata_tmp(active_index,1:nobs)
      enddo
      deallocate(robdata_tmp)

      ! Broadcast the remaining obsdat variables
      ncomm=1
      call rpn_comm_bcast(obsdat%numHeader,ncomm,"mpi_integer",master,"world", &
                                                                             ier)
      call rpn_comm_bcast(obsdat%numBody,  ncomm,"mpi_integer",master,"world", &
                                                                             ier)
      call rpn_comm_bcast(obsdat%mpi_local,ncomm,"mpi_integer",master,"world", &
                                                                             ier)
      call rpn_comm_bcast(obsdat%datestamp,ncomm,"mpi_integer",master,"world", &
                                                                             ier)

      if (nens.gt.0) then
         ncomm=nobs*nens
         call rpn_comm_bcast(hx,ncomm,"mpi_double_precision",master,"world",ier)
      endif

      return

   end subroutine obs_comm


   subroutine obs_copy(obs_a,obs_b)
      !
      ! object  - copy an obsdat object
      !
      !author  : Peter Houtekamer. August 2011.
      !
      !arguments
      !     input : obs_a input object
      !     output: obs_b a copy of obs_a
      !
      !note:  this method assumes that obs_b has already been initialized
      !
      implicit none

      type(struct_obs), intent(in)  :: obs_a
      type(struct_obs), intent(inout) :: obs_b
      integer :: column_index

      if(obs_a%mpi_local)then
         call obs_abort( &
               "obs_copy() is not equipped to handle the case, mpi_local=.true.")
      end if

      do column_index=NHDR_REAL_BEG,NHDR_REAL_END
         if(obs_columnActive_RH(column_index)) &
            obs_b%robhdr(column_index)%value_r(:) = obs_a%robhdr(column_index)%value_r(:)
      enddo
      do column_index=NHDR_INT_BEG,NHDR_INT_END
         if(obs_columnActive_IH(column_index)) &
            obs_b%mobhdr(column_index)%value_i(:) = obs_a%mobhdr(column_index)%value_i(:)
      enddo
      do column_index=NBDY_REAL_BEG,NBDY_REAL_END
         if(obs_columnActive_RB(column_index)) &
            obs_b%robdata(column_index)%value_r(:) = obs_a%robdata(column_index)%value_r(:)
      enddo
      do column_index=NBDY_INT_BEG,NBDY_INT_END
         if(obs_columnActive_IB(column_index)) &
            obs_b%mobdata(column_index)%value_i(:) = obs_a%mobdata(column_index)%value_i(:)
      enddo
      obs_b%cstnid          = obs_a%cstnid
      obs_b%cfamily         = obs_a%cfamily

      obs_b%numHeader= obs_a%numHeader
      obs_b%numHeader_max   = obs_a%numHeader_max
      obs_b%numBody = obs_a%numBody
      obs_b%numBody_max     = obs_a%numBody_max

      obs_b%mpi_local       = obs_a%mpi_local
      obs_b%datestamp       = obs_a%datestamp
   end subroutine obs_copy


   subroutine obs_count_headers(obsdat,kulout)
      !
      ! object - count the number of stations and
      !         observations that are in the obsdat.
      !
      !author  : Peter Houtekamer
      !
      !arguments
      !     input:    kulout: unit number for ASCII error messages and 
      !                  observation counts.
      !
      implicit none

      integer, parameter :: maxid = 256
      type (struct_obs), intent(in) :: obsdat
      integer, intent(in) :: kulout

      integer  :: allstn,allobs,id,idata,kobs
      integer, dimension(maxid)   :: numobs,numstn

      ! initialize totals to zero
      numstn(:)=0
      numobs(:)=0
      allstn=0
      allobs=0

      do kobs=1,obsdat%numHeader
         id=obsdat%mobhdr(OBS_ITY)%value_i(kobs)
         if(id.gt.maxid) then
            id=mod(id,1000)
         endif
         if ((id.lt.1).or.(id.gt.maxid)) then 
            write(kulout,*) 'id out of range: ',id
            call obs_abort('OBS_COUNT_HEADERS: id out of range')
         endif
         numstn(id)=numstn(id)+1
         ! idata: number of obs for this station
         idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)
         numobs(id)=numobs(id)+idata
      enddo

      write(kulout,*) 'number of stations and observations'
      write(kulout,*) ' idtype #stations #observations '
      do id=1,maxid
         if (numstn(id).gt.0) then
            write(kulout,'(i3,3x,i7,2x,i8)') id,numstn(id),numobs(id)
         endif
         allstn=allstn+numstn(id)
         allobs=allobs+numobs(id)
      enddo
      write(kulout,'(1x,A,I7)') 'total number of stations:     ',allstn
      write(kulout,'(1x,A,I7)') 'total number of observations: ',allobs

      return
   end subroutine obs_count_headers


   subroutine obs_deallocate(obsdat)
      !s/r obs_deallocate - De-allocate the object's arrays.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  De-allocate arrays.  This is a private method.
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      integer :: ierr,column_index

      if (associated(obsdat%cfamily)) then
         deallocate(obsdat%cfamily,STAT=ierr)
         nullify(obsdat%cfamily)
         if(ierr.ne.0)write(*,*) 'Problem detected with CFAMILY. IERR =',ierr
      end if

      if (associated(obsdat%cstnid))then
         deallocate(obsdat%cstnid,STAT=ierr)
         nullify(obsdat%cstnid)
         if(ierr.ne.0)write(*,*) 'Problem detected with CSTNID. IERR =',ierr
      end if

      if (associated(obsdat%robhdr))then
         do column_index=NHDR_REAL_BEG,NHDR_REAL_END
            if(obs_columnActive_RH(column_index)) &
               call odc_deallocate(obsdat%robhdr(column_index))
         enddo
      end if

      if (associated(obsdat%mobhdr))then
         do column_index=NHDR_INT_BEG,NHDR_INT_END
            if(obs_columnActive_IH(column_index)) &
               call odc_deallocate(obsdat%mobhdr(column_index))
         enddo
      end if

      if (associated(obsdat%robdata))then
         do column_index=NBDY_REAL_BEG,NBDY_REAL_END
            if(obs_columnActive_RB(column_index)) &
               call odc_deallocate(obsdat%robdata(column_index))
         enddo
      end if

      if (associated(obsdat%mobdata))then
         do column_index=NBDY_INT_BEG,NBDY_INT_END
            if(obs_columnActive_IB(column_index)) &
               call odc_deallocate(obsdat%mobdata(column_index))
         enddo
      end if

   end subroutine obs_deallocate


   function obs_elem_c(obsdat,name,index) result(value)
      !func obs_elem_c - Get a character-string-valued observation-data element
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (character) value of the ObsData element with the indicated
      !              name and index.

      implicit none

      character(len=12) :: value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (trim(name))
      case ('STID'); value=obsdat%cstnid(index)

      case default
         write(*,*)"ERROR:  ", name(1:4)," is not character(len=*) observation."
         value='xxxxxxxxx'
      end select
   end function obs_elem_c


   subroutine obs_enkf_bdy(obsdat,vconv, &
                           pvalues,klist,kflags,profil, &
                           ldairs,kndat,kvcord,pvcord,kindex,kidtyp, &
                           nvcordtyp, vcordsf)
      !s/r obs_enkf_bdy -FILL BODY OF OBSDAT REPORT
      !
      !Author    . P. KOCLAS(CMC TEL. 4665)
      !
      !Revision:
      !          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
      !          .   before insertion of U and V for consistency
      !          . P. Koclas *CMC/AES February  1995:
      !          .  New call sequence neccessary to :
      !          . -allow insertion of "grouped data" records in BURP files.
      !          . -allow data observed in various vertical coordinates
      !          . -observation errors no longer initialized
      !
      !          . P. Koclas *CMC/AES March     1995:
      !            -Additions for humsat and satem data
      !          .
      !          . C. Charette *ARMA Jan        2001
      !            -Max value for T-Td surface element(12203)
      !
      !           JM Belanger CMDA/SMC  Feb 2001
      !                   . 32 bits conversion
      !           P. Houtekamer July 2005. Remove the lines for HUMSAT data
      !          . A. Beaulne *CMDA/SMC  Aug 2006
      !                     -Additions for AIRS data
      !           Xingxiu Deng, August 2008. added calling readpeak, calling airszha
      !                     to define robdata(ncmzha,:) for AIRS
      !           Xingxiu Deng, July 2009. added including column.cdk, calling readip1
      !                     to get ptop and define ncmzha for AMSU-A channel 11 and 12
      !                      if ptop is equal or higher than 2 hPa.
      !
      !    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
      !              THE IN-CORE FORMAT (OBSDAT) OF THE ANALYSIS
      !
      !    ARGUMENTS:
      !     INPUT:
      !
      !           -PVALUES : DATA BLOCK
      !           -KLIST   : LIST OF BUFR ELEMENTS
      !           -KFLAGS  : QUALITY CONTROL FLAGS
      !
      !           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (AIRS RADIANCES)
      !
      !           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
      !           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
      !           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
      !           -KIDTYP  :  burptype
      !           -vconv   :  conversion factor for pressure coordinate
      !           -profil  :  for GOES and AIRS
      !           -nvcordtyp :
      !
      !    OUTPUT:
      !           -KNDAT   : NUMBER OF DATA INSERTED IN OBSDAT FILE
      !           -OBSDAT%ROBDATA, OBSDAT%MOBDATA: obsdat body-information (new information added)
      !
      use EarthConstants_mod, only:  GRAV
      use MathPhysConstants_mod
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      logical, intent(in)  :: ldairs
      integer, intent(in)  :: kidtyp,kindex,kvcord
      integer, dimension(:),     intent(in) :: klist 
      integer, dimension(:,:,:), intent(in) :: kflags
      real(kind=4), intent(in) :: vconv
      real(kind=4), dimension(:), intent(in) :: profil,pvcord
      real(kind=4), dimension(:,:,:),  intent(in) :: pvalues
      integer, intent(out) :: kndat
      integer, intent(in) :: nvcordtyp
                                        ! vertical coordinate parameters
                                        ! for surface data
      real, dimension(:,:) :: vcordsf

      real (kind=4), parameter :: PPMIS=-999.0 ! VALUE OF MISSING DATA

      integer :: ichn,ik,ilem,ind,ip,ielement,ilevel,n_elements_in_block
      integer :: n_levels_in_block,zesmax

      real(kind=4) :: pdum,pvalue,zemfact,ztorad

      ! -n_elements_in_block    : NUMBER OF ELEMENTS IN DATA BLOCK
      ! -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
      n_elements_in_block=size(kflags,1)
      n_levels_in_block=size(kflags,2)
      !
      !     SET UNIT CONVERSION CONSTANTS
      !
      ZTORAD=MPC_RADIANS_PER_DEGREE_R4

      ZEMFACT=0.01
      ZESMAX=30.

      IP=OBSDAT%numBody + 1
      IND=0
      !
      !     PUT ALL NON MISSING DATA IN OBSDAT FILE
      !     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO OBSDAT FILE
      !     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
      !
      IK= KINDEX
      DO ielement=1,n_elements_in_block
         ILEM=obs_get_obs_index_for_bufr_element(KLIST(ielement))
         IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
            DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis) then
                  IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                     pvalue=PVALUES(ielement,ilevel,IK)
                     ! PLH replaced ndatamx by numBody_max
                     IF ( IP + IND .LE. obsdat%numBody_max ) THEN
                                        ! VERTICAL COORDINATE
                        OBSDAT%ROBDATA(OBS_PPP)%value_r(IP+IND) &
                                      =PVCORD(ilevel)*vconv +vcordsf(ilem,kidtyp)
                                        !
                                        !  FOR PNM HEIGHT IS SET TO 0
                                        ! ----------------------------
                        IF ( ILEM .EQ. 53 ) THEN
                           OBSDAT%ROBDATA(OBS_PPP)%value_r(IP+IND)=0.
                        ENDIF
                                        ! ----------------------------
                                        ! CONVERT TO GZ
                        if ( ILEM .EQ. 3 ) then
                           pvalue=GRAV*pvalue
                        endif
                                        ! Max value T-Td upper air
                        IF ( ILEM .EQ. 9 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! Max value T-Td surface
                        IF ( ILEM .EQ. 11 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! CONVERT TO RADIANS
                        if ( ILEM .EQ. 48 ) then
                           pvalue=ztorad*pvalue
                        endif
                                        ! FLAGS
                        obsdat%mobdata(OBS_FLG)%value_i(IP+IND) &
                                                      =KFLAGS(ielement,ilevel,IK)

                        OBSDAT%ROBDATA(OBS_VAR)%value_r(IP+IND)=pvalue
                                        ! initialise o minus p , o minus p6,
                                        ! o minus a and hpht to undefined values
                                        ! (-999)
                        obsdat%robdata(OBS_OMP)%value_r(ip+ind)=-999.
                        obsdat%robdata(OBS_OMP6)%value_r(ip+ind)=-999.
                        obsdat%robdata(OBS_OMA)%value_r(ip+ind)=-999.
                        obsdat%robdata(OBS_HPHT)%value_r(ip+ind)=-999.
                        obsdat%mobdata(OBS_VNM)%value_i(IP+IND)=KLIST(ielement)
                        obsdat%mobdata(OBS_VCO)%value_i(IP+IND)=nvcordtyp
                        !
                        !    SURFACE EMISSIVITIES FOR GOES AND AIRS RADIANCES
                        if ( LDAIRS ) then
                           OBSDAT%ROBDATA(OBS_SEM)%value_r(IP+IND) &
                                                          =PROFIL(ilevel)*ZEMFACT
                        endif
                        ind=ind + 1
                     else
                        kndat = ind
                        obsdat%numBody = obsdat%numBody + kndat
                        return
                     endif
                  endif
               endif
            enddo
         endif
      enddo
      kndat = ind
      obsdat%numBody = obsdat%numBody + kndat

      return
   end subroutine obs_enkf_bdy


   subroutine obs_enkf_prntbdy(obsdat,kstn,kulout)
      !
      ! object  - print all data records associated with an observation
      !
      !author  : P. Gauthier, C. Charette
      !revision:
      !      P. Houtekamer mrb 2000: reduction and improved readability of output
      !
      !arguments
      !     i   kstn  : no. of station 
      !     i   kulout: unit used for printing
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer,      intent(in)  :: kstn, kulout

      integer :: ipnt, idata, idata2, jdata, var3d

      ! general information

      ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kstn)
      idata = obsdat%mobhdr(OBS_NLV)%value_i(kstn)

      if(idata.eq.1) then
         write(kulout,fmt=9101)idata,kstn
      else
         write(kulout,fmt=9100)idata,kstn
      end if
9100  format(2x,'there are ',i3,1x,'data in record no.',1x,i6)
9101  format(2x,'there is ',i3,1x,'data in record no.',1x,i6)

      ! print all data records

      write(kulout,'(a,a,a)') '   no.   var.  press. ass observ. ', &
         '  o minus p  o minus p6  o minus a    obserr. root(hpht) acc     ', &
         'zhad  vco'
      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if (btest(obsdat%mobdata(OBS_FLG)%value_i(jdata),12)) then 
            var3d=1
         else
            var3d=0
         endif

         write(kulout,fmt=9201) idata2,obsdat%mobdata(OBS_VNM)%value_i(jdata), &
            obsdat%robdata(OBS_PPP )%value_r(jdata), &
            obsdat%mobdata(OBS_ASS )%value_i(jdata), &
            obsdat%robdata(OBS_VAR )%value_r(jdata), &
            obsdat%robdata(OBS_OMP )%value_r(jdata), &
            obsdat%robdata(OBS_OMP6)%value_r(jdata), &
            obsdat%robdata(OBS_OMA )%value_r(jdata), &
            obsdat%robdata(OBS_OER )%value_r(jdata), &
            obsdat%robdata(OBS_HPHT)%value_r(jdata), &
            var3d, &
            obsdat%robdata(OBS_ZHA )%value_r(jdata), &
            obsdat%mobdata(OBS_VCO )%value_i(jdata)

      enddo

9201  format(1x,i3,1x,i6,1x,f7.0,1x,i3,6(1x,f10.3),1x,i2, &
         1x,f10.3,1x,i2)

      return

   end subroutine obs_enkf_prntbdy


   subroutine obs_enkf_prnthdr(obsdat,kobs,kulout)
      !
      ! object  - printing of the header of an observation record
      !
      !author  : P. Gauthier *arma/aes  June 9, 1992
      !revision:
      !     . P. Houtekamer modification of the cma format 
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for optional printing
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer,      intent(in)  :: kobs, kulout

      ! general information

      write(kulout,fmt=9100)kobs,obsdat%cstnid(KOBS)
9100  format(//,2x,'-- observation record no.' &
         ,1x,i6,3x,' station id:',A12)

      ! print header's content

9202  format(2x,'position within robdata:',i6)
      write(kulout,fmt=9200) &
         obsdat%mobhdr(OBS_RLN)%value_i(kobs), &
         obsdat%mobhdr(OBS_ONM)%value_i(kobs), &
         obsdat%mobhdr(OBS_DAT)%value_i(kobs), &
         obsdat%mobhdr(OBS_ETM)%value_i(kobs), &
         obsdat%mobhdr(OBS_INS)%value_i(kobs), &
         obsdat%mobhdr(OBS_OTP)%value_i(kobs), &
         obsdat%mobhdr(OBS_ITY)%value_i(kobs), &
         obsdat%robhdr(OBS_LAT)%value_r(kobs), &
         obsdat%robhdr(OBS_LON)%value_r(kobs), &
         obsdat%robhdr(OBS_ALT)%value_r(kobs), &
         obsdat%robhdr(OBS_BX )%value_r(kobs), &
         obsdat%robhdr(OBS_BY )%value_r(kobs), &
         obsdat%robhdr(OBS_BZ )%value_r(kobs)
      write(kulout,fmt=9201) & 
         obsdat%mobhdr(OBS_NLV)%value_i(kobs), &
         obsdat%mobhdr(OBS_OFL)%value_i(kobs), &
         obsdat%mobhdr(OBS_PAS)%value_i(kobs), &
         obsdat%mobhdr(OBS_REG)%value_i(kobs), &
         obsdat%mobhdr(OBS_IP )%value_i(kobs), &
         obsdat%mobhdr(OBS_AZA)%value_i(kobs)

9200  format(2x,'position within robdata:',i6,1x,'stn. number:',i6,1x,/, &
         '  date: ',i10,1x,' time: ',i8,/, &
         '  model box:',i12,1x,'instrument: ',i6,1x, &
         'obs. type:',i8,1x,/, &
         '  (lat,lon):',f12.6,1x,f12.6,1x, &
         'stations altitude:',f12.6,1x,/,2x, &
         'block location: ',3(f12.6,1x))
9201  format('  number of data:',i6,1x,'report status: ',i6,1x, &
         ' pass: ',i6,' region: ',i6,/,2x, &
         'processor: ',i6,' azimuth angle: ',i6)

      return
   end subroutine obs_enkf_prnthdr


   subroutine obs_exchange_stations(obsdat,j,k) 
      !
      !author: Peter Houtekamer
      !        February 2000
      ! February 2011: Peter Houtekamer moved the original routine exchange
      !   from sortcma.f to the module.
      !
      !object: exchange the headers of stations j and k 
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer, intent(in)         :: j,k

      real(OBS_REAL):: rdum 
      integer       :: i,idum
      character(12) :: cdum

      do i=NHDR_INT_BEG,NHDR_INT_END
         if(obs_columnActive_IH(i)) then
            idum=obsdat%mobhdr(i)%value_i(j)
            obsdat%mobhdr(i)%value_i(j)=obsdat%mobhdr(i)%value_i(k)
            obsdat%mobhdr(i)%value_i(k)=idum
         endif
      enddo

      do i=NHDR_REAL_BEG,NHDR_REAL_END
         if(obs_columnActive_RH(i)) then
            rdum=obsdat%robhdr(i)%value_r(j)
            obsdat%robhdr(i)%value_r(j)=obsdat%robhdr(i)%value_r(k) 
            obsdat%robhdr(i)%value_r(k)=rdum 
         endif
      enddo

      cdum=obsdat%cstnid(j)
      obsdat%cstnid(j)=obsdat%cstnid(k)
      obsdat%cstnid(k)=cdum

      call adjust_obs(j)
      call adjust_obs(k)

      return

   contains
      subroutine adjust_obs(hdx)
         ! Make the body members of header(hdx) point to the new index of hdx.
         implicit none
         integer, intent(in) :: hdx     ! Header index

         integer       :: ifirst, ilast

         ifirst=obsdat%mobhdr(OBS_RLN)%value_i(hdx)
         ilast =obsdat%mobhdr(OBS_RLN)%value_i(hdx) + &
                obsdat%mobhdr(OBS_NLV)%value_i(hdx) -1
         do i=ifirst,ilast
            obsdat%mobdata(OBS_HIND)%value_i(i) = hdx
         end do
      end subroutine adjust_obs
   end subroutine obs_exchange_stations


   subroutine obs_expandToMpiGlobal(obsdat)
      !
      !**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
      !
      !Author    . Bin He (ARMA/MRB )
      !
      !Revision:
      !      PURPOSE:  To reconstitute the mpi-global observation object by
      !                gathering the necessary data from all processors (to all
      !                processors).
      !                NOTE: for the character data cstnid(:), this is converted
      !                      to integers with IACHAR and back to characters with
      !                      ACHAR, to facilitate this gather through
      !                      rpn_comm_allreduce
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      integer,allocatable,dimension(:,:)        :: int_cstnid_partial, &
                                                   int_cstnid_complete
      integer,allocatable,dimension(:,:)        :: int_cfamily_partial, &
                                                   int_cfamily_complete
      real(OBS_REAL),allocatable,dimension(:,:) :: robdata_partial, &
                                                   robdata_complete
      real(OBS_REAL),allocatable,dimension(:,:) :: robhdr_partial, &
                                                   robhdr_complete
      integer,allocatable,dimension(:,:) :: mobdata_partial, &
                                            mobdata_complete
      integer,allocatable,dimension(:,:) :: mobhdr_partial, &
                                            mobhdr_complete 

      integer :: ierr
      integer :: numHeader_mpiGlobal,numBody_mpiGlobal
      integer :: bodyIndex_mpilocal,bodyIndex_mpiglobal
      integer :: headerIndex_mpilocal,headerIndex_mpiglobal
      integer :: sizedata
      integer :: indexChar,column_index,active_index
#if OBS_REAL==4
      character(len=*), parameter :: MPI_OBS_REAL="mpi_real"
#elif OBS_REAL==8
      character(len=*), parameter :: MPI_OBS_REAL="mpi_double_precision"
#endif
      !!---------------------------------------------------------------

      write(*,*) 'Entering obs_expandToMpiGlobal'

      if(.not. obsdat%mpi_local)then
         call obs_abort('OBS_EXPANDTOMPIGLOBAL has been called, but the ' &
                        // 'obsSpaceData object is already in mpi-global state')
      end if

      ! determine number of rows in mpiglobal arrays
      sizedata=1
      call rpn_comm_allreduce(obsdat%numHeader,numHeader_mpiGlobal,sizedata, &
                              "mpi_integer","mpi_sum","GRID",ierr)
      call rpn_comm_allreduce(obsdat%numBody,  numBody_mpiGlobal,  sizedata, &
                              "mpi_integer","mpi_sum","GRID",ierr)

      ! allocate memory for the temporary arrays for header-level data
      allocate(mobhdr_partial  (obs_numActiveColumn_IH(),numHeader_mpiglobal))
      allocate(mobhdr_complete (obs_numActiveColumn_IH(),numHeader_mpiglobal))
      allocate(robhdr_partial  (obs_numActiveColumn_RH(),numHeader_mpiglobal))
      allocate(robhdr_complete (obs_numActiveColumn_RH(),numHeader_mpiglobal))
      allocate(int_cstnid_partial  (numHeader_mpiglobal,len(obsdat%cstnid(1))))
      allocate(int_cstnid_complete (numHeader_mpiglobal,len(obsdat%cstnid(1))))
      allocate(int_cfamily_partial (numHeader_mpiglobal,len(obsdat%cfamily(1))))
      allocate(int_cfamily_complete(numHeader_mpiglobal,len(obsdat%cfamily(1))))

      int_cstnid_partial  (:,:)=0
      int_cstnid_complete (:,:)=0
      robhdr_partial      (:,:)=real(0.0d0, OBS_REAL)
      robhdr_complete     (:,:)=real(0.0d0, OBS_REAL)
      mobhdr_partial      (:,:)=0
      mobhdr_complete     (:,:)=0
      int_cfamily_partial (:,:)=0
      int_cfamily_complete(:,:)=0

      ! copy mpilocal data into temporary mpiglobal arrays for header-level data
      do headerIndex_mpilocal=1,obsdat%numHeader
         headerIndex_mpiglobal=obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)

         do active_index=1,obs_numActiveColumn_IH()
            column_index=obs_columnIndexFromActiveIndex_IH(active_index)
            mobhdr_partial(active_index,headerIndex_mpiglobal) &
                       =obsdat%mobhdr(column_index)%value_i(headerIndex_mpilocal)
         enddo

         do active_index=1,obs_numActiveColumn_RH()
            column_index=obs_columnIndexFromActiveIndex_RH(active_index)
            robhdr_partial(active_index,headerIndex_mpiglobal) &
                       =obsdat%robhdr(column_index)%value_r(headerIndex_mpilocal)
         enddo

         ! ATTN: for cstnid and cfamily, character strings are converted to
         !       integer arrays!!!
         do indexChar=1,len(obsdat%cstnid(1))
            int_cstnid_partial(headerIndex_mpiglobal,indexChar) = &
                 iachar(obsdat%cstnid(headerIndex_mpilocal)(indexChar:indexChar))
         enddo

         do indexChar=1,len(obsdat%cfamily(1))
            int_cfamily_partial(headerIndex_mpiglobal,indexChar) = &
                iachar(obsdat%cfamily(headerIndex_mpilocal)(indexChar:indexChar))
         enddo
      enddo

      ! merge the temporary global arrays for header-level data
      sizedata=size(mobhdr_complete)
      call rpn_comm_allreduce(mobhdr_partial,mobhdr_complete,sizedata, &
                              "mpi_integer","mpi_sum","GRID",ierr)

                                        ! Make RLN point to global data
      do headerIndex_mpiglobal=1,numHeader_mpiGlobal
         if(headerIndex_mpiglobal == 1) then
            mobhdr_complete(OBS_RLN,headerIndex_mpiglobal) = 1
         else
            mobhdr_complete(OBS_RLN,headerIndex_mpiglobal) = &
                               mobhdr_complete(OBS_RLN,headerIndex_mpiglobal-1) &
                             + mobhdr_complete(OBS_NLV,headerIndex_mpiglobal-1)
         endif
      enddo

      sizedata=size(robhdr_partial)
      call rpn_comm_allreduce(robhdr_partial,robhdr_complete,sizedata, &
         MPI_OBS_REAL, "mpi_sum","GRID",ierr)

      sizedata=size(int_cstnid_partial)
      call rpn_comm_allreduce(int_cstnid_partial,int_cstnid_complete, &
         sizedata,"mpi_integer","mpi_sum","GRID",ierr)

      sizedata=size(int_cfamily_partial)
      call rpn_comm_allreduce(int_cfamily_partial,int_cfamily_complete, &
         sizedata,"mpi_integer","mpi_sum","GRID",ierr)

      ! allocate memory for the temporary arrays for body-level data
      allocate(mobdata_partial (obs_numActiveColumn_IB(),obsdat%numBody_max))
      allocate(mobdata_complete(obs_numActiveColumn_IB(),obsdat%numBody_max))
      allocate(robdata_partial (obs_numActiveColumn_RB(),obsdat%numBody_max))
      allocate(robdata_complete(obs_numActiveColumn_RB(),obsdat%numBody_max))
      mobdata_partial =0
      mobdata_complete=0
      robdata_partial =real(0.0d0,OBS_REAL)
      robdata_complete=real(0.0d0,OBS_REAL)

      ! copy mpilocal data into temporary mpiglobal arrays for body-level data
      do bodyIndex_mpilocal=1,obsdat%numBody
         bodyIndex_mpiglobal=obsdat%bodyIndex_mpiglobal(bodyIndex_mpilocal)

         do active_index=1,obs_numActiveColumn_IB()
            column_index=obs_columnIndexFromActiveIndex_IB(active_index)
            mobdata_partial(active_index,bodyIndex_mpiglobal)= &
                         obsdat%mobdata(column_index)%value_i(bodyIndex_mpilocal)
         enddo

         do active_index=1,obs_numActiveColumn_RB()
            column_index=obs_columnIndexFromActiveIndex_RB(active_index)
            robdata_partial(active_index,bodyIndex_mpiglobal)= &
                         obsdat%robdata(column_index)%value_r(bodyIndex_mpilocal)
         enddo

                                        ! Make HIND point to global header
         headerIndex_mpilocal=obsdat%mobdata(OBS_HIND) &
                                                     %value_i(bodyIndex_mpilocal)
         mobdata_partial(obs_activeIndexFromColumnIndex_IB(OBS_HIND), &
                         bodyIndex_mpiglobal) &
                       = obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)
      enddo

      ! merge the temporary global arrays for body-level data
      sizedata=size(mobdata_partial)
      call rpn_comm_allreduce(mobdata_partial,mobdata_complete,sizedata, &
                              "mpi_integer","mpi_sum","GRID",ierr)

      sizedata=size(robdata_partial)
      call rpn_comm_allreduce(robdata_partial,robdata_complete,sizedata, &
                              MPI_OBS_REAL,"mpi_sum","GRID",ierr)

      ! destroy object's mpilocal data and allocate mpiglobal data
      call obs_deallocate(obsdat)
      call obs_allocate(obsdat,numHeader_mpiGlobal,obsdat%numBody_max)

      ! copy the temporary arrays to the object's arrays
      !   ATTN: for cstnid and cfamily, integer arrays converted back to
      !         character strings!!!
      do headerIndex_mpiglobal=1,numHeader_mpiglobal
         do indexChar=1,len(obsdat%cstnid(1))
            obsdat%cstnid(headerIndex_mpiglobal)(indexChar:indexChar) = &
                      achar(int_cstnid_complete(headerIndex_mpiglobal,indexChar))
         enddo

         do indexChar=1,len(obsdat%cfamily(1))
            obsdat%cfamily(headerIndex_mpiglobal)(indexChar:indexChar) = &
                     achar(int_cfamily_complete(headerIndex_mpiglobal,indexChar))
         enddo
      enddo

      do active_index=1,obs_numActiveColumn_RH()
         column_index=obs_columnIndexFromActiveIndex_RH(active_index)
         obsdat%robhdr(column_index)%value_r(:)=robhdr_complete(active_index,:)
      enddo

      do active_index=1,obs_numActiveColumn_IH()
         column_index=obs_columnIndexFromActiveIndex_IH(active_index)
         obsdat%mobhdr(column_index)%value_i(:)=mobhdr_complete(active_index,:)
      enddo

      do active_index=1,obs_numActiveColumn_RB()
         column_index=obs_columnIndexFromActiveIndex_RB(active_index)
         obsdat%robdata(column_index)%value_r(:)=robdata_complete(active_index,:)
      enddo

      do active_index=1,obs_numActiveColumn_IB()
         column_index=obs_columnIndexFromActiveIndex_IB(active_index)
         obsdat%mobdata(column_index)%value_i(:)=mobdata_complete(active_index,:)
      enddo

      obsdat%numBody     =  numBody_mpiGlobal
      obsdat%numHeader   =numHeader_mpiGlobal

      ! deallocate the temporary arrays
      deallocate(int_cstnid_partial)
      deallocate(int_cstnid_complete)
      deallocate(int_cfamily_partial)
      deallocate(int_cfamily_complete)
      deallocate(robhdr_partial)
      deallocate(robhdr_complete)
      deallocate(mobhdr_partial)
      deallocate(mobhdr_complete)
      deallocate(robdata_partial)
      deallocate(robdata_complete)
      deallocate(mobdata_partial)
      deallocate(mobdata_complete)

      obsdat%mpi_local = .false.

      write(*,*) 'Leaving obs_expandToMpiGlobal'
      return
   end subroutine obs_expandToMpiGlobal


   subroutine obs_finalize(obsdat)
      !s/r obs_finalize - De-allocate memory and clean up the object.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  De-allocate object arrays, and perform any other clean-up
      !              that is necessary before object deletion.
      implicit none
      type(struct_obs), intent(inout) :: obsdat
      integer :: column_index

      call obs_deallocate(obsdat)
   end subroutine obs_finalize


   subroutine obs_generate_header(obsdat, ilat, ilon, ialt, inbon, instrum, &
                                  isatzen, nvtyp, ity, idate, itime, clstnid, &
                                  imask, isatazim, isunza, iclfr)
      !
      !    OUTPUT:
      !           obsdat%robhdr(OBS_LON,) - in degrees
      !           obsdat%robhdr(OBS_LAT,) - in degrees, equator at 0 degrees
      !           obsdat%robhdr(OBS_ALT,) - in metres, with no offset
      !
      use MathPhysConstants_mod
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: ilat, ilon, ialt, inbon, instrum, isatzen
      integer, intent(in) :: nvtyp, ity, idate, itime
      integer, intent(in) :: imask, isatazim, isunza, iclfr
      character(len=9), intent(in) :: clstnid
      real(kind=8) :: torad

      torad=MPC_RADIANS_PER_DEGREE_R8

      !
      !     IF VALID DATA WERE FOUND GENERATE THE OBSDAT HEADER
      !      AND INCREMENT OBSDAT%numHeader
      !
      ! PLH          if  ( obsdat%numHeader .lt. nmxobs) then
      if ( obsdat%numHeader .lt. obsdat%numHeader_max) then
         obsdat%numHeader=obsdat%numHeader + 1

         obsdat%robhdr(OBS_LON)%value_r(obsdat%numHeader) = real(ilon) *0.01
         obsdat%robhdr(OBS_LAT)%value_r(obsdat%numHeader) = real(ilat) *0.01-90.0
         ! PLH ADDED OBS_BX OBS_BY OBS_BZ
         obsdat%robhdr(OBS_BX)%value_r(obsdat%numHeader)=0.0
         obsdat%robhdr(OBS_BY)%value_r(obsdat%numHeader)=0.0
         obsdat%robhdr(OBS_BZ)%value_r(obsdat%numHeader)=0.0

         obsdat%robhdr(OBS_ALT)%value_r(obsdat%numHeader) = real(ialt)
         ! PLH       obsdat%robhdr(ncmtlo)%value_r(obsdat%numHeader) = (real(ilon)*0.01)*ztorad
         ! PLH       obsdat%robhdr(ncmtla)%value_r(obsdat%numHeader) = (real(ilat)*0.01-90.)*ztorad
         obsdat%mobhdr(OBS_NLV)%value_i(obsdat%numHeader) = inbon
         !       print*,'NOBTOTAL=',obsdat%numHeader

         if ( obsdat%numHeader .eq. 1) then
            ! This is the first entry into the obsdat
            obsdat%mobhdr(OBS_RLN)%value_i(1)=1
         else
            obsdat%mobhdr(OBS_RLN)%value_i(obsdat%numHeader) &
                   =   obsdat%mobhdr(OBS_RLN)%value_i(obsdat%numHeader-1) &
                     + obsdat%mobhdr(OBS_NLV)%value_i(obsdat%numHeader-1)
         endif
         !
         !          REMAINDER OF HEADER
         !
         obsdat%mobhdr(OBS_ONM)%value_i(obsdat%numHeader) = obsdat%numHeader
         obsdat%mobhdr(OBS_INS)%value_i(obsdat%numHeader) =instrum +isatzen*10000
         obsdat%mobhdr(OBS_OTP)%value_i(obsdat%numHeader) = nvtyp
         obsdat%mobhdr(OBS_ITY)%value_i(obsdat%numHeader) = ity
         obsdat%mobhdr(OBS_DAT)%value_i(obsdat%numHeader) = idate
         obsdat%mobhdr(OBS_ETM)%value_i(obsdat%numHeader) = itime
         obsdat%cstnid(obsdat%numHeader)         = clstnid
         ! PLH       obsdat%mobhdr(ncmoec)%value_i(obsdat%numHeader) = 999
         obsdat%mobhdr(OBS_OFL)%value_i(obsdat%numHeader) = imask
         obsdat%mobhdr(OBS_AZA)%value_i(obsdat%numHeader) = isatazim
         obsdat%mobhdr(OBS_SUN)%value_i(obsdat%numHeader) = isunza
         obsdat%mobhdr(OBS_CLF)%value_i(obsdat%numHeader) = iclfr
         ! PLH       obsdat%mobhdr(ncmst1)%value_i(obsdat%numHeader) = iflgs
      endif

   end subroutine obs_generate_header


   function obs_get_datestamp(obsdat) result(datestamp)
      !
      ! object: to control access to the observation object.  Returns the date
      !         stamp of the obsdat object.

      implicit none
      type(struct_obs), intent(in) :: obsdat
      integer :: datestamp

      datestamp = obsdat%datestamp

   end function obs_get_datestamp


   integer function obs_get_obs_index_for_bufr_element(kbufrn)
      implicit none
      integer, intent(in) :: kbufrn
      !
      !      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
      !               THAT CONTAINS A BUFR ELEMENT NUMBER
      !
      !    ARGUMENTS:
      !               INPUT:
      !                   -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
      !                            i.e. known locally as the 'burp variable type'
      !                            i.e. table B of the ECMWF BUFR reference
      !                            BUFR = Binary Universal Form for the
      !                                   Representation of meteorological data
      !
      !               OUTPUT:
      !                   - obs_get_obs_index_for_bufr_element:
      !                            THE FOUND INDEX (=-1 IF NOT FOUND)
      !
      !       AUTHOR: P. KOCLAS (CMC TEL. 4665)

      integer indbuf
      integer, parameter, dimension(OBS_JPNBRELEM) :: NVNUMB = (/ &
         011003, 011004, 010194, 010192,     29, & !  1-10
         013208, 012063, 012001, 012192, 012004, &
         012203, 011215, 011216, 013210, 013220, & ! 11-20
         62, 015001,     64,     65, 015036, &
         015031, 015032,     69,     70,     71, & ! 21-30
         72,     73,     74,     75,     76, &
         77,     78,     79,     80,     81, & ! 31-40
         82,     83,     84,     85,     86, &
         87,     88,     89,     90,     91, & ! 41-50
         012163, 010004, 011001, 011002, 012062, &
         008001, 008004, 010051, 011011, 011012, & ! 51-57
         41,     42 /)


      ! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
      !  Descriptions taken from 3d variational code(March 2011, revision 11.0.2)
      !
      !  1 =011003 (U COMPONENT)           (m/s)
      !  2 =011004 (V COMPONENT)           (m/s)
      !  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
      !  4 =010192 (THICKNESS IN M)
      !  5 =    29 (RELATIVE HUMIDITY)
      !  6 =013208
      !  7 =012063 BRIGHTNESS TEMPERATURE 1
      !  8 =012001 (TEMPERATURE)            (kelvin)
      !  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
      ! 10 =012004 (2M TEMPERATURE)
      ! 11 =012203 (2M DEW-POINT DEPRESSION)
      ! 12 =011215 SURFACE U     WIND COMPONENT M/S)
      ! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
      ! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
      ! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
      ! 16 =007006 HEIGHT ABOVE STATION (M)
      ! 17 =015001 (Total Ozone from TOVS)
      ! 18 =    64 (CM)
      ! 19 =    65 (CL)
      ! 20 =015036 (GPSRO REFRACTIVITY)
      ! 21 =015031 (GPSGB ZTD IN M)
      ! 22 =015032 (GPSGB ZTD ERROR IN M)
      ! 23 =    69 (C)
      ! 24 =    70 (NS)
      ! 25 =    71 (S)
      ! 26 =    72 (E)
      ! 27 =    73 (TGTG)
      ! 28 =    74 (SPSP)
      ! 29 =    75 (SPSP)
      ! 30 =    76 (RS)
      ! 31 =    77 (ESES)
      ! 32 =    78 (IS)
      ! 33 =    79 (TRTR)
      ! 34 =    80 (RR)
      ! 35 =    81 (JJ)
      ! 36 =    82 (VS)
      ! 37 =    83 (DS)
      ! 38 =    84 (HWHW)
      ! 39 =    85 (PWPW)
      ! 40 =    86 (DWDW)
      ! 41 =    87 (GENERAL CLOUD GROUP)
      ! 42 =    88 (RH FROM LOW CLOUDS)
      ! 43 =    89 (RH FROM MIDDLE CLOUDS)
      ! 44 =    90 (RH FROM HIGH CLOUDS)
      ! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
      ! 46 =012163 (TOVS LEVEL 1B RADIANCES)
      ! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
      ! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
      ! 49 =011002(FF (WIND SPEED))                (m/s)
      ! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
      ! 51 =008001
      ! 52 =008004
      ! 53 =010051
      ! 54 =011011
      ! 55 =011012
      ! 56 =    41 (U AT 10M)
      ! 57 =    42 (V AT 10M)

      obs_get_obs_index_for_bufr_element=-1
      do indbuf=1,OBS_JPNBRELEM
         if (NVNUMB(indbuf) .eq. kbufrn ) then
            obs_get_obs_index_for_bufr_element=indbuf
            return
         endif
      enddo

      return
   end function obs_get_obs_index_for_bufr_element


   function obs_getBodyIndex_depot(obsdat) result(index)
      ! Return the next element from the current body list
      implicit none
      integer :: index
      type(struct_obs), intent(inout) :: obsdat

      index = ild_get_next_index(obsdat%body_index_list_depot)
   end function obs_getBodyIndex_depot


   function obs_getBodyIndex_private(private_list) result(index)
      ! Return the next element from the supplied private body list
      implicit none
      integer :: index
      type(struct_index_list), pointer, intent(inout) :: private_list

      index = ild_get_next_index(private_list)
   end function obs_getBodyIndex_private


   function obs_getFamily(obsdat,headerIndex,bodyIndex)
      !
      ! object: Return the family for the indicated header, or else for the
      !         indicated body.

      implicit none

      character(len=2)             :: obs_getFamily
      type(struct_obs), intent(in) :: obsdat
      integer,optional, intent(in) :: headerIndex,bodyIndex

      integer          :: headerIndex2

      if(present(headerIndex)) then
         obs_getFamily=obsdat%cfamily(headerIndex)
      elseif(present(bodyIndex)) then
         headerIndex2=obs_bodyElem_i(obsdat,OBS_HIND,bodyIndex)
         obs_getFamily=obsdat%cfamily(headerIndex2)
      else
         call obs_abort('OBS_GETFAMILY: Header or Body index must be specified!')
      endif

   end function obs_getFamily


   function obs_getHeaderIndex(obsdat) result(index)
      ! Return the next element from the current header list
      implicit none
      integer :: index
      type(struct_obs), intent(inout) :: obsdat

      index = ild_get_next_index(obsdat%header_index_list_depot)
   end function obs_getHeaderIndex


   function obs_headElem_i(obsdat,column_index,index) result(value)
      !func obs_headElem_i - Get an integer-valued observation-data element
      !                      from the Header
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (integer) value of the ObsData element with the indicated
      !              name and index.

      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: column_index
      integer         , intent(in)  :: index

      if(column_index.ge.NHDR_INT_BEG.and.column_index.le.NHDR_INT_END) then
         if(obs_columnActive_IH(column_index)) then
            value=obsdat%mobhdr(column_index)%value_i(index)
         else
            write(*,*) 'obs_headElem_i: column not active: ', &
                                              obs_ColumnNameList_IH(column_index)
            call obs_abort('abort in obs_headElem_i')
         endif
      else
         write(*,*) 'obs_headElem_i: column index out of range: ',column_index
         call obs_abort('abort in obs_headElem_i')
      endif

   end function obs_headElem_i


   function obs_headElem_r(obsdat,column_index,index) result(value)
      !func obs_headElem_r - Get a real-valued observation-data element
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (real) value of the ObsData element with the indicated
      !              name and index.

      implicit none
      real(kind=OBS_REAL)           :: value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: column_index
      integer         , intent(in)  :: index

      if(column_index.ge.NHDR_REAL_BEG.and.column_index.le.NHDR_REAL_END) then
         if(obs_columnActive_RH(column_index)) then
            value=obsdat%robhdr(column_index)%value_r(index)
         else
            write(*,*) 'obs_headElem_r: column not active: ', &
                                              obs_ColumnNameList_RH(column_index)
            call obs_abort('abort in obs_headElem_r')
         endif
      else
         write(*,*) 'obs_headElem_r: column index out of range: ',column_index
         call obs_abort('abort in obs_headElem_r')
      endif

   end function obs_headElem_r


   function obs_headerIndex_mpiglobal(obsdat,index) result(value)
      !func obs_headerIndex_mpiglobal - Get the mpiglobal header row index
      !
      !Author    . M. Buehner
      !
      !    PURPOSE:  to control access to the mpiglobal index into the "header".

      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      integer         , intent(in)  :: index

      value=obsdat%headerIndex_mpiglobal(index)

   end function obs_headerIndex_mpiglobal


   subroutine obs_headSet_i(obsdat, column_index, index, value)
      !s/r obs_headSet_i - set an integer header value in the observation object
      !
      !Author    . J.W. Blezius and M. Buehner
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      integer         , intent(in)     :: column_index
      integer         , intent(in)     :: index
      integer         , intent(in)     :: value

      if(column_index.ge.NHDR_INT_BEG.and.column_index.le.NHDR_INT_END) then
         if(obs_columnActive_IH(column_index)) then
            obsdat%mobhdr(column_index)%value_i(index) = value;
         else
            write(*,*) 'obs_headSet_i: column not active: ', &
                                              obs_ColumnNameList_IH(column_index)
            call obs_abort('abort in obs_headSet_i')
         endif
      else
         write(*,*) 'obs_headSet_i: column index out of range: ',column_index
         call obs_abort('abort in obs_headSet_i')
      endif

      if(index == (obsdat%numHeader+1)) obsdat%numHeader = obsdat%numHeader+1

   end subroutine obs_headSet_i


   subroutine obs_headSet_r(obsdat, column_index, index, value)
      !s/r obs_headSet_r - set a real header value in the observation object
      !
      !Author    . J.W. Blezius and M. Buehner
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs)   , intent(inout)  :: obsdat
      integer            , intent(in)     :: column_index
      integer            , intent(in)     :: index
      real(kind=OBS_REAL), intent(in)     :: value

      if(column_index.ge.NHDR_REAL_BEG.and.column_index.le.NHDR_REAL_END) then
         if(obs_columnActive_RH(column_index)) then
            obsdat%robhdr(column_index)%value_r(index) = value;
         else
            write(*,*) 'obs_headSet_r: column not active: ', &
                                              obs_ColumnNameList_RH(column_index)
            call obs_abort('abort in obs_headSet_r')
         endif
      else
         write(*,*) 'obs_headSet_r: column index out of range: ',column_index
         call obs_abort('abort in obs_headSet_r')
      endif

      if(index == (obsdat%numHeader+1)) obsdat%numHeader = obsdat%numHeader+1

   end subroutine obs_headSet_r


   subroutine obs_mpiDistributeIndices(obsdat)
      !
      !  Compute headerIndex_mpiglobal and bodyIndex_mpiglobal: 
      !  this determines how obs are distributed over MPI processes
      !  and is needed for converting from mpiglobal to mpilocal and vice versa.
      !  The header indices are distributes following "round robin" approach:
      !  "do headerIndex_mpiglobal=(my_mpi_id+1),obsdat%numHeader,nprocs_mpi"
      !
      !  Note: this subroutine is called before converting from mpiglobal to 
      !        mpilocal
      !
      !Author  : Bin He *ARMA/MRB  Feb. 2009
      !
      !Revision:
      !  
      !Arguments: none
      !
      !Comments:  In principle this method could have obtained nprocs_mpi and
      !           my_mpi_id by use'ing the module, mpi.  However, it queries
      !           rpn_comm for itself because the mpi module belongs to the
      !           3dvar code, whereas the present module is shared code.
      !
      implicit none
      type(struct_obs), intent(inout) :: obsdat

      integer :: headerIndex_mpiglobal,headerIndex_mpilocal
      integer ::   bodyIndex_mpiglobal,  bodyIndex_mpilocal
      integer :: numHeader_mpiLocal,numBody_mpiLocal,idata,idataend
      integer :: nprocs_mpi, my_mpi_id, my_mpi_idx_dummy, my_mpi_idy_dummy, ierr

      write(*,*) '-------- Start obs_mpiDistributeIndices ---------'

      if(obsdat%mpi_local) call obs_abort( &
                      'obs_mpiDistributeIndices: data already mpi-local, Abort!')

      ! Obtain nprocs_mpi and  my_mpi_id
      call rpn_comm_size("ALL", nprocs_mpi, ierr)
      call rpn_comm_mype(my_mpi_id, my_mpi_idx_dummy, my_mpi_idy_dummy)
      if(nprocs_mpi == 0) nprocs_mpi=1

      write(*,*) 'numHeader_mpiGlobal= ',obsdat%numHeader 

      ! first determine the number of rows of the mpilocal data and allocate
      ! index lists
      numHeader_mpiLocal=0
      numBody_mpiLocal=0
      do headerIndex_mpiglobal=(my_mpi_id+1),obsdat%numHeader,nprocs_mpi
         numHeader_mpiLocal=numHeader_mpiLocal+1
         numBody_mpilocal=numBody_mpilocal &
                         +obsdat%mobhdr(OBS_NLV)%value_i(headerIndex_mpiglobal)
      enddo
      if(numHeader_mpilocal<=0) call obs_abort( &
                                  'Zero length of headerIndex_mpiglobal,Abort!') 
      allocate(obsdat%headerIndex_mpiglobal(numHeader_mpilocal))
      if(numBody_mpiLocal<=0) call obs_abort('Zero length of BodyTag,Abort!') 
      allocate(obsdat%bodyIndex_mpiglobal(numBody_mpilocal))

      ! determine the list of header indices
      headerIndex_mpilocal=0
      do headerIndex_mpiglobal=(my_mpi_id+1),obsdat%numHeader,nprocs_mpi
         headerIndex_mpilocal=headerIndex_mpilocal+1
         obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)=headerIndex_mpiglobal
      enddo

      ! determine the corresponding list of body indices
      bodyIndex_mpilocal=0
      do headerIndex_mpilocal=1,numHeader_mpilocal
         headerIndex_mpiglobal=obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)
         idata= obsdat%mobhdr(OBS_RLN)%value_i(headerIndex_mpiglobal)
         idataend = obsdat%mobhdr(OBS_NLV)%value_i(headerIndex_mpiglobal) &
                  + idata -1 
         do bodyIndex_mpiglobal=idata,idataend 
            bodyIndex_mpilocal=bodyIndex_mpilocal+1 
            obsdat%bodyIndex_mpiglobal(bodyIndex_mpilocal) = bodyIndex_mpiglobal
         enddo
      enddo

      write(*,*) '-------- END OF obs_mpiDistributeIndices ---------'
      write(*,*) ' '
   end subroutine obs_mpiDistributeIndices


   subroutine obs_initialize(obsdat, obsColumnMode_in, header_max, body_max)
      use ObsDataColumn_mod
      !s/r obs_initialize - Set an observation-data module to a known state.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  Initialize module variables, and allocate arrays according
      !              to the parameters, header_max and body_max.
      implicit none
      ! number of header elements allocated
      integer, optional, intent(in) :: header_max
      ! total no. of body elements allocated
      integer, optional, intent(in) :: body_max
      ! instance of obsSpaceData
      type(struct_obs), intent(out) :: obsdat
      ! mode that controls subset of columns that are activated
      character(len=*), optional :: obsColumnMode_in
      character(len=12), save :: obsColumnMode_save = '            '

      logical :: lfirsttime = .true.
      integer :: nulnam,fnom,fclos,ierr
      integer :: nmxobs,ndatamx,column_index
      namelist /namdimo/nmxobs,ndatamx


      if(present(header_max)) then
         ! body_max is necessarily also present
         nmxobs = header_max
         ndatamx = body_max

      else
         nmxobs=30000                   ! These default values will be used
         ndatamx=200000                 ! if namdimo does not supply values

         nulnam=0
         ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
         read(nulnam,nml=namdimo,iostat=ierr)
         write(*,*) 'obs_initialize: reading namelist, ierr=',ierr
         write(*,nml=namdimo)
         ierr=fclos(nulnam)
      end if

      write(*,*) ' DIMENSIONS OF OBSERVATION ARRAYS:'
      write(*,*) ' numHeader_max = ',NMXOBS,'  numBody_max = ',NDATAMX

      obsdat%numHeader_max=nmxobs
      obsdat%numBody_max=ndatamx
      obsdat%numHeader = 0
      obsdat%numBody  = 0
      obsdat%mpi_local = .false.

      nullify(obsdat%headerIndex_mpiglobal)
      nullify(obsdat%bodyIndex_mpiglobal)

      if(lfirsttime) then
         lfirsttime=.false.
         ! determine which columns will be initially active
         if(present(obsColumnMode_in)) then
            obsColumnMode_save=trim(obsColumnMode_in)
         else
            obsColumnMode_save='ALL '
         endif
         write(*,*) 'OBS_INITIALIZE: obsColumnMode=',trim(obsColumnMode_save)
         if(trim(obsColumnMode_save).eq.'ALL') then

            do column_index=NHDR_INT_BEG,NHDR_INT_END
               call obs_activateColumn_IH(column_index)
            enddo
            do column_index=NHDR_REAL_BEG,NHDR_REAL_END
               call obs_activateColumn_RH(column_index)
            enddo
            do column_index=NBDY_INT_BEG,NBDY_INT_END
               call obs_activateColumn_IB(column_index)
            enddo
            do column_index=NBDY_REAL_BEG,NBDY_REAL_END
               call obs_activateColumn_RB(column_index)
            enddo

         elseif(trim(obsColumnMode_save).eq.'VAR') then

            do column_index=NHDR_INT_BEG,NHDR_INT_END
               if(column_index.ne.OBS_IDF.and.column_index.ne.OBS_IDO)  &
                  call obs_activateColumn_IH(column_index)
            enddo
            do column_index=NHDR_REAL_BEG,NHDR_REAL_END
               if(     column_index.ne.OBS_BX &
                  .and.column_index.ne.OBS_BY &
                  .and.column_index.ne.OBS_BZ &
                 ) call obs_activateColumn_RH(column_index)
            enddo
            do column_index=NBDY_INT_BEG,NBDY_INT_END
               if(     column_index.ne.OBS_KFA &
                  .and.column_index.ne.OBS_IDD &
                 ) call obs_activateColumn_IB(column_index)
            enddo
            do column_index=NBDY_REAL_BEG,NBDY_REAL_END
               if(column_index.ne.OBS_OMP6)  &
                  call obs_activateColumn_RB(column_index)
            enddo

         endif
      else
         write(*,*) 'obs_initialize: !!! WARNING WARNING WARNING!!!'
         write(*,*) 'obs_initialize: already called before, not re-activating ' &
                    // 'columns'
         write(*,*) 'obs_initialize: !!! WARNING WARNING WARNING!!!'
         if(present(obsColumnMode_in)) then
            if(trim(obsColumnMode_in).ne.trim(obsColumnMode_save)) then
               call obs_abort('obs_initialize: called with different value of ' &
                              // 'obsColumnMode than during first call: ' &
                              // trim(obsColumnMode_save) // ' .ne. ' &
                              // trim(obsColumnMode_in))
            endif
         endif
      endif

      call obs_allocate(obsdat,obsdat%numHeader_max,obsdat%numBody_max)
      call ild_initialize(obsdat%header_index_list_depot, obsdat%numHeader_max)
      call ild_initialize(obsdat%body_index_list_depot,   obsdat%numBody_max)
      return
   end subroutine obs_initialize


   logical function obs_mpiLocal(obsdat)
      !func obs_mpiLocal - returns true if the object contains only data that are
      !                    needed by the current mpi PE; false if it contains all
      !                    data.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the state of the internal variable, mpiLocal.
      !              This method exists primarily to facilitate unit tests on
      !              this module.
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_mpiLocal=obsdat%mpi_local
   end function obs_mpiLocal


   integer function obs_numBody(obsdat)
      !func obs_numBody - returns the number of observations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of observations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numBody=obsdat%numBody
   end function obs_numBody


   integer function obs_numBody_max(obsdat)
      !func obs_numBody_max - returns the number of observations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of observations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numBody_max=obsdat%numBody_max
   end function obs_numBody_max


   integer function obs_numHeader(obsdat)
      !func obs_numHeader - returns the number of stations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of stations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numHeader=obsdat%numHeader
   end function obs_numHeader


   integer function obs_numHeader_max(obsdat)
      !func obs_numHeader_max - returns the dimensioned number of stations
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of stations that is currently
      !              dimensioned in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numHeader_max=obsdat%numHeader_max
   end function obs_numHeader_max


   subroutine obs_order(obsdat)
      !
      !author: Peter Houtekamer
      !        March 2000
      !
      !object:
      !    Put an obsdat file into the order required for the
      !    sequential assimilation. Note that it is known,
      !    as a by-product of the algorithm that was used 
      !    to determine the pass and the region for each
      !    station, at what exact location (information 
      !    in OBS_ONM) each station has to be. The algorithm
      !    requires the exchange of at most mxstn headers. 
      !    A faster algorithm likely exists.
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat

      integer stn,jk
      logical sorted

      do stn=1,obsdat%numHeader
         sorted=.false.
         do while(.not.sorted)
            jk=obsdat%mobhdr(OBS_ONM)%value_i(stn)
            if (jk.eq.stn) then
               sorted=.true.
            else
               call obs_exchange_stations(obsdat,jk,stn)
            endif
         end do
      enddo

      return
   end subroutine obs_order


   subroutine obs_print(obsdat,nobsout)
      !
      ! object  - print the contents of the obsdat to an ASCII file
      !
      !author  : P. Houtekamer  February 2011
      !
      !arguments
      !     i   nobsout: unit used for printing
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer,         intent(in)    :: nobsout

      integer :: jo

      do jo=1,obsdat%numHeader
         call obs_enkf_prnthdr(obsdat,jo,nobsout)
         call obs_enkf_prntbdy(obsdat,jo,nobsout)
      enddo

      return
   end subroutine obs_print


   subroutine obs_prnt_csv(obsdat,nhdrsql,nbdysql)
      !
      ! object  - print the contents of the obsdat to csv (comma separated
      !           values) files
      !
      !author  : P. Houtekamer  February 2011
      !
      !arguments
      !     i   nhdrsql: unit used for printing header
      !     i   nbdysql: unit used for printing body
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,      intent(in)  :: nhdrsql, nbdysql

      integer :: jo

      do jo=1,obsdat%numHeader
         call obs_tosqlhdr(obsdat,jo,nhdrsql)
         call obs_tosqlbdy(obsdat,jo,nbdysql)
      enddo

      return
   end subroutine obs_prnt_csv


   subroutine obs_prntbdy(obsdat,index_header,unitout)
      !
      !**s/r PRNTBDY  - Print all data records associated with an observation
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
      !
      !     . C. Charette *ARMA/AES Mar 1996 : format statement
      !     . C. Charette *ARMA/AES Nov 1999 : Added print of flag OBS_ASS
      !       JM Belanger CMDA/SMC  Jul 2000
      !                   . 32 bits conversion
      !     . S. Pellerin ARMA, January 2008 : Remove OBS_OMN print.
      !
      !Arguments
      !     i   index_header  : index of the group of observations to be printed
      !     i   unitout       : unit number on which to print
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer         , intent(in) :: index_header
                                        ! variable output unit facilitates unit
                                        ! testing
      integer         , intent(in), optional :: unitout

      integer :: unitout_

      integer :: ipnt, idata, idata2, jdata, ivco
      character(len=13) :: ccordtyp(3)

      if(present(unitout)) then
         unitout_ = unitout
      else
         unitout_ = 6
      end if

      ccordtyp(1)='HEIGHT      :'
      ccordtyp(2)='PRESSURE    :'
      ccordtyp(3)='VCO UNDEFINED'
      !
      ! 1. General information
      !
      ipnt  = obs_headElem_i(obsdat,OBS_RLN,index_header)
      idata = obs_headElem_i(obsdat,OBS_NLV,index_header)

      if(idata.eq.1) then
         write(unitout_,fmt=9101)idata,index_header, &
                      NBDY_INT_END-NBDY_INT_BEG+1 + NBDY_REAL_END-NBDY_REAL_BEG+1
      else
         write(unitout_,fmt=9100)idata,index_header, &
                      NBDY_INT_END-NBDY_INT_BEG+1 + NBDY_REAL_END-NBDY_REAL_BEG+1
      end if
9100  format(4x,'THERE ARE ', &
         i3,1x,'DATA IN OBSERVATION RECORD NO.' &
         ,1x,i6,4x,'DATA RECORD''S LENGTH:',i6)
9101  format(4x,'THERE IS ', &
         i3,1x,'DATUM IN OBSERVATION RECORD NO.' &
         ,1x,i6,4x,'DATA RECORD''S LENGTH:',i6)
      !
      ! 2. Print all data records
      !
      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if(obs_bodyElem_i(obsdat,OBS_ASS,jdata).eq.1) then
            ivco=obs_bodyElem_i(obsdat,OBS_VCO,jdata)
            if(ivco.ne.1.and.ivco.ne.2) ivco=3
            write(unitout_,fmt=9201) idata2 &
               ,obs_bodyElem_i(obsdat,OBS_VNM ,jdata) &
               ,ccordtyp  (ivco) &
               ,obs_bodyElem_r(obsdat,OBS_PPP ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_SEM ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_POB ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_VAR ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_OMF ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_OMA ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_OMI ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_OER ,jdata) &
               ,obs_bodyElem_r(obsdat,OBS_HPHT,jdata) &
               ,obs_bodyElem_i(obsdat,OBS_FLG ,jdata) &
               ,obs_bodyElem_i(obsdat,OBS_ASS ,jdata)
         end if
      end do

9201  format(4x,'DATA NO.',i6,/,10x &
         !     ,'VARIABLE NO.:',i6,4x,'PRESSURE LEVEL:',g12.6,4x &
         ,'VARIABLE NO.:',i6,4x,a13,g12.6,4x &
         ,'REFERENCE LEVEL PRESSURE:',g12.6,4x &
         ,/,33x &
         ,'PRESSURE/GEOPOTENTIAL:',g12.6,4x &
         ,/,10x &
         ,'OBSERVE VALUE:',g23.16,15x,'FIRST-GUESS - OBSERVED VALUE:' &
         ,g23.16,4x &
         ,/,10x &
         ,'ANALYZED - OBSERVED VALUE:',g12.6,4x &
         ,'INITIALIZED - OBSERVED VALUE:',g23.16 &
         ,/,10x &
         ,'ERROR STANDARD DEVIATIONS FOR' &
         ,/,20x &
         ,'OBSERVATION:',g12.6,4x &
         ,/,20x &
         ,'FIRST-GUESS:',g12.6,4x &
         ,/,10x &
         ,'BURP FLAGS:',i6,4x,'OBS. ASSIMILATED (1-->YES;0-->NO):',i3)

      return
   end subroutine obs_prntbdy


   subroutine obs_prnthdr(obsdat,index_hd,unitout)
      !
      !**s/r PRNTHDR  - Printing of the header of an observation record
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
      !     . P. Koclas   *CMC: Format for transformed latitude has been modified
      !     .                   to handle an integer (latitude index of the first
      !     .                   latitude circle north of the observation)
      !Arguments
      !     i   index_hd  : index of the header to be printed
      !     i   unitout       : unit number on which to print
      !

      implicit none


      type(struct_obs), intent(in) :: obsdat
      integer         , intent(in) :: index_hd
                                        ! variable output unit facilitates unit
                                        ! testing
      integer         , intent(in), optional :: unitout

      integer :: unitout_

      if(present(unitout)) then
         unitout_ = unitout
      else
         unitout_ = 6
      end if

      !
      ! 1. General information
      !
      write(unitout_,fmt=9100)index_hd, &
                      NHDR_INT_END-NHDR_INT_BEG+1 + NHDR_REAL_END-NHDR_REAL_BEG+1
9100  format(//,10x,'-- OBSERVATION RECORD NO.' &
         ,1x,i6,3x,'HEADER''S LENGTH:',i6)
      !
      ! 2. PRINT HEADER'S CONTENT
      !
      write(unitout_,fmt=9200)&
          obs_headElem_i(obsdat,OBS_RLN,index_hd) &
         ,obs_headElem_i(obsdat,OBS_ONM,index_hd) &
         ,obs_headElem_i(obsdat,OBS_INS,index_hd) &
         ,obs_headElem_i(obsdat,OBS_OTP,index_hd) &
         ,obs_headElem_i(obsdat,OBS_ITY,index_hd) &
         ,obs_headElem_r(obsdat,OBS_LAT,index_hd) &
         ,obs_headElem_r(obsdat,OBS_LON,index_hd) &
         ,obs_headElem_i(obsdat,OBS_DAT,index_hd) &
         ,obs_headElem_i(obsdat,OBS_ETM,index_hd) &
         ,obs_elem_c(obsdat,'STID',index_hd)      &
         ,obs_headElem_r(obsdat,OBS_ALT,index_hd) &
         ,obs_headElem_i(obsdat,OBS_NLV,index_hd) &
         ,obs_headElem_i(obsdat,OBS_OFL,index_hd) &
         ,obs_headElem_i(obsdat,OBS_ST1,index_hd)

9200  format(6x,'Position within ROBDATA:',i6,1x,'OBS. NUMBER:',i6,1x &
         ,'INSTR. ID:',i6,1x,'OBS. TYPE:',i6,1x &
         ,'INSTR./RETR. TYPE:',i6,1x &
         ,/,6x &
         ,'OBSERVATION LOCATION. (LAT,LON):',2(f12.6,1x) &
         ,'DATE:',i12,1x,'EXACT TIME: ',i6,1x &
         ,/,6x &
         ,'STATION ID:',a9,1x &
         ,'STATION''S ALTITUDE:',g12.6,1x &
         ,'NUMBER OF DATA:',i6,1x &
         ,/,6x &
         ,'REPORT STATUS:',i6,5x,'REPORT STATUS 2:',i6,1x &
         ,/,6x &
         )

      return
   end subroutine obs_prnthdr


   subroutine obs_read(obsdat,hx,nobshdr,nobsbdy,nobshx)
      !
      !authors Peter Houtekamer and Herschel Mitchell October 1999
      !
      !object: read the obsdat structure with observational information from
      !        unformatted files.  The files have been written by obs_write().
      !
      !   input: 
      !      nobshdr: unit number of the file with obsdat header info.
      !      nobsbdy: unit number of the file with obsdat body info.
      !      nobshx:  unit number of the file with hx (-1 if not used)
      !   output:
      !      mobhdr,robhdr,cstnid:             station header information
      !      mobdata,robdata,hx:               observation data
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat  ! the OBSDAT being prep'ed
      integer,      intent(in)  :: nobshdr,nobsbdy,nobshx
      real(8),      intent(out) :: hx(:,:)

      integer  :: i,ifirst,ilast,iobscur,istn,j,k,myip,nens
      integer  :: column_index,active_index

      obsdat%mpi_local = .false.

      if (nobshx.eq.-1) then
         nens=0
      else
         nens=size(hx,1)
      endif
      column_index=obs_columnIndexFromActiveIndex_RB(1) ! get index of 1st active column
      obsdat%numBody=size(obsdat%robdata(column_index)%value_r,1)
      column_index=obs_columnIndexFromActiveIndex_RH(1) ! get index of 1st active column
      obsdat%numHeader=size(obsdat%robhdr(column_index)%value_r,1)

      iobscur=0

      ! read stations

      readstn: do istn=1,obsdat%numHeader
         read(nobshdr,end=288,err=288) &
            (obsdat%mobhdr(obs_columnIndexFromActiveIndex_IH(i))%value_i(istn),&
                                                 i=1,obs_numActiveColumn_IH()),&
            (obsdat%robhdr(obs_columnIndexFromActiveIndex_RH(j))%value_r(istn),&
                                                 j=1,obs_numActiveColumn_RH()),&
            obsdat%cstnid(istn), &
            obsdat%cfamily(istn), &
            obsdat%datestamp

         if (istn.eq.1) then 
            obsdat%mobhdr(OBS_RLN)%value_i(istn)=1
         else
            obsdat%mobhdr(OBS_RLN)%value_i(istn) &
               =obsdat%mobhdr(OBS_RLN)%value_i(istn-1) &
               +obsdat%mobhdr(OBS_NLV)%value_i(istn-1)
         endif
         iobscur=iobscur+obsdat%mobhdr(OBS_NLV)%value_i(istn)
         ! now read the observations:
         ifirst=obsdat%mobhdr(OBS_RLN)%value_i(istn)
         ilast=obsdat%mobhdr(OBS_RLN)%value_i(istn) &
              +obsdat%mobhdr(OBS_NLV)%value_i(istn)-1
         do i=ifirst,ilast
            read(nobsbdy) &
               (obsdat%mobdata(obs_columnIndexFromActiveIndex_IB(j))%value_i(i),&
                                                  j=1,obs_numActiveColumn_IB()),&
               (obsdat%robdata(obs_columnIndexFromActiveIndex_RB(k))%value_r(i),&
                                                  k=1,obs_numActiveColumn_RB())
         enddo
         if (nens.gt.0) then
            do i=ifirst,ilast
               read(nobshx)  (hx(j,i),j=1,nens)
            enddo
         endif
      enddo readstn

      if (iobscur.ne.obsdat%numBody) then
         write(*,*) 'OBS_READ: the number of observations ', &
            iobscur,' should equal ',obsdat%numBody
         call obs_abort('OBS_READ: the number of references in the header does '&
                        // 'not matche the body size')
      endif
288   write(*,*) 'file is now empty'
      write(*,*) 'close nobshdr which is on unit: ',nobshdr
      close(nobshdr)
      write(*,*) 'close nobsbdy which is on unit: ',nobsbdy
      close(nobsbdy)
      if (nens.gt.0) then
         write(*,*) 'close nobshx which is on unit: ',nobshx
         close(nobshx)
      endif
      write(*,*) 'exit from obs_read'
      return

   end subroutine obs_read


   subroutine obs_readstns(obsdat,myip,ipasscur,iregcur,nobshdr,nobsbdy,np, &
                           mxstn,mxobs)
      !
      ! obs_readstns
      !
      !authors Peter Houtekamer and Herschel Mitchell October 1999
      !
      !object: read the stations for one analysis pass, from unformatted files,
      !        and store them in an ObsSpaceData_mod object.  The files have been
      !        written by obs_write().
      !        (this routine is intended for the master mpi process,
      !         other processes exit immediately)
      !
      !   input: 
      !      myip:     number of the process
      !      ipasscur: number of the current analysis pass (i.e. batch)
      !      nobshdr:  unit number of the file with obsdat header info.
      !      nobsbdy:  unit number of the file with obsdat body info.
      !      np   :    total number of processes used in MPI. 
      !   output:
      !      iregcur: number of the region to be done for this pass. 
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer,          intent(in)  :: ipasscur,myip,nobshdr,nobsbdy,np,mxstn, &
                                       mxobs
      integer,          intent(out) :: iregcur

      integer :: i,idata,ifirst,ilast,ipass,ireg,j,k,column_index

      real(kind=OBS_REAL), save :: robhdr_1(NHDR_REAL_BEG:NHDR_REAL_END)
      integer,             save :: mobhdr_1(NHDR_INT_BEG:NHDR_INT_END)
      character(len=12),   save :: cstnid_1
      character(len=2),    save :: cfamily_1
      integer,             save :: datestamp_1
      logical,             save :: empty  = .false., &
                                   hasone = .false.

      if (myip.ne.0) return

      if (empty) then
         write(*,*) 'file is empty'
         return
      endif

      iregcur=1

      ! read stations for this pass of the sequential algorithm

      ! hasone indicates whether a station has been read without being
      ! inserted into obsdat. This occurs after the stations for one pass have
      ! been read. In this case one should not read a new station 
      ! but first insert the saved one.

      do while( get_one() )
         ireg=mobhdr_1(OBS_REG)
         ipass=mobhdr_1(OBS_PAS)

         if ((ipass /= ipasscur)) then
            if(obs_numHeader(obsdat) == 0) then
               write(6,*)"ERROR"
               write(6,*)"ERROR:  In obs_readstns(), the next"
               write(6,*)"ERROR:  OBS_PAS value, ", ipass, "does not match the"
               write(6,*)"ERROR:  current  pass, ", ipasscur,".  Exiting."
               write(6,*)"ERROR"
               call obs_abort('OBS_READSTNS: ipass /= ipasscur')
            end if
            exit
         end if

         ! default assignment of all input variables to obsdat.
         obsdat%numHeader=obsdat%numHeader+1
         idata=obsdat%numHeader
         do column_index=NHDR_INT_BEG,NHDR_INT_END
            if(obs_columnActive_IH(column_index))  &
               obsdat%mobhdr(column_index)%value_i(idata)=mobhdr_1(column_index)
         enddo
         do column_index=NHDR_REAL_BEG,NHDR_REAL_END
            if(obs_columnActive_RH(column_index))  &
               obsdat%robhdr(column_index)%value_r(idata)=robhdr_1(column_index)
         enddo
         obsdat%cstnid(idata)  =cstnid_1
         obsdat%cfamily(idata) =cfamily_1
         obsdat%datestamp      =datestamp_1

         ! determine which process will handle this station.
         ! the corresponding scatter operation is in program scattercma.
         obsdat%mobhdr(OBS_IP)%value_i(idata) &
                                   =mod(obsdat%mobhdr(OBS_ONM)%value_i(idata),np)

         ireg=obsdat%mobhdr(OBS_REG)%value_i(idata)
         if (iregcur.ne.ireg) then
            iregcur=ireg
         endif

         if (idata.eq.1) then 
            obsdat%mobhdr(OBS_RLN)%value_i(idata)=1
         else
            obsdat%mobhdr(OBS_RLN)%value_i(idata) &
               =obsdat%mobhdr(OBS_RLN)%value_i(idata-1) &
               +obsdat%mobhdr(OBS_NLV)%value_i(idata-1)
         endif

         ! now read the observations:
         ifirst=obsdat%mobhdr(OBS_RLN)%value_i(idata)
         ilast=obsdat%mobhdr(OBS_RLN)%value_i(idata) &
              +obsdat%mobhdr(OBS_NLV)%value_i(idata)-1
         do i=ifirst,ilast
            read(nobsbdy) &
              (obsdat%mobdata(obs_columnIndexFromActiveIndex_IB(j))%value_i(i), &
                                                 j=1,obs_numActiveColumn_IB()), &
              (obsdat%robdata(obs_columnIndexFromActiveIndex_RB(k))%value_r(i), &
                                                 k=1,obs_numActiveColumn_RB())
                                        ! Make HIND point to new header index
            obsdat%mobdata(OBS_HIND)%value_i(i)=idata
         enddo
         obsdat%numBody = obsdat%numBody + ilast - ifirst + 1

         hasone=.false.

         ! go back to read the next station
      end do

      return


   contains
      logical function get_one()
         integer :: ierr

         if (.not. hasone) then 
            read(nobshdr,iostat=ierr) &
                                   (mobhdr_1(i),i=NHDR_INT_BEG, NHDR_INT_END),&
                                   (robhdr_1(j),j=NHDR_REAL_BEG,NHDR_REAL_END), &
                                   cstnid_1, &
                                   cfamily_1, &
                                   datestamp_1
            if(ierr == 0) then
               hasone = .true.
            else
               hasone = .false.
               empty=.true.
               write(*,*) 'file is now empty'
               close(nobshdr)
               close(nobsbdy)
            end if ! ierr
         end if ! hasone

         get_one = hasone
         return
      end function get_one

   end subroutine obs_readstns


   subroutine obs_reduceToMpiLocal(obsdat)
      !
      !**s/r obs_reduceToMpiLocal - re-construct observation data object by
      !                             giving local Obs TAG. 
      !
      !Author    . Bin He (ARMA/MRB )
      !
      !revision:
      !      PURPOSE:  To retain in the observation object only those data that
      !                are pertinent to the present mpi processor, i.e. convert
      !                from mpiglobal to mpilocal.
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      ! Declare Local Variables
      character(len=12),allocatable,dimension(:) :: cstnid_tmp
      character(len=2), allocatable,dimension(:) :: cfamily_tmp
      real(OBS_REAL),allocatable,dimension(:,:) :: robhdr_tmp
      real(OBS_REAL),allocatable,dimension(:,:) :: robdata_tmp

      integer,allocatable,dimension(:,:) :: mobhdr_tmp,mobdata_tmp

      integer :: i,j,startindx,endindx 
      integer :: numHeader_mpilocal,numHeader_mpiglobal
      integer ::   numBody_mpilocal,  numBody_mpiglobal
      integer :: bodyIndex_mpilocal,bodyIndex_mpiglobal
      integer :: headerIndex_mpilocal,headerIndex_mpiglobal
      integer :: idataend,jj,ifamid,istart,idata,column_index,active_index
      logical :: lfirst 
      !!---------------------------------------------------------------
      WRITE(*,*) '============= Enter obs_reduceToMpiLocal =============='

      if(obsdat%mpi_local)then
         call obs_abort('OBS_REDUCETOMPILOCAL() has been called, but the ' &
                        // 'obsSpaceData object is already in mpi-local state')
      end if

      ! compute the mpilocal lists of indices into the mpiglobal data
      call obs_mpiDistributeIndices(obsdat)

      ! calculate the size of the local obs data  
      numHeader_mpilocal=size(obsdat%headerIndex_mpiglobal) 
      numBody_mpiLocal=0
      do headerIndex_mpilocal=1,numHeader_mpilocal
         headerIndex_mpiglobal=obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)
         idata=obsdat%mobhdr(OBS_NLV)%value_i(headerIndex_mpiglobal)
         numBody_mpiLocal = numBody_mpiLocal + idata
      enddo

      numHeader_mpiGlobal = obs_numHeader(obsdat)
      numBody_mpiGlobal   = obs_numBody(obsdat)

      ! allocate temporary arrays to hold mpilocal data
      allocate(cfamily_tmp(          numHeader_mpiLocal)) 
      allocate( cstnid_tmp(          numHeader_mpiLocal)) 
      allocate(robhdr_tmp(obs_numActiveColumn_RH(),numHeader_mpilocal)) 
      allocate(mobhdr_tmp(obs_numActiveColumn_IH(),numHeader_mpilocal)) 
      allocate(robdata_tmp(obs_numActiveColumn_RB(),numBody_mpilocal))
      allocate(mobdata_tmp(obs_numActiveColumn_IB(),numBody_mpilocal)) 

      ! copy the mpilocal data to temporary arrays: header-level data
      do headerIndex_mpilocal=1,numHeader_mpilocal 
         headerIndex_mpiglobal=obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)

         do active_index=1,obs_numActiveColumn_RH()
            column_index=obs_columnIndexFromActiveIndex_RH(active_index)
            robhdr_tmp(active_index,headerIndex_mpilocal)= &
                       obsdat%robhdr(column_index)%value_r(headerIndex_mpiglobal)
         enddo

         do active_index=1,obs_numActiveColumn_IH()
            column_index=obs_columnIndexFromActiveIndex_IH(active_index)
            mobhdr_tmp(active_index,headerIndex_mpilocal)= &
                       obsdat%mobhdr(column_index)%value_i(headerIndex_mpiglobal)
         enddo

         cstnid_tmp (headerIndex_mpilocal) =obsdat%cstnid (headerIndex_mpiglobal)
         cfamily_tmp(headerIndex_mpilocal) =obsdat%cfamily(headerIndex_mpiglobal)

                                        ! Make RLN point to local data
         if(headerIndex_mpilocal== 1) then
            mobhdr_tmp(obs_activeIndexFromColumnIndex_IH(OBS_RLN),1) = 1
         else
            mobhdr_tmp(obs_activeIndexFromColumnIndex_IH(OBS_RLN), &
                                                        headerIndex_mpilocal) = &
                mobhdr_tmp(obs_activeIndexFromColumnIndex_IH(OBS_RLN), &
                                                        headerIndex_mpilocal-1) &
              + mobhdr_tmp(obs_activeIndexFromColumnIndex_IH(OBS_NLV), &
                                                        headerIndex_mpilocal-1) 
         endif
      enddo

      ! copy the mpilocal data to temporary arrays: body-level data
      bodyIndex_mpilocal=0 
      do headerIndex_mpilocal=1,numHeader_mpilocal
         headerIndex_mpiglobal=obsdat%headerIndex_mpiglobal(headerIndex_mpilocal)
 
                                        ! Make HIND point to local header
         idata    = obsdat%mobhdr(OBS_RLN)%value_i(headerIndex_mpiglobal)
         idataend = obsdat%mobhdr(OBS_NLV)%value_i(headerIndex_mpiglobal)+idata-1
         do bodyIndex_mpiglobal=idata,idataend 
            bodyIndex_mpilocal=bodyIndex_mpilocal+1 
            do active_index=1,obs_numActiveColumn_RB()
               column_index=obs_columnIndexFromActiveIndex_RB(active_index)
               robdata_tmp(active_index,bodyIndex_mpilocal)= &
                        obsdat%robdata(column_index)%value_r(bodyIndex_mpiglobal)
         enddo

            do active_index=1,obs_numActiveColumn_IB()
               column_index=obs_columnIndexFromActiveIndex_IB(active_index)
               mobdata_tmp(active_index,bodyIndex_mpilocal)= &
                        obsdat%mobdata(column_index)%value_i(bodyIndex_mpiglobal)
      enddo

            mobdata_tmp(obs_activeIndexFromColumnIndex_IB(OBS_HIND), &
                        bodyIndex_mpilocal) = headerIndex_mpilocal
         enddo
      enddo

      ! destroy object's mpiglobal data and allocate mpilocal data
      obsdat%numHeader=numHeader_mpiLocal
      obsdat%numBody=numBody_mpiLocal
      call obs_deallocate(obsdat)
      call obs_allocate(obsdat,obsdat%numHeader,obsdat%numBody)

      ! copy all data from temporary arrays to object's arrays
      obsdat%cfamily(:  )=cfamily_tmp(:  ) 
      obsdat%cstnid (:  )= cstnid_tmp(:  )
      do active_index=1,obs_numActiveColumn_RH()
         column_index=obs_columnIndexFromActiveIndex_RH(active_index)
         obsdat%robhdr(column_index)%value_r(:)=robhdr_tmp(active_index,:)
      enddo
      do active_index=1,obs_numActiveColumn_IH()
         column_index=obs_columnIndexFromActiveIndex_IH(active_index)
         obsdat%mobhdr(column_index)%value_i(:)=mobhdr_tmp(active_index,:) 
      enddo
      do active_index=1,obs_numActiveColumn_RB()
         column_index=obs_columnIndexFromActiveIndex_RB(active_index)
         obsdat%robdata(column_index)%value_r(:)=robdata_tmp(active_index,:) 
      enddo
      do active_index=1,obs_numActiveColumn_IB()
         column_index=obs_columnIndexFromActiveIndex_IB(active_index)
         obsdat%mobdata(column_index)%value_i(:)=mobdata_tmp(active_index,:) 
      enddo

      ! deallocate temporary arrays
      deallocate(cfamily_tmp)
      deallocate(cstnid_tmp)
      deallocate(robhdr_tmp)
      deallocate(mobhdr_tmp)
      deallocate(robdata_tmp)
      deallocate(mobdata_tmp)

      obsdat%mpi_local = .true.

      write(*,*) obsdat%numHeader,numHeader_mpiGlobal,obsdat%numBody, &
                 numBody_mpiGlobal
      write(*,*) '============= Leave obs_reduceToMpiLocal =============='

      return
   end subroutine obs_reduceToMpiLocal


   subroutine obs_select(obsdat,hx,obs_sel,hx_sel,zhamin,zhamax,nens,nobsout)
      !
      ! object  - select only the observations with zhamin < lop(P) <= zhamax.   
      !
      !author  : Peter Houtekamer
      !     January 2012: created using obs_clean as an example
      !
      !arguments
      !     obsdat,hx        : input obsdat and interpolated values
      !     obs_sel,hx_sel: selected obsdat and interpolated values
      !     zhamin,zhamax : range of zha values to be selected.
      !     nens          : number of ensemble members
      !     nobsout       : unit number for the ASCII output
      !
      implicit none

      type (struct_obs), intent(in) :: obsdat
      type (struct_obs), intent(inout) :: obs_sel

      real(8),      intent(in) :: hx(:,:),zhamin,zhamax
      real(8),      intent(out) :: hx_sel(:,:)

      integer, intent(in)    :: nens, nobsout

      integer :: iaccept,idata,ipnt,iwrite
      integer :: jdata,kobs,kobsout,column_index

      if(obsdat%mpi_local)then
         call obs_abort("obs_select() is not equipped to handle the case, mpi_local=.true.")
      end if

      write(nobsout,'(1x,A,I7)')'stations prior to selection: ', obsdat%numHeader
      write(*,*) 'enter obs_select'

      kobsout=0 
      iwrite=0
      stations: do kobs=1,obsdat%numHeader
         ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kobs)
         idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)
         iaccept=0
         observations: do jdata = ipnt, ipnt + idata - 1
            ! To remove observations that are not in the desired vertical layer 
            if ((obsdat%robdata(OBS_ZHA)%value_r(jdata) .gt. zhamin).and. &
               (obsdat%robdata(OBS_ZHA)%value_r(jdata) .le. zhamax)) then
               iaccept=iaccept+1
               iwrite=iwrite+1
               do column_index=NBDY_INT_BEG,NBDY_INT_END
                  if(obs_columnActive_IB(column_index))  &
                     obs_sel%mobdata(column_index)%value_i(iwrite) &
                                     =obsdat%mobdata(column_index)%value_i(jdata)
               enddo
               do column_index=NBDY_REAL_BEG,NBDY_REAL_END
                  if(obs_columnActive_RB(column_index))  &
                     obs_sel%robdata(column_index)%value_r(iwrite) &
                                     =obsdat%robdata(column_index)%value_r(jdata)
               enddo
               hx_sel(1:nens,iwrite)=hx(1:nens,jdata)
            endif
         enddo observations
         ! adjust obs_sel%robhdr 
         if (iaccept.gt.0) then
            kobsout=kobsout+1
            do column_index=NHDR_INT_BEG,NHDR_INT_END
               if(obs_columnActive_IH(column_index)) &
                  obs_sel%mobhdr(column_index)%value_i(kobsout) &
                                       =obsdat%mobhdr(column_index)%value_i(kobs)
            enddo
            do column_index=NHDR_REAL_BEG,NHDR_REAL_END
               if(obs_columnActive_RH(column_index)) &
                  obs_sel%robhdr(column_index)%value_r(kobsout) &
                                       =obsdat%robhdr(column_index)%value_r(kobs)
            enddo
            obs_sel%cstnid(kobsout)=obsdat%cstnid(kobs)
            obs_sel%cfamily(kobsout)=obsdat%cfamily(kobs)
            obs_sel%mobhdr(OBS_NLV)%value_i(kobsout)=iaccept
            obs_sel%mobhdr(OBS_RLN)%value_i(kobsout)=iwrite-iaccept+1
         endif
      enddo stations
      obs_sel%numHeader=kobsout
      obs_sel%numBody = iwrite
      obs_sel%mpi_local = .false.
      obs_sel%datestamp = obsdat%datestamp

      write(nobsout, '(1x, A, 2F20.15)') &
                 'after selection of observations in the range: ', zhamin, zhamax
      write(nobsout,'(1x,A,I7)') &
         'number of stations containing valid data      ',obs_sel%numHeader
      write(nobsout,'(1x,A,I7)') & 
         'number of observations now in the obsdat file ',obs_sel%numBody

   end subroutine obs_select


   subroutine obs_set_c(obsdat, name, index, value)
      !s/r obs_set_c - set a character(len=9) in the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      character(len=*), intent(in)     :: name
      integer         , intent(in)     :: index
      character(len=*), intent(in)     :: value

      select case (trim(name))
      case ('STID'); obsdat%cstnid (index) = value
         if(Index == (obsdat%numHeader+1)) obsdat%numHeader = obsdat%numHeader+1

      case default
         write(*,*)"ERROR writing:  ", trim(name)," is not a character(len=9) ",&
                   "observation."
      end select
   end subroutine obs_set_c


   subroutine obs_set_current_body_list_from_family(obsdat, family, &
      list_is_empty, current_list)
      ! Create an index list from the indicated family and place it in the body
      ! depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      character(len=*), intent(in) :: family
      logical, intent(out), optional :: list_is_empty
      type(struct_index_list), pointer, intent(out), optional :: current_list

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: index_header, list, list_index, item_index
      integer :: first, last

      nullify(index_list)
      depot => obsdat%body_index_list_depot

      ! Search for an existing list
      if(present(current_list)) then
         if(associated(current_list)) then
            if (current_list%family == family) then
               index_list => current_list
            end if ! family matches
         end if ! associated

      else ! not present(current_list)
         do list = 1, NUMBER_OF_LISTS
            if (depot%index_lists(list)%family == family) then
               index_list => depot%index_lists(list)
               exit                     ! Don't look any further
            end if
         end do
      end if

      ! If the list does not already exist
      if (.not. associated(index_list)) then

         ! Acquire memory for the list
         if(present(current_list)) then
            ! This is an OMP thread. Re-use the same physical memory for the list
            index_list => ild_get_empty_index_list(depot, current_list)
         else
            index_list => ild_get_empty_index_list(depot)
         end if

         ! Initialize the new list
         index_list%family = family
         index_list%header = -99        ! not used

         !
         ! Populate the li-st
         !

         ! Loop over all header indices of the family
         list_index = 0
         call obs_set_current_header_list(obsdat, family)
         HEADER: do
            index_header = obs_getHeaderIndex(obsdat)
            if (index_header < 0) exit HEADER
            first= obs_headElem_i(obsdat,OBS_RLN,index_header)
            last = obs_headElem_i(obsdat,OBS_NLV,index_header) + first - 1
            do item_index=first,last    ! For each item indicated in the header
               ! Add the item_index to the list
               list_index = list_index + 1
               index_list%indices(list_index) = item_index
            end do
         end do HEADER
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list

      if(present(list_is_empty)) then
         ! Return whether the list is empty
         list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
      end if

      if(present(current_list)) then
         ! Return a pointer to the current list
         current_list => index_list
      end if
   end subroutine obs_set_current_body_list_from_family


   subroutine obs_set_current_body_list_from_header(obsdat, header, &
      list_is_empty, current_list)
      ! Create an index list from the indicated header and place it in the body
      ! depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      integer, intent(in) :: header
      logical, intent(out), optional :: list_is_empty
      type(struct_index_list), pointer, intent(out), optional :: current_list

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: list, list_index, item_index
      integer :: first, last

      nullify(index_list)
      depot => obsdat%body_index_list_depot

      ! Search for an existing list
      if(present(current_list)) then
         if(associated(current_list)) then
            if (current_list%header == header) then
               index_list => current_list
            end if ! header matches
         end if ! associated

      else ! not present(current_list)
         do list = 1, NUMBER_OF_LISTS
            if (depot%index_lists(list)%header == header) then
               index_list => depot%index_lists(list)
!               write(*,*) 'found list:',list
!               write(*,*) 'list=',index_list%indices(1:5)
               exit                     ! Don't look any further
            end if
         end do
      end if

      ! If the list does not already exist
      if (.not. associated(index_list)) then

         ! Acquire memory for the list
         if(present(current_list)) then
            ! This is an OMP thread. Re-use the same physical memory for the list
            index_list => ild_get_empty_index_list(depot, current_list)
         else
!            write(*,*) 'generate an empty list'
            index_list => ild_get_empty_index_list(depot)
         end if

         ! Initialize the new list
         index_list%family = 'xx'       ! not used
         index_list%header = header

         ! Populate the list
         first= obs_headElem_i(obsdat,OBS_RLN,header)
         last = obs_headElem_i(obsdat,OBS_NLV,header) + first - 1
!         write(*,*) 'populating list:',first,last,header
         list_index = 0
         do item_index=first,last       ! For each item indicated in the header
            ! Add the item_index to the list
            list_index = list_index + 1
            index_list%indices(list_index) = item_index
         end do
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
!         write(*,*) 'resulting list=',index_list%indices(1:5)
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list

      if(present(list_is_empty)) then
         ! Return whether the list is empty
         list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
      end if

      if(present(current_list)) then
         ! Return a pointer to the current list
         current_list => index_list
      end if
   end subroutine obs_set_current_body_list_from_header


   subroutine obs_set_current_header_list(obsdat, family)
      ! Find or create an index list for the indicated family and place it in the
      ! header depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      character(len=*), intent(in) :: family

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: list, list_index, item_index

      nullify(index_list)
      depot => obsdat%header_index_list_depot

      ! Search for an existing list
      do list = 1, NUMBER_OF_LISTS
         if (depot%index_lists(list)%family == family) then
            index_list => depot%index_lists(list)
            index_list%current_element=0! Start at the beginning of the list
            exit                        ! Don't look any further
         end if
      end do

      ! If the list does not already exist
      if (.not. associated(index_list)) then
         ! Create a new list
         index_list => ild_get_empty_index_list(depot)
         index_list%family = family
         index_list%header = -1

         ! Populate the list
         list_index = 0
         do item_index = 1, obsdat%numHeader
            ! If the station is of the right family
            if(obsdat%cfamily(item_index) == family) then
               ! Add the item_index to the list
               list_index = list_index + 1
               index_list%indices(list_index) = item_index
            end if
         end do
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list
   end subroutine obs_set_current_header_list


   subroutine obs_set_datestamp(obsdat,datestamp)
      implicit none
      !
      ! object: to control access to the observation object.  Sets the date
      !         stamp of the obsdat object to the indicated value.

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: datestamp

      obsdat%datestamp = datestamp

   end subroutine obs_set_datestamp


   subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
      implicit none
      !
      ! object: Set to the indicated value the family for the indicated header,
      !         or else for the indicated body.

      type(struct_obs), intent(inout) :: obsdat
      character(len=*), intent(in)    :: Family_in
      integer,optional, intent(in)    :: headerIndex,bodyIndex

      integer          :: headerIndex2

      if(present(headerIndex)) then
         obsdat%cfamily(headerIndex)=Family_in
         if(headerIndex.eq.(obsdat%numHeader+1)) then
            obsdat%numHeader=obsdat%numHeader+1
         endif
      elseif(present(bodyIndex)) then
         headerIndex2=obs_bodyElem_i(obsdat,OBS_HIND,bodyIndex)
         obsdat%cfamily(headerIndex2)=Family_in
         if(headerIndex2.eq.(obsdat%numHeader+1)) then
            obsdat%numHeader=obsdat%numHeader+1
         endif
      else
         call obs_abort('OBS_SETFAMILY: Header or Body index must be specified!')
      endif

   end subroutine obs_setFamily


   subroutine obs_status(obsdat, obs_full, numstns_out, numobs_out, kulout)
      !func obs_status - obtain basic status of the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  returns the values of the object's status variables 
      !
      type (struct_obs), intent(in) :: obsdat
      logical, intent(out) :: obs_full
      integer, intent(out) :: numstns_out, numobs_out
      integer, intent(in)  :: kulout


      ! PLH   if ( obsdat%numHeader .ge. nmxobs ) then
      ! PLH     if ( obsdat%numBody .ge. ndatamx .or. obsdat%numHeader .ge. nmxobs ) then
      if (     obsdat%numBody   .ge. obsdat%numBody_max &
          .or. obsdat%numHeader .ge. obsdat%numHeader_max) then
         write(kulout,*) ' OBSDAT FILE FULL'
         obs_full = .true.

      else
         obs_full = .false.
      end if

      numstns_out = obsdat%numHeader
      numobs_out  = obsdat%numBody
   end subroutine obs_status


   subroutine obs_swapVarOmf(obsdat)
      !
      ! object: exchange the values in the VAR and OMF columns.

      implicit none

      type(struct_obs), intent(inout) :: obsdat

      real(kind=OBS_REAL) :: temp_robdata
      integer             :: index_body

      !    temp = OBS_VAR
      !    OBS_VAR = OBS_OMF
      !    OBS_OMF = temp

      do index_body=1,obsdat%numBody 
         temp_robdata=obsdat%robdata(OBS_VAR)%value_r(index_body)
         obsdat%robdata(OBS_VAR)%value_r(index_body) &
                                     =obsdat%robdata(OBS_OMF)%value_r(index_body)
         obsdat%robdata(OBS_OMF)%value_r(index_body)=temp_robdata
      enddo

   end subroutine obs_swapVarOmf


   subroutine obs_tosqlbdy(obsdat,kobs,kulout)
      !
      !s/r obs_tosqlbdybdy  - print all data records associated with a station
      !
      !authors  : Peter Houtekamer and Chantal Cote, July 2003. 
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for printing
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,      intent(in) :: kobs,kulout

      integer :: idata,idata2,ihpht,ioer,ioma,iomp,iomp6,ipnt,ippp, &
         ivnm,ivnmc,istat,ivar,jdata,jtrans,var3d
      integer  :: mrbcol,mrbcvt
      real     :: rppp
      external :: mrbcol,mrbcvt

      ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kobs)
      idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)

      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if (btest(obsdat%mobdata(OBS_FLG)%value_i(jdata),12)) then
            var3d=1
         else
            var3d=0
         endif

         ippp=obsdat%robdata(OBS_PPP)%value_r(jdata)
         rppp=float(ippp)

         ivnm=obsdat%mobdata(OBS_VNM)%value_i(jdata)
         istat=mrbcol(ivnm,ivnmc,1)
         istat=mrbcvt(ivnmc,ivar,obsdat%robdata(OBS_VAR)%value_r(jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,iomp,obsdat%robdata(OBS_OMP)%value_r(jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,iomp6,obsdat%robdata(OBS_OMP6)%value_r(jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ioma,obsdat%robdata(OBS_OMA)%value_r(jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ioer,obsdat%robdata(OBS_OER)%value_r(jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ihpht,obsdat%robdata(OBS_HPHT)%value_r(jdata),1,1,1,1)
         jtrans=obsdat%mobdata(OBS_VCO)%value_i(jdata)
         if (jtrans .eq. 1) then
            istat=mrbcol(7001,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         elseif (jtrans .eq. 2) then
            istat=mrbcol(7004,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         elseif (jtrans .eq. 3) then
            istat=mrbcol(2150,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         else 
            call obs_abort('OBS_TOSQLBDY: attention, mauvaise coordonnee verticale')
            ippp=-1
         endif

         write(kulout,fmt=9201) kobs,idata2, &
            obsdat%mobdata(OBS_VNM)%value_i(jdata),ippp, &
            obsdat%mobdata(OBS_ASS)%value_i(jdata), &
            ivar,iomp,iomp6,ioma,ioer,ihpht,var3d,  &
            obsdat%robdata(OBS_ZHA)%value_r(jdata), &
            obsdat%mobdata(OBS_VCO)%value_i(jdata), &
            obsdat%mobdata(OBS_FLG)%value_i(jdata)
      enddo

9201  format(1x,i9,',',i3,2(',',i6),',',i3,6(',',i8), &
         ',',i2,',',f10.3,',',i2,',',i12)

      return
   end subroutine obs_tosqlbdy


   subroutine obs_tosqlhdr(obsdat,kobs,kulout)
      !
      !s/r obs_tosqlhdr  - printing of the header of a station record for sql
      !
      !author  : Peter Houtekamer and Chantal Cote, July 2003.
      !
      ! Revision July 2005 by Peter Houtekamer. Removed ncmblk from the OBSDAT.
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for output
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: kobs,kulout

      integer :: ialt,idburp,ii,ilon,ilat,iout,jtrans
      character(len=12) :: ccstnid
      real(8) :: torad 

      torad=4.d0*atan(1.d0)/180.d0

      ccstnid=obsdat%cstnid(kobs)

      ! Replace occasional appearance of "," by "b" in CCSTNID to avoid problem
      ! when converting this output to sqlite. - Xingxiu Deng, March 2009
      do
         iout=index(ccstnid,',')
         if (iout .gt. 0 ) then
            ccstnid(iout:iout)='b'
         else
            exit
         endif
      enddo

      ialt=obsdat%robhdr(OBS_ALT)%value_r(kobs)+400
      ilon=nint((obsdat%robhdr(OBS_LON)%value_r(kobs)/torad)*100)
      ilat=nint((obsdat%robhdr(OBS_LAT)%value_r(kobs)/torad+90.0)*100)

      idburp=mod(obsdat%mobhdr(OBS_ITY)%value_i(kobs),1000)
      write(kulout,fmt=9200) kobs,CCSTNID, &
         obsdat%mobhdr(OBS_DAT)%value_i(kobs), &
         obsdat%mobhdr(OBS_ETM)%value_i(kobs), &
         obsdat%mobhdr(OBS_RLN)%value_i(kobs), &
         obsdat%mobhdr(OBS_ONM)%value_i(kobs), &
         obsdat%mobhdr(OBS_INS)%value_i(kobs), &
         obsdat%mobhdr(OBS_OTP)%value_i(kobs), &
         idburp,ilat,ilon,ialt,                &
         obsdat%mobhdr(OBS_NLV)%value_i(kobs), &
         obsdat%mobhdr(OBS_OFL)%value_i(kobs), &
         obsdat%mobhdr(OBS_PAS)%value_i(kobs), &
         obsdat%mobhdr(OBS_REG)%value_i(kobs), &
         obsdat%mobhdr(OBS_IP )%value_i(kobs)

9200  format(2x,i9,',',a9,',',i10,',',i8,',',i6,',',i6, &
         ',',i12,',',i6,4(',',i8),5(',',i6))

      return

   end subroutine obs_tosqlhdr


   subroutine obs_write(obsdat,hx, &
      nens,nobshdrout,nobsbdyout,nobshxout,nobsdimout)
      !
      ! author: Peter Houtekamer February 2011
      ! 
      ! object: 
      !   Write the obsdat info to unformatted files.
      !   Note that the body information is written in the 
      !   order that it will be used by sekfeta.f
      !
      implicit none
      type(struct_obs), intent(in) :: obsdat
      real(8),      intent(in), dimension(:,:) :: hx
      integer,      intent(in) :: nens,nobshdrout,nobsbdyout, &
         nobshxout,nobsdimout

      integer :: irobdata,jo,nrobdata

      irobdata=1
      do jo=1,obsdat%numHeader
         call obs_write_hdr(obsdat,jo,nobshdrout,irobdata,nrobdata)
         call obs_write_bdy(obsdat,jo,nobsbdyout)
         if (nens.gt.0) then
            call obs_write_hx(obsdat,hx,jo,nobshxout)
         endif
         irobdata=irobdata+nrobdata
      enddo
      write(nobsdimout,*) obsdat%numHeader
      write(nobsdimout,*) irobdata-1
      write(nobsdimout,*) nens

      return

   end subroutine obs_write


   subroutine obs_write_bdy(obsdat,kobs,kulout)
      !
      ! object  - write the data records associated with a
      !                 station in unformatted form.
      !
      !author  : P. Houtekamer  March 2000
      !
      !arguments
      !    input
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for writing 
      !
      implicit none 

      type(struct_obs), intent(in) :: obsdat
      integer, intent(in) ::  kobs,kulout

      integer :: ipnt,idata,j,jdata,k


      ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kobs) 
      idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)

      ! write the data records
      do jdata=ipnt,ipnt+idata-1
         write(kulout) &
           (obsdat%mobdata(obs_columnIndexFromActiveIndex_IB(k))%value_i(jdata),&
                                                  k=1,obs_numActiveColumn_IB()),&
           (obsdat%robdata(obs_columnIndexFromActiveIndex_RB(j))%value_r(jdata),&
                                                  j=1,obs_numActiveColumn_RB())
      enddo

      return

   end subroutine obs_write_bdy


   subroutine obs_write_hdr(obsdat,kobs,kulout,irobdata,nrobdata)
      !
      !object - writing of the header of a station record
      !
      !author  : Peter Houtekamer March 2000
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for output 
      !     i   irobdata: location in the sorted robdata
      !    output
      !     i   nrobdata: number of observations for this station
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer,      intent(in)  :: kobs,kulout,irobdata
      integer,      intent(out) :: nrobdata

      integer :: i,j

      ! (note that as a part of the writing, the body is being sorted
      !  so that the order of the observations in the body array 
      !  corresponds with the order of the stations in the header array).

      if(obsdat%mpi_local) then
         call obs_abort("obs_write_hdr() is not equipped to handle the case, mpi_local=.true.")
      end if

      nrobdata=obsdat%mobhdr(OBS_NLV)%value_i(kobs)
      ! write the header's content 
      write(kulout) irobdata, &
            (obsdat%mobhdr(obs_columnIndexFromActiveIndex_IH(i))%value_i(kobs), &
                                                 i=2,obs_numActiveColumn_IH()), &
            (obsdat%robhdr(obs_columnIndexFromActiveIndex_RH(j))%value_r(kobs), &
                                                 j=1,obs_numActiveColumn_RH()), &
            obsdat%cstnid(kobs), &
            obsdat%cfamily(kobs), &
            obsdat%datestamp

      return

   end subroutine obs_write_hdr


   subroutine obs_write_hx(obsdat,hx,kobs,kulout)
      !
      ! object  - write the interpolated values associated with a
      !                 station in unformatted form.
      !
      !author  : P. Houtekamer and H. Mitchell May 2005
      !
      !arguments
      !    input
      !        hx    : interpolated values    
      !        kobs  : no. of station 
      !        kulout: unit used for writing 
      !
      implicit none 

      type(struct_obs), intent(in) :: obsdat
      real(8), intent(in), dimension(:,:) :: hx
      integer, intent(in) :: kobs,kulout

      integer :: ipnt,idata,iens,j,jdata,k,nens

      nens = size(hx,1)

      ipnt  = obsdat%mobhdr(OBS_RLN)%value_i(kobs) 
      idata = obsdat%mobhdr(OBS_NLV)%value_i(kobs)

      ! write the data records
      do jdata=ipnt,ipnt+idata-1
         write(kulout) (hx(iens,jdata),iens=1,nens)
      enddo

      return

   end subroutine obs_write_hx

end module obsSpaceData_mod
