! ObsSpaceData_mod:  the module, ObsSpaceData_mod, follows IndexListDepot_mod

MODULE IndexListDepot_mod
  ! This is not a fully fledged module.  It is more like a structure definition
  ! with a couple of helpful methods.  It is intended that clients read/write
  ! directly from/to instances of these structures.  The intended client is
  ! obsSpaceData_mod.

  implicit none
  save
  public

  ! methods
  public :: ild_initialize, ild_get_empty_index_list, ild_get_next_index

  interface ild_get_next_index
    module procedure ild_get_next_index_depot
    module procedure ild_get_next_index_private
  end interface

                                        ! This dimension must accommodate the
                                        ! maximum number of OMP processors 
  integer, parameter :: NUMBER_OF_LISTS = 16

  type struct_index_list
    ! a list of integers, not to say indices into a struct_obs
    character(len=2) :: family          ! current_element's belong to this family
                                        ! Used only for a body list:
    integer :: header                   ! current_element's belong to this header
    integer :: current_element          ! the element that has just been returned

                                        ! the actual list of integers
                                        ! N.B.:  that which is an index to a
                                        !        client of this module is an
                                        !        element to this module
    integer, dimension(:), allocatable :: indices
  end type struct_index_list

  type struct_index_list_depot
    ! A collection of lists, either empty or populated
                                        ! the collection of lists
    type(struct_index_list), dimension(NUMBER_OF_LISTS) :: index_lists
    integer :: list_last_attributed     ! list that was populated most recently
                                        ! list that was   used    most recently
    type(struct_index_list), pointer :: current_list
  end type struct_index_list_depot


contains
    subroutine ild_initialize(depot, numheader_max)
    ! Initialize the indicated list depot
    implicit none
    type(struct_index_list_depot), intent(inout) :: depot
      integer , intent(in) :: numheader_max   ! max size of struct_obs & hence of depot

    integer :: list                     ! an index

    ! Allocate each list
    do list = 1,NUMBER_OF_LISTS
        allocate(depot%index_lists(list)%indices(numheader_max))
      depot%list_last_attributed = 0
    end do
  end subroutine ild_initialize


    function ild_get_empty_index_list(depot, private_list) &
                                                         result(empty_index_list)
    ! From the given depot, return an index-list structure that contains no
    ! data, as a pointer.
    !
    ! In other words, clear data from the (cyclicly) next (i.e. oldest) list
    ! and return a pointer to it.
    implicit none
    type(struct_index_list), pointer :: empty_index_list
    type(struct_index_list_depot), intent(inout), target :: depot
    type(struct_index_list), pointer, intent(inout), optional :: private_list

    nullify(empty_index_list)

    if(present(private_list)) then
      ! This is an OMP thread
      if(associated(private_list)) then
        ! Memory has already been assigned for that thread.  Re-use it.
        empty_index_list => private_list ! Set the return pointer
      end if
    end if

    if(.not. associated(empty_index_list)) then
!$omp critical
      ! Increment (cyclicly) the index to the next list
      depot%list_last_attributed = depot%list_last_attributed + 1
      if (depot%list_last_attributed > NUMBER_OF_LISTS) &
           depot%list_last_attributed = 1

      ! Set the return pointer
      empty_index_list => depot%index_lists(depot%list_last_attributed)
!$omp end critical
    end if

    ! Initialize some values in the list
    ! empty_index_list%indices(:) = -1 --> No, the array is too big.
    empty_index_list%family = '  '
    empty_index_list%header = -1
    empty_index_list%current_element = 0

    return
  end function ild_get_empty_index_list


  function ild_get_next_index_depot(depot, no_advance) result(next_index)
    ! From the given depot, increment the index to the current element, and
    ! return the element itself, the new current element.
    implicit none
    integer :: next_index
    type(struct_index_list_depot), intent(inout), target :: depot
                                        ! Do not increment current_element,
                                        ! just return the next one
    logical, intent(in), optional :: no_advance

                                        ! current list of the depot
    type(struct_index_list), pointer :: current_list
    integer :: next_element             ! next element of the current list

    current_list => depot%current_list
!$omp critical
                                        ! Obtain the next element from the list
    next_element = current_list%current_element + 1
    next_index = current_list%indices(next_element)

    if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
      current_list%current_element = next_element
    end if
!$omp end critical
  end function ild_get_next_index_depot


    function ild_get_next_index_private(private_list, no_advance) &
                                                               result(next_index)
    ! From the given list, increment the index to the current element, and
    ! return the element itself, the new current element.
    implicit none
    integer :: next_index
    type(struct_index_list), pointer, intent(inout) :: private_list
                                        ! Do not increment current_element,
                                        ! just return the next one
    logical, intent(in), optional :: no_advance

    integer :: next_element             ! next element of the list

                                        ! Obtain the next element from the list
    next_element = private_list%current_element + 1
    next_index = private_list%indices(next_element)

    if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
      private_list%current_element = next_element
    end if
  end function ild_get_next_index_private

end MODULE IndexListDepot_mod







MODULE obsSpaceData_mod
  use IndexListDepot_mod
  implicit none
  save
  private

  ! main observation space data instance
  public           :: OBS_JPNBRELEM

  ! header column numbers
  public           :: NCM_LET, NCM_RLN, NCM_ONM, NCM_BOX, NCM_OTP, NCM_ITY,  &
                      NCM_LAT, NCM_LON, NCM_DAT, NCM_ETM, NCM_ALT,  &
                      NCM_NLV, NCM_OEC, NCM_OFL, NCM_ST1, NCM_TLA, NCM_AZA,  &
                      NCM_SUN, NCM_CLF, NCM_REG, NCM_PAS, NCM_IP,  NCM_BX,   &
                      NCM_BY,  NCM_BZ

  ! body column numbers
  public           :: NCM_LBO, NCM_VNM, NCM_PPP, NCM_PRL, NCM_POB, NCM_VAR,  &
                      NCM_OMF, NCM_OMA, NCM_OMI, NCM_OMN, NCM_OER, NCM_RER,  &
                      NCM_FGE, NCM_PER, NCM_FLG, NCM_POS, NCM_LYR, NCM_ASS,  &
                      NCM_XTR, NCM_OBS, NCM_LOBS,NCM_VCO, NCM_PRM, NCM_KFA,  &
                      NCM_ZHA, NCM_HPHT,NCM_OMP

  ! methods
  public           :: obs_initialize,obs_finalize
  public           :: obs_elem_i,obs_elem_r4,obs_elem_r8,obs_elem_c9
  public           ::  obs_set_i, obs_set_r4, obs_set_r8, obs_set_c9
  public           :: obs_numbody,obs_numheader,obs_numbody_max,obs_numheader_max,obs_numheader_mpiglobal
  public           :: obs_swapVarOmf,obs_ifind
  public           :: obs_getFamily,obs_setFamily,obs_bdy
  public           :: obs_reduceToMpiLocal,obs_expandToMpiGlobal
  public           :: obs_elem_mpiglobal_r4,obs_elem_mpiglobal_i
  public           :: obs_prnthdr,obs_prntbdy
  public           :: obs_set_current_header_list, obs_getHeaderIndex
  public           :: obs_set_current_body_list,   obs_getBodyIndex
  public           :: obs_set_datestamp,obs_get_datestamp

  interface obs_getBodyIndex
   module procedure obs_getBodyIndex_depot
   module procedure obs_getBodyIndex_private
  end interface obs_getBodyIndex

  interface obs_set_current_body_list
   module procedure obs_set_current_body_list_from_header
   module procedure obs_set_current_body_list_from_family
  end interface obs_set_current_body_list

  ! private methods
  !                obs_allocate, obs_deallocate, obs_allocateG, obs_deallocateG
  !                obs_abort
  !                obs_set_current_index_list

  ! derived type and module variable declarations

  public :: struct_obs

  type struct_obs
   private
   type(struct_index_list_depot) :: header_index_list_depot
   type(struct_index_list_depot) :: body_index_list_depot
   character(len=9),  pointer, dimension(:)   :: cstnid   !! need len=12 for EnKF
   character(len=2),  pointer, dimension(:)   :: cfamily
   real(kind=4),      pointer, dimension(:,:) :: robhdr
   integer,           pointer, dimension(:,:) :: mobhdr
   real(kind=4),      pointer, dimension(:,:) :: robdata
   real(kind=8),      pointer, dimension(:,:) :: robdata8
   integer,           pointer, dimension(:,:) :: mobdata
   integer :: numheader                 ! Actual number of stations on record
   integer :: numheader_max             ! maximum number of stations
   integer :: numbody                   ! Actual total number of data on record
   integer :: numbody_max               ! maximum number observations (i.e. data)
   integer :: numheader_mpiglobal       ! Actual number of stations on record

                                        ! Headers of the mpi-Global obs data
   integer,           pointer, dimension(:,:) :: mobhdr_g
   real(kind=4),      pointer, dimension(:,:) :: robhdr_g
   character(len=9),  pointer, dimension(:)   :: cstnid_g
   integer, pointer, dimension(:) :: locObsTag

   logical :: mpi_local                 ! T: keep only data needed by this PE
   integer :: datestamp
  end type struct_obs

  ! header column numbers
  integer,parameter :: NCM_LET = 22 ! Dimension for var3d
  integer,parameter :: NCM_RLN = 1
  integer,parameter :: NCM_ONM = 2
  integer,parameter :: NCM_BOX = 3
  integer,parameter :: NCM_OTP = 4
  integer,parameter :: NCM_ITY = 5
  integer,parameter :: NCM_LAT = 6
  integer,parameter :: NCM_LON = 7
  integer,parameter :: NCM_DAT = 8
  integer,parameter :: NCM_ETM = 9
  integer,parameter :: NCM_ALT = 11
  integer,parameter :: NCM_NLV = 12
  integer,parameter :: NCM_OEC = 13
  integer,parameter :: NCM_OFL = 14
  integer,parameter :: NCM_ST1 = 15
  integer,parameter :: NCM_TLA = 16
  integer,parameter :: NCM_AZA = 20
  integer,parameter :: NCM_SUN = 21
  integer,parameter :: NCM_CLF = 22
! integer,parameter :: NCM_STID=    ! Not needed since only 1 cstnid exists
! integer,parameter :: NCM_FAM =    ! Not needed since only 1 cfamily exists
! These values are used only by EnKF, and not by var3d
  integer,parameter :: NCM_REG = 23
  integer,parameter :: NCM_PAS = 24
  integer,parameter :: NCM_IP  = 25
  integer,parameter :: NCM_BX  = 26
  integer,parameter :: NCM_BY  = 27
  integer,parameter :: NCM_BZ  = 28

  ! body column numbers
  integer,parameter :: NCM_LBO = 22
  integer,parameter :: NCM_VNM = 1
  integer,parameter :: NCM_POB = 2
  integer,parameter :: NCM_PRL = 3
  integer,parameter :: NCM_PPP = 4
  integer,parameter :: NCM_VAR = 5
  integer,parameter :: NCM_OMF = 6
  integer,parameter :: NCM_OMA = 7
  integer,parameter :: NCM_OMI = 8
  integer,parameter :: NCM_OMN = 9
  integer,parameter :: NCM_OER = 10
  integer,parameter :: NCM_PRM = 11
  integer,parameter :: NCM_RER = 12
  integer,parameter :: NCM_FGE = 13
  integer,parameter :: NCM_PER = 14
  integer,parameter :: NCM_FLG = 15
  integer,parameter :: NCM_POS = 16
  integer,parameter :: NCM_LYR = 17
  integer,parameter :: NCM_ASS = 18
  integer,parameter :: NCM_XTR = 19
  integer,parameter :: NCM_OBS = 20
  integer,parameter :: NCM_LOBS= 21
  integer,parameter :: NCM_VCO = 22
! added for EnKF
  integer,parameter :: NCM_KFA = 23
  integer,parameter :: NCM_ZHA = 24
  integer,parameter :: NCM_HPHT= 26
  integer,parameter :: NCM_OMP = 25

  integer, parameter :: OBS_JPNBRELEM = 57

  integer, parameter :: ROBDATA8_LOWER = NCM_POB
  integer, parameter :: ROBDATA8_UPPER = NCM_PER


  contains


  subroutine obs_initialize(obsdat)
    implicit none

    type(struct_obs), intent(out) :: obsdat
    integer :: nulnam,fnom,fclos,ierr
    integer :: nmxobs,ndatamx
    namelist /namdimo/nmxobs,ndatamx

    nmxobs=30000
    ndatamx=200000

    nulnam=0
    ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
    read(nulnam,nml=namdimo,iostat=ierr)
    write(*,*) 'obs_initialize: reading namelist, ierr=',ierr
    write(*,nml=namdimo)
    ierr=fclos(nulnam)

    write(*,*) ' DIMENSIONS OF OBSERVATION ARRAYS:'
    write(*,*) ' NMXOBS = ',NMXOBS,'  NDATAMX = ',NDATAMX

    obsdat%numheader_max=nmxobs
    obsdat%numbody_max=ndatamx
    obsdat%numheader = 0
    obsdat%numbody  = 0
    obsdat%numheader_mpiglobal = 0
    obsdat%mpi_local = .false.

    nullify(obsdat%mobhdr_g)
    nullify(obsdat%robhdr_g)
    nullify(obsdat%cstnid_g)

    call obs_allocate(obsdat,obsdat%numheader_max,obsdat%numbody_max)
    call ild_initialize(obsdat%header_index_list_depot, obsdat%numheader_max)
    call ild_initialize(obsdat%body_index_list_depot,   obsdat%numbody_max)
    return
  end subroutine obs_initialize


  subroutine obs_finalize(obsdat)
    implicit none
    type(struct_obs), intent(inout) :: obsdat

    call obs_deallocate(obsdat)
    call obs_deallocateG(obsdat)
  end subroutine obs_finalize


  subroutine obs_allocate(obsdat,numheader_max,numbody_max)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)  :: numheader_max,numbody_max

    integer :: ierr

    ALLOCATE(obsdat%cfamily(numheader_max),STAT=ierr)
    obsdat%cfamily(:)='XX'

    ALLOCATE(obsdat%cstnid(numheader_max),STAT=ierr)
    obsdat%cstnid(:)='XXXXXXXXX' !! // 'XXX'   needed for EnKF

    ALLOCATE(obsdat%ROBHDR(NCM_LET,numheader_max),STAT=ierr)
    obsdat%ROBHDR=0.0

    ALLOCATE(obsdat%MOBHDR(NCM_LET,numheader_max),STAT=ierr)
    obsdat%MOBHDR=0

    ALLOCATE(obsdat%ROBDATA(NCM_LBO,numbody_max),STAT=ierr)
    obsdat%ROBDATA=0.0

    ALLOCATE(obsdat%ROBDATA8(ROBDATA8_LOWER:ROBDATA8_UPPER,numbody_max),STAT=ierr)
    obsdat%ROBDATA8=0.0D0

    ALLOCATE(obsdat%MOBDATA(NCM_LBO,numbody_max),STAT=ierr)
    obsdat%MOBDATA=0

  end subroutine obs_allocate

  subroutine obs_allocateG(obsdat,maxNumHdr)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)    :: maxNumHdr

    integer :: ierr

    ALLOCATE(obsdat%cstnid_g(maxNumHdr),STAT=ierr)
    obsdat%cstnid_g(:)='XXXXXXXXX' !! // 'XXX'   needed for EnKF

    ALLOCATE(obsdat%ROBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%ROBHDR_g=0.0

    ALLOCATE(obsdat%MOBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%MOBHDR_g=0

  end subroutine obs_allocateG


  subroutine obs_deallocateG(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%cstnid_g)) then
      deallocate(obsdat%cstnid_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CSTNID_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CSTNID_g. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robhdr_g)) then
      deallocate(obsdat%robhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR_g. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr_g)) then
      deallocate(obsdat%mobhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR_g. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocateG


  subroutine obs_deallocate(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%cfamily)) then
      deallocate(obsdat%cfamily,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CFAMILY checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CFAMILY. IERR =',ierr
      endif
    end if

    if (associated(obsdat%cstnid))then
      deallocate(obsdat%cstnid,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CSTNID checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CSTNID. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robhdr))then
      deallocate(obsdat%robhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr))then
      deallocate(obsdat%mobhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata))then
      deallocate(obsdat%robdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata8))then
      deallocate(obsdat%robdata8,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA8 checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA8. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobdata))then
      deallocate(obsdat%mobdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBDATA. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocate


  subroutine obs_abort(cdmessage)
#if defined (DOC) 
*
***s/r OBS_ABORT  - Abort a job on error
*
*
*Author  : P. Gauthier *ARMA/AES  June 9, 1992
*Revision:
*     . P. Gauthier *ARMA/AES  January 29, 1996 
*     . P. Koclas   CMC/CMSV   January  1997 
*         -add call to abort
*     . S. Pellerin ARMA/SMC   October 2000
*         - replace call to abort for call to exit(1)
*     . C. Charette ARMA/SMC   October 2001
*         - replace SUTERM by SUTERMF to only close files
*     . J. Blezius  import ABORT3D into obsspacedata_mod as OBS_ABORT
*         - delete call to SUTERMF
*    -------------------
**    Purpose:
*     To stop a job when an error occurred
*
*Arguments
*     i     CDMESSAGE: message to be printed
#endif

      implicit none
      character(len=*) cdmessage

      write(*,'(//,4X,"ABORTING IN ObsSpaceData_mod:-------",/,8X,A)')cdmessage
      call flush(6)

      call qqexit(1)

      stop
  end subroutine obs_abort


  subroutine obs_swapVarOmf(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    real(kind=4),allocatable :: temp_robdata(:)
    real(kind=8),allocatable :: temp_robdata8(:)
    integer                  :: ierr

!    temp = NCM_VAR
!    NCM_VAR = NCM_OMF
!    NCM_OMF = temp

    allocate(temp_robdata (lbound(obsdat%robdata ,2):ubound(obsdat%robdata ,2)),stat=ierr)
    temp_robdata(:)=obsdat%robdata(NCM_VAR,:)
    obsdat%robdata(NCM_VAR,:)=obsdat%robdata(NCM_OMF,:)
    obsdat%robdata(NCM_OMF,:)=temp_robdata(:)
    deallocate(temp_robdata)

    allocate(temp_robdata8(lbound(obsdat%robdata8,2):ubound(obsdat%robdata8,2)),stat=ierr)
    temp_robdata8(:)=obsdat%robdata8(NCM_VAR,:)
    obsdat%robdata8(NCM_VAR,:)=obsdat%robdata8(NCM_OMF,:)
    obsdat%robdata8(NCM_OMF,:)=temp_robdata8(:)
    deallocate(temp_robdata8)

  end subroutine obs_swapVarOmf


  function obs_getFamily(obsdat,headerIndex,bodyIndex)
    implicit none

    character(len=2)             :: obs_getFamily
    type(struct_obs), intent(in) :: obsdat
    integer,optional, intent(in) :: headerIndex,bodyIndex

    integer          :: headerIndex2

    if(present(headerIndex)) then
      obs_getFamily=obsdat%cfamily(headerIndex)
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obs_getFamily=obsdat%cfamily(headerIndex2)
    else
      write(*,*) 'OBS_GETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call qqexit(1)
    endif

  end function obs_getFamily


  subroutine obs_set_datestamp(obsdat,datestamp)
    implicit none
    type(struct_obs), intent(inout) :: obsdat
    integer, intent(in) :: datestamp

    obsdat%datestamp = datestamp

  end subroutine obs_set_datestamp


  function obs_get_datestamp(obsdat) result(datestamp)
    implicit none
    type(struct_obs), intent(inout) :: obsdat
    integer :: datestamp

    datestamp = obsdat%datestamp

  end function obs_get_datestamp


  subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    character(len=2), intent(in)    :: Family_in
    integer,optional, intent(in)    :: headerIndex,bodyIndex

    integer          :: headerIndex2
    
    if(present(headerIndex)) then
      obsdat%cfamily(headerIndex)=Family_in
      if(headerIndex.eq.(obsdat%numheader+1)) then
        obsdat%numheader=obsdat%numheader+1
      endif
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obsdat%cfamily(headerIndex2)=Family_in
      if(headerIndex2.eq.(obsdat%numheader+1)) then
        obsdat%numheader=obsdat%numheader+1
      endif
     else
      write(*,*) 'OBS_SETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call qqexit(1)
    endif

  end subroutine obs_setFamily

  
  SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                    LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                    n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                    KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                    vconv,nonelev)
    use EarthConstants_mod
    use MathPhysConstants_mod
    IMPLICIT NONE
!
    type(struct_obs), intent(inout) :: obsdat
    INTEGER, intent(out) :: KNDAT
    INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
    INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
    INTEGER, intent(in)  :: KLIST(n_elements_in_block)
    INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
    integer, intent(in)  :: nvcordtyp,nonelev
!
    REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
    REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
    REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
    REAL(kind=8),intent(in)::PPMIS
    real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
    real(kind=8),intent(in)::vcordsf(:,:)
!
    LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI
!
#if defined (DOC)
!***********************************************************************
!
!***s/r OBS_BDY -FILL BODY OF CMA REPORT
!
!Author    . P. KOCLAS(CMC TEL. 4665)
!
!Revision:
!          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
!          .   before insertion of U and V for consistency
!          . P. Koclas *CMC/AES February  1995:
!          .  New call sequence neccessary to :
!          . -allow insertion of "grouped data" records in BURP files.
!          . -allow data observed in various vertical coordinates
!          . -observation errors no longer initialized
!
!          . P. Koclas *CMC/AES March     1995:
!            -Additions for humsat and satem data
!          .
!          . C. Charette *ARMA Jan        2001
!            -Max value for T-Td surface element(12203)
!
!           JM Belanger CMDA/SMC  Feb 2001
!                   . 32 bits conversion
!          . P. Koclas *CMC/CMDA Sept     2001:
!            -set first-guess and observation errors to missing values
!
!          .N Wagneur CMDA/SMC  Jine 2002
!                   . -Additions for goes data
!          . P. Koclas *CMC/CMDA Dec      2003:
!                -conversion for surface wind
!          . C. Charette *ARMA/SMC Apr      2005:
!                -Set flag bit #12 (Element assimilated by analysis) to zero
!                 (see banco-burp documentation for more detail)
!          . A. Beaulne *CMDA/SMC  Aug 2006
!                     -Additions for AIRS data
!          . S. Heilliette
!                     -Additions for IASI data
!
!
!    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
!              THE IN-CORE FORMAT (CMA) OF THE 3-D VARIATIONAL ANALYSIS
!
!    ARGUMENTS:
!     INPUT:
!
!           -PVALUES : DATA BLOCK
!           -KLIST   : LIST OF BUFR ELEMENTS
!           -KFLAGS  : QUALITY CONTROL FLAGS
!
!           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN CMA
!                      .FALSE. --> INSERT DUMMY VALUE(2**12)
!           -LERR    :  .TRUE. --> INSERT OBS ERROR IN CMA (HUMSAT DATA)
!           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN CMA (SATEMS)
!           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN CMA (GOES RADIANCES)
!           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (AIRS RADIANCES)
!           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (IASI RADIANCES)
!
!           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
!           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
!           -KNT     :  THIRD DIMENSION OF DATA BLOCK
!           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
!           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
!           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
!           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
!           -PPMIS   :  VALUE OF MISSING DATA
!           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
!
!    OUTPUT:
!           -KNDAT   : NUMBER OF DATA INSERTED IN CMA FILE
!
!***********************************************************************
#endif

    INTEGER ILEM,IND,IIND,IP,IK
    INTEGER IBAD,IFLAG
    INTEGER ielement,ilevel
    INTEGER ZESMAX,ZES
!
    REAL(kind=8) ZFACT,padd,pmul,ZEMFACT,pvalue
!
!***********************************************************************
!     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
!***********************************************************************
!
    IIND  =-1
    IBAD=2**11
!
    ZFACT=VCONV
!
    ZEMFACT=0.01
    ZESMAX=30.
!
    IP=obsdat%numbody + 1
    IND=0
!
!***********************************************************************
!     PUT ALL NON MISSING DATA IN CMA FILE
!     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO CMA FILE
!     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
!***********************************************************************
!
    IK= KINDEX
       DO ielement=1,n_elements_in_block
          ILEM=obs_ifind(KLIST(ielement))
          IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
             DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                    nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                      IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                         pvalue=PVALUES(ielement,ilevel,IK)
                         IF ( IP + IND .LE. obsdat%numbody_max ) THEN
!                                       VERTICAL COORDINATE
                            obsdat%robdata8(NCM_PPP,IP+IND)=PVCORD(ilevel)*ZFACT +vcordsf(ilem,kidtyp)
!
!                           FOR PNM HEIGHT IS SET TO 0
!                           ----------------------------
                            IF ( ILEM .EQ. 53 ) THEN
                               obsdat%robdata8(NCM_PPP,IP+IND)=0.D0
                            ENDIF
!                           ----------------------------
!
!                           IF ( ILEM .EQ. 2 ) Units:  V
!                                        CONVERT TO GZ
                            IF ( ILEM .EQ. 3 ) THEN
                             pvalue=RG*pvalue
                            ENDIF
!                           IF ( ILEM .EQ. 4 ) Units: METERS
!                           IF ( ILEM .EQ. 8 ) Units:  CELSIUS
!                                  Max value T-Td upper air
                            IF ( ILEM .EQ. 9 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    Max value T-Td surface
                            IF ( ILEM .EQ. 11 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    CONVERT TO RADIANS
                            IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                             pvalue=MPC_RADIANS_PER_DEGREE_R8*pvalue
                            ENDIF
!                                       FLAGS
                            IF  (LDFLAG) THEN
!                                 SET BIT 12  TO ZERO
!                                 (Element assim by 3dvar)
                               IFLAG = KFLAGS(ielement,ilevel,IK)
                               IFLAG = IBCLR(IFLAG,12)
                               obsdat%mobdata(NCM_FLG,IP+IND)= IFLAG
                            ELSE
                               obsdat%mobdata(NCM_FLG,IP+IND)= IBAD
                            ENDIF
!
                            obsdat%robdata8(NCM_VAR,IP+IND)=pvalue
                            obsdat%mobdata (NCM_VNM,IP+IND)=KLIST(ielement)
                            obsdat%mobdata (NCM_VCO,IP+IND)=NVCORDTYP
                            obsdat%robdata8(NCM_OMF,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMA,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMI,IP+IND)=PPMIS
                            obsdat%robdata (NCM_FGE,IP+IND)=real(PPMIS)
                            obsdat%robdata8(NCM_OER,IP+IND)=PPMIS
!
!                           OBS ERROR FOR HUMSAT
!
                            IF ( LDERR ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)
                            ENDIF
!
!                           REFERENCE LEVEL FOR SATEMS
!
                            IF ( LDSAT ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)*ZFACT
                              obsdat%robdata8(NCM_OER,IP+IND)=1.0D0
                            ENDIF
!
!                           SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
!
                            IF ( LDGO ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            ENDIF

                            IF ( LDAIRS ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            END IF

                            IF ( LDIASI ) THEN
                               obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                    *ZEMFACT
                            END IF

!
                            IND=IND + 1
                         ELSE
!==================================================
                            KNDAT = IND
                            obsdat%numbody = obsdat%numbody + KNDAT
!==================================================
                            RETURN
                         ENDIF
                      ENDIF
                ENDIF
             END DO
          ENDIF
       END DO
!=============================
    KNDAT = IND
    obsdat%numbody = obsdat%numbody + KNDAT
!=============================
!
    RETURN
!
  END SUBROUTINE obs_bdy


 function obs_elem_r4(obsdat,name,index) result(value)
  implicit none
  real(kind=4) value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr(NCM_BZ , index)

  case ('PPP '); value=obsdat%robdata(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata(NCM_PRL, index)
  case ('VAR '); value=obsdat%robdata(NCM_VAR, index)
  case ('OMP '); value=obsdat%robdata(NCM_OMP, index)
  case ('OMA '); value=obsdat%robdata(NCM_OMA, index)
  case ('OER '); value=obsdat%robdata(NCM_OER, index)
  case ('HPHT'); value=obsdat%robdata(NCM_HPHT,index)
  case ('ZHA '); value=obsdat%robdata(NCM_ZHA, index)
  ! Added for var3d
  case ('POB '); value=obsdat%robdata(NCM_POB, index)
  case ('OMF '); value=obsdat%robdata(NCM_OMF, index)
  case ('OMI '); value=obsdat%robdata(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata(NCM_OMN, index)
  case ('RER '); value=obsdat%robdata(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(4) observation."
   value=-999.
  end select
 end function obs_elem_r4

 function obs_elem_mpiglobal_r4(obsdat,name,index) result(value)
  ! This method is supplied for use by those external to the present module who
  ! are aware of the mpi-local or -global state of this module.
  implicit none
  real(kind=4) value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr_g(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr_g(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr_g(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr_g(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr_g(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr_g(NCM_BZ , index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not available in the mpi-global context."
   value=-999.
  end select
 end function obs_elem_mpiglobal_r4

 function obs_elem_r8(obsdat,name,index) result(value)
  implicit none
  real(kind=8) value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  ! Added for var3d
  case ('PPP '); value=obsdat%robdata8(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata8(NCM_PRL, index)
  case ('POB '); value=obsdat%robdata8(NCM_POB, index)
  case ('VAR '); value=obsdat%robdata8(NCM_VAR, index)
  case ('OMF '); value=obsdat%robdata8(NCM_OMF, index)
  case ('OMA '); value=obsdat%robdata8(NCM_OMA, index)
  case ('OMI '); value=obsdat%robdata8(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata8(NCM_OMN, index)
  case ('OER '); value=obsdat%robdata8(NCM_OER, index)
  case ('RER '); value=obsdat%robdata8(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata8(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata8(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata8(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(8) observation."
   value=-999
  end select
 end function obs_elem_r8

 function obs_elem_i(obsdat,name,index) result(value)
  implicit none
  integer value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr(NCM_CLF, index)
  ! Added for var3d
  case ('OEC '); value=obsdat%mobhdr(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr(NCM_TLA, index)
  case ('GHI '); value=obsdat%locObsTag(index)

  case ('VNM '); value=obsdat%mobdata(NCM_VNM, index)
  case ('FLG '); value=obsdat%mobdata(NCM_FLG, index)
  case ('KFA '); value=obsdat%mobdata(NCM_KFA, index)
  case ('ASS '); value=obsdat%mobdata(NCM_ASS, index)
  case ('OBS '); value=obsdat%mobdata(NCM_OBS, index)
  case ('VCO '); value=obsdat%mobdata(NCM_VCO, index)
  ! Added for var3d
  case ('LBO '); value=obsdat%mobdata(NCM_LBO, index)
  case ('POS '); value=obsdat%mobdata(NCM_POS, index)
  case ('XTR '); value=obsdat%mobdata(NCM_XTR, index)
  case ('LOBS'); value=obsdat%mobdata(NCM_LOBS,index)
  case ('LYR '); value=obsdat%mobdata(NCM_LYR, index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
   value=-999
  end select
 end function obs_elem_i

 function obs_elem_mpiglobal_i(obsdat,name,index) result(value)
  ! This method is supplied for use by those external to the present module who
  ! are aware of the mpi-local or -global state of this module.
  implicit none
  integer value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr_g(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr_g(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr_g(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr_g(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr_g(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr_g(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr_g(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr_g(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr_g(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr_g(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr_g(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr_g(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr_g(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr_g(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr_g(NCM_CLF, index)
  ! Added for var3d
  case ('OEC '); value=obsdat%mobhdr_g(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr_g(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr_g(NCM_TLA, index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not available in the mpi-global context."
   value=-999
  end select
 end function obs_elem_mpiglobal_i


 function obs_elem_c9(obsdat,name,index) result(value)
  implicit none

  character(len=9) :: value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('STID'); value=obsdat%cstnid(index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not character(len=9) observation."
   value='xxxxxxxxx'
  end select
 end function obs_elem_c9


 subroutine obs_set_current_header_list(obsdat, family)
  ! Find or create an index list for the indicated family and place it in the
  ! header depot.
  implicit none
  type(struct_obs), intent(inout), target :: obsdat
  character(len=2), intent(in) :: family

  type(struct_index_list_depot), pointer :: depot
  type(struct_index_list), pointer :: index_list
  integer :: list, list_index, item_index

  nullify(index_list)
  depot => obsdat%header_index_list_depot

  ! Search for an existing list
  do list = 1, NUMBER_OF_LISTS
   if (depot%index_lists(list)%family == family) then
    index_list => depot%index_lists(list)
    index_list%current_element = 0      ! Start at the beginning of the list
    exit                                ! Don't look any further
   end if
  end do

                                        ! If the list does not already exist
  if (.not. associated(index_list)) then
   ! Create a new list
   index_list => ild_get_empty_index_list(depot)
   index_list%family = family
   index_list%header = -1

   ! Populate the list
   list_index = 0
      do item_index = 1, obsdat%numheader
                                        ! If the station is of the right family
    if(obsdat%cfamily(item_index) == family) then
                                        ! Add the item_index to the list
     list_index = list_index + 1
     index_list%indices(list_index) = item_index
    end if
   end do
   index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
   index_list%indices(list_index+2)= -1 ! ... clearly
  end if ! list does not already exist

  index_list%current_element = 0        ! Set pointer to the start of the list
  depot%current_list => index_list      ! Note the current list
 end subroutine obs_set_current_header_list


 subroutine obs_set_current_body_list_from_header(obsdat, header, &
                                                  list_is_empty, current_list)
  ! Create an index list from the indicated header and place it in the body
  ! depot.
  implicit none
  type(struct_obs), intent(inout), target :: obsdat
  integer, intent(in) :: header
  logical, intent(out), optional :: list_is_empty
  type(struct_index_list), pointer, intent(out), optional :: current_list

  type(struct_index_list_depot), pointer :: depot
  type(struct_index_list), pointer :: index_list
  integer :: list, list_index, item_index
  integer :: first, last

  nullify(index_list)
  depot => obsdat%body_index_list_depot

  ! Search for an existing list
  if(present(current_list)) then
   if(associated(current_list)) then
    if (current_list%header == header) then
     index_list => current_list
    end if ! header matches
   end if ! associated

  else ! not present(current_list)
   do list = 1, NUMBER_OF_LISTS
    if (depot%index_lists(list)%header == header) then
     index_list => depot%index_lists(list)
     exit                               ! Don't look any further
    end if
   end do
  end if

                                        ! If the list does not already exist
  if (.not. associated(index_list)) then

   ! Acquire memory for the list
   if(present(current_list)) then
    ! This is an OMP thread.  Re-use the same physical memory for the list
    index_list => ild_get_empty_index_list(depot, current_list)
   else
    index_list => ild_get_empty_index_list(depot)
   end if

   ! Initialize the new list
   index_list%family = 'xx'             ! not used
   index_list%header = header

   ! Populate the list
   first= obs_elem_i(obsdat,'RLN ',header)
   last = obs_elem_i(obsdat,'NLV ',header) + first - 1
   list_index = 0
   do item_index=first,last             ! For each item indicated in the header
                                        ! Add the item_index to the list
    list_index = list_index + 1
    index_list%indices(list_index) = item_index
   end do
   index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
   index_list%indices(list_index+2)= -1 ! ... clearly
  end if ! list does not already exist

  index_list%current_element = 0        ! Set pointer to the start of the list
  depot%current_list => index_list      ! Note the current list

  if(present(list_is_empty)) then
                                        ! Return whether the list is empty
   list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
  end if

  if(present(current_list)) then
                                        ! Return a pointer to the current list
   current_list => index_list
  end if
 end subroutine obs_set_current_body_list_from_header


 subroutine obs_set_current_body_list_from_family(obsdat, family, &
                                                  list_is_empty, current_list)
  ! Create an index list from the indicated family and place it in the body
  ! depot.
  implicit none
  type(struct_obs), intent(inout), target :: obsdat
  character(len=2), intent(in) :: family
  logical, intent(out), optional :: list_is_empty
  type(struct_index_list), pointer, intent(out), optional :: current_list

  type(struct_index_list_depot), pointer :: depot
  type(struct_index_list), pointer :: index_list
  integer :: index_header, list, list_index, item_index
  integer :: first, last

  nullify(index_list)
  depot => obsdat%body_index_list_depot

  ! Search for an existing list
  if(present(current_list)) then
   if(associated(current_list)) then
    if (current_list%family == family) then
     index_list => current_list
    end if ! family matches
   end if ! associated

  else ! not present(current_list)
   do list = 1, NUMBER_OF_LISTS
    if (depot%index_lists(list)%family == family) then
     index_list => depot%index_lists(list)
     exit                               ! Don't look any further
    end if
   end do
  end if

                                        ! If the list does not already exist
  if (.not. associated(index_list)) then

   ! Acquire memory for the list
   if(present(current_list)) then
    ! This is an OMP thread.  Re-use the same physical memory for the list
    index_list => ild_get_empty_index_list(depot, current_list)
   else
    index_list => ild_get_empty_index_list(depot)
   end if

   ! Initialize the new list
   index_list%family = family
   index_list%header = -99              ! not used

   !
   ! Populate the li-st
   !

   ! Loop over all header indices of the family
   list_index = 0
   call obs_set_current_header_list(obsdat, family)
   HEADER: do
    if (index_header < 0) exit HEADER
    index_header = obs_getHeaderIndex(obsdat)
    first= obs_elem_i(obsdat,'RLN ',index_header)
    last = obs_elem_i(obsdat,'NLV ',index_header) + first - 1
    do item_index=first,last            ! For each item indicated in the header
                                        ! Add the item_index to the list
     list_index = list_index + 1
     index_list%indices(list_index) = item_index
    end do
   end do HEADER
   index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
   index_list%indices(list_index+2)= -1 ! ... clearly
  end if ! list does not already exist

  index_list%current_element = 0        ! Set pointer to the start of the list
  depot%current_list => index_list      ! Note the current list

  if(present(list_is_empty)) then
                                        ! Return whether the list is empty
   list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
  end if

  if(present(current_list)) then
                                        ! Return a pointer to the current list
   current_list => index_list
  end if
 end subroutine obs_set_current_body_list_from_family


 function obs_getHeaderIndex(obsdat) result(index)
  ! Return the next element from the current header list
  implicit none
  integer :: index
  type(struct_obs), intent(inout) :: obsdat

  index = ild_get_next_index(obsdat%header_index_list_depot)
 end function obs_getHeaderIndex


 function obs_getBodyIndex_depot(obsdat) result(index)
  ! Return the next element from the current body list
  implicit none
  integer :: index
  type(struct_obs), intent(inout) :: obsdat

  index = ild_get_next_index(obsdat%body_index_list_depot)
 end function obs_getBodyIndex_depot


 function obs_getBodyIndex_private(private_list) result(index)
  ! Return the next element from the current body list
  implicit none
  integer :: index
  type(struct_index_list), pointer, intent(inout) :: private_list

  index = ild_get_next_index(private_list)
 end function obs_getBodyIndex_private


 subroutine obs_getobstag(obsdat)
!
!**s/r read local observation tag from GEM TLM-ADJ .
!
!Author  : Bin He *ARMA/MRB  Feb. 2009
!
!Revision:
!  
!Arguments: none
!
  use mpi
  implicit none
  type(struct_obs), intent(inout) :: obsdat

  integer, allocatable :: locObsTag_tmp(:)
  integer ::  iobs_mpiglobal,ierr
  integer :: numheader_mpilocal 

  write(*,*) '-------- Start obs_getobstag ---------'
  numheader_mpilocal=0
  if(mpi_nprocs == 0) mpi_nprocs=1
  write(*,*) 'numheader= ',obsdat%numheader 
  allocate(locObsTag_tmp(obsdat%numheader),stat=ierr)

  do iobs_mpiglobal=(mpi_myid+1),obsdat%numheader,mpi_nprocs
    numheader_mpilocal=numheader_mpilocal+1
    locObsTag_tmp(numheader_mpilocal)=iobs_mpiglobal
  enddo
  if(numheader_mpilocal<=0) call obs_abort('Zero length of ObsTag,Abort!') 

  allocate(obsdat%locObsTag(numheader_mpilocal),stat=ierr)

  obsdat%locObsTag(1:numheader_mpilocal)=locObsTag_tmp(1:numheader_mpilocal)

  deallocate(locObsTag_tmp) 

  write(*,*) '-------- END OF obs_getobstag ---------'
  write(*,*) ' '

 end subroutine obs_getobstag  


 integer function obs_numbody(obsdat)
!func obs_numbody - returns the number of observations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of observations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_numbody=obsdat%numbody
 end function obs_numbody


 integer function obs_numbody_max(obsdat)
!func obs_numbody_max - returns the number of observations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of observations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_numbody_max=obsdat%numbody_max
 end function obs_numbody_max


 integer function obs_numheader(obsdat)
!func obs_numheader - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_numheader=obsdat%numheader
 end function obs_numheader


 integer function obs_numheader_max(obsdat)
!func obs_numheader_max - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_numheader_max=obsdat%numheader_max
 end function obs_numheader_max


 integer function obs_numheader_mpiglobal(obsdat)
!func obs_numheader_mpiglobal - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_numheader_mpiglobal=obsdat%numheader_mpiglobal
 end function obs_numheader_mpiglobal


 SUBROUTINE obs_prntbdy(obsdat,KOBS,KULOUT)
!
!**s/r PRNTBDY  - Print all data records associated with an observation
!
!Author  : P. Gauthier *ARMA/AES  June 9, 1992
!Revision:
!     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
!
!     . C. Charette *ARMA/AES Mar 1996 : format statement
!     . C. Charette *ARMA/AES Nov 1999 : Added print of flag NCM_ASS
!       JM Belanger CMDA/SMC  Jul 2000
!                   . 32 bits conversion
!     . S. Pellerin ARMA, January 2008 : Remove NCM_OMN print.
!
!Arguments
!     i   KOBS  : No. of observation
!     i   KULOUT: unit used for printing
!
  implicit none

  type(struct_obs), intent(in) :: obsdat
  INTEGER         , intent(in) :: KOBS, KULOUT

  INTEGER :: IPNT, IDATA, IDATA2, JDATA, IVCO
  CHARACTER(len=13) :: ccordtyp(3)

  ccordtyp(1)='HEIGHT      :'
  ccordtyp(2)='PRESSURE    :'
  ccordtyp(3)='VCO UNDEFINED'
!
! 1. General information
!
  IPNT  = obs_elem_i(obsdat,'RLN ',KOBS)
  IDATA = obs_elem_i(obsdat,'NLV ',KOBS)

  IF(IDATA.EQ.1) THEN
   WRITE(KULOUT,FMT=9101)IDATA,KOBS,NCM_LBO
  ELSE
   WRITE(KULOUT,FMT=9100)IDATA,KOBS,NCM_LBO
  END IF
 9100 FORMAT(4x,'THERE ARE ', &
           I3,1X,'DATA IN OBSERVATION RECORD NO.' &
           ,1X,I6,4X,'DATA RECORD''S LENGTH:',I6)
 9101 FORMAT(4x,'THERE IS ', &
           I3,1X,'DATA IN OBSERVATION RECORD NO.' &
           ,1X,I6,4X,'DATA RECORD''S LENGTH:',I6)
!
! 2. Print all data records
!
  DO JDATA = IPNT, IPNT + IDATA - 1
     IDATA2 = JDATA -IPNT + 1
     if(obs_elem_i(obsdat,'ASS ',JDATA).eq.1) then
        ivco=obs_elem_i(obsdat,'VCO ',JDATA)
        if(ivco.ne.1.and.ivco.ne.2) ivco=3
        WRITE(KULOUT,FMT=9201) IDATA2 &
             ,obs_elem_i (obsdat,'VNM ',JDATA) &
             ,ccordtyp   (ivco) &
             ,obs_elem_r4(obsdat,'PPP ',JDATA) &
             ,obs_elem_r4(obsdat,'PRL ',JDATA),obs_elem_r4(obsdat,'POB ',JDATA) &
             ,obs_elem_r4(obsdat,'VAR ',JDATA),obs_elem_r4(obsdat,'OMF ',JDATA) &
             ,obs_elem_r4(obsdat,'OMA ',JDATA),obs_elem_r4(obsdat,'OMI ',JDATA) &
             ,obs_elem_r4(obsdat,'OER ',JDATA) &
             ,obs_elem_r4(obsdat,'RER ',JDATA),obs_elem_r4(obsdat,'FGE ',JDATA) &
             ,obs_elem_r4(obsdat,'PER ',JDATA),obs_elem_i (obsdat,'FLG ',JDATA) &
             ,obs_elem_i (obsdat,'ASS ',JDATA)
     end if
  end do

 9201 FORMAT(4X,'DATA NO.',I6,/,10x &
!     ,'VARIABLE NO.:',I6,4X,'PRESSURE LEVEL:',G12.6,4X &
      ,'VARIABLE NO.:',I6,4X,A13,G12.6,4X &
           ,'REFERENCE LEVEL PRESSURE:',G12.6,4X &
           ,/,33X &
           ,'PRESSURE/GEOPOTENTIAL:',G12.6,4X &
           ,/,10X &
           ,'OBSERVE VALUE:',G23.16,15X,'FIRST-GUESS - OBSERVED VALUE:' &
           ,G23.16,4X &
           ,/,10X &
           ,'ANALYZED - OBSERVED VALUE:',G12.6,4X &
           ,'INITIALIZED - OBSERVED VALUE:',G23.16 &
           ,/,10X &
           ,'ERROR STANDARD DEVIATIONS FOR' &
           ,/,20X &
           ,'OBSERVATION:',G12.6,4X,'REPRESENTATIVENESS:',G12.6,4X &
           ,/,20X &
           ,'FIRST-GUESS:',G12.6,4X,'PERSISTENCE:',G12.6 &
           ,/,10X &
           ,'BURP FLAGS:',I6,4x,'OBS. ASSIMILATED (1-->YES;0-->NO):',I3)

  RETURN
 END subroutine obs_prntbdy


 SUBROUTINE obs_prnthdr(obsdat,KOBS,KULOUT)
#if defined (DOC)
!
!**s/r PRNTHDR  - Printing of the header of an observation record
!
!Author  : P. Gauthier *ARMA/AES  June 9, 1992
!Revision:
!     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
!     . P. Koclas   *CMC:  Format for transformed latitude has been modified
!     .                    to handle an integer (latitude index of the first
!     .                    latitude circle north of the observation)
!Arguments
!     i   KOBS  : No. of observation
!     i   KULOUT: unit used for optional printing
!
#endif

  implicit none


  type(struct_obs), intent(in) :: obsdat
  INTEGER         , intent(in) :: KOBS, KULOUT

!
! 1. General information
!
  WRITE(KULOUT,FMT=9100)KOBS,NCM_LET
 9100 FORMAT(//,10x,'-- OBSERVATION RECORD NO.' &
        ,1X,I6,3X,'HEADER''S LENGTH:',I6)
!
! 2. PRINT HEADER'S CONTENT
!
  WRITE(KULOUT,FMT=9200)&
      obs_elem_i (obsdat,'RLN ',KOBS),obs_elem_i (obsdat,'ONM ',KOBS) &
     ,obs_elem_i (obsdat,'BOX ',KOBS),obs_elem_i (obsdat,'OTP ',KOBS) &
     ,obs_elem_i (obsdat,'ITY ',KOBS) &
     ,obs_elem_r4(obsdat,'LAT ',KOBS),obs_elem_r4(obsdat,'LON ',KOBS)&
     ,obs_elem_i (obsdat,'DAT ',KOBS),obs_elem_i (obsdat,'ETM ',KOBS) &
     ,obs_elem_c9(obsdat,'STID',KOBS),obs_elem_r4(obsdat,'ALT ',KOBS) &
     ,obs_elem_i (obsdat,'NLV ',KOBS),obs_elem_i (obsdat,'OEC ',KOBS) &
     ,obs_elem_i (obsdat,'OFL ',KOBS),obs_elem_i (obsdat,'ST1 ',KOBS) &
     ,obs_elem_i (obsdat,'TLA ',KOBS)

 9200 FORMAT(6X,'Position within ROBDATA:',I6,1X,'OBS. NUMBER:',I6,1X &
           ,'MODEL BOX:',I6,1X,'OBS. TYPE:',I6,1X &
           ,'INSTR./RETR. TYPE:',I6,1X &
           ,/,6X &
           ,'OBSERVATION LOCATION. (LAT,LON):',2(F12.6,1X) &
           ,'DATE:',I12,1X,'EXACT TIME: ',I6,1X &
           ,/,6X &
           ,'STATION ID:',A9,1X &
           ,'STATION''S ALTITUDE:',G12.6,1X &
           ,'NUMBER OF DATA:',I6,1X,'ERROR CORR. TYPE',I6,1X &
           ,/,6X &
           ,'REPORT STATUS:',I6,5X,'REPORT STATUS 2:',I6,1X &
           ,/,6X &
           ,'Index of latitude north of the observation:',(1X,I6) &
           )

  RETURN
 END SUBROUTINE obs_prnthdr


 subroutine obs_set_i(obsdat, name, index, value)
!s/r obs_set_i - set an integer value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  integer         , intent(in)     :: value

  select case (name(1:4))
  case ('RLN '); obsdat%mobhdr (NCM_RLN, index) = value
  case ('ONM '); obsdat%mobhdr (NCM_ONM, index) = value
  case ('BOX '); obsdat%mobhdr (NCM_BOX, index) = value
  case ('OTP '); obsdat%mobhdr (NCM_OTP, index) = value
  case ('ITY '); obsdat%mobhdr (NCM_ITY, index) = value
  case ('DAT '); obsdat%mobhdr (NCM_DAT, index) = value
  case ('ETM '); obsdat%mobhdr (NCM_ETM, index) = value
  case ('NLV '); obsdat%mobhdr (NCM_NLV, index) = value
  case ('OFL '); obsdat%mobhdr (NCM_OFL, index) = value
  case ('PAS '); obsdat%mobhdr (NCM_PAS, index) = value
  case ('REG '); obsdat%mobhdr (NCM_REG, index) = value
  case ('IP  '); obsdat%mobhdr (NCM_IP , index) = value
  case ('AZA '); obsdat%mobhdr (NCM_AZA, index) = value
  case ('SUN '); obsdat%mobhdr (NCM_SUN, index) = value
  case ('CLF '); obsdat%mobhdr (NCM_CLF, index) = value
  ! Added for var3d
  case ('OEC '); obsdat%mobhdr (NCM_OEC, index) = value
  case ('ST1 '); obsdat%mobhdr (NCM_ST1, index) = value
  case ('TLA '); obsdat%mobhdr (NCM_TLA, index) = value

  ! integer body values
  case ('VNM '); obsdat%mobdata(NCM_VNM, index) = value
  case ('FLG '); obsdat%mobdata(NCM_FLG, index) = value
  case ('KFA '); obsdat%mobdata(NCM_KFA, index) = value
  case ('ASS '); obsdat%mobdata(NCM_ASS, index) = value
  case ('OBS '); obsdat%mobdata(NCM_OBS, index) = value
  case ('VCO '); obsdat%mobdata(NCM_VCO, index) = value
  case ('LBO '); obsdat%mobdata(NCM_LBO, index) = value
  case ('POS '); obsdat%mobdata(NCM_POS, index) = value
  case ('LYR '); obsdat%mobdata(NCM_LYR, index) = value
  case ('XTR '); obsdat%mobdata(NCM_XTR, index) = value
  case ('LOBS'); obsdat%mobdata(NCM_LOBS,index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
  end select
 end subroutine obs_set_i


 subroutine obs_set_r4(obsdat, name, index, value)
!s/r obs_set_r4 - set a real value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  real(kind=4)    , intent(in)     :: value

  select case (name(1:4))
  case ('LAT '); obsdat%robhdr (NCM_LAT, index) = value
  case ('LON '); obsdat%robhdr (NCM_LON, index) = value
  case ('ALT '); obsdat%robhdr (NCM_ALT, index) = value
  case ('BX  '); obsdat%robhdr (NCM_BX , index) = value
  case ('BY  '); obsdat%robhdr (NCM_BY , index) = value
  case ('BZ  '); obsdat%robhdr (NCM_BZ , index) = value

  case ('PPP '); obsdat%robdata(NCM_PPP, index) = value
  case ('PRL '); obsdat%robdata(NCM_PRL, index) = value
  case ('VAR '); obsdat%robdata(NCM_VAR, index) = value
  case ('OMP '); obsdat%robdata(NCM_OMP, index) = value
  case ('OMA '); obsdat%robdata(NCM_OMA, index) = value
  case ('OER '); obsdat%robdata(NCM_OER, index) = value
  case ('HPHT'); obsdat%robdata(NCM_HPHT,index) = value
  case ('ZHA '); obsdat%robdata(NCM_ZHA, index) = value
  case ('POB '); obsdat%robdata(NCM_POB, index) = value
  case ('OMF '); obsdat%robdata(NCM_OMF, index) = value
  case ('OMI '); obsdat%robdata(NCM_OMI, index) = value
  case ('OMN '); obsdat%robdata(NCM_OMN, index) = value
  case ('RER '); obsdat%robdata(NCM_RER, index) = value
  case ('FGE '); obsdat%robdata(NCM_FGE, index) = value
  case ('PER '); obsdat%robdata(NCM_PER, index) = value
  case ('PRM '); obsdat%robdata(NCM_PRM, index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a real(4) observation."
  end select
 end subroutine obs_set_r4


 subroutine obs_set_r8(obsdat, name, index, value)
!s/r obs_set_r8 - set a double value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  real(kind=8)    , intent(in)     :: value

  select case (name(1:4))
  case ('PPP '); obsdat%robdata8(NCM_PPP, index) = value
  case ('PRL '); obsdat%robdata8(NCM_PRL, index) = value
  case ('POB '); obsdat%robdata8(NCM_POB, index) = value
  case ('VAR '); obsdat%robdata8(NCM_VAR, index) = value
  case ('OMF '); obsdat%robdata8(NCM_OMF, index) = value
  case ('OMA '); obsdat%robdata8(NCM_OMA, index) = value
  case ('OMI '); obsdat%robdata8(NCM_OMI, index) = value
  case ('OMN '); obsdat%robdata8(NCM_OMN, index) = value
  case ('OER '); obsdat%robdata8(NCM_OER, index) = value
  case ('RER '); obsdat%robdata8(NCM_RER, index) = value
  case ('FGE '); obsdat%robdata8(NCM_FGE, index) = value
  case ('PER '); obsdat%robdata8(NCM_PER, index) = value
  case ('PRM '); obsdat%robdata8(NCM_PRM, index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a real(8) observation."
  end select
 end subroutine obs_set_r8


 subroutine obs_set_c9(obsdat, name, index, value)
!s/r obs_set_c9 - set a character(len=9) in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  character(len=9), intent(in)     :: value

  select case (name(1:4))
  case ('STID'); obsdat%cstnid (index) = value !! // '   '

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a character(len=9) observation."
  end select
 end subroutine obs_set_c9


 integer function obs_ifind(kbufrn)
  implicit none
!
  integer, intent(in) :: kbufrn
!
!      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
!               THAT CONTAINS A BUFR ELEMENT NUMBER
!
!    ARGUMENTS:
!               INPUT:
!                      -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
!                               i.e. known locally as the 'burp variable type'
!                               i.e. table B of the ECMWF BUFR reference
!                               BUFR = Binary Universal Form for the
!                                      Representation of meteorological data
!
!               OUTPUT:
!                      - obs_ifind:
!                                              THE FOUND INDEX (=-1 IF NOT FOUND)
!
!       AUTHOR: P. KOCLAS (CMC TEL. 4665)

  integer indbuf
  integer, parameter, dimension(OBS_JPNBRELEM) :: nvnumb = (/ &
    011003, 011004, 010194, 010192,     29, & !  1-10
    013208, 012063, 012001, 012192, 012004, &
    012203, 011215, 011216, 013210, 013220, & ! 11-20
        62, 015001,     64,     65, 015036, &
    015031, 015032,     69,     70,     71, & ! 21-30
        72,     73,     74,     75,     76, &
        77,     78,     79,     80,     81, & ! 31-40
        82,     83,     84,     85,     86, &
        87,     88,     89,     90,     91, & ! 41-50
    012163, 010004, 011001, 011002, 012062, &
    008001, 008004, 010051, 011011, 011012, & ! 51-57
        41,     42 /)


! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
!   Descriptions taken from 3d variational code (March 2011, revision 11.0.2)
!
!  1 =011003 (U COMPONENT)           (m/s)
!  2 =011004 (V COMPONENT)           (m/s)
!  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
!  4 =010192 (THICKNESS IN M)
!  5 =    29 (RELATIVE HUMIDITY)
!  6 =013208
!  7 =012063 BRIGHTNESS TEMPERATURE 1
!  8 =012001 (TEMPERATURE)            (kelvin)
!  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
! 10 =012004 (2M TEMPERATURE)
! 11 =012203 (2M DEW-POINT DEPRESSION)
! 12 =011215 SURFACE U     WIND COMPONENT M/S)
! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
! 16 =007006 HEIGHT ABOVE STATION (M)
! 17 =015001 (Total Ozone from TOVS)
! 18 =    64 (CM)
! 19 =    65 (CL)
! 20 =015036 (GPSRO REFRACTIVITY)
! 21 =015031 (GPSGB ZTD IN M)
! 22 =015032 (GPSGB ZTD ERROR IN M)
! 23 =    69 (C)
! 24 =    70 (NS)
! 25 =    71 (S)
! 26 =    72 (E)
! 27 =    73 (TGTG)
! 28 =    74 (SPSP)
! 29 =    75 (SPSP)
! 30 =    76 (RS)
! 31 =    77 (ESES)
! 32 =    78 (IS)
! 33 =    79 (TRTR)
! 34 =    80 (RR)
! 35 =    81 (JJ)
! 36 =    82 (VS)
! 37 =    83 (DS)
! 38 =    84 (HWHW)
! 39 =    85 (PWPW)
! 40 =    86 (DWDW)
! 41 =    87 (GENERAL CLOUD GROUP)
! 42 =    88 (RH FROM LOW CLOUDS)
! 43 =    89 (RH FROM MIDDLE CLOUDS)
! 44 =    90 (RH FROM HIGH CLOUDS)
! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
! 46 =012163 (TOVS LEVEL 1B RADIANCES)
! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
! 49 =011002(FF (WIND SPEED))                (m/s)
! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
! 51 =008001
! 52 =008004
! 53 =010051
! 54 =011011
! 55 =011012
! 56 =    41 (U AT 10M)
! 57 =    42 (V AT 10M)

  obs_ifind=-1
  do indbuf=1,OBS_JPNBRELEM
   if (nvnumb(indbuf) .EQ. kbufrn ) then
    obs_ifind=indbuf
    return
   endif
  enddo
  return

 end function obs_ifind


 SUBROUTINE obs_reduceToMpiLocal(obsdat, nfiles, nbegintyp, &
                                 nendtyp, nbegintyp_g, nendtyp_g)
!
!**s/r obs_reduceToMpiLocal - re-construct observation data object by giving 
!                             local Obs TAG. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To retain in the observation object only those data that are
!                pertinent to the present mpi processor.
!
  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in)    :: nfiles
  integer, intent(inout) :: nbegintyp(:), nendtyp(:)
  integer, intent  (out) :: nbegintyp_g(:), nendtyp_g(:)

! Declare Local Variables
  CHARACTER(len=9),ALLOCATABLE,DIMENSION(:) :: cstnid_tmp
  CHARACTER(len=2),ALLOCATABLE,DIMENSION(:) :: cfamily_tmp
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBHDR_tmp,ROBDATA_tmp
  REAL(8),ALLOCATABLE,DIMENSION(:,:) :: ROBDATA8_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp,MOBDATA_TMP
  INTEGER,ALLOCATABLE,DIMENSION(:) :: locObsTag_tmp
  integer :: numbody_mpilocal
  
  INTEGER :: i,j,iobs,ierr ,numheader_mpilocal ,startindx,endindx 
  INTEGER :: idataend,jj,ifamid,istart,idata,ii 
  LOGICAL :: lfirst 
!!---------------------------------------------------------------
  WRITE(*,*) '============= Enter obs_reduceToMpiLocal =============='

  call obs_getobstag(obsdat)

  write(*,*) obsdat%numheader,obsdat%numheader_mpiglobal,obsdat%numbody

  if(obsdat%mpi_local .eqv. .true.)then
    write(*,*)'ERROR: obs_reduceToMpiLocal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-local state'
    call qqexit(1)
  end if
  obsdat%mpi_local = .true.

  numheader_mpilocal=size(obsdat%locObsTag) 

  ! Calculate the size of the local obs data  
  numbody_mpilocal=0
  DO i=1,numheader_mpilocal
   iobs=obsdat%locObsTag(i)
   idata=obsdat%mobhdr(NCM_NLV, iobs)
   numbody_mpilocal = numbody_mpilocal + idata
  ENDDO 

  ALLOCATE(cfamily_tmp(numheader_mpilocal),STAT=ierr) 
  ALLOCATE(cstnid_tmp(numheader_mpilocal),STAT=ierr) 
  ALLOCATE(ROBHDR_tmp(NCM_LET,numheader_mpilocal),STAT=ierr) 
  ALLOCATE(MOBHDR_tmp(NCM_LET,numheader_mpilocal),STAT=ierr) 
  ALLOCATE(MOBDATA_tmp(NCM_LBO,numbody_mpilocal),STAT=ierr) 
  ALLOCATE(ROBDATA_tmp(NCM_LBO,numbody_mpilocal),STAT=ierr) 
  ALLOCATE(ROBDATA8_tmp(3:11,numbody_mpilocal),STAT=ierr) 
!  
  call obs_allocateG(obsdat,obsdat%numheader)
!
  obsdat%numheader_mpiglobal=obsdat%numheader

!! keep the Global ROBHDR and MOBHDR
  DO iobs=1,obsdat%numheader_mpiglobal
    obsdat%CSTNID_G(iobs)=obsdat%CSTNID(iobs)
    obsdat%MOBHDR_G(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,iobs)
    obsdat%ROBHDR_G(1:NCM_LET,iobs)=obsdat%ROBHDR(1:NCM_LET,iobs)
  ENDDO  
!!
  DO i=1,numheader_mpilocal 
    iobs=obsdat%locObsTag(i) 
    ROBHDR_tmp(1:NCM_LET,i)=obsdat%ROBHDR(1:NCM_LET,iobs)
    MOBHDR_tmp(1:NCM_LET,i)=obsdat%MOBHDR(1:NCM_LET,iobs)
    cstnid_tmp(i) = obsdat%cstnid(iobs)
    cfamily_tmp(i) = obsdat%cfamily(iobs) 
    IF(i== 1) THEN
       MOBHDR_tmp(NCM_RLN,1) = 1
    ELSE
       MOBHDR_tmp(NCM_RLN,i)=MOBHDR_tmp(NCM_RLN,i-1) + MOBHDR_tmp(NCM_NLV,i-1) 
    ENDIF 
  ENDDO

  ii=0 
  DO i=1,numheader_mpilocal
    iobs=obsdat%locObsTag(i) 
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
    DO j=idata,idataend 
       ii=ii+1 
       ROBDATA8_tmp(3:11,ii)=obsdat%ROBDATA8(3:11,j)
       MOBDATA_tmp(1:NCM_LBO,ii)=obsdat%MOBDATA(1:NCM_LBO,j) 
       ROBDATA_tmp(1:NCM_LBO,ii)=obsdat%ROBDATA(1:NCM_LBO,j) 
       MOBDATA_tmp(NCM_OBS,ii) = i
    ENDDO 
  ENDDO 
  
  obsdat%numheader=numheader_mpilocal
  obsdat%numbody=numbody_mpilocal
  write(*,*) 'NUMHEADER= ',obsdat%numheader 
  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,obsdat%numheader,obsdat%numbody)
!
  DO i=1,obsdat%numheader
     obsdat%cfamily(i)=cfamily_tmp(i) 
     obsdat%cstnid(i)=cstnid_tmp(i)
     obsdat%ROBHDR(1:NCM_LET,i)=ROBHDR_tmp(1:NCM_LET,i)
     obsdat%MOBHDR(1:NCM_LET,i)=MOBHDR_tmp(1:NCM_LET,i) 
  ENDDO 

  DO i=1,obsdat%numbody
     obsdat%ROBDATA8(3:11,i)=ROBDATA8_tmp(3:11,i) 
     obsdat%MOBDATA(1:NCM_LBO,i)=MOBDATA_tmp(1:NCM_LBO,i) 
     obsdat%ROBDATA(1:NCM_LBO,i)=ROBDATA_tmp(1:NCM_LBO,i)
  ENDDO 

  deallocate(cfamily_tmp)
  deallocate(cstnid_tmp)
  deallocate(ROBHDR_tmp)
  deallocate(MOBHDR_tmp)
  deallocate(ROBDATA8_tmp)
  deallocate(MOBDATA_tmp)
  deallocate(ROBDATA_tmp)

 ! rebuild NBEGINTYP and NENDTYP  
 !============================
  jj=0
  NBEGINTYP_G=NBEGINTYP
  NENDTYP_G=NENDTYP
 
  NBEGINTYP=0
  NENDTYP=0
  DO j=1,NFILES
    lfirst=.true. 
    DO i=1,numheader_mpilocal
      istart=obsdat%mobhdr(NCM_RLN, i)
      idata=obsdat%mobhdr(NCM_NLV, i)
      ifamid=obsdat%mobhdr(NCM_OEC, i)
      IF(ifamid == J) THEN
         IF(lfirst) THEN
           NBEGINTYP(j) = istart 
           lfirst=.false. 
         ENDIF 
         JJ=JJ+idata 
      ENDIF 
    ENDDO 
    NENDTYP(J) = JJ 
    IF(NBEGINTYP(j) == 0)  NENDTYP(J) = 0
    WRITE(*,*) 'J NBEGINTYP(j) NENDTYP(j)= ',J,NBEGINTYP(j), NENDTYP(j),ifamid
  ENDDO  
  
  write(*,*) obsdat%numheader,obsdat%numheader_mpiglobal,obsdat%numbody
  WRITE(*,*) '============= Leave obs_reduceToMpiLocal =============='

  RETURN
 END SUBROUTINE obs_reduceToMpiLocal


 SUBROUTINE obs_expandToMpiGlobal(obsdat)
#if defined (DOC)
!
!**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global observation object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat

  CHARACTER(len=9),ALLOCATABLE    :: cstnid_tmp(:)

  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBDATA_tmp
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBHDR_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBDATA_tmp
  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp 
  
  INTEGER :: i,j,iobs,ierr,startindx,endindx 
  INTEGER :: idataend,idata,ii  
  INTEGER :: sizeMOBHDR,sizeROBHDR,sizeMOBDATA,sizeROBDATA  
!!---------------------------------------------------------------

  write(*,*) 'Entering obs_expandToMpiGlobal'

  if(obsdat%mpi_local .eqv. .false.)then
    write(*,*)'ERROR: obs_expandToMpiGlobal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-global state'
    call qqexit(1)
  end if
  obsdat%mpi_local = .false.

  ! Restore header elements
  ALLOCATE(MOBHDR_tmp(NCM_LET,obsdat%numheader_mpiglobal),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cannot allocate mobhdr_tmp!')
  MOBHDR_TMP=0

  ALLOCATE(ROBHDR_tmp(NCM_LET,obsdat%numheader_mpiglobal),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cannot allocate robhdr_tmp!')
  ROBHDR_TMP=0

  DO i=1,obsdat%numheader
     iobs=obsdat%locObsTag(i)
     MOBHDR_tmp(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,i)
     ROBHDR_tmp(1:NCM_LET,iobs)=obsdat%ROBHDR(1:NCM_LET,i)
  ENDDO

  sizeMOBHDR=size(MOBHDR_tmp)
  CALL RPN_COMM_ALLReduce(MOBHDR_tmp,MOBHDR_tmp,sizeMOBHDR,"mpi_integer", &
                          "mpi_sum","GRID",ierr)

  sizeROBHDR=size(ROBHDR_tmp)
  CALL RPN_COMM_ALLReduce(ROBHDR_tmp,ROBHDR_tmp,sizeROBHDR,"mpi_real", &
                          "mpi_sum","GRID",ierr)

  ! Get the cstnid from the global copy
  ALLOCATE(cstnid_tmp(obsdat%numheader_mpiglobal),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cannot allocate cstnid_tmp!')
  do i=1,obsdat%numheader_mpiglobal
    cstnid_tmp(i)=obsdat%cstnid_g(i)
  enddo

  ! Allocate memory for the temporary arrays.
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%numbody_max),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cant allocate Mem. to MOBDATA_tmp,Abort!')
  MOBDATA_tmp=0

  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%numbody_max),STAT=ierr)
  IF(ierr /= 0) call  obs_abort('Cant allocate Mem. to ROBDATA_tmp,Abort!')
  ROBDATA_tmp=0.0

  ! Restore the global arrays MOBDATA and ROBDATA
  ii=0
  DO i=1,obsdat%numheader
    iobs=obsdat%locObsTag(i)
    idata= obsdat%mobhdr_g(NCM_RLN, iobs)
    idataend = obsdat%mobhdr_g(NCM_NLV, iobs) + idata -1
    DO j=idata,idataend
       ii=ii+1
       MOBDATA_tmp(1:NCM_LBO,j)=obsdat%MOBDATA(1:NCM_LBO,ii)
       ROBDATA_tmp(1:NCM_LBO,j)=obsdat%ROBDATA(1:NCM_LBO,ii)
    ENDDO
  ENDDO
   !
   ! Merge the global arrays MOBDATA_tmp and ROBDATA_tmp.
  sizeMOBDATA=size(MOBDATA_tmp)
  CALL RPN_COMM_ALLReduce(MOBDATA_tmp,MOBDATA_tmp,sizeMOBDATA,"mpi_integer",&
                          "mpi_sum","GRID",ierr)
  sizeROBDATA=size(ROBDATA_tmp)
  CALL RPN_COMM_ALLReduce(ROBDATA_tmp,ROBDATA_tmp,sizeROBDATA,"mpi_real",&
                          "mpi_sum","GRID",ierr)
   !

  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,obsdat%numheader_mpiglobal,obsdat%numbody_max)

  obsdat%cstnid=cstnid_tmp
  obsdat%ROBHDR=ROBHDR_tmp
  obsdat%MOBHDR=MOBHDR_tmp
  obsdat%ROBDATA=ROBDATA_tmp
  obsdat%MOBDATA=MOBDATA_tmp

  DEALLOCATE(cstnid_tmp)
  DEALLOCATE(ROBHDR_tmp)
  DEALLOCATE(MOBHDR_tmp)
  DEALLOCATE(ROBDATA_tmp)
  DEALLOCATE(MOBDATA_tmp)

  call obs_deallocateG(obsdat)

  write(*,*) 'Leaving obs_expandToMpiGlobal'
  RETURN
 END SUBROUTINE obs_expandToMpiGlobal


end module obsSpaceData_mod
