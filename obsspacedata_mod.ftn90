! ObsSpaceData_mod:  the module, ObsSpaceData_mod, follows IndexListDepot_mod
#include "maincompileswitch.inc"
#include "compileswitches.inc"


module IndexListDepot_mod
   ! This is not a fully fledged module.  It is more like a structure definition
   ! with a couple of helpful methods.  It is intended that clients read/write
   ! directly from/to instances of these structures.  The intended client is
   ! obsSpaceData_mod.

   implicit none
   save
   public

   ! methods
   public :: ild_initialize, ild_get_empty_index_list, ild_get_next_index

   interface ild_get_next_index
      module procedure ild_get_next_index_depot
      module procedure ild_get_next_index_private
   end interface

   ! This dimension must accommodate the
   ! maximum number of OMP processors 
   integer, parameter :: NUMBER_OF_LISTS = 32

   type struct_index_list
      ! a list of integers, not to say indices into a struct_obs
      character(len=2) :: family        ! current_element's belong to this family
      ! Used only for a body list:
      integer :: header                 ! current_element's belong to this header
      integer :: current_element        ! the element that has just been returned

                                        ! the actual list of integers
                                        ! N.B.:  that which is an index to a
                                        !        client of this module is an
                                        !        element to this module
      integer, dimension(:), allocatable :: indices
   end type struct_index_list

   type struct_index_list_depot
      ! A collection of lists, either empty or populated
                                        ! the collection of lists
      type(struct_index_list), dimension(NUMBER_OF_LISTS) :: index_lists
      integer :: list_last_attributed   ! list that was populated most recently
                                        ! list that was   used    most recently
      type(struct_index_list), pointer :: current_list
   end type struct_index_list_depot


contains
   subroutine ild_initialize(depot, numheader_max)
      ! Initialize the indicated list depot
      implicit none
      type(struct_index_list_depot), intent(inout) :: depot
                                        ! max size of struct_obs & hence of depot
      integer , intent(in) :: numheader_max

      integer :: list                   ! an index

      ! Allocate each list
      do list = 1,NUMBER_OF_LISTS
         allocate(depot%index_lists(list)%indices(numheader_max))
         depot%list_last_attributed = 0
      end do
   end subroutine ild_initialize


   function ild_get_empty_index_list(depot, private_list) &
      result(empty_index_list)
      ! From the given depot, return an index-list structure that contains no
      ! data, as a pointer.
      !
      ! In other words, clear data from the (cyclicly) next (i.e. oldest) list
      ! and return a pointer to it.
      implicit none
      type(struct_index_list), pointer :: empty_index_list
      type(struct_index_list_depot), intent(inout), target :: depot
      type(struct_index_list), pointer, intent(inout), optional :: private_list

      nullify(empty_index_list)

      if(present(private_list)) then
         ! This is an OMP thread
         if(associated(private_list)) then
            ! Memory has already been assigned for that thread.  Re-use it.
            empty_index_list => private_list ! Set the return pointer
         end if
      end if

      if(.not. associated(empty_index_list)) then
         !$omp critical
         ! Increment (cyclicly) the index to the next list
         depot%list_last_attributed = depot%list_last_attributed + 1
         if (depot%list_last_attributed > NUMBER_OF_LISTS) &
            depot%list_last_attributed = 1

         ! Set the return pointer
         empty_index_list => depot%index_lists(depot%list_last_attributed)
         !$omp end critical
      end if

      ! Initialize some values in the list
      ! empty_index_list%indices(:) = -1 --> No, the array is too big.
      empty_index_list%family = '  '
      empty_index_list%header = -1
      empty_index_list%current_element = 0

      return
   end function ild_get_empty_index_list


   function ild_get_next_index_depot(depot, no_advance) result(next_index)
      ! From the given depot, increment the index to the current element, and
      ! return the element itself, the new current element.
      implicit none
      integer :: next_index
      type(struct_index_list_depot), intent(inout), target :: depot
                                        ! Do not increment current_element,
                                        ! just return the next one
      logical, intent(in), optional :: no_advance

                                        ! current list of the depot
      type(struct_index_list), pointer :: current_list
      integer :: next_element           ! next element of the current list

      current_list => depot%current_list
      !$omp critical
                                        ! Obtain the next element from the list
      next_element = current_list%current_element + 1
      next_index = current_list%indices(next_element)

      if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
         current_list%current_element = next_element
      end if
      !$omp end critical
   end function ild_get_next_index_depot


   function ild_get_next_index_private(private_list, no_advance) &
      result(next_index)
      ! From the given list, increment the index to the current element, and
      ! return the element itself, the new current element.
      implicit none
      integer :: next_index
      type(struct_index_list), pointer, intent(inout) :: private_list
                                        ! Do not increment current_element,
                                        ! just return the next one
      logical, intent(in), optional :: no_advance

      integer :: next_element           ! next element of the list

                                        ! Obtain the next element from the list
      next_element = private_list%current_element + 1
      next_index = private_list%indices(next_element)

      if(.not. present(no_advance) .and. next_index .ne. -1) then
                                        ! Increment the current element
         private_list%current_element = next_element
      end if
   end function ild_get_next_index_private

end module IndexListDepot_mod







module obsSpaceData_mod
   use IndexListDepot_mod
   implicit none
   save
   private

   ! This module deals with operations involving the data structure for
   ! storing observational information.
   !   (this had evolved from the CMA structure, originated in work by
   !    D. Vasiljevic at ECMWF)
   !
   ! First creation of the module: February 2011 by Peter Houtekamer
   !

   ! PUBLIC METHODS:
   public obs_allocate   ! array allocation
   public obs_append     ! append an obsdat object to another obsdat object
   public obs_bdy        ! fill in the ObsSpaceData body from burp(3dvar version)
   public obs_clean      ! remove from obs data those that not to be assimilated
   public obs_comm       ! communicate header and body info between mpi processes
   public obs_copy       ! copy an obsdat object
   public obs_count_headers ! count the stations and observations in the object
   public obs_deallocate ! array de-allocation
   public obs_elem_c     ! obtain character element from the observation object
   public obs_elem_i     ! obtain an integer element from the observation object
   public obs_elem_mpiglobal_i ! obs_elem_i, not restricted to the mpi-local PE
   public obs_elem_mpiglobal_r ! obs_elem_r, not restricted to the mpi-local PE
   public obs_elem_r     ! obtain a real element from the observation object
   public obs_enkf_bdy   ! fill in the ObsSpaceData body from burp(EnKF version)
   public obs_enkf_prntbdy! print all data records associated with an observation
   public obs_enkf_prnthdr! print the header of an observation record
   public obs_expandToMpiGlobal ! restore data for the mpi-global context
   public obs_finalize   ! object clean-up
   public obs_generate_header ! fill in observation-data header, from burp files
   public obs_get_datestamp ! get the object's date stamp
                         ! find the index into the variable types list of the
                         ! obsdat element that contains given BUFR element number
   public obs_get_obs_index_for_bufr_element
   public obs_getBodyIndex ! obtain an element from the current boedy list
   public obs_getFamily  ! return the family of a datum
   public obs_getHeaderIndex ! obtain an element from the current header list
   public obs_initialize ! variable initialization
   public obs_numbody    ! returns the number of observations recorded
   public obs_numbody_max! returns the dimensioned number of observations
   public obs_numheader  ! returns the number of stations recorded
   public obs_numheader_max ! returns the dimensioned number of stations
   public obs_numheader_mpiglobal ! no. stations recorded, in mpi-global context
   public obs_order      ! put obs data in the order required for assimilation
   public obs_print      ! obs_enkf_prnthdr & obs_enkf_prntbdy for each station
   public obs_prnt_csv   ! call obs_tosqlhdr and obs_tosqlbdy for each station
   public obs_prntbdy    ! print the body data for one header
   public obs_prnthdr    ! print the data contained in one header
   public obs_read       ! read the observation data from binary files
   public obs_readstns   ! read stations for one analysis pass & store in buffers
   public obs_reduceToMpiLocal ! retain only data pertinent to the mpi-local PE
   public obs_select     ! select observations in a vertical range
   public obs_set_c      ! set a character value in the observation object
   public obs_set_current_body_list   ! set a body list for a family as current
   public obs_set_current_header_list ! set a header list for a family as current
   public obs_set_datestamp! set the object's date stamp
   public obs_set_i      ! set an integer value in the observation object
   public obs_set_r      ! set a real value in the observation object
   public obs_setFamily  ! set the family of a datum
   public obs_status     ! returns the values of the object's status variables
   public obs_swapVarOmf ! exchange the values of 'VAR ' and 'OMF '
   public obs_write      ! write the observation data to binary files
                         ! (calls obs_write_hdr, obs_write_bdy, obs_write_hx
                         !  for each station)

   ! PRIVATE METHODS:
   private obs_abort     ! abort a job on error
   private obs_allocateG ! array allocation for mpi-local context
   private obs_deallocateG ! array de-allocation for mpi-local context
   private obs_exchange_stations ! exchange the headers of stations j and k
   private obs_getobstag ! read local observation tag from GEM TLM-ADJ
   private obs_tosqlbdy  ! write the observation data in comma-separated format
   private obs_tosqlhdr  ! write the observation header in comma-separated format
   private obs_write_bdy ! write the observation data to binary files
   private obs_write_hdr ! write the observation header to binary files
   private obs_write_hx  ! write to binary files a station's interpolated values


   interface obs_getBodyIndex
      module procedure obs_getBodyIndex_depot
      module procedure obs_getBodyIndex_private
   end interface

   interface obs_set_current_body_list
      module procedure obs_set_current_body_list_from_family
      module procedure obs_set_current_body_list_from_header
   end interface


   ! observation-space fundamental parameters
   public           :: OBS_JPNBRELEM

   ! column dimensions
   public           :: NHDR_INT, NHDR_REAL, NBDY_INT, NBDY_REAL


   ! derived type and module variable declarations
   type, public :: struct_obs
      private
      type(struct_index_list_depot) :: header_index_list_depot
      type(struct_index_list_depot) :: body_index_list_depot
                                        ! For these arrays:
                                        !   1st dim'n:  entry index
      character(len=12),  pointer, dimension(:)   :: cstnid
      character(len=2),   pointer, dimension(:)   :: cfamily
                                        ! For these arrays:
                                        !   1st dim'n:  column number
                                        !   2nd dim'n:  entry index
      real(kind=OBS_REAL),pointer, dimension(:,:) :: robhdr
      integer,            pointer, dimension(:,:) :: mobhdr
      real(kind=OBS_REAL),pointer, dimension(:,:) :: robdata
      integer,            pointer, dimension(:,:) :: mobdata
      integer :: numheader              ! Actual number of stations on record
      integer :: numheader_max          ! maximum number of stations
      integer :: numbody                ! Actual total number of data on record
      integer :: numbody_max            ! maximum number observations (i.e. data)
      integer :: numheader_mpiglobal    ! Actual number of stations on record
      integer :: numbody_mpiglobal      ! Actual total number of data on record

      ! Headers of the mpi-Global obs data
      integer,            pointer, dimension(:,:) :: mobhdr_g
      real(kind=OBS_REAL),pointer, dimension(:,:) :: robhdr_g
      character(len=12),  pointer, dimension(:)   :: cstnid_g
      integer,            pointer, dimension(:)   :: locObsTag

      logical :: mpi_local              ! T: keep only data needed by this PE
      integer :: datestamp
   end type struct_obs

   !
   ! INTEGER-HEADER COLUMN NUMBERS
   !  
   integer, parameter :: NCM_RLN = 1         ! report location
   integer, parameter :: NCM_ONM = NCM_RLN+1 ! unique(within obsdat) station id #
   integer, parameter :: NCM_INS = NCM_ONM+1 ! instrument ID  
   integer, parameter :: NCM_OTP = NCM_INS+1 ! observation Type (file index)
   integer, parameter :: NCM_ITY = NCM_OTP+1 ! code: instrument & retrieval type
   integer, parameter :: NCM_SAT = NCM_ITY+1 ! satellite code 
   integer, parameter :: NCM_TEC = NCM_SAT+1 ! satellite processing technique
   integer, parameter :: NCM_DAT = NCM_TEC+1 ! date YYYYMMD
   integer, parameter :: NCM_ETM = NCM_DAT+1 ! time HHMM
   integer, parameter :: NCM_NLV = NCM_ETM+1 ! number of data at this location
   integer, parameter :: NCM_OFL = NCM_NLV+1 ! report status events
   integer, parameter :: NCM_PAS = NCM_OFL+1 ! batch no. in sequential analysis
   integer, parameter :: NCM_REG = NCM_PAS+1 ! region number in the batch
   integer, parameter :: NCM_IP  = NCM_REG+1 ! number of processor
   integer, parameter :: NCM_AZA = NCM_IP+1  ! satellite azimuthal angle
   integer, parameter :: NCM_SZA = NCM_AZA+1 ! satellite zenith angle
   integer, parameter :: NCM_SUN = NCM_SZA+1 ! sun zenith angle
   integer, parameter :: NCM_CLF = NCM_SUN+1 ! cloud fraction
   integer, parameter :: NCM_ST1 = NCM_CLF+1 ! header level status/rejection flag
   integer, parameter :: NCM_TLA = NCM_ST1+1 ! index of latitude N of observation
   integer, parameter :: NCM_IDO = NCM_TLA+1 ! (absolutely) unique station id no.
   integer, parameter :: NCM_IDF = NCM_IDO+1 ! id. no. of observation-source file

   ! the number of integer variables defined just above
   integer, parameter :: NHDR_INT = NCM_IDF

   !
   ! REAL-HEADER COLUMN NUMBERS
   !
   integer, parameter :: NCM_LAT = 1         ! latitude  in radians (N positive)
   integer, parameter :: NCM_LON = NCM_LAT+1 ! longitude in radians (E positive)
   integer, parameter :: NCM_ALT = NCM_LON+1 ! station altitude
   integer, parameter :: NCM_BX  = NCM_ALT+1 ! x-coordinate of block in R3
   integer, parameter :: NCM_BY  = NCM_BX +1 ! y-coordinate of block in R3
   integer, parameter :: NCM_BZ  = NCM_BY +1 ! z-coordinate of block in R3

   ! the number of real variables defined just above
   integer, parameter :: NHDR_REAL = NCM_BZ

   !
   ! INTEGER-BODY COLUMN NUMBERS
   !
   integer, parameter :: NCM_VNM = 1         ! variable number
   integer, parameter :: NCM_FLG = NCM_VNM+1 ! flags
   integer, parameter :: NCM_KFA = NCM_FLG+1 ! marker for forward interp problems
   integer, parameter :: NCM_ASS = NCM_KFA+1 ! flag to indicate if assimilated
   integer, parameter :: NCM_OBS = NCM_ASS+1 ! observation number (as in header)
   integer, parameter :: NCM_VCO = NCM_OBS+1 ! type of vertical coordinate
   integer, parameter :: NCM_LYR = NCM_VCO+1 ! Index of anal level above observ'n

                                             ! Flag: extrapolation necessary of
                                             ! anal variables to obs'n location 
   integer, parameter :: NCM_XTR = NCM_LYR+1
   integer, parameter :: NCM_IDD = NCM_XTR+1 ! data id. no.

   ! the number of integer variables defined just above
   integer, parameter :: NBDY_INT = NCM_IDD

   !
   ! REAL-BODY COLUMN NUMBERS
   !
   integer, parameter :: NCM_PPP = 1          ! Pressure (vertical coordinate)
   integer, parameter :: NCM_SEM = NCM_PPP +1 ! surface emissivity
   integer, parameter :: NCM_VAR = NCM_SEM +1 ! value of the observation
   integer, parameter :: NCM_OMP = NCM_VAR +1 ! obs - H (trial field)
   integer, parameter :: NCM_OMA = NCM_OMP +1 ! obs - H (analysis)
   integer, parameter :: NCM_OER = NCM_OMA +1 ! sigma(obs)
   integer, parameter :: NCM_HPHT= NCM_OER +1 ! root of (hpht with hx scalar)
   integer, parameter :: NCM_ZHA = NCM_HPHT+1 ! vert coordinate for Schur product
   integer, parameter :: NCM_OMP6= NCM_ZHA +1 ! obs - H (6-h trial field)
                                              ! Initial value of "gamma" for
   integer, parameter :: NCM_POB = NCM_OMP6+1 ! variational QC 
   integer, parameter :: NCM_OMF = NCM_POB +1 ! observation minus forecast value
                                              ! Work space for use during
   integer, parameter :: NCM_OMI = NCM_OMF +1 ! variational minimization  
                                              ! Value from variational QC used
   integer, parameter :: NCM_OMN = NCM_OMI +1 ! to flag when rejected
                                              ! (Adjusted) observed value for
   integer, parameter :: NCM_PRM = NCM_OMN +1 ! tovs in variational assimilation

   ! the number of real variables defined just above
   integer, parameter :: NBDY_REAL = NCM_PRM

   integer, parameter :: OBS_JPNBRELEM = 57   ! obs variable-types table length


contains

   subroutine obs_abort(cdmessage)
      ! s/r OBS_ABORT  - Abort a job on error
      !
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES  January 29, 1996 
      !     . P. Koclas   CMC/CMSV   January  1997 
      !         -add call to abort
      !     . S. Pellerin ARMA/SMC   October 2000
      !         - replace call to abort for call to exit(1)
      !     . C. Charette ARMA/SMC   October 2001
      !         - replace SUTERM by SUTERMF to only close files
      !     . J. Blezius  import ABORT3D into obsspacedata_mod as OBS_ABORT
      !         - delete call to SUTERMF
      !    -------------------
      !     Purpose:
      !     To stop a job when an error occurred
      !
      !Arguments
      !     i     CDMESSAGE: message to be printed

      implicit none
      character(len=*) cdmessage

      write(*,'(//,4X,"ABORTING IN ObsSpaceData_mod:-------",/,8X,A)')cdmessage
      call flush(6)

      call qqexit(1)

      stop
   end subroutine obs_abort


   subroutine obs_allocate(obsdat,numheader_max,numbody_max)
      !s/r obs_allocate - Allocate the object's arrays.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  Allocate arrays according to the parameters, header_max and
      !              body_max.  This is a private method.
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer         , intent(in)  :: numheader_max,numbody_max

      allocate(obsdat%cfamily(numheader_max))
      obsdat%cfamily(:)='XX'

      allocate(obsdat%cstnid(numheader_max))
      obsdat%cstnid(:)='XXXXXXXXXXXX'

      allocate(obsdat%robhdr(NHDR_REAL,numheader_max))
      obsdat%robhdr(:,:)=real(0.0d0, OBS_REAL)

      allocate(obsdat%mobhdr(NHDR_INT,numheader_max))
      obsdat%mobhdr(:,:)=0

      allocate(obsdat%robdata(NBDY_REAL,numbody_max))
      obsdat%robdata(:,:)=real(0.0D0, OBS_REAL)

      allocate(obsdat%mobdata(NBDY_INT,numbody_max))
      obsdat%mobdata(:,:)=0
   end subroutine obs_allocate


   subroutine obs_allocateG(obsdat,maxNumHdr)
      !
      ! object: allocate arrays to accommodate the mpi-local context

      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer         , intent(in)    :: maxNumHdr

      allocate(obsdat%cstnid_g(maxNumHdr))
      obsdat%cstnid_g(:)='XXXXXXXXXXXX'

      allocate(obsdat%robhdr_g(NHDR_REAL,maxNumHdr))
      obsdat%robhdr_g(:,:)=real(0.0d0, OBS_REAL)

      allocate(obsdat%mobhdr_g(NHDR_INT,maxNumHdr))
      obsdat%mobhdr_g(:,:)=0

   end subroutine obs_allocateG


   subroutine obs_append(obsdat,hx,obs_out,hx_out)
      !
      ! object: with a call of type obs_append(obs_1,obs_2) append obs_1 to obs_2
      !
      ! author  : Peter Houtekamer: May 2011

      type (struct_obs), intent(in)    :: obsdat
      type (struct_obs), intent(inout) :: obs_out

      real(8),           intent(in)    :: hx(:,:)
      real(8),           intent(inout) :: hx_out(:,:)

      integer :: i_data_read,i_data_read_first,i_data_read_last,i_data_write
      integer :: i_last,istation,i_station_write,nens,i_write_first
      integer :: loc,loc_last

      if (obsdat%numheader.eq.0) then
         write(*,*) 'odd input for routine obs_append'
         write(*,*) 'no stations need to be added to the obsdat.'
         return
      endif

      nens=size(hx,1)
      if (obs_out%numheader.ge.1) then 
         i_last=1
         loc_last=obs_out%mobhdr(NCM_RLN,1)
         storedlast: do istation=2,obs_out%numheader
            loc=obs_out%mobhdr(NCM_RLN,istation)
            if (loc.gt.loc_last) then
               i_last=istation
               loc_last=loc
            endif
         enddo storedlast
         ! the first available locations in the output 
         i_station_write=obs_out%numheader+1
         i_data_write=obs_out%mobhdr(NCM_RLN,i_last)+ &
            obs_out%mobhdr(NCM_NLV,i_last)
      else
         i_station_write=1
         i_data_write=1
      endif

      stations: do istation=1,obsdat%numheader
         i_data_read_first=obsdat%mobhdr(NCM_RLN,istation)
         i_data_read_last=i_data_read_first+obsdat%mobhdr(NCM_NLV,istation)-1
         i_write_first=i_data_write
         observations: do i_data_read=i_data_read_first,i_data_read_last
            obs_out%mobdata(:,i_data_write)=obsdat%mobdata(:,i_data_read)
            obs_out%robdata(:,i_data_write)=obsdat%robdata(:,i_data_read)
            hx_out(1:nens,i_data_write)=hx(:,i_data_read)
            i_data_write=i_data_write+1  
         enddo observations

         obs_out%mobhdr(:,i_station_write)=obsdat%mobhdr(:,istation)
         obs_out%mobhdr(NCM_ONM,i_station_write)=i_station_write
         obs_out%mobhdr(NCM_RLN,i_station_write)=i_write_first

         if (obs_out%numheader.gt.0) then
            obs_out%mobhdr(NCM_PAS,i_station_write) &
               =   obs_out%mobhdr(NCM_PAS,i_station_write) &
                 + obs_out%mobhdr(NCM_PAS,obs_out%numheader)
         end if

         obs_out%robhdr(:,i_station_write)=obsdat%robhdr(:,istation) 
         obs_out%cstnid(i_station_write)=obsdat%cstnid(istation)

         i_station_write=i_station_write+1
      enddo stations

      obs_out%numheader=obs_out%numheader+obsdat%numheader
   end subroutine obs_append


   SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                      LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                      n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                      KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                      vconv,nonelev)
      use EarthConstants_mod
      use MathPhysConstants_mod
      IMPLICIT NONE

      type(struct_obs), intent(inout) :: obsdat
      INTEGER, intent(out) :: KNDAT
      INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
      INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
      INTEGER, intent(in)  :: KLIST(n_elements_in_block)
      INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
      integer, intent(in)  :: nvcordtyp,nonelev

      REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
      REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
      REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
      REAL(kind=8),intent(in)::PPMIS
      real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
      real(kind=8),intent(in)::vcordsf(:,:)

      LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI

      !***********************************************************************
      !
      !***s/r OBS_BDY -FILL BODY OF OBSDAT REPORT
      !
      !Author    . P. KOCLAS(CMC TEL. 4665)
      !
      !Revision:
      !          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
      !          .   before insertion of U and V for consistency
      !          . P. Koclas *CMC/AES February  1995:
      !          .  New call sequence neccessary to :
      !          . -allow insertion of "grouped data" records in BURP files.
      !          . -allow data observed in various vertical coordinates
      !          . -observation errors no longer initialized
      !
      !          . P. Koclas *CMC/AES March     1995:
      !            -Additions for humsat and satem data
      !          .
      !          . C. Charette *ARMA Jan        2001
      !            -Max value for T-Td surface element(12203)
      !
      !           JM Belanger CMDA/SMC  Feb 2001
      !                   . 32 bits conversion
      !          . P. Koclas *CMC/CMDA Sept     2001:
      !            -set first-guess and observation errors to missing values
      !
      !          .N Wagneur CMDA/SMC  Jine 2002
      !                   . -Additions for goes data
      !          . P. Koclas *CMC/CMDA Dec      2003:
      !                -conversion for surface wind
      !          . C. Charette *ARMA/SMC Apr      2005:
      !                -Set flag bit #12 (Element assimilated by analysis) to zero
      !                 (see banco-burp documentation for more detail)
      !          . A. Beaulne *CMDA/SMC  Aug 2006
      !                     -Additions for AIRS data
      !          . S. Heilliette
      !                     -Additions for IASI data
      !
      !
      !    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
      !              THE IN-CORE FORMAT (OBSDAT) OF THE 3-D VARIATIONAL ANALYSIS
      !
      !    ARGUMENTS:
      !     INPUT:
      !
      !           -PVALUES : DATA BLOCK
      !           -KLIST   : LIST OF BUFR ELEMENTS
      !           -KFLAGS  : QUALITY CONTROL FLAGS
      !
      !           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN OBSDAT
      !                      .FALSE. --> INSERT DUMMY VALUE(2**12)
      !           -LERR    :  .TRUE. --> INSERT OBS ERROR IN OBSDAT (HUMSAT DATA)
      !           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN OBSDAT (SATEMS)
      !           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (GOES RADIANCES)
      !           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (AIRS RADIANCES)
      !           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (IASI RADIANCES)
      !
      !           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
      !           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
      !           -KNT     :  THIRD DIMENSION OF DATA BLOCK
      !           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
      !           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
      !           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
      !           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
      !           -PPMIS   :  VALUE OF MISSING DATA
      !           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
      !
      !    OUTPUT:
      !           -KNDAT   : NUMBER OF DATA INSERTED IN OBSDAT FILE
      !
      !***********************************************************************

      INTEGER ILEM,IND,IIND,IP,IK
      INTEGER IBAD,IFLAG
      INTEGER ielement,ilevel
      INTEGER ZESMAX,ZES

      REAL(kind=8) ZFACT,padd,pmul,ZEMFACT,pvalue

      !***********************************************************************
      !     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
      !***********************************************************************

      IIND  =-1
      IBAD=2**11

      ZFACT=VCONV

      ZEMFACT=0.01
      ZESMAX=30.

      IP=obsdat%numbody + 1
      IND=0

      !***********************************************************************
      !     PUT ALL NON MISSING DATA IN OBSDAT FILE
      !     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO OBSDAT FILE
      !     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
      !***********************************************************************

      IK= KINDEX
      DO ielement=1,n_elements_in_block
         ILEM=obs_get_obs_index_for_bufr_element(KLIST(ielement))
         IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
            DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                  nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                  IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                     pvalue=PVALUES(ielement,ilevel,IK)
                     IF ( IP + IND .LE. obsdat%numbody_max ) THEN
                                        ! VERTICAL COORDINATE
                        obsdat%robdata(NCM_PPP,IP+IND)=real(PVCORD(ilevel) &
                                           *ZFACT +vcordsf(ilem,kidtyp),OBS_REAL)

                                        !  FOR PNM HEIGHT IS SET TO 0
                                        ! ----------------------------
                        IF ( ILEM .EQ. 53 ) THEN
                           obsdat%robdata(NCM_PPP,IP+IND)=real(0.D0,OBS_REAL)
                        ENDIF
                                        ! ----------------------------

                                        ! IF ( ILEM .EQ. 2 ) Units:  V
                                        ! CONVERT TO GZ
                        IF ( ILEM .EQ. 3 ) THEN
                           pvalue=RG*pvalue
                        ENDIF
                                        ! IF ( ILEM .EQ. 4 ) Units: METERS
                                        ! IF ( ILEM .EQ. 8 ) Units:  CELSIUS
                                        ! Max value T-Td upper air
                        IF ( ILEM .EQ. 9 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! Max value T-Td surface
                        IF ( ILEM .EQ. 11 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! CONVERT TO RADIANS
                        IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                           pvalue=MPC_RADIANS_PER_DEGREE_R8*pvalue
                        ENDIF
                                        ! FLAGS
                        IF  (LDFLAG) THEN
                                        ! SET BIT 12  TO ZERO
                                        ! (Element assim by 3dvar)
                           IFLAG = KFLAGS(ielement,ilevel,IK)
                           IFLAG = IBCLR(IFLAG,12)
                           obsdat%mobdata(NCM_FLG,IP+IND)= IFLAG
                        ELSE
                           obsdat%mobdata(NCM_FLG,IP+IND)= IBAD
                        ENDIF

                        obsdat%robdata(NCM_VAR,IP+IND)=real(pvalue,OBS_REAL)
                        obsdat%mobdata (NCM_VNM,IP+IND)=KLIST(ielement)
                        obsdat%mobdata (NCM_VCO,IP+IND)=NVCORDTYP
                        obsdat%robdata(NCM_OMF,IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(NCM_OMA,IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(NCM_OMI,IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(NCM_HPHT,IP+IND)=real(PPMIS,OBS_REAL)
                        obsdat%robdata(NCM_OER,IP+IND)=real(PPMIS,OBS_REAL)
                        !
                        ! OBS ERROR FOR HUMSAT
                        !
                        IF ( LDERR ) THEN
                           obsdat%robdata(NCM_OER,IP+IND)=real(PROFIL(ilevel)&
                              ,OBS_REAL)
                        ENDIF
                        !
                        ! REFERENCE LEVEL FOR SATEMS
                        !
                        IF ( LDSAT ) THEN
                           obsdat%robdata(NCM_OER,IP+IND)= &
                              real(PROFIL(ilevel)*ZFACT,OBS_REAL)
                           obsdat%robdata(NCM_OER,IP+IND)=real(1.0D0,OBS_REAL)
                        ENDIF
                        !
                        ! SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
                        !
                        IF ( LDGO ) THEN
                           obsdat%robdata(NCM_SEM,IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        ENDIF

                        IF ( LDAIRS ) THEN
                           obsdat%robdata(NCM_SEM,IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        END IF

                        IF ( LDIASI ) THEN
                           obsdat%robdata(NCM_SEM,IP+IND)=real(PROFIL(ilevel)&
                              *ZEMFACT,OBS_REAL)
                        END IF

                        IND=IND + 1
                     ELSE
                        !==================================================
                        KNDAT = IND
                        obsdat%numbody = obsdat%numbody + KNDAT
                        !==================================================
                        RETURN
                     ENDIF
                  ENDIF
               ENDIF
            END DO
         ENDIF
      END DO
      !=============================
      KNDAT = IND
      obsdat%numbody = obsdat%numbody + KNDAT
      !=============================

      RETURN
   END SUBROUTINE obs_bdy


   subroutine obs_clean(obsdat,hx,nens,nobsout,qcvar)
      !
      ! object  - remove all observations from the obsdat  
      !         that will not be assimilated. 
      !
      !author  : Peter Houtekamer
      !     revision may 2005. Houtekamer and Mitchell. Addition of the
      !          hx and nens arguments
      !
      !arguments
      !     nobsout       : unit number for the ASCII output
      !     qcvar         : input logical indicating if the input obsdat 
      !                     data have benefited from a qc-var procedure
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat

      real(8), intent(inout) :: hx(:,:)
      integer, intent(in)    :: nens, nobsout
      logical, intent(in)    :: qcvar

      integer :: iaccept,idata,ipnt,iwrite
      integer :: jdata,kobs,var3d,kobsout

      write(nobsout,*) 'stations prior to cleanup: ', obsdat%numheader
      write(*,*) 'enter obs_clean'

      kobsout=0 
      iwrite=0
      stations: do kobs=1,obsdat%numheader
         ipnt  = obsdat%mobhdr(NCM_RLN,kobs)
         idata = obsdat%mobhdr(NCM_NLV,kobs)
         iaccept=0
         observations: do jdata = ipnt, ipnt + idata - 1
            if (btest(obsdat%mobdata(NCM_FLG,jdata),12).or. .not. qcvar) then 
               ! data will be accepted if they went through the variational
               ! system  including the qcvar. They will also be accepted if the
               ! qcvar procedure was not applied (i.e. when backalt files are
               ! used as input).
               var3d=1
            else
               var3d=0
            endif

            ! To remove channels assimilated by 4D_var but flagged to
            ! be 0 in stats_tovs (ncmzha=-1 in OBSDAT BDY)
            if (obsdat%robdata(NCM_ZHA,jdata) .lt. 0.) then
               obsdat%mobdata(NCM_ASS,jdata)=-1
            endif

            if ((obsdat%mobdata(NCM_ASS,jdata).eq.1).and.(var3d.eq.1)) then 
               ! the observation will be used in the analysis
               iaccept=iaccept+1
               iwrite=iwrite+1
               obsdat%mobdata(:,iwrite)=obsdat%mobdata(:,jdata)
               obsdat%robdata(:,iwrite)=obsdat%robdata(:,jdata)
               hx(1:nens,iwrite)=hx(1:nens,jdata)
            endif
         enddo observations

         ! adjust obsdat%robhdr 
         if (iaccept.gt.0) then
            kobsout=kobsout+1
            obsdat%mobhdr(:,kobsout)=obsdat%mobhdr(:,kobs)
            obsdat%robhdr(:,kobsout)=obsdat%robhdr(:,kobs)
            obsdat%cstnid(kobsout)=obsdat%cstnid(kobs)
            obsdat%mobhdr(NCM_NLV,kobsout)=iaccept
            obsdat%mobhdr(NCM_RLN,kobsout)=iwrite-iaccept+1
         endif
      enddo stations
      obsdat%numheader=kobsout
      obsdat%numbody = iwrite

      write(nobsout,*) 'after cleanup of the obsdat: '
      write(nobsout,*) &
         'number of stations containing valid data   ',obsdat%numheader
      write(nobsout,*) & 
         'number of observations now in the obsdat file ',obsdat%numbody

   end subroutine obs_clean


   subroutine obs_comm(obsdat,myip,nens,nstncom,hx)
      !authors  Peter Houtekamer and Herschel Mitchell May 2005
      !     (this routine evolved from the earlier routine commstns that worked
      !      per analysis pass and did not consider hx).
      !
      !object: communicate information on the stations and the observations
      !        between the processes
      !
      !input variables:
      !     myip: number of the processor.
      !     nens: number of ensemble members for hx (may be zero)
      !     nstncom: we wish to exchange the obsdat for stations 1 ... nstncom
      !       (nstncom may be less than obsdat%numheader_max).

      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,           intent(in)    :: myip,nens,nstncom
      real(8),           intent(inout), dimension(:,:) :: hx    

      integer :: ier,master,mxstn,ncomm,nobs
#if OBS_REAL==4
      character(len=*), parameter :: MPI_OBS_REAL="mpi_real"
#elif OBS_REAL==8
      character(len=*), parameter :: MPI_OBS_REAL="mpi_double_precision"
#endif

      ! broadcast relevant integers from master to all processes 

      master=0

      ! if nothing to communicate, return
      if (obsdat%numheader_max.le.0) return

      if (nstncom.gt.obsdat%numheader_max) then
         write(*,*) 'ERROR in obs_comm: nstncom ',nstncom, &
            ' may not exceed numheader_max ',obsdat%numheader_max
         call obs_abort('OBS_COMM: nstncom exceeds numheader_max')
      endif
      if (nstncom.le.0) then
         call obs_abort('OBS_COMM: nstncom should be positive')
      endif

      ncomm=nstncom*NHDR_INT 
      call rpn_comm_bcast(obsdat%mobhdr,ncomm,"mpi_integer",master,"world",ier)
      ncomm=nstncom*NHDR_REAL
      call rpn_comm_bcast(obsdat%robhdr,ncomm,MPI_OBS_REAL,master,"world",ier)
      ncomm=nstncom*12
      call rpn_comm_bcastc(obsdat%cstnid,ncomm,"mpi_character",master,"world", &
                                                                             ier)

      nobs=obsdat%mobhdr(NCM_RLN,nstncom) + obsdat%mobhdr(NCM_NLV,nstncom) - 1
      if (nobs.gt.obsdat%numbody_max) then
         write(*,*) 'ERROR in obs_comm: nobs ',nobs, &
            ' may not exceed obsdat%numbody_max ',obsdat%numbody_max
         call obs_abort('OBS_COMM: nobs exceeds obsdat%numbody_max')
      endif
      if (nobs.le.0) then
         write(*,*) 'ERROR in obs_comm: nobs ',nobs,' should be positive. '
         call obs_abort('OBS_COMM: nobs should be positive')
      endif

      ncomm=nobs*NBDY_INT
      call rpn_comm_bcast(obsdat%mobdata,ncomm,"mpi_integer",master,"world",ier)

      ncomm=nobs*NBDY_REAL
      call rpn_comm_bcast(obsdat%robdata,ncomm,MPI_OBS_REAL,master,"world",ier)

      ! Broadcast the remaining obsdat variables
      ncomm=1
      call rpn_comm_bcast(obsdat%numheader,ncomm,"mpi_integer",master,"world", &
                                                                             ier)
      call rpn_comm_bcast(obsdat%numbody, ncomm,"mpi_integer",master,"world",ier)

      if (nens.gt.0) then
         ncomm=nobs*nens
         call rpn_comm_bcast(hx,ncomm,"mpi_double_precision",master,"world",ier)
      endif

      return

   end subroutine obs_comm


   subroutine obs_copy(obs_a,obs_b)
      !
      ! object  - copy an obsdat object
      !
      !author  : Peter Houtekamer. August 2011.
      !
      !arguments
      !     input : obs_a input object
      !     output: obs_b a copy of obs_a 
      !
      implicit none

      type(struct_obs), intent(in)  :: obs_a
      type(struct_obs), intent(out) :: obs_b

      obs_b%robhdr          = obs_a%robhdr
      obs_b%mobhdr          = obs_a%mobhdr
      obs_b%cstnid          = obs_a%cstnid
      obs_b%robdata         = obs_a%robdata
      obs_b%mobdata         = obs_a%mobdata

      obs_b%numheader= obs_a%numheader
      obs_b%numheader_max      = obs_a%numheader_max
      obs_b%numbody = obs_a%numbody
      obs_b%numbody_max      = obs_a%numbody_max
   end subroutine obs_copy


   subroutine obs_count_headers(obsdat,kulout)
      !
      ! object - count the number of stations and
      !         observations that are in the obsdat.
      !
      !author  : Peter Houtekamer
      !
      !arguments
      !     input:    kulout: unit number for ASCII error messages and 
      !                  observation counts.
      !
      implicit none

      integer, parameter :: maxid = 256
      type (struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: kulout

      integer  :: allstn,allobs,id,idata,kobs
      integer, dimension(maxid)   :: numobs,numstn

      ! initialize totals to zero
      numstn=0
      numobs=0
      allstn=0
      allobs=0

      do kobs=1,obsdat%numheader
         id=obsdat%mobhdr(NCM_ITY,kobs)
         if(id.gt.maxid) then
            id=mod(id,1000)
         endif
         if ((id.lt.1).or.(id.gt.maxid)) then 
            write(kulout,*) 'id out of range: ',id
            call obs_abort('OBS_COUNT_HEADERS: id out of range')
         endif
         numstn(id)=numstn(id)+1
         ! idata: number of obs for this station
         idata = obsdat%mobhdr(NCM_NLV,kobs)
         numobs(id)=numobs(id)+idata
      enddo

      write(kulout,*) 'number of stations and observations'
      write(kulout,*) ' idtype #stations #observations '
      do id=1,maxid
         if (numstn(id).gt.0) then
            write(kulout,'(i3,3x,i7,2x,i8)') id,numstn(id),numobs(id)
         endif
         allstn=allstn+numstn(id)
         allobs=allobs+numobs(id)
      enddo
      write(kulout,*) 'total number of stations:     ',allstn
      write(kulout,*) 'total number of observations: ',allobs

      return
   end subroutine obs_count_headers


   subroutine obs_deallocate(obsdat)
      !s/r obs_deallocate - De-allocate the object's arrays.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  De-allocate arrays.  This is a private method.
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      integer :: ierr

      if (associated(obsdat%cfamily)) then
         deallocate(obsdat%cfamily,STAT=ierr)
         nullify(obsdat%cfamily)
         if(ierr.ne.0)write(*,*) 'Problem detected with CFAMILY. IERR =',ierr
      end if

      if (associated(obsdat%cstnid))then
         deallocate(obsdat%cstnid,STAT=ierr)
         nullify(obsdat%cstnid)
         if(ierr.ne.0)write(*,*) 'Problem detected with CSTNID. IERR =',ierr
      end if

      if (associated(obsdat%robhdr))then
         deallocate(obsdat%robhdr,stat=ierr)
         nullify(obsdat%robhdr)
         if(ierr.ne.0)write(*,*) 'Problem detected with ROBHDR. IERR =',ierr
      end if

      if (associated(obsdat%mobhdr))then
         deallocate(obsdat%mobhdr,stat=ierr)
         nullify(obsdat%mobhdr)
         if(ierr.ne.0)write(*,*) 'Problem detected with MOBHDR. IERR =',ierr
      end if

      if (associated(obsdat%robdata))then
         deallocate(obsdat%robdata,stat=ierr)
         nullify(obsdat%robdata)
         if(ierr.ne.0)write(*,*) 'Problem detected with ROBDATA. IERR =',ierr
      end if

      if (associated(obsdat%mobdata))then
         deallocate(obsdat%mobdata,stat=ierr)
         nullify(obsdat%mobdata)
         if(ierr.ne.0)write(*,*) 'Problem detected with MOBDATA. IERR =',ierr
      end if

   end subroutine obs_deallocate


   subroutine obs_deallocateG(obsdat)
      !
      ! object: de-allocate arrays that accommodated the mpi-local context

      implicit none

      type(struct_obs), intent(inout) :: obsdat

      integer :: ierr

      if (associated(obsdat%cstnid_g)) then
         deallocate(obsdat%cstnid_g,stat=ierr)
         nullify(obsdat%cstnid_g)
         if(ierr /= 0) write(*,*) 'Problem detected in CSTNID_g. IERR =',ierr
      end if

      if (associated(obsdat%robhdr_g)) then
         deallocate(obsdat%robhdr_g,stat=ierr)
         nullify(obsdat%robhdr_g)
         if(ierr /= 0) write(*,*) 'Problem detected in ROBHDR_g. IERR =',ierr
      end if

      if (associated(obsdat%mobhdr_g)) then
         deallocate(obsdat%mobhdr_g,stat=ierr)
         nullify(obsdat%mobhdr_g)
         if(ierr /= 0) write(*,*) 'Problem detected in MOBHDR_g. IERR =',ierr
      end if

   end subroutine obs_deallocateG


   function obs_elem_c(obsdat,name,index) result(value)
      !func obs_elem_c - Get a character-string-valued observation-data element
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (character) value of the ObsData element with the indicated
      !              name and index.

      implicit none

      character(len=12) :: value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (trim(name))
      case ('STID'); value=obsdat%cstnid(index)

      case default
         write(*,*)"ERROR:  ", name(1:4)," is not character(len=*) observation."
         value='xxxxxxxxx'
      end select
   end function obs_elem_c


   function obs_elem_i(obsdat,name,index) result(value)
      !func obs_elem_i - Get an integer-valued observation-data element
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (integer) value of the ObsData element with the indicated
      !              name and index.

      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (trim(name))
      case ('RLN');  value=obsdat%mobhdr(NCM_RLN, index)
      case ('ONM');  value=obsdat%mobhdr(NCM_ONM, index)
      case ('INS');  value=obsdat%mobhdr(NCM_INS, index)
      case ('OTP');  value=obsdat%mobhdr(NCM_OTP, index)
      case ('ITY');  value=obsdat%mobhdr(NCM_ITY, index)
      case ('SAT');  value=obsdat%mobhdr(NCM_SAT, index)
      case ('TEC');  value=obsdat%mobhdr(NCM_TEC, index)
      case ('DAT');  value=obsdat%mobhdr(NCM_DAT, index)
      case ('ETM');  value=obsdat%mobhdr(NCM_ETM, index)
      case ('NLV');  value=obsdat%mobhdr(NCM_NLV, index)
      case ('OFL');  value=obsdat%mobhdr(NCM_OFL, index)
      case ('PAS');  value=obsdat%mobhdr(NCM_PAS, index)
      case ('REG');  value=obsdat%mobhdr(NCM_REG, index)
      case ('IP');   value=obsdat%mobhdr(NCM_IP , index)
      case ('AZA');  value=obsdat%mobhdr(NCM_AZA, index)
      case ('SZA');  value=obsdat%mobhdr(NCM_SZA, index)
      case ('SUN');  value=obsdat%mobhdr(NCM_SUN, index)
      case ('CLF');  value=obsdat%mobhdr(NCM_CLF, index)
      case ('ST1');  value=obsdat%mobhdr(NCM_ST1, index)
      case ('TLA');  value=obsdat%mobhdr(NCM_TLA, index)
      case ('IDO');  value=obsdat%mobhdr(NCM_IDO, index)
      case ('IDF');  value=obsdat%mobhdr(NCM_IDF, index)

      case ('GHI');  value=obsdat%locObsTag(index)

      case ('VNM');  value=obsdat%mobdata(NCM_VNM, index)
      case ('FLG');  value=obsdat%mobdata(NCM_FLG, index)
      case ('KFA');  value=obsdat%mobdata(NCM_KFA, index)
      case ('ASS');  value=obsdat%mobdata(NCM_ASS, index)
      case ('OBS');  value=obsdat%mobdata(NCM_OBS, index)
      case ('VCO');  value=obsdat%mobdata(NCM_VCO, index)
      case ('LYR');  value=obsdat%mobdata(NCM_LYR, index)
      case ('XTR');  value=obsdat%mobdata(NCM_XTR, index)
      case ('IDD');  value=obsdat%mobdata(NCM_IDD, index)

      case default
         write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
         value=-999
      end select
   end function obs_elem_i


   function obs_elem_mpiglobal_i(obsdat,name,index) result(value)
      ! This method is supplied for use by those external to the present module
      ! that are aware of the mpi-local or -global state of this module.
      implicit none
      integer value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (name(1:4))
      case ('RLN');  value=obsdat%mobhdr_g(NCM_RLN, index)
      case ('ONM');  value=obsdat%mobhdr_g(NCM_ONM, index)
      case ('INS');  value=obsdat%mobhdr_g(NCM_INS, index)
      case ('OTP');  value=obsdat%mobhdr_g(NCM_OTP, index)
      case ('ITY');  value=obsdat%mobhdr_g(NCM_ITY, index)
      case ('SAT');  value=obsdat%mobhdr_g(NCM_SAT, index)
      case ('TEC');  value=obsdat%mobhdr_g(NCM_TEC, index)
      case ('DAT');  value=obsdat%mobhdr_g(NCM_DAT, index)
      case ('ETM');  value=obsdat%mobhdr_g(NCM_ETM, index)
      case ('NLV');  value=obsdat%mobhdr_g(NCM_NLV, index)
      case ('OFL');  value=obsdat%mobhdr_g(NCM_OFL, index)
      case ('PAS');  value=obsdat%mobhdr_g(NCM_PAS, index)
      case ('REG');  value=obsdat%mobhdr_g(NCM_REG, index)
      case ('IP');   value=obsdat%mobhdr_g(NCM_IP , index)
      case ('AZA');  value=obsdat%mobhdr_g(NCM_AZA, index)
      case ('SZA');  value=obsdat%mobhdr_g(NCM_SZA, index)
      case ('SUN');  value=obsdat%mobhdr_g(NCM_SUN, index)
      case ('CLF');  value=obsdat%mobhdr_g(NCM_CLF, index)
      case ('ST1');  value=obsdat%mobhdr_g(NCM_ST1, index)
      case ('TLA');  value=obsdat%mobhdr_g(NCM_TLA, index)
      case ('IDO');  value=obsdat%mobhdr_g(NCM_IDO, index)
      case ('IDF');  value=obsdat%mobhdr_g(NCM_IDF, index)

      case default
         write(*,*)"ERROR:  ", name(1:4), &
                   " is not available in the mpi-global context."
         value=-999
      end select
   end function obs_elem_mpiglobal_i


   function obs_elem_mpiglobal_r(obsdat,name,index) result(value)
      ! This method is supplied for use by those external to the present module
      ! that are aware of the mpi-local or -global state of this module.
      implicit none
      real(kind=OBS_REAL) value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (trim(name))
      case ('LAT');  value=obsdat%robhdr_g(NCM_LAT, index)
      case ('LON');  value=obsdat%robhdr_g(NCM_LON, index)
      case ('ALT');  value=obsdat%robhdr_g(NCM_ALT, index)
      case ('BX');   value=obsdat%robhdr_g(NCM_BX , index)
      case ('BY');   value=obsdat%robhdr_g(NCM_BY , index)
      case ('BZ');   value=obsdat%robhdr_g(NCM_BZ , index)

      case default
         write(*,*)"ERROR:  ", name(1:4), &
                   " is not available in the mpi-global context."
         value=-999.
      end select
   end function obs_elem_mpiglobal_r


   function obs_elem_r(obsdat,name,index) result(value)
      !func obs_elem_r - Get a real-valued observation-data element
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object.  Returns the
      !              (real) value of the ObsData element with the indicated name
      !              and index.
      !
      !    COMMENT:  the real kind, OBS_REAL, is specified at compile time.
      implicit none
      real(kind=OBS_REAL) :: value
      type(struct_obs), intent(in)  :: obsdat
      character(len=*), intent(in)  :: name
      integer         , intent(in)  :: index

      select case (trim(name))
      case ('LAT');  value=obsdat%robhdr(NCM_LAT, index)
      case ('LON');  value=obsdat%robhdr(NCM_LON, index)
      case ('ALT');  value=obsdat%robhdr(NCM_ALT, index)
      case ('BX');   value=obsdat%robhdr(NCM_BX , index)
      case ('BY');   value=obsdat%robhdr(NCM_BY , index)
      case ('BZ');   value=obsdat%robhdr(NCM_BZ , index)

      case ('PPP');  value=obsdat%robdata(NCM_PPP, index)
      case ('SEM');  value=obsdat%robdata(NCM_SEM, index)
      case ('POB');  value=obsdat%robdata(NCM_POB, index)
      case ('VAR');  value=obsdat%robdata(NCM_VAR, index)
      case ('OMF');  value=obsdat%robdata(NCM_OMF, index)
      case ('OMP');  value=obsdat%robdata(NCM_OMP, index)
      case ('OMP6'); value=obsdat%robdata(NCM_OMP6,index)
      case ('OMA');  value=obsdat%robdata(NCM_OMA, index)
      case ('OMI');  value=obsdat%robdata(NCM_OMI, index)
      case ('OMN');  value=obsdat%robdata(NCM_OMN, index)
      case ('OER');  value=obsdat%robdata(NCM_OER, index)
      case ('HPHT'); value=obsdat%robdata(NCM_HPHT,index)
      case ('ZHA');  value=obsdat%robdata(NCM_ZHA, index)
      case ('PRM');  value=obsdat%robdata(NCM_PRM, index)

      case default
         write(*,*)"ERROR:  ", name(1:4), " is not a real(",OBS_REAL, &
                   ") observation."
         value=-999
      end select
   end function obs_elem_r


   subroutine obs_enkf_bdy(obsdat,vconv, &
                           pvalues,klist,kflags,profil, &
                           ldairs,kndat,kvcord,pvcord,kindex,kidtyp, &
                           nvcordtyp, vcordsf)
      !s/r obs_enkf_bdy -FILL BODY OF OBSDAT REPORT
      !
      !Author    . P. KOCLAS(CMC TEL. 4665)
      !
      !Revision:
      !          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
      !          .   before insertion of U and V for consistency
      !          . P. Koclas *CMC/AES February  1995:
      !          .  New call sequence neccessary to :
      !          . -allow insertion of "grouped data" records in BURP files.
      !          . -allow data observed in various vertical coordinates
      !          . -observation errors no longer initialized
      !
      !          . P. Koclas *CMC/AES March     1995:
      !            -Additions for humsat and satem data
      !          .
      !          . C. Charette *ARMA Jan        2001
      !            -Max value for T-Td surface element(12203)
      !
      !           JM Belanger CMDA/SMC  Feb 2001
      !                   . 32 bits conversion
      !           P. Houtekamer July 2005. Remove the lines for HUMSAT data
      !          . A. Beaulne *CMDA/SMC  Aug 2006
      !                     -Additions for AIRS data
      !           Xingxiu Deng, August 2008. added calling readpeak, calling airszha
      !                     to define robdata(ncmzha,:) for AIRS
      !           Xingxiu Deng, July 2009. added including column.cdk, calling readip1
      !                     to get ptop and define ncmzha for AMSU-A channel 11 and 12
      !                      if ptop is equal or higher than 2 hPa.
      !
      !    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
      !              THE IN-CORE FORMAT (OBSDAT) OF THE ANALYSIS
      !
      !    ARGUMENTS:
      !     INPUT:
      !
      !           -PVALUES : DATA BLOCK
      !           -KLIST   : LIST OF BUFR ELEMENTS
      !           -KFLAGS  : QUALITY CONTROL FLAGS
      !
      !           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN OBSDAT (AIRS RADIANCES)
      !
      !           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
      !           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
      !           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
      !           -KIDTYP  :  burptype
      !           -vconv   :  conversion factor for pressure coordinate
      !           -profil  :  for GOES and AIRS
      !           -nvcordtyp :
      !
      !    OUTPUT:
      !           -KNDAT   : NUMBER OF DATA INSERTED IN OBSDAT FILE
      !           -OBSDAT%ROBDATA, OBSDAT%MOBDATA: obsdat body-information (new information added)
      !
      use EarthConstants_mod, only:  GRAV
      use MathPhysConstants_mod
      implicit none

      type(struct_obs), intent(inout) :: obsdat

      logical, intent(in)  :: ldairs
      integer, intent(in)  :: kidtyp,kindex,kvcord
      integer, dimension(:),     intent(in) :: klist 
      integer, dimension(:,:,:), intent(in) :: kflags
      real(kind=4), intent(in) :: vconv
      real(kind=4), dimension(:), intent(in) :: profil,pvcord
      real(kind=4), dimension(:,:,:),  intent(in) :: pvalues
      integer, intent(out) :: kndat
      integer, intent(in) :: nvcordtyp
                                        ! vertical coordinate parameters
                                        ! for surface data
      real, dimension(:,:) :: vcordsf

      real (kind=4), parameter :: PPMIS=-999.0 ! VALUE OF MISSING DATA

      integer :: ichn,ik,ilem,ind,ip,ielement,ilevel,n_elements_in_block
      integer :: n_levels_in_block,zesmax

      real(kind=4) :: pdum,pvalue,zemfact,ztorad

      ! -n_elements_in_block    : NUMBER OF ELEMENTS IN DATA BLOCK
      ! -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
      n_elements_in_block=size(kflags,1)
      n_levels_in_block=size(kflags,2)
      !
      !     SET UNIT CONVERSION CONSTANTS
      !
      ZTORAD=MPC_RADIANS_PER_DEGREE_R4

      ZEMFACT=0.01
      ZESMAX=30.

      IP=OBSDAT%numbody + 1
      IND=0
      !
      !     PUT ALL NON MISSING DATA IN OBSDAT FILE
      !     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO OBSDAT FILE
      !     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
      !
      IK= KINDEX
      DO ielement=1,n_elements_in_block
         ILEM=obs_get_obs_index_for_bufr_element(KLIST(ielement))
         IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
            DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis) then
                  IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                     pvalue=PVALUES(ielement,ilevel,IK)
                     ! PLH replaced ndatamx by numbody_max
                     IF ( IP + IND .LE. obsdat%numbody_max ) THEN
                                        ! VERTICAL COORDINATE
                        OBSDAT%ROBDATA(NCM_PPP,IP+IND)=PVCORD(ilevel)*vconv +vcordsf(ilem,kidtyp)
                                        !
                                        !  FOR PNM HEIGHT IS SET TO 0
                                        ! ----------------------------
                        IF ( ILEM .EQ. 53 ) THEN
                           OBSDAT%ROBDATA(NCM_PPP,IP+IND)=0.
                        ENDIF
                                        ! ----------------------------
                                        ! CONVERT TO GZ
                        if ( ILEM .EQ. 3 ) then
                           pvalue=GRAV*pvalue
                        endif
                                        ! Max value T-Td upper air
                        IF ( ILEM .EQ. 9 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! Max value T-Td surface
                        IF ( ILEM .EQ. 11 ) THEN
                           IF ( pvalue .GT. ZESMAX) THEN
                              pvalue=ZESMAX
                           ENDIF
                        ENDIF
                                        ! CONVERT TO RADIANS
                        if ( ILEM .EQ. 48 ) then
                           pvalue=ztorad*pvalue
                        endif
                                        ! FLAGS
                        obsdat%mobdata(NCM_FLG,IP+IND)=KFLAGS(ielement,ilevel,IK)

                        OBSDAT%ROBDATA(NCM_VAR,IP+IND)=pvalue
                                        ! initialise o minus p , o minus p6,
                                        ! o minus a and hpht to undefined values
                                        ! (-999)
                        obsdat%robdata(NCM_OMP,ip+ind)=-999.
                        obsdat%robdata(NCM_OMP6,ip+ind)=-999.
                        obsdat%robdata(NCM_OMA,ip+ind)=-999.
                        obsdat%robdata(NCM_HPHT,ip+ind)=-999.
                        obsdat%mobdata(NCM_VNM,IP+IND)=KLIST(ielement)
                        obsdat%mobdata(NCM_VCO,IP+IND)=nvcordtyp
                        !
                        !    SURFACE EMISSIVITIES FOR GOES AND AIRS RADIANCES
                        if ( LDAIRS ) then
                           OBSDAT%ROBDATA(NCM_SEM,IP+IND)=PROFIL(ilevel)*ZEMFACT
                        endif
                        ind=ind + 1
                     else
                        kndat = ind
                        obsdat%numbody = obsdat%numbody + kndat
                        return
                     endif
                  endif
               endif
            enddo
         endif
      enddo
      kndat = ind
      obsdat%numbody = obsdat%numbody + kndat

      return
   end subroutine obs_enkf_bdy


   subroutine obs_enkf_prntbdy(obsdat,kstn,kulout)
      !
      ! object  - print all data records associated with an observation
      !
      !author  : P. Gauthier, C. Charette
      !revision:
      !      P. Houtekamer mrb 2000: reduction and improved readability of output
      !
      !arguments
      !     i   kstn  : no. of station 
      !     i   kulout: unit used for printing
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer,      intent(in)  :: kstn, kulout

      integer :: ipnt, idata, idata2, jdata, var3d

      ! general information

      ipnt  = obsdat%mobhdr(NCM_RLN,kstn)
      idata = obsdat%mobhdr(NCM_NLV,kstn)

      if(idata.eq.1) then
         write(kulout,fmt=9101)idata,kstn
      else
         write(kulout,fmt=9100)idata,kstn
      end if
9100  format(2x,'there are ',i3,1x,'data in record no.',1x,i6)
9101  format(2x,'there is ',i3,1x,'data in record no.',1x,i6)

      ! print all data records

      write(kulout,'(a,a,a)') '   no.   var.  press. ass observ. ', &
         '  o minus p  o minus p6  o minus a    obserr. root(hpht) acc     ', &
         'zhad  vco'
      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if (btest(obsdat%mobdata(NCM_FLG,jdata),12)) then 
            var3d=1
         else
            var3d=0
         endif

         write(kulout,fmt=9201) idata2,obsdat%mobdata(NCM_VNM,jdata), &
            obsdat%robdata(NCM_PPP,jdata),obsdat%mobdata(NCM_ASS,jdata), &
            obsdat%robdata(NCM_VAR,jdata),obsdat%robdata(NCM_OMP,jdata), &
            obsdat%robdata(NCM_OMP6,jdata),obsdat%robdata(NCM_OMA,jdata), &
            obsdat%robdata(NCM_OER,jdata),obsdat%robdata(NCM_HPHT,jdata), &
            var3d,obsdat%robdata(NCM_ZHA,jdata),obsdat%mobdata(NCM_VCO,jdata)

      enddo

9201  format(1x,i3,1x,i6,1x,f7.0,1x,i3,6(1x,f10.3),1x,i2, &
         1x,f10.3,1x,i2)

      return

   end subroutine obs_enkf_prntbdy


   subroutine obs_enkf_prnthdr(obsdat,kobs,kulout)
      !
      ! object  - printing of the header of an observation record
      !
      !author  : P. Gauthier *arma/aes  June 9, 1992
      !revision:
      !     . P. Houtekamer modification of the cma format 
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for optional printing
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer,      intent(in)  :: kobs, kulout

      ! general information

      write(kulout,fmt=9100)kobs,obsdat%cstnid(KOBS)
9100  format(//,2x,'-- observation record no.' &
         ,1x,i6,3x,' station id:',A12)

      ! print header's content

9202  format(2x,'position within robdata:',i6)
      write(kulout,fmt=9200) &
         obsdat%mobhdr(NCM_RLN,kobs),obsdat%mobhdr(NCM_ONM,kobs), &
         obsdat%mobhdr(NCM_DAT,kobs), &
         obsdat%mobhdr(NCM_ETM,kobs),obsdat%mobhdr(NCM_INS,kobs), &
         obsdat%mobhdr(NCM_OTP,kobs),obsdat%mobhdr(NCM_ITY,kobs), &
         obsdat%robhdr(NCM_LAT,kobs),obsdat%robhdr(NCM_LON,kobs), &
         obsdat%robhdr(NCM_ALT,kobs), &
         obsdat%robhdr(NCM_BX,kobs),obsdat%robhdr(NCM_BY,kobs), &
         obsdat%robhdr(NCM_BZ,kobs)
      write(kulout,fmt=9201) & 
         obsdat%mobhdr(NCM_NLV,kobs),obsdat%mobhdr(NCM_OFL,kobs), &
         obsdat%mobhdr(NCM_PAS,kobs), &
         obsdat%mobhdr(NCM_REG,kobs),obsdat%mobhdr(NCM_IP,kobs), &
         obsdat%mobhdr(NCM_AZA,kobs)

9200  format(2x,'position within robdata:',i6,1x,'stn. number:',i6,1x,/, &
         '  date: ',i10,1x,' time: ',i8,/, &
         '  model box:',i12,1x,'instrument: ',i6,1x, &
         'obs. type:',i8,1x,/, &
         '  (lat,lon):',f12.6,1x,f12.6,1x, &
         'stations altitude:',f12.6,1x,/,2x, &
         'block location: ',3(f12.6,1x))
9201  format('  number of data:',i6,1x,'report status: ',i6,1x, &
         ' pass: ',i6,' region: ',i6,/,2x, &
         'processor: ',i6,' azimuth angle: ',i6)

      return
   end subroutine obs_enkf_prnthdr


   subroutine obs_exchange_stations(obsdat,j,k) 
      !
      !author: Peter Houtekamer
      !        February 2000
      ! February 2011: Peter Houtekamer moved the original routine exchange
      !   from sortcma.f to the module.
      !
      !object: exchange the headers of stations j and k 
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer, intent(in)         :: j,k

      real(4)       :: rdum 
      integer       :: i,idum,nhdrint,nhdrreal
      character(12) :: cdum     

      nhdrint=size(obsdat%mobhdr,1)
      do i=1,nhdrint
         idum=obsdat%mobhdr(i,j)
         obsdat%mobhdr(i,j)=obsdat%mobhdr(i,k)
         obsdat%mobhdr(i,k)=idum
      enddo

      nhdrreal=size(obsdat%robhdr,1) 
      do i=1,nhdrreal
         rdum=obsdat%robhdr(i,j)
         obsdat%robhdr(i,j)=obsdat%robhdr(i,k) 
         obsdat%robhdr(i,k)=rdum 
      enddo

      cdum=obsdat%cstnid(j)
      obsdat%cstnid(j)=obsdat%cstnid(k)
      obsdat%cstnid(k)=cdum

      return
   end subroutine obs_exchange_stations


   subroutine obs_expandToMpiGlobal(obsdat)
      !
      !**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
      !
      !Author    . Bin He (ARMA/MRB )
      !
      !Revision:
      !      PURPOSE:  To reconstitute the mpi-global observation object by
      !                gathering the necessary data from all processors (to all
      !                processors).
      !

      implicit none

      type(struct_obs), intent(inout) :: obsdat

      character(len=12),allocatable    :: cstnid_tmp(:)

      real(OBS_REAL),allocatable,dimension(:,:) :: robdata_tmp
      real(OBS_REAL),allocatable,dimension(:,:) :: robhdr_tmp

      integer,allocatable,dimension(:,:) :: mobdata_tmp
      integer,allocatable,dimension(:,:) :: mobhdr_tmp 

      integer :: i,j,iobs,ierr,startindx,endindx 
      integer :: idataend,idata,ii  
      integer :: sizemobhdr,sizerobhdr,sizemobdata,sizerobdata  
#if OBS_REAL==4
      character(len=*), parameter :: MPI_OBS_REAL="mpi_real"
#elif OBS_REAL==8
      character(len=*), parameter :: MPI_OBS_REAL="mpi_double_precision"
#endif
      !!---------------------------------------------------------------

      write(*,*) 'Entering obs_expandToMpiGlobal'

      if(obsdat%mpi_local .eqv. .false.)then
         call obs_abort('OBS_EXPANDTOMPIGLOBAL has been called, but the obsSpaceData object is already in mpi-global state')
      end if
      obsdat%mpi_local = .false.

      ! Restore header elements
      allocate(mobhdr_tmp(NHDR_INT,obsdat%numheader_mpiglobal))
      mobhdr_tmp=0

      allocate(robhdr_tmp(NHDR_REAL,obsdat%numheader_mpiglobal))
      robhdr_tmp=real(0.0d0, OBS_REAL)

      do i=1,obsdat%numheader
         iobs=obsdat%locObsTag(i)
         mobhdr_tmp(1:NHDR_INT,iobs)=obsdat%mobhdr(1:NHDR_INT,i)
         robhdr_tmp(1:NHDR_REAL,iobs)=obsdat%robhdr(1:NHDR_REAL,i)
      enddo

      sizemobhdr=size(mobhdr_tmp)
      call rpn_comm_allreduce(mobhdr_tmp,mobhdr_tmp,sizemobhdr,"mpi_integer", &
         "mpi_sum","GRID",ierr)

      sizerobhdr=size(robhdr_tmp)
      call rpn_comm_allreduce(robhdr_tmp,robhdr_tmp,sizerobhdr,MPI_OBS_REAL, &
         "mpi_sum","GRID",ierr)

      ! Get the cstnid from the global copy
      allocate(cstnid_tmp(obsdat%numheader_mpiglobal))
      cstnid_tmp(:)=obsdat%cstnid_g(1:obsdat%numheader_mpiglobal)

      ! Allocate memory for the temporary arrays.
      allocate(mobdata_tmp(NBDY_INT,obsdat%numbody_max))
      mobdata_tmp=0

      allocate(robdata_tmp(NBDY_REAL,obsdat%numbody_max))
      robdata_tmp=real(0.0d0,OBS_REAL)

      ! Restore the global arrays MOBDATA and ROBDATA
      ii=0
      do i=1,obsdat%numheader
         iobs=obsdat%locObsTag(i)
         idata= obsdat%mobhdr_g(NCM_RLN, iobs)
         idataend = obsdat%mobhdr_g(NCM_NLV, iobs) + idata -1
         do j=idata,idataend
            ii=ii+1
            mobdata_tmp(1:NBDY_INT,j)=obsdat%mobdata(1:NBDY_INT,ii)
            robdata_tmp(1:NBDY_REAL,j)=obsdat%robdata(1:NBDY_REAL,ii)
         enddo
      enddo
      !
      ! Merge the global arrays MOBDATA_tmp and ROBDATA_tmp.
      sizemobdata=size(mobdata_tmp)
      call rpn_comm_allreduce(mobdata_tmp,mobdata_tmp,sizemobdata,"mpi_integer",&
         "mpi_sum","GRID",ierr)
      sizerobdata=size(robdata_tmp)
      call rpn_comm_allreduce(robdata_tmp,robdata_tmp,sizerobdata,MPI_OBS_REAL,&
         "mpi_sum","GRID",ierr)

      call obs_deallocate(obsdat)
      call obs_allocate(obsdat,obsdat%numheader_mpiglobal,obsdat%numbody_max)

      obsdat%cstnid=cstnid_tmp
      obsdat%robhdr=robhdr_tmp
      obsdat%mobhdr=mobhdr_tmp
      obsdat%robdata=robdata_tmp
      obsdat%mobdata=mobdata_tmp
      obsdat%numbody=obsdat%numbody_mpiglobal
      obsdat%numheader=obsdat%numheader_mpiglobal

      deallocate(cstnid_tmp)
      deallocate(robhdr_tmp)
      deallocate(mobhdr_tmp)
      deallocate(robdata_tmp)
      deallocate(mobdata_tmp)

      call obs_deallocateG(obsdat)

      write(*,*) 'Leaving obs_expandToMpiGlobal'
      return
   end subroutine obs_expandToMpiGlobal


   subroutine obs_finalize(obsdat)
      !s/r obs_finalize - De-allocate memory and clean up the object.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  De-allocate object arrays, and perform any other clean-up
      !              that is necessary before object deletion.
      implicit none
      type(struct_obs), intent(inout) :: obsdat

      call obs_deallocate(obsdat)
      call obs_deallocateG(obsdat)
   end subroutine obs_finalize


   subroutine obs_generate_header(obsdat, ilat, ilon, ialt, inbon, instrum, &
                                  isatzen, nvtyp, ity, idate, itime, clstnid, &
                                  imask, isatazim, isunza, iclfr)
      !
      !    OUTPUT:
      !           obsdat%robhdr(NCM_LON,) - in degrees
      !           obsdat%robhdr(NCM_LAT,) - in degrees, equator at 0 degrees
      !           obsdat%robhdr(NCM_ALT,) - in metres, with no offset
      !
      use MathPhysConstants_mod
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: ilat, ilon, ialt, inbon, instrum, isatzen
      integer, intent(in) :: nvtyp, ity, idate, itime
      integer, intent(in) :: imask, isatazim, isunza, iclfr
      character(len=9), intent(in) :: clstnid
      real(kind=8) :: torad

      torad=MPC_RADIANS_PER_DEGREE_R8

      !
      !     IF VALID DATA WERE FOUND GENERATE THE OBSDAT HEADER
      !      AND INCREMENT OBSDAT%numheader
      !
      ! PLH          if  ( obsdat%numheader .lt. nmxobs) then
      if ( obsdat%numheader .lt. obsdat%numheader_max) then
         obsdat%numheader=obsdat%numheader + 1

         obsdat%robhdr(NCM_LON,obsdat%numheader) = real(ilon) * 0.01
         obsdat%robhdr(NCM_LAT,obsdat%numheader) = real(ilat) * 0.01 - 90.0
         ! PLH ADDED NCM_BX NCM_BY NCM_BZ
         obsdat%robhdr(NCM_BX,obsdat%numheader)=0.0
         obsdat%robhdr(NCM_BY,obsdat%numheader)=0.0
         obsdat%robhdr(NCM_BZ,obsdat%numheader)=0.0

         obsdat%robhdr(NCM_ALT,obsdat%numheader) = real(ialt)
         ! PLH       obsdat%robhdr(ncmtlo,obsdat%numheader) = (real(ilon)*0.01)*ztorad
         ! PLH       obsdat%robhdr(ncmtla,obsdat%numheader) = (real(ilat)*0.01-90.)*ztorad
         obsdat%mobhdr(NCM_NLV,obsdat%numheader) = inbon
         !       print*,'NOBTOTAL=',obsdat%numheader

         if ( obsdat%numheader .eq. 1) then
            ! This is the first entry into the obsdat
            obsdat%mobhdr(NCM_RLN,1)=1
         else
            obsdat%mobhdr(NCM_RLN,obsdat%numheader) &
                   =   obsdat%mobhdr(NCM_RLN,obsdat%numheader-1) &
                     + obsdat%mobhdr(NCM_NLV,obsdat%numheader-1)
         endif
         !
         !          REMAINDER OF HEADER
         !
         obsdat%mobhdr(NCM_ONM,obsdat%numheader) = obsdat%numheader
         obsdat%mobhdr(NCM_INS,obsdat%numheader) = instrum + isatzen*10000
         obsdat%mobhdr(NCM_OTP,obsdat%numheader) = nvtyp
         obsdat%mobhdr(NCM_ITY,obsdat%numheader) = ity
         obsdat%mobhdr(NCM_DAT,obsdat%numheader) = idate
         obsdat%mobhdr(NCM_ETM,obsdat%numheader) = itime
         obsdat%cstnid(obsdat%numheader)         = clstnid
         ! PLH       obsdat%mobhdr(ncmoec,obsdat%numheader) = 999
         obsdat%mobhdr(NCM_OFL,obsdat%numheader) = imask
         obsdat%mobhdr(NCM_AZA,obsdat%numheader) = isatazim
         obsdat%mobhdr(NCM_SUN,obsdat%numheader) = isunza
         obsdat%mobhdr(NCM_CLF,obsdat%numheader) = iclfr
         ! PLH       obsdat%mobhdr(ncmst1,obsdat%numheader) = iflgs
      endif

   end subroutine obs_generate_header


   function obs_get_datestamp(obsdat) result(datestamp)
      !
      ! object: to control access to the observation object.  Returns the date
      !         stamp of the obsdat object.

      implicit none
      type(struct_obs), intent(inout) :: obsdat
      integer :: datestamp

      datestamp = obsdat%datestamp

   end function obs_get_datestamp


   integer function obs_get_obs_index_for_bufr_element(kbufrn)
      implicit none
      integer, intent(in) :: kbufrn
      !
      !      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
      !               THAT CONTAINS A BUFR ELEMENT NUMBER
      !
      !    ARGUMENTS:
      !               INPUT:
      !                   -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
      !                            i.e. known locally as the 'burp variable type'
      !                            i.e. table B of the ECMWF BUFR reference
      !                            BUFR = Binary Universal Form for the
      !                                   Representation of meteorological data
      !
      !               OUTPUT:
      !                   - obs_get_obs_index_for_bufr_element:
      !                            THE FOUND INDEX (=-1 IF NOT FOUND)
      !
      !       AUTHOR: P. KOCLAS (CMC TEL. 4665)

      integer indbuf
      integer, parameter, dimension(OBS_JPNBRELEM) :: NVNUMB = (/ &
         011003, 011004, 010194, 010192,     29, & !  1-10
         013208, 012063, 012001, 012192, 012004, &
         012203, 011215, 011216, 013210, 013220, & ! 11-20
         62, 015001,     64,     65, 015036, &
         015031, 015032,     69,     70,     71, & ! 21-30
         72,     73,     74,     75,     76, &
         77,     78,     79,     80,     81, & ! 31-40
         82,     83,     84,     85,     86, &
         87,     88,     89,     90,     91, & ! 41-50
         012163, 010004, 011001, 011002, 012062, &
         008001, 008004, 010051, 011011, 011012, & ! 51-57
         41,     42 /)


      ! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
      !  Descriptions taken from 3d variational code(March 2011, revision 11.0.2)
      !
      !  1 =011003 (U COMPONENT)           (m/s)
      !  2 =011004 (V COMPONENT)           (m/s)
      !  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
      !  4 =010192 (THICKNESS IN M)
      !  5 =    29 (RELATIVE HUMIDITY)
      !  6 =013208
      !  7 =012063 BRIGHTNESS TEMPERATURE 1
      !  8 =012001 (TEMPERATURE)            (kelvin)
      !  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
      ! 10 =012004 (2M TEMPERATURE)
      ! 11 =012203 (2M DEW-POINT DEPRESSION)
      ! 12 =011215 SURFACE U     WIND COMPONENT M/S)
      ! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
      ! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
      ! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
      ! 16 =007006 HEIGHT ABOVE STATION (M)
      ! 17 =015001 (Total Ozone from TOVS)
      ! 18 =    64 (CM)
      ! 19 =    65 (CL)
      ! 20 =015036 (GPSRO REFRACTIVITY)
      ! 21 =015031 (GPSGB ZTD IN M)
      ! 22 =015032 (GPSGB ZTD ERROR IN M)
      ! 23 =    69 (C)
      ! 24 =    70 (NS)
      ! 25 =    71 (S)
      ! 26 =    72 (E)
      ! 27 =    73 (TGTG)
      ! 28 =    74 (SPSP)
      ! 29 =    75 (SPSP)
      ! 30 =    76 (RS)
      ! 31 =    77 (ESES)
      ! 32 =    78 (IS)
      ! 33 =    79 (TRTR)
      ! 34 =    80 (RR)
      ! 35 =    81 (JJ)
      ! 36 =    82 (VS)
      ! 37 =    83 (DS)
      ! 38 =    84 (HWHW)
      ! 39 =    85 (PWPW)
      ! 40 =    86 (DWDW)
      ! 41 =    87 (GENERAL CLOUD GROUP)
      ! 42 =    88 (RH FROM LOW CLOUDS)
      ! 43 =    89 (RH FROM MIDDLE CLOUDS)
      ! 44 =    90 (RH FROM HIGH CLOUDS)
      ! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
      ! 46 =012163 (TOVS LEVEL 1B RADIANCES)
      ! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
      ! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
      ! 49 =011002(FF (WIND SPEED))                (m/s)
      ! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
      ! 51 =008001
      ! 52 =008004
      ! 53 =010051
      ! 54 =011011
      ! 55 =011012
      ! 56 =    41 (U AT 10M)
      ! 57 =    42 (V AT 10M)

      obs_get_obs_index_for_bufr_element=-1
      do indbuf=1,OBS_JPNBRELEM
         if (NVNUMB(indbuf) .eq. kbufrn ) then
            obs_get_obs_index_for_bufr_element=indbuf
            return
         endif
      enddo

      return
   end function obs_get_obs_index_for_bufr_element


   function obs_getBodyIndex_depot(obsdat) result(index)
      ! Return the next element from the current body list
      implicit none
      integer :: index
      type(struct_obs), intent(inout) :: obsdat

      index = ild_get_next_index(obsdat%body_index_list_depot)
   end function obs_getBodyIndex_depot


   function obs_getBodyIndex_private(private_list) result(index)
      ! Return the next element from the supplied private body list
      implicit none
      integer :: index
      type(struct_index_list), pointer, intent(inout) :: private_list

      index = ild_get_next_index(private_list)
   end function obs_getBodyIndex_private


   function obs_getFamily(obsdat,headerIndex,bodyIndex)
      !
      ! object: Return the family for the indicated header, or else for the
      !         indicated body.

      implicit none

      character(len=2)             :: obs_getFamily
      type(struct_obs), intent(in) :: obsdat
      integer,optional, intent(in) :: headerIndex,bodyIndex

      integer          :: headerIndex2

      if(present(headerIndex)) then
         obs_getFamily=obsdat%cfamily(headerIndex)
      elseif(present(bodyIndex)) then
         headerIndex2=obs_elem_i(obsdat,'OBS',bodyIndex)
         obs_getFamily=obsdat%cfamily(headerIndex2)
      else
         call obs_abort('OBS_GETFAMILY: Header or Body index must be specified!')
      endif

   end function obs_getFamily


   function obs_getHeaderIndex(obsdat) result(index)
      ! Return the next element from the current header list
      implicit none
      integer :: index
      type(struct_obs), intent(inout) :: obsdat

      index = ild_get_next_index(obsdat%header_index_list_depot)
   end function obs_getHeaderIndex


   subroutine obs_getobstag(obsdat)
      !
      !**s/r read local observation tag from GEM TLM-ADJ .
      !
      !Author  : Bin He *ARMA/MRB  Feb. 2009
      !
      !Revision:
      !  
      !Arguments: none
      !
      !Comments:  In principle this method could have obtained nprocs_mpi and
      !           my_mpi_id by use'ing the module, mpi.  However, it queries
      !           rpn_comm for itself because the mpi module belongs to the
      !           3dvar code, whereas the present module is shared code.
      !
      implicit none
      type(struct_obs), intent(inout) :: obsdat

      integer, allocatable :: locObsTag_tmp(:)
      integer :: iobs_mpiglobal
      integer :: numheader_mpilocal 
      integer :: nprocs_mpi, my_mpi_id, my_mpi_idx_dummy, my_mpi_idy_dummy, ierr
      logical, save :: data_obtained = .false.

      write(*,*) '-------- Start obs_getobstag ---------'
      if(.not. data_obtained) then
         ! Obtain nprocs_mpi and  my_mpi_id
         call rpn_comm_size("ALL", nprocs_mpi, ierr)
         call rpn_comm_mype(my_mpi_id, my_mpi_idx_dummy, my_mpi_idy_dummy)
         data_obtained = .true.
      end if

      numheader_mpilocal=0
      if(nprocs_mpi == 0) nprocs_mpi=1

      write(*,*) 'numheader= ',obsdat%numheader 
      allocate(locObsTag_tmp(obsdat%numheader))

      do iobs_mpiglobal=(my_mpi_id+1),obsdat%numheader,nprocs_mpi
         numheader_mpilocal=numheader_mpilocal+1
         locObsTag_tmp(numheader_mpilocal)=iobs_mpiglobal
      enddo
      if(numheader_mpilocal<=0) call obs_abort('Zero length of ObsTag,Abort!') 

      allocate(obsdat%locObsTag(numheader_mpilocal))

      obsdat%locObsTag(1:numheader_mpilocal)=locObsTag_tmp(1:numheader_mpilocal)

      deallocate(locObsTag_tmp) 

      write(*,*) '-------- END OF obs_getobstag ---------'
      write(*,*) ' '
   end subroutine obs_getobstag


   subroutine obs_initialize(obsdat, header_max, body_max)
      !s/r obs_initialize - Set an observation-data module to a known state.
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  Initialize module variables, and allocate arrays according
      !              to the parameters, header_max and body_max.
      implicit none
      ! number of header elements allocated
      integer, optional, intent(in) :: header_max
      ! total no. of body elements allocated
      integer, optional, intent(in) :: body_max
      type(struct_obs), intent(out) :: obsdat

      integer :: nulnam,fnom,fclos,ierr
      integer :: nmxobs,ndatamx
      namelist /namdimo/nmxobs,ndatamx


      if(present(header_max)) then
         ! body_max is necessarily also present
         nmxobs = header_max
         ndatamx = body_max

      else
         nmxobs=30000                   ! These default values will be used
         ndatamx=200000                 ! if namdimo does not supply values

         nulnam=0
         ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
         read(nulnam,nml=namdimo,iostat=ierr)
         write(*,*) 'obs_initialize: reading namelist, ierr=',ierr
         write(*,nml=namdimo)
         ierr=fclos(nulnam)
      end if

      write(*,*) ' DIMENSIONS OF OBSERVATION ARRAYS:'
      write(*,*) ' numheader_max = ',NMXOBS,'  numbody_max = ',NDATAMX

      obsdat%numheader_max=nmxobs
      obsdat%numbody_max=ndatamx
      obsdat%numheader = 0
      obsdat%numbody  = 0
      obsdat%numheader_mpiglobal = 0
      obsdat%numbody_mpiglobal = 0
      obsdat%mpi_local = .false.

      nullify(obsdat%mobhdr_g)
      nullify(obsdat%robhdr_g)
      nullify(obsdat%cstnid_g)

      call obs_allocate(obsdat,obsdat%numheader_max,obsdat%numbody_max)
      call ild_initialize(obsdat%header_index_list_depot, obsdat%numheader_max)
      call ild_initialize(obsdat%body_index_list_depot,   obsdat%numbody_max)
      return
   end subroutine obs_initialize


   integer function obs_numbody(obsdat)
      !func obs_numbody - returns the number of observations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of observations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numbody=obsdat%numbody
   end function obs_numbody


   integer function obs_numbody_max(obsdat)
      !func obs_numbody_max - returns the number of observations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of observations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numbody_max=obsdat%numbody_max
   end function obs_numbody_max


   integer function obs_numheader(obsdat)
      !func obs_numheader - returns the number of stations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of stations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numheader=obsdat%numheader
   end function obs_numheader


   integer function obs_numheader_max(obsdat)
      !func obs_numheader_max - returns the dimensioned number of stations
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of stations that is currently
      !              dimensioned in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numheader_max=obsdat%numheader_max
   end function obs_numheader_max


   integer function obs_numheader_mpiglobal(obsdat)
      !func obs_numheader_mpiglobal - returns the number of stations recorded
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to provide the number of stations that are currently
      !              recorded in the observation-data object
      !
      implicit none
      type(struct_obs) , intent(in)  :: obsdat
      obs_numheader_mpiglobal=obsdat%numheader_mpiglobal
   end function obs_numheader_mpiglobal


   subroutine obs_order(obsdat)
      !
      !author: Peter Houtekamer
      !        March 2000
      !
      !object:
      !    Put a obsdat-file into the order required for the
      !    sequential assimilation. Note that it is known,
      !    as a by-product of the algorithm that was used 
      !    to determine the pass and the region for each
      !    station, at what exact location (information 
      !    in NCM_ONM) each station has to be. The algorithm
      !    requires the exchange of at most mxstn headers. 
      !    A faster algorithm likely exists.
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat

      integer stn,jk
      logical sorted

      do stn=1,obsdat%numheader
         sorted=.false.
         do while(.not.sorted)
            jk=obsdat%mobhdr(NCM_ONM,stn)
            if (jk.eq.stn) then
               sorted=.true.
            else
               call obs_exchange_stations(obsdat,jk,stn)
            endif
         end do
      enddo

      return
   end subroutine obs_order


   subroutine obs_print(obsdat,nobsout)
      !
      ! object  - print the contents of the obsdat to an ASCII file
      !
      !author  : P. Houtekamer  February 2011
      !
      !arguments
      !     i   nobsout: unit used for printing
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer,         intent(in)    :: nobsout

      integer :: jo

      do jo=1,obsdat%numheader
         call obs_enkf_prnthdr(obsdat,jo,nobsout)
         call obs_enkf_prntbdy(obsdat,jo,nobsout)
      enddo

      return
   end subroutine obs_print


   subroutine obs_prnt_csv(obsdat,nhdrsql,nbdysql)
      !
      ! object  - print the contents of the obsdat to csv (comma separated
      !           values) files
      !
      !author  : P. Houtekamer  February 2011
      !
      !arguments
      !     i   nhdrsql: unit used for printing header
      !     i   nbdysql: unit used for printing body
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,      intent(in)  :: nhdrsql, nbdysql

      integer :: jo

      do jo=1,obsdat%numheader
         call obs_tosqlhdr(obsdat,jo,nhdrsql)
         call obs_tosqlbdy(obsdat,jo,nbdysql)
      enddo

      return
   end subroutine obs_prnt_csv


   subroutine obs_prntbdy(obsdat,kobs,kulout)
      !
      !**s/r PRNTBDY  - Print all data records associated with an observation
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
      !
      !     . C. Charette *ARMA/AES Mar 1996 : format statement
      !     . C. Charette *ARMA/AES Nov 1999 : Added print of flag NCM_ASS
      !       JM Belanger CMDA/SMC  Jul 2000
      !                   . 32 bits conversion
      !     . S. Pellerin ARMA, January 2008 : Remove NCM_OMN print.
      !
      !Arguments
      !     i   KOBS  : No. of observation
      !     i   KULOUT: unit used for printing
      !
      implicit none

      type(struct_obs), intent(in) :: obsdat
      integer         , intent(in) :: kobs, kulout

      integer :: ipnt, idata, idata2, jdata, ivco
      character(len=13) :: ccordtyp(3)

      ccordtyp(1)='HEIGHT      :'
      ccordtyp(2)='PRESSURE    :'
      ccordtyp(3)='VCO UNDEFINED'
      !
      ! 1. General information
      !
      ipnt  = obs_elem_i(obsdat,'RLN',KOBS)
      idata = obs_elem_i(obsdat,'NLV',KOBS)

      if(idata.eq.1) then
         write(kulout,fmt=9101)idata,kobs, NBDY_INT + NBDY_REAL
      else
         write(kulout,fmt=9100)idata,kobs, NBDY_INT + NBDY_REAL
      end if
9100  format(4x,'THERE ARE ', &
         i3,1x,'DATA IN OBSERVATION RECORD NO.' &
         ,1x,i6,4x,'DATA RECORD''S LENGTH:',i6)
9101  format(4x,'THERE IS ', &
         i3,1x,'DATUM IN OBSERVATION RECORD NO.' &
         ,1x,i6,4x,'DATA RECORD''S LENGTH:',i6)
      !
      ! 2. Print all data records
      !
      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if(obs_elem_i(obsdat,'ASS',jdata).eq.1) then
            ivco=obs_elem_i(obsdat,'VCO',jdata)
            if(ivco.ne.1.and.ivco.ne.2) ivco=3
            write(kulout,fmt=9201) idata2 &
               ,obs_elem_i(obsdat,'VNM',jdata) &
               ,ccordtyp  (ivco) &
               ,obs_elem_r(obsdat,'PPP',jdata) &
               ,obs_elem_r(obsdat,'SEM',jdata),obs_elem_r(obsdat,'POB',jdata) &
               ,obs_elem_r(obsdat,'VAR',jdata),obs_elem_r(obsdat,'OMF',jdata) &
               ,obs_elem_r(obsdat,'OMA',jdata),obs_elem_r(obsdat,'OMI',jdata) &
               ,obs_elem_r(obsdat,'OER',jdata) &
               ,obs_elem_r(obsdat,'HPHT',jdata) &
               ,obs_elem_i(obsdat,'FLG',jdata) &
               ,obs_elem_i(obsdat,'ASS',jdata)
         end if
      end do

9201  format(4x,'DATA NO.',i6,/,10x &
         !     ,'VARIABLE NO.:',i6,4x,'PRESSURE LEVEL:',g12.6,4x &
         ,'VARIABLE NO.:',i6,4x,a13,g12.6,4x &
         ,'REFERENCE LEVEL PRESSURE:',g12.6,4x &
         ,/,33x &
         ,'PRESSURE/GEOPOTENTIAL:',g12.6,4x &
         ,/,10x &
         ,'OBSERVE VALUE:',g23.16,15x,'FIRST-GUESS - OBSERVED VALUE:' &
         ,g23.16,4x &
         ,/,10x &
         ,'ANALYZED - OBSERVED VALUE:',g12.6,4x &
         ,'INITIALIZED - OBSERVED VALUE:',g23.16 &
         ,/,10x &
         ,'ERROR STANDARD DEVIATIONS FOR' &
         ,/,20x &
         ,'OBSERVATION:',g12.6,4x &
         ,/,20x &
         ,'FIRST-GUESS:',g12.6,4x &
         ,/,10x &
         ,'BURP FLAGS:',i6,4x,'OBS. ASSIMILATED (1-->YES;0-->NO):',i3)

      return
   end subroutine obs_prntbdy


   subroutine obs_prnthdr(obsdat,kobs,kulout)
      !
      !**s/r PRNTHDR  - Printing of the header of an observation record
      !
      !Author  : P. Gauthier *ARMA/AES  June 9, 1992
      !Revision:
      !     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
      !     . P. Koclas   *CMC:  Format for transformed latitude has been modified
      !     .                    to handle an integer (latitude index of the first
      !     .                    latitude circle north of the observation)
      !Arguments
      !     i   KOBS  : No. of observation
      !     i   KULOUT: unit used for optional printing
      !

      implicit none


      type(struct_obs), intent(in) :: obsdat
      integer         , intent(in) :: kobs, kulout

      !
      ! 1. General information
      !
      write(kulout,fmt=9100)kobs, NHDR_INT + NHDR_REAL
9100  format(//,10x,'-- OBSERVATION RECORD NO.' &
         ,1x,i6,3x,'HEADER''S LENGTH:',i6)
      !
      ! 2. PRINT HEADER'S CONTENT
      !
      write(kulout,fmt=9200)&
          obs_elem_i(obsdat,'RLN',kobs), obs_elem_i(obsdat,'ONM',kobs) &
         ,obs_elem_i(obsdat,'INS',kobs), obs_elem_i(obsdat,'OTP',kobs) &
         ,obs_elem_i(obsdat,'ITY',kobs) &
         ,obs_elem_r(obsdat,'LAT',kobs), obs_elem_r(obsdat,'LON',kobs)&
         ,obs_elem_i(obsdat,'DAT',kobs), obs_elem_i(obsdat,'ETM',kobs) &
         ,obs_elem_c(obsdat,'STID',kobs),obs_elem_r(obsdat,'ALT',kobs) &
         ,obs_elem_i(obsdat,'NLV',kobs) &
         ,obs_elem_i(obsdat,'OFL',kobs), obs_elem_i(obsdat,'ST1 ',kobs) &
         ,obs_elem_i(obsdat,'TLA',kobs)

9200  format(6x,'Position within ROBDATA:',i6,1x,'OBS. NUMBER:',i6,1x &
         ,'INSTR. ID:',i6,1x,'OBS. TYPE:',i6,1x &
         ,'INSTR./RETR. TYPE:',i6,1x &
         ,/,6x &
         ,'OBSERVATION LOCATION. (LAT,LON):',2(f12.6,1x) &
         ,'DATE:',i12,1x,'EXACT TIME: ',i6,1x &
         ,/,6x &
         ,'STATION ID:',a9,1x &
         ,'STATION''S ALTITUDE:',g12.6,1x &
         ,'NUMBER OF DATA:',i6,1x &
         ,/,6x &
         ,'REPORT STATUS:',i6,5x,'REPORT STATUS 2:',i6,1x &
         ,/,6x &
         ,'Index of latitude north of the observation:',(1x,i6) &
         )

      return
   end subroutine obs_prnthdr


   subroutine obs_read(obsdat,hx,nobshdr,nobsbdy,nobshx)
      !
      !authors Peter Houtekamer and Herschel Mitchell October 1999
      !
      !object: read the obsdat structure with observational information from files.
      !
      !   input: 
      !      nobshdr: unit number of the file with obsdat header info.
      !      nobsbdy: unit number of the file with obsdat body info.
      !      nobshx:  unit number of the file with hx (-1 if not used)
      !   output:
      !      mobhdr,robhdr,cstnid:             station header information
      !      mobdata,robdata,hx:               observation data
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat  ! the OBSDAT being prep'ed
      integer,      intent(in)  :: nobshdr,nobsbdy,nobshx
      real(8),      intent(out) :: hx(:,:)

      integer  :: i,ifirst,ilast,iobscur,istn,j,k,myip,nens

      if (nobshx.eq.-1) then
         nens=0
      else
         nens=size(hx,1)
      endif
      obsdat%numbody=size(obsdat%robdata,2)
      obsdat%numheader=size(obsdat%robhdr,2)

      iobscur=0

      ! read stations

      readstn: do istn=1,obsdat%numheader
         read(nobshdr,end=288,err=288) (obsdat%mobhdr(i,istn),i=1,NHDR_INT), &
            (obsdat%robhdr(j,istn),j=1,NHDR_REAL),obsdat%cstnid(istn)

         if (istn.eq.1) then 
            obsdat%mobhdr(NCM_RLN,istn)=1
         else
            obsdat%mobhdr(NCM_RLN,istn)=obsdat%mobhdr(NCM_RLN,istn-1)+ &
               obsdat%mobhdr(NCM_NLV,istn-1)
         endif
         iobscur=iobscur+obsdat%mobhdr(NCM_NLV,istn)
         ! now read the observations:
         ifirst=obsdat%mobhdr(NCM_RLN,istn)
         ilast=obsdat%mobhdr(NCM_RLN,istn)+obsdat%mobhdr(NCM_NLV,istn)-1
         do i=ifirst,ilast
            read(nobsbdy) (obsdat%mobdata(j,i),j=1,NBDY_INT), &
               (obsdat%robdata(k,i),k=1,NBDY_REAL)
         enddo
         if (nens.gt.0) then
            do i=ifirst,ilast
               read(nobshx)  (hx(j,i),j=1,nens)
            enddo
         endif
      enddo readstn

      if (iobscur.ne.obsdat%numbody) then
         write(*,*) 'OBS_READ: the number of observations ', &
            iobscur,' should equal ',obsdat%numbody
         call obs_abort('OBS_READ: the number of references in the header does not matche the body size')
      endif
288   write(*,*) 'file is now empty'
      write(*,*) 'close nobshdr which is on unit: ',nobshdr
      close(nobshdr)
      write(*,*) 'close nobsbdy which is on unit: ',nobsbdy
      close(nobsbdy)
      if (nens.gt.0) then
         write(*,*) 'close nobshx which is on unit: ',nobshx
         close(nobshx)
      endif
      write(*,*) 'exit from obs_read'
      return

   end subroutine obs_read


   subroutine obs_readstns(obsdat,myip,ipasscur,iregcur,nobshdr,nobsbdy,np, &
                           mxstn,mxobs)
      !
      ! obs_readstns
      !
      !authors Peter Houtekamer and Herschel Mitchell October 1999
      !
      !object: read the stations for one analysis pass and store them
      !        in buffers.
      !        (this routine is intended for the master mpi process,
      !         other processes exit immediately)
      !
      !   input: 
      !      myip:     number of the process
      !      ipasscur: number of the current analysis pass (i.e. batch)
      !      nobshdr:  unit number of the file with obsdat header info.
      !      nobsbdy:  unit number of the file with obsdat body info.
      !      np   :    total number of processes used in MPI. 
      !   output:
      !      iregcur: number of regions to be done for this pass. 
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer,          intent(in)  :: ipasscur,myip,nobshdr,nobsbdy,np,mxstn, &
                                       mxobs
      integer,          intent(out) :: iregcur

      integer :: i,idata,ifirst,ilast,ipass,ireg,j,k

      real(4),           save :: robhdr_1(NHDR_REAL)
      integer,           save :: mobhdr_1(NHDR_INT)
      character(len=12), save :: cstnid_1
      logical,           save :: empty  = .false., &
         hasone = .false.

      if (myip.ne.0) return

      if (empty) then
         write(*,*) 'file is empty'
         return
      endif

      iregcur=1

      ! read stations for this pass of the sequential algorithm

      ! hasone indicates whether a station has been read without being
      ! buffered. This occurs after the stations for one pass have
      ! been read. In this case one should not read a new station 
      ! but first buffer the saved one.

      do while( get_one() )
         ireg=mobhdr_1(NCM_REG)
         ipass=mobhdr_1(NCM_PAS)

         if ((ipass /= ipasscur)) then
            if(obs_numheader(obsdat) == 0) then
               write(6,*)"ERROR"
               write(6,*)"ERROR:  In obs_readstns(), the next"
               write(6,*)"ERROR:  NCM_PAS value, ", ipass, "does not match the"
               write(6,*)"ERROR:  current  pass, ", ipasscur,".  Exiting."
               write(6,*)"ERROR"
               call obs_abort('OBS_READSTNS: ipass /= ipasscur')
            end if
            exit
         end if

         ! default assignment of all input variables to obsdat.
         obsdat%numheader=obsdat%numheader+1
         idata=obsdat%numheader
         obsdat%mobhdr(:,idata)=mobhdr_1(:)
         obsdat%robhdr(:,idata)=robhdr_1(:)
         obsdat%cstnid(idata)=cstnid_1

         ! determine which process will handle this station.
         ! the corresponding scatter operation is in program scattercma.
         obsdat%mobhdr(NCM_IP,idata)=mod(obsdat%mobhdr(NCM_ONM,idata),np)

         ireg=obsdat%mobhdr(NCM_REG,idata)
         if (iregcur.ne.ireg) then
            iregcur=ireg
         endif

         if (idata.eq.1) then 
            obsdat%mobhdr(NCM_RLN,idata)=1
         else
            obsdat%mobhdr(NCM_RLN,idata)=obsdat%mobhdr(NCM_RLN,idata-1)+ &
               obsdat%mobhdr(NCM_NLV,idata-1)
         endif

         ! now read the observations:
         ifirst=obsdat%mobhdr(NCM_RLN,idata)
         ilast=obsdat%mobhdr(NCM_RLN,idata) + obsdat%mobhdr(NCM_NLV,idata)-1
         do i=ifirst,ilast
            read(nobsbdy) (obsdat%mobdata(j,i),j=1,NBDY_INT), &
               (obsdat%robdata(k,i),k=1,NBDY_REAL)
         enddo

         hasone=.false.

         ! go back to read the next station
      end do

      return


   contains
      logical function get_one()
         integer :: ierr

         if (.not. hasone) then 
            read(nobshdr,iostat=ierr) (mobhdr_1(i),i=1,NHDR_INT), &
               (robhdr_1(j),j=1,NHDR_REAL),cstnid_1
            if(ierr == 0) then
               hasone = .true.
            else
               hasone = .false.
               empty=.true.
               write(*,*) 'file is now empty'
               close(nobshdr)
               close(nobsbdy)
            end if ! ierr
         end if ! hasone

         get_one = hasone
         return
      end function get_one

   end subroutine obs_readstns


   subroutine obs_reduceToMpiLocal(obsdat, nfiles, nbegintyp, &
      nendtyp, nbegintyp_g, nendtyp_g)
      !
      !**s/r obs_reduceToMpiLocal - re-construct observation data object by
      !                             giving  local Obs TAG. 
      !
      !Author    . Bin He (ARMA/MRB )
      !
      !revision:
      !      PURPOSE:  To retain in the observation object only those data that
      !                are pertinent to the present mpi processor.
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in)    :: nfiles
      integer, intent(inout) :: nbegintyp(:), nendtyp(:)
      integer, intent  (out) :: nbegintyp_g(:), nendtyp_g(:)

      ! Declare Local Variables
      character(len=12),allocatable,dimension(:) :: cstnid_tmp
      character(len=2), allocatable,dimension(:) :: cfamily_tmp
      real(OBS_REAL),allocatable,dimension(:,:) :: robhdr_tmp
      real(OBS_REAL),allocatable,dimension(:,:) :: robdata_tmp

      integer,allocatable,dimension(:,:) :: mobhdr_tmp,mobdata_tmp
      integer,allocatable,dimension(:) :: locobstag_tmp
      integer :: numbody_mpilocal

      integer :: i,j,iobs ,numheader_mpilocal ,startindx,endindx 
      integer :: idataend,jj,ifamid,istart,idata,ii 
      logical :: lfirst 
      !!---------------------------------------------------------------
      WRITE(*,*) '============= Enter obs_reduceToMpiLocal =============='

      call obs_getobstag(obsdat)

      write(*,*) obsdat%numheader,obsdat%numheader_mpiglobal,obsdat%numbody, &
                 obsdat%numbody_mpiglobal

      if(obsdat%mpi_local .eqv. .true.)then
         call obs_abort('OBS_REDUCETOMPILOCAL() has been called, but the obsSpaceData object is already in mpi-local state')
      end if
      obsdat%mpi_local = .true.

      numheader_mpilocal=size(obsdat%locObsTag) 

      ! Calculate the size of the local obs data  
      numbody_mpilocal=0
      do i=1,numheader_mpilocal
         iobs=obsdat%locObsTag(i)
         idata=obsdat%mobhdr(NCM_NLV, iobs)
         numbody_mpilocal = numbody_mpilocal + idata
      enddo

      allocate(cfamily_tmp(numheader_mpilocal)) 
      allocate(cstnid_tmp(numheader_mpilocal)) 
      allocate(robhdr_tmp(NHDR_REAL,numheader_mpilocal)) 
      allocate(mobhdr_tmp(NHDR_INT,numheader_mpilocal)) 
      allocate(mobdata_tmp(NBDY_INT,numbody_mpilocal)) 
      allocate(robdata_tmp(NBDY_REAL,numbody_mpilocal))

      call obs_allocateG(obsdat,obsdat%numheader)

      obsdat%numheader_mpiglobal=obsdat%numheader
      obsdat%numbody_mpiglobal=obsdat%numbody

      !! keep the Global ROBHDR and MOBHDR
      do iobs=1,obsdat%numheader_mpiglobal
         obsdat%cstnid_g(iobs)=obsdat%cstnid(iobs)
         obsdat%mobhdr_g(:,iobs)=obsdat%mobhdr(:,iobs)
         obsdat%robhdr_g(:,iobs)=obsdat%robhdr(:,iobs)
      enddo

      do i=1,numheader_mpilocal 
         iobs=obsdat%locobstag(i) 
         robhdr_tmp(:,i)=obsdat%robhdr(:,iobs)
         mobhdr_tmp(:,i)=obsdat%mobhdr(:,iobs)
         cstnid_tmp(i) = obsdat%cstnid(iobs)
         cfamily_tmp(i) = obsdat%cfamily(iobs) 
         if(i== 1) then
            mobhdr_tmp(NCM_RLN,1) = 1
         else
            mobhdr_tmp(NCM_RLN,i) =   mobhdr_tmp(NCM_RLN,i-1) &
                                    + mobhdr_tmp(NCM_NLV,i-1) 
         endif
      enddo

      ii=0 
      do i=1,numheader_mpilocal
         iobs=obsdat%locObsTag(i) 
         idata= obsdat%mobhdr(NCM_RLN, iobs)
         idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
         do j=idata,idataend 
            ii=ii+1 
            robdata_tmp(:,ii)=obsdat%robdata(:,j)
            mobdata_tmp(:,ii)=obsdat%mobdata(:,j) 
            mobdata_tmp(ncm_obs,ii) = i
         enddo
      enddo

      obsdat%numheader=numheader_mpilocal
      obsdat%numbody=numbody_mpilocal
      write(*,*) 'NUMHEADER= ',obsdat%numheader 
      call obs_deallocate(obsdat)
      call obs_allocate(obsdat,obsdat%numheader,obsdat%numbody)

      do i=1,obsdat%numheader
         obsdat%cfamily(i)=cfamily_tmp(i) 
         obsdat%cstnid(i)=cstnid_tmp(i)
         obsdat%robhdr(:,i)=robhdr_tmp(:,i)
         obsdat%mobhdr(:,i)=mobhdr_tmp(:,i) 
      enddo

      do i=1,obsdat%numbody
         obsdat%robdata(:,i)=robdata_tmp(:,i) 
         obsdat%mobdata(:,i)=mobdata_tmp(:,i) 
      enddo

      deallocate(cfamily_tmp)
      deallocate(cstnid_tmp)
      deallocate(robhdr_tmp)
      deallocate(mobhdr_tmp)
      deallocate(robdata_tmp)
      deallocate(mobdata_tmp)

      ! rebuild NBEGINTYP and NENDTYP  
      !============================
      jj=0
      nbegintyp_g=nbegintyp
      nendtyp_g=nendtyp

      nbegintyp=0
      nendtyp=0
      do j=1,nfiles
         lfirst=.true. 
         do i=1,numheader_mpilocal
            istart=obsdat%mobhdr(NCM_RLN, i)
            idata=obsdat%mobhdr(NCM_NLV, i)
            ifamid=obsdat%mobhdr(NCM_OTP, i)
            if(ifamid == j) then
               if(lfirst) then
                  nbegintyp(j) = istart 
                  lfirst=.false. 
               endif
               jj=jj+idata 
            endif
         enddo
         nendtyp(j) = jj 
         if(nbegintyp(j) == 0)  nendtyp(j) = 0
         write(*,*) 'J NBEGINTYP(j) NENDTYP(j)= ',j,nbegintyp(j), nendtyp(j), &
                                                 ifamid
      enddo

      write(*,*) obsdat%numheader,obsdat%numheader_mpiglobal,obsdat%numbody, &
                 obsdat%numbody_mpiglobal
      write(*,*) '============= Leave obs_reduceToMpiLocal =============='

      return
   end subroutine obs_reducetompilocal


   subroutine obs_select(obsdat,hx,obs_sel,hx_sel,zhamin,zhamax,nens,nobsout)
      !
      ! object  - select only the observations with zhamin < lop(P) <= zhamax.   
      !
      !author  : Peter Houtekamer
      !     January 2012: created using obs_clean as an example
      !
      !arguments
      !     obsdat,hx        : input obsdat and interpolated values
      !     obs_sel,hx_sel: selected obsdat and interpolated values
      !     zhamin,zhamax : range of zha values to be selected.
      !     nens          : number of ensemble members
      !     nobsout       : unit number for the ASCII output
      !
      implicit none

      type (struct_obs), intent(in) :: obsdat
      type (struct_obs), intent(inout) :: obs_sel

      real(8),      intent(in) :: hx(:,:),zhamin,zhamax
      real(8),      intent(out) :: hx_sel(:,:)

      integer, intent(in)    :: nens, nobsout

      integer :: iaccept,idata,ipnt,iwrite
      integer :: jdata,kobs,kobsout

      write(nobsout,*) 'stations prior to selection: ', obsdat%numheader
      write(*,*) 'enter obs_select'

      kobsout=0 
      iwrite=0
      stations: do kobs=1,obsdat%numheader
         ipnt  = obsdat%mobhdr(NCM_RLN,kobs)
         idata = obsdat%mobhdr(NCM_NLV,kobs)
         iaccept=0
         observations: do jdata = ipnt, ipnt + idata - 1
            ! To remove observations that are not in the desired vertical layer 
            if ((obsdat%robdata(NCM_ZHA,jdata) .gt. zhamin).and. &
               (obsdat%robdata(NCM_ZHA,jdata) .le. zhamax)) then
               iaccept=iaccept+1
               iwrite=iwrite+1
               obs_sel%mobdata(:,iwrite)=obsdat%mobdata(:,jdata)
               obs_sel%robdata(:,iwrite)=obsdat%robdata(:,jdata)
               hx_sel(1:nens,iwrite)=hx(1:nens,jdata)
            endif
         enddo observations
         ! adjust obs_sel%robhdr 
         if (iaccept.gt.0) then
            kobsout=kobsout+1
            obs_sel%mobhdr(:,kobsout)=obsdat%mobhdr(:,kobs)
            obs_sel%robhdr(:,kobsout)=obsdat%robhdr(:,kobs)
            obs_sel%cstnid(kobsout)=obsdat%cstnid(kobs)
            obs_sel%mobhdr(NCM_NLV,kobsout)=iaccept
            obs_sel%mobhdr(NCM_RLN,kobsout)=iwrite-iaccept+1
         endif
      enddo stations
      obs_sel%numheader=kobsout
      obs_sel%numbody = iwrite

      write(nobsout,*) 'after selection of observations in the range: ', &
         zhamin,zhamax
      write(nobsout,*) &
         'number of stations containing valid data   ',obs_sel%numheader
      write(nobsout,*) & 
         'number of observations now in the obsdat file ',obs_sel%numbody

   end subroutine obs_select


   subroutine obs_set_c(obsdat, name, index, value)
      !s/r obs_set_c - set a character(len=9) in the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      character(len=*), intent(in)     :: name
      integer         , intent(in)     :: index
      character(len=*), intent(in)     :: value

      select case (trim(name))
      case ('STID'); obsdat%cstnid (index) = value 

      case default
         write(*,*)"ERROR:  ", trim(name)," is not a character(len=9) observation."
      end select
   end subroutine obs_set_c


   subroutine obs_set_current_body_list_from_family(obsdat, family, &
      list_is_empty, current_list)
      ! Create an index list from the indicated family and place it in the body
      ! depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      character(len=*), intent(in) :: family
      logical, intent(out), optional :: list_is_empty
      type(struct_index_list), pointer, intent(out), optional :: current_list

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: index_header, list, list_index, item_index
      integer :: first, last

      nullify(index_list)
      depot => obsdat%body_index_list_depot

      ! Search for an existing list
      if(present(current_list)) then
         if(associated(current_list)) then
            if (current_list%family == family) then
               index_list => current_list
            end if ! family matches
         end if ! associated

      else ! not present(current_list)
         do list = 1, NUMBER_OF_LISTS
            if (depot%index_lists(list)%family == family) then
               index_list => depot%index_lists(list)
               exit                     ! Don't look any further
            end if
         end do
      end if

      ! If the list does not already exist
      if (.not. associated(index_list)) then

         ! Acquire memory for the list
         if(present(current_list)) then
            ! This is an OMP thread. Re-use the same physical memory for the list
            index_list => ild_get_empty_index_list(depot, current_list)
         else
            index_list => ild_get_empty_index_list(depot)
         end if

         ! Initialize the new list
         index_list%family = family
         index_list%header = -99        ! not used

         !
         ! Populate the li-st
         !

         ! Loop over all header indices of the family
         list_index = 0
         call obs_set_current_header_list(obsdat, family)
         HEADER: do
            if (index_header < 0) exit HEADER
            index_header = obs_getHeaderIndex(obsdat)
            first= obs_elem_i(obsdat,'RLN',index_header)
            last = obs_elem_i(obsdat,'NLV',index_header) + first - 1
            do item_index=first,last    ! For each item indicated in the header
               ! Add the item_index to the list
               list_index = list_index + 1
               index_list%indices(list_index) = item_index
            end do
         end do HEADER
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list

      if(present(list_is_empty)) then
         ! Return whether the list is empty
         list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
      end if

      if(present(current_list)) then
         ! Return a pointer to the current list
         current_list => index_list
      end if
   end subroutine obs_set_current_body_list_from_family


   subroutine obs_set_current_body_list_from_header(obsdat, header, &
      list_is_empty, current_list)
      ! Create an index list from the indicated header and place it in the body
      ! depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      integer, intent(in) :: header
      logical, intent(out), optional :: list_is_empty
      type(struct_index_list), pointer, intent(out), optional :: current_list

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: list, list_index, item_index
      integer :: first, last

      nullify(index_list)
      depot => obsdat%body_index_list_depot

      ! Search for an existing list
      if(present(current_list)) then
         if(associated(current_list)) then
            if (current_list%header == header) then
               index_list => current_list
            end if ! header matches
         end if ! associated

      else ! not present(current_list)
         do list = 1, NUMBER_OF_LISTS
            if (depot%index_lists(list)%header == header) then
               index_list => depot%index_lists(list)
               exit                     ! Don't look any further
            end if
         end do
      end if

      ! If the list does not already exist
      if (.not. associated(index_list)) then

         ! Acquire memory for the list
         if(present(current_list)) then
            ! This is an OMP thread. Re-use the same physical memory for the list
            index_list => ild_get_empty_index_list(depot, current_list)
         else
            index_list => ild_get_empty_index_list(depot)
         end if

         ! Initialize the new list
         index_list%family = 'xx'       ! not used
         index_list%header = header

         ! Populate the list
         first= obs_elem_i(obsdat,'RLN',header)
         last = obs_elem_i(obsdat,'NLV',header) + first - 1
         list_index = 0
         do item_index=first,last       ! For each item indicated in the header
            ! Add the item_index to the list
            list_index = list_index + 1
            index_list%indices(list_index) = item_index
         end do
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list

      if(present(list_is_empty)) then
         ! Return whether the list is empty
         list_is_empty = (ild_get_next_index(depot, no_advance=.true.) < 0)
      end if

      if(present(current_list)) then
         ! Return a pointer to the current list
         current_list => index_list
      end if
   end subroutine obs_set_current_body_list_from_header


   subroutine obs_set_current_header_list(obsdat, family)
      ! Find or create an index list for the indicated family and place it in the
      ! header depot.
      implicit none
      type(struct_obs), intent(inout), target :: obsdat
      character(len=*), intent(in) :: family

      type(struct_index_list_depot), pointer :: depot
      type(struct_index_list), pointer :: index_list
      integer :: list, list_index, item_index

      nullify(index_list)
      depot => obsdat%header_index_list_depot

      ! Search for an existing list
      do list = 1, NUMBER_OF_LISTS
         if (depot%index_lists(list)%family == family) then
            index_list => depot%index_lists(list)
            index_list%current_element=0! Start at the beginning of the list
            exit                        ! Don't look any further
         end if
      end do

      ! If the list does not already exist
      if (.not. associated(index_list)) then
         ! Create a new list
         index_list => ild_get_empty_index_list(depot)
         index_list%family = family
         index_list%header = -1

         ! Populate the list
         list_index = 0
         do item_index = 1, obsdat%numheader
            ! If the station is of the right family
            if(obsdat%cfamily(item_index) == family) then
               ! Add the item_index to the list
               list_index = list_index + 1
               index_list%indices(list_index) = item_index
            end if
         end do
         index_list%indices(list_index+1)= -1 ! Flag the end of the list ...
         index_list%indices(list_index+2)= -1 ! ... clearly
      end if ! list does not already exist

      index_list%current_element = 0    ! Set pointer to the start of the list
      depot%current_list => index_list  ! Note the current list
   end subroutine obs_set_current_header_list


   subroutine obs_set_datestamp(obsdat,datestamp)
      implicit none
      !
      ! object: to control access to the observation object.  Sets the date
      !         stamp of the obsdat object to the indicated value.

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: datestamp

      obsdat%datestamp = datestamp

   end subroutine obs_set_datestamp


   subroutine obs_set_i(obsdat, name, index, value)
      !s/r obs_set_i - set an integer value in the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      character(len=*), intent(in)     :: name
      integer         , intent(in)     :: index
      integer         , intent(in)     :: value

      select case (trim(name))
         ! integer header values
      case ('RLN');  obsdat%mobhdr (NCM_RLN, index) = value
      case ('ONM');  obsdat%mobhdr (NCM_ONM, index) = value
      case ('INS');  obsdat%mobhdr (NCM_INS, index) = value
      case ('OTP');  obsdat%mobhdr (NCM_OTP, index) = value
      case ('ITY');  obsdat%mobhdr (NCM_ITY, index) = value
      case ('SAT');  obsdat%mobhdr (NCM_SAT, index) = value
      case ('TEC');  obsdat%mobhdr (NCM_TEC, index) = value
      case ('DAT');  obsdat%mobhdr (NCM_DAT, index) = value
      case ('ETM');  obsdat%mobhdr (NCM_ETM, index) = value
      case ('NLV');  obsdat%mobhdr (NCM_NLV, index) = value
      case ('OFL');  obsdat%mobhdr (NCM_OFL, index) = value
      case ('PAS');  obsdat%mobhdr (NCM_PAS, index) = value
      case ('REG');  obsdat%mobhdr (NCM_REG, index) = value
      case ('IP');   obsdat%mobhdr (NCM_IP , index) = value
      case ('AZA');  obsdat%mobhdr (NCM_AZA, index) = value
      case ('SZA');  obsdat%mobhdr (NCM_SZA, index) = value
      case ('SUN');  obsdat%mobhdr (NCM_SUN, index) = value
      case ('CLF');  obsdat%mobhdr (NCM_CLF, index) = value
      case ('ST1');  obsdat%mobhdr (NCM_ST1, index) = value
      case ('TLA');  obsdat%mobhdr (NCM_TLA, index) = value
      case ('IDO');  obsdat%mobhdr (NCM_IDO, index) = value
      case ('IDF');  obsdat%mobhdr (NCM_IDF, index) = value

         ! integer body values
      case ('VNM');  obsdat%mobdata(NCM_VNM, index) = value
      case ('FLG');  obsdat%mobdata(NCM_FLG, index) = value
      case ('KFA');  obsdat%mobdata(NCM_KFA, index) = value
      case ('ASS');  obsdat%mobdata(NCM_ASS, index) = value
      case ('OBS');  obsdat%mobdata(NCM_OBS, index) = value
      case ('VCO');  obsdat%mobdata(NCM_VCO, index) = value
      case ('LYR');  obsdat%mobdata(NCM_LYR, index) = value
      case ('XTR');  obsdat%mobdata(NCM_XTR, index) = value
      case ('IDD');  obsdat%mobdata(NCM_IDD, index) = value

      case default
         write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
      end select
   end subroutine obs_set_i


   subroutine obs_set_r(obsdat, name, index, value)
      !s/r obs_set_r - set a real value in the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  to control access to the observation object
      !
      !    COMMENT:  the real kind, OBS_REAL, is specified at compile time.
      !
      implicit none
      type(struct_obs), intent(inout)  :: obsdat
      character(len=*), intent(in)     :: name
      integer         , intent(in)     :: index
      real(kind=OBS_REAL), intent(in)  :: value

      select case (trim(name))
         ! real header values
      case ('LAT');  obsdat%robhdr (NCM_LAT, index) = value
      case ('LON');  obsdat%robhdr (NCM_LON, index) = value
      case ('ALT');  obsdat%robhdr (NCM_ALT, index) = value
      case ('BX');   obsdat%robhdr (NCM_BX , index) = value
      case ('BY');   obsdat%robhdr (NCM_BY , index) = value
      case ('BZ');   obsdat%robhdr (NCM_BZ , index) = value

         ! real body values
      case ('PPP');  obsdat%robdata(NCM_PPP, index) = value
      case ('SEM');  obsdat%robdata(NCM_SEM, index) = value
      case ('POB');  obsdat%robdata(NCM_POB, index) = value
      case ('VAR');  obsdat%robdata(NCM_VAR, index) = value
      case ('OMP');  obsdat%robdata(NCM_OMP, index) = value
      case ('OMP6'); obsdat%robdata(NCM_OMP6,index) = value
      case ('OMF');  obsdat%robdata(NCM_OMF, index) = value
      case ('OMA');  obsdat%robdata(NCM_OMA, index) = value
      case ('OMI');  obsdat%robdata(NCM_OMI, index) = value
      case ('OMN');  obsdat%robdata(NCM_OMN, index) = value
      case ('OER');  obsdat%robdata(NCM_OER, index) = value
      case ('HPHT'); obsdat%robdata(NCM_HPHT,index) = value
      case ('PRM');  obsdat%robdata(NCM_PRM, index) = value
      case ('ZHA');  obsdat%robdata(NCM_ZHA, index) = value

      case default
         write(*,*)"ERROR:  ", name(1:4)," is not a real(",OBS_REAL, &
                   ") observation."
      end select
   end subroutine obs_set_r


   subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
      implicit none
      !
      ! object: Set to the indicated value the family for the indicated header,
      !         or else for the indicated body.

      type(struct_obs), intent(inout) :: obsdat
      character(len=*), intent(in)    :: Family_in
      integer,optional, intent(in)    :: headerIndex,bodyIndex

      integer          :: headerIndex2

      if(present(headerIndex)) then
         obsdat%cfamily(headerIndex)=Family_in
         if(headerIndex.eq.(obsdat%numheader+1)) then
            obsdat%numheader=obsdat%numheader+1
         endif
      elseif(present(bodyIndex)) then
         headerIndex2=obs_elem_i(obsdat,'OBS',bodyIndex)
         obsdat%cfamily(headerIndex2)=Family_in
         if(headerIndex2.eq.(obsdat%numheader+1)) then
            obsdat%numheader=obsdat%numheader+1
         endif
      else
         call obs_abort('OBS_SETFAMILY: Header or Body index must be specified!')
      endif

   end subroutine obs_setFamily


   subroutine obs_status(obsdat, obs_full, numstns_out, numobs_out, kulout)
      !func obs_status - obtain basic status of the observation object
      !
      !Author    . J.W. Blezius
      !
      !    PURPOSE:  returns the values of the object's status variables 
      !
      type (struct_obs), intent(in) :: obsdat
      logical, intent(out) :: obs_full
      integer, intent(out) :: numstns_out, numobs_out
      integer, intent(in)  :: kulout


      ! PLH   if ( obsdat%numheader .ge. nmxobs ) then
      ! PLH     if ( obsdat%numbody .ge. ndatamx .or. obsdat%numheader .ge. nmxobs ) then
      if (     obsdat%numbody   .ge. obsdat%numbody_max &
          .or. obsdat%numheader .ge. obsdat%numheader_max) then
         write(kulout,*) ' OBSDAT FILE FULL'
         obs_full = .true.

      else
         obs_full = .false.
      end if

      numstns_out = obsdat%numheader
      numobs_out  = obsdat%numbody
   end subroutine obs_status


   subroutine obs_swapVarOmf(obsdat)
      !
      ! object: exchange the values in the VAR and OMF columns.

      implicit none

      type(struct_obs), intent(inout) :: obsdat

      real(kind=OBS_REAL),allocatable :: temp_robdata(:)

      !    temp = NCM_VAR
      !    NCM_VAR = NCM_OMF
      !    NCM_OMF = temp

      allocate(temp_robdata(lbound(obsdat%robdata,2):ubound(obsdat%robdata,2)))
      temp_robdata(:)=obsdat%robdata(NCM_VAR,:)
      obsdat%robdata(NCM_VAR,:)=obsdat%robdata(NCM_OMF,:)
      obsdat%robdata(NCM_OMF,:)=temp_robdata(:)
      deallocate(temp_robdata)

   end subroutine obs_swapVarOmf


   subroutine obs_tosqlbdy(obsdat,kobs,kulout)
      !
      !s/r obs_tosqlbdybdy  - print all data records associated with a station
      !
      !authors  : Peter Houtekamer and Chantal Cote, July 2003. 
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for printing
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer,      intent(in) :: kobs,kulout

      integer :: idata,idata2,ihpht,ioer,ioma,iomp,iomp6,ipnt,ippp, &
         ivnm,ivnmc,istat,ivar,jdata,jtrans,var3d
      integer  :: mrbcol,mrbcvt
      real     :: rppp
      external :: mrbcol,mrbcvt

      ipnt  = obsdat%mobhdr(NCM_RLN,kobs)
      idata = obsdat%mobhdr(NCM_NLV,kobs)

      do jdata = ipnt, ipnt + idata - 1
         idata2 = jdata -ipnt + 1
         if (btest(obsdat%mobdata(NCM_FLG,jdata),12)) then
            var3d=1
         else
            var3d=0
         endif

         ippp=obsdat%robdata(NCM_PPP,jdata)
         rppp=float(ippp)

         ivnm=obsdat%mobdata(NCM_VNM,jdata)
         istat=mrbcol(ivnm,ivnmc,1)
         istat=mrbcvt(ivnmc,ivar,obsdat%robdata(NCM_VAR,jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,iomp,obsdat%robdata(NCM_OMP,jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,iomp6,obsdat%robdata(NCM_OMP6,jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ioma,obsdat%robdata(NCM_OMA,jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ioer,obsdat%robdata(NCM_OER,jdata),1,1,1,1)
         istat=mrbcvt(ivnmc,ihpht,obsdat%robdata(NCM_HPHT,jdata),1,1,1,1)
         jtrans=obsdat%mobdata(NCM_VCO,jdata)
         if (jtrans .eq. 1) then
            istat=mrbcol(7001,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         elseif (jtrans .eq. 2) then
            istat=mrbcol(7004,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         elseif (jtrans .eq. 3) then
            istat=mrbcol(2150,ivnmc,1)
            istat=mrbcvt(ivnmc,ippp,rppp,1,1,1,1)
         else 
            call obs_abort('OBS_TOSQLBDY: attention, mauvaise coordonnee verticale')
            ippp=-1
         endif

         write(kulout,fmt=9201) kobs,idata2, &
            obsdat%mobdata(NCM_VNM,jdata),ippp,obsdat%mobdata(NCM_ASS,jdata), &
            ivar,iomp,iomp6,ioma,ioer,ihpht,var3d,obsdat%robdata(NCM_ZHA,jdata),&
            obsdat%mobdata(NCM_VCO,jdata),obsdat%mobdata(NCM_FLG,jdata)
      enddo

9201  format(1x,i9,',',i3,2(',',i6),',',i3,6(',',i8), &
         ',',i2,',',f10.3,',',i2,',',i12)

      return
   end subroutine obs_tosqlbdy


   subroutine obs_tosqlhdr(obsdat,kobs,kulout)
      !
      !s/r obs_tosqlhdr  - printing of the header of a station record for sql
      !
      !author  : Peter Houtekamer and Chantal Cote, July 2003.
      !
      ! Revision July 2005 by Peter Houtekamer. Removed ncmblk from the OBSDAT.
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for output
      !
      implicit none

      type (struct_obs), intent(inout) :: obsdat
      integer, intent(in) :: kobs,kulout

      integer :: ialt,idburp,ii,ilon,ilat,iout,jtrans
      character(len=12) :: ccstnid
      real(8) :: torad 

      torad=4.d0*atan(1.d0)/180.d0

      ccstnid=obsdat%cstnid(kobs)

      ! Replace occasional appearance of "," by "b" in CCSTNID to avoid problem
      ! when converting this output to sqlite. - Xingxiu Deng, March 2009
      do
         iout=index(ccstnid,',')
         if (iout .gt. 0 ) then
            ccstnid(iout:iout)='b'
         else
            exit
         endif
      enddo

      ialt=obsdat%robhdr(NCM_ALT,kobs)+400
      ilon=nint((obsdat%robhdr(NCM_LON,kobs)/torad)*100)
      ilat=nint((obsdat%robhdr(NCM_LAT,kobs)/torad+90.0)*100)

      idburp=mod(obsdat%mobhdr(NCM_ITY,kobs),1000)
      write(kulout,fmt=9200) kobs,CCSTNID, &
         obsdat%mobhdr(NCM_DAT,kobs),obsdat%mobhdr(NCM_ETM,kobs), &
         obsdat%mobhdr(NCM_RLN,kobs), &
         obsdat%mobhdr(NCM_ONM,kobs),obsdat%mobhdr(NCM_INS,kobs), &
         obsdat%mobhdr(NCM_OTP,kobs),idburp,ilat,ilon,ialt, &
         obsdat%mobhdr(NCM_NLV,kobs),obsdat%mobhdr(NCM_OFL,kobs), &
         obsdat%mobhdr(NCM_PAS,kobs),obsdat%mobhdr(NCM_REG,kobs), &
         obsdat%mobhdr(NCM_IP,kobs)

9200  format(2x,i9,',',a9,',',i10,',',i8,',',i6,',',i6, &
         ',',i12,',',i6,4(',',i8),5(',',i6))

      return

   end subroutine obs_tosqlhdr


   subroutine obs_write(obsdat,hx, &
      nens,nobshdrout,nobsbdyout,nobshxout,nobsdimout)
      !
      ! author: Peter Houtekamer February 2011
      ! 
      ! object: 
      !   write the obsdat info to unformatted files
      !   note that the body information is written in the 
      !   order that it will be used by sekfeta.f
      !
      implicit none
      type(struct_obs), intent(inout) :: obsdat
      real(8),      intent(in), dimension(:,:) :: hx
      integer,      intent(in) :: nens,nobshdrout,nobsbdyout, &
         nobshxout,nobsdimout

      integer :: irobdata,jo,nrobdata

      irobdata=1
      do jo=1,obsdat%numheader
         call obs_write_hdr(obsdat,jo,nobshdrout,irobdata,nrobdata)
         call obs_write_bdy(obsdat,jo,nobsbdyout)
         if (nens.gt.0) then
            call obs_write_hx(obsdat,hx,jo,nobshxout)
         endif
         irobdata=irobdata+nrobdata
      enddo
      write(nobsdimout,*) obsdat%numheader
      write(nobsdimout,*) irobdata-1
      write(nobsdimout,*) nens

      return

   end subroutine obs_write


   subroutine obs_write_bdy(obsdat,kobs,kulout)
      !
      ! object  - write the data records associated with a
      !                 station in unformatted form.
      !
      !author  : P. Houtekamer  March 2000
      !
      !arguments
      !    input
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for writing 
      !
      implicit none 

      type(struct_obs), intent(inout) :: obsdat
      integer, intent(in) ::  kobs,kulout

      integer :: ipnt,idata,j,jdata,k


      ipnt  = obsdat%mobhdr(NCM_RLN,kobs) 
      idata = obsdat%mobhdr(NCM_NLV,kobs)

      ! write the data records
      do jdata=ipnt,ipnt+idata-1
         write(kulout) (obsdat%mobdata(k,jdata),k=1,NBDY_INT), &
            (obsdat%robdata(j,jdata),j=1,NBDY_REAL)
      enddo

      return

   end subroutine obs_write_bdy


   subroutine obs_write_hdr(obsdat,kobs,kulout,irobdata,nrobdata)
      !
      !object - writing of the header of a station record
      !
      !author  : Peter Houtekamer March 2000
      !
      !arguments
      !     i   kobs  : no. of observation
      !     i   kulout: unit used for output 
      !     i   irobdata: location in the sorted robdata
      !    output
      !     i   nrobdata: number of observations for this station
      !
      implicit none

      type(struct_obs), intent(inout) :: obsdat
      integer,      intent(in)  :: kobs,kulout,irobdata
      integer,      intent(out) :: nrobdata

      integer :: i,j

      ! (note that as a part of the writing the body is being sorted
      !  so that the order of the observations in the body array 
      !  corresponds with the order of the stations in the header array).

      nrobdata=obsdat%mobhdr(NCM_NLV,kobs)
      ! write the header's content 
      write(kulout) irobdata,(obsdat%mobhdr(i,kobs),i=2,NHDR_INT), &
         (obsdat%robhdr(j,kobs),j=1,NHDR_REAL),obsdat%cstnid(kobs)

      return

   end subroutine obs_write_hdr


   subroutine obs_write_hx(obsdat,hx,kobs,kulout)
      !
      ! object  - write the interpolated values associated with a
      !                 station in unformatted form.
      !
      !author  : P. Houtekamer and H. Mitchell May 2005
      !
      !arguments
      !    input
      !        hx    : interpolated values    
      !        kobs  : no. of station 
      !        kulout: unit used for writing 
      !
      implicit none 

      type(struct_obs), intent(inout) :: obsdat
      real(8), intent(in), dimension(:,:) :: hx
      integer, intent(in) :: kobs,kulout

      integer :: ipnt,idata,iens,j,jdata,k,nens

      nens = size(hx,1)

      ipnt  = obsdat%mobhdr(NCM_RLN,kobs) 
      idata = obsdat%mobhdr(NCM_NLV,kobs)

      ! write the data records
      do jdata=ipnt,ipnt+idata-1
         write(kulout) (hx(iens,jdata),iens=1,nens)
      enddo

      return

   end subroutine obs_write_hx

end module obsSpaceData_mod
