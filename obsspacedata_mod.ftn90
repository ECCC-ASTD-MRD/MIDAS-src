MODULE obsSpaceData_mod
  implicit none
  save
  private

  ! main observation space data instance
  public           :: obsSpaceData
  public           :: OBS_JPNBRELEM

  ! header column numbers
  public           :: NCM_LET, NCM_RLN, NCM_ONM, NCM_BOX, NCM_OTP, NCM_ITY,  &
                      NCM_LAT, NCM_LON, NCM_DAT, NCM_ETM, NCM_SID, NCM_ALT,  &
                      NCM_NLV, NCM_OEC, NCM_OFL, NCM_ST1, NCM_TLA, NCM_AZA,  &
                      NCM_SUN, NCM_CLF, NCM_REG, NCM_PAS, NCM_IP,  NCM_BX,   &
                      NCM_BY,  NCM_BZ

  ! body column numbers
  public           :: NCM_LBO, NCM_VNM, NCM_PPP, NCM_PRL, NCM_POB, NCM_VAR,  &
                      NCM_OMF, NCM_OMA, NCM_OMI, NCM_OMN, NCM_OER, NCM_RER,  &
                      NCM_FGE, NCM_PER, NCM_FLG, NCM_POS, NCM_LYR, NCM_ASS,  &
                      NCM_XTR, NCM_OBS, NCM_LOBS,NCM_VCO, NCM_PRM, NCM_KFA,  &
                      NCM_ZHA, NCM_HPHT,NCM_OMP

  ! subroutines
  public           :: obs_initialize
  public           :: obs_allocate,obs_deallocate,obs_allocateG,obs_deallocateG
  public           :: obs_elem_i,obs_elem_r4,obs_elem_r8,obs_elem_c9,obs_set
  public           :: obs_num_obstotal,obs_num_stn,obs_swapVarOmf,obs_ifind
  public           :: obs_getFamily,obs_setFamily,obs_bdy
  public           :: obs_reduceToMpiLocal,obs_expandToMpiGlobal

  ! derived type and module variable declarations

 type struct_obs
  character(len=9),  pointer, dimension(:)   :: cstnid   !! need len=12 for EnKF
  character(len=2),  pointer, dimension(:)   :: cfamily
  real(kind=4),      pointer, dimension(:,:) :: robhdr
  integer,           pointer, dimension(:,:) :: mobhdr
  real(kind=4),      pointer, dimension(:,:) :: robdata
  real(kind=8),      pointer, dimension(:,:) :: robdata8
  integer,           pointer, dimension(:,:) :: mobdata
  integer :: numstns_recorded           ! Actual number of stations on record
  integer :: mxstntotal                 ! maximum number of stations
  integer :: numobs_recorded            ! Actual total number of data on record
  integer :: mxobstotal                 ! maximum number observations
! Added for 3dvar
  integer                                    :: numobs_recorded_l
  integer,           pointer, dimension(:,:) :: mobhdr_g
  real(kind=4),      pointer, dimension(:,:) :: robhdr_g
  end type struct_obs

  type(struct_obs) :: obsSpaceData

  ! header column numbers
  integer,parameter :: NCM_LET = 22 ! Dimension for var3d
  integer,parameter :: NCM_RLN = 1
  integer,parameter :: NCM_ONM = 2
  integer,parameter :: NCM_BOX = 3
  integer,parameter :: NCM_OTP = 4
  integer,parameter :: NCM_ITY = 5
  integer,parameter :: NCM_LAT = 6
  integer,parameter :: NCM_LON = 7
  integer,parameter :: NCM_DAT = 8
  integer,parameter :: NCM_ETM = 9
  integer,parameter :: NCM_SID = 10
  integer,parameter :: NCM_ALT = 11
  integer,parameter :: NCM_NLV = 12
  integer,parameter :: NCM_OEC = 13
  integer,parameter :: NCM_OFL = 14
  integer,parameter :: NCM_ST1 = 15
  integer,parameter :: NCM_TLA = 16
  integer,parameter :: NCM_AZA = 20
  integer,parameter :: NCM_SUN = 21
  integer,parameter :: NCM_CLF = 22
! integer,parameter :: NCM_STID=    ! Not needed since only 1 cstnid exists
! integer,parameter :: NCM_FAM =    ! Not needed since only 1 cfamily exists
! These values are used only by EnKF, and not by var3d
  integer,parameter :: NCM_REG = 23
  integer,parameter :: NCM_PAS = 24
  integer,parameter :: NCM_IP  = 25
  integer,parameter :: NCM_BX  = 26
  integer,parameter :: NCM_BY  = 27
  integer,parameter :: NCM_BZ  = 28

  ! body column numbers
  integer,parameter :: NCM_LBO = 22
  integer,parameter :: NCM_VNM = 1
  integer,parameter :: NCM_POB = 2
  integer,parameter :: NCM_PRL = 3
  integer,parameter :: NCM_PPP = 4
  integer,parameter :: NCM_VAR = 5
  integer,parameter :: NCM_OMF = 6
  integer,parameter :: NCM_OMA = 7
  integer,parameter :: NCM_OMI = 8
  integer,parameter :: NCM_OMN = 9
  integer,parameter :: NCM_OER = 10
  integer,parameter :: NCM_PRM = 11
  integer,parameter :: NCM_RER = 12
  integer,parameter :: NCM_FGE = 13
  integer,parameter :: NCM_PER = 14
  integer,parameter :: NCM_FLG = 15
  integer,parameter :: NCM_POS = 16
  integer,parameter :: NCM_LYR = 17
  integer,parameter :: NCM_ASS = 18
  integer,parameter :: NCM_XTR = 19
  integer,parameter :: NCM_OBS = 20
  integer,parameter :: NCM_LOBS= 21
  integer,parameter :: NCM_VCO = 22
! added for EnKF
  integer,parameter :: NCM_KFA = 23
  integer,parameter :: NCM_ZHA = 24
  integer,parameter :: NCM_HPHT= 26
  integer,parameter :: NCM_OMP = 25

  integer, parameter :: OBS_JPNBRELEM = 57

  integer, parameter :: ROBDATA8_LOWER = NCM_POB
  integer, parameter :: ROBDATA8_UPPER = NCM_PER

  contains


  subroutine obs_initialize(obsdat)
    implicit none

    type(struct_obs), intent(out) :: obsdat

    obsdat%numstns_recorded = 0
    obsdat%numobs_recorded  = 0
    return
  end subroutine obs_initialize


  subroutine obs_allocate(obsdat,maxNumHdr,maxNumBdy)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)  :: maxNumHdr,maxNumBdy

    integer :: ierr

! TBD - JWB:  this initialization causes var3d to crash
!    obsdat%mxstntotal=maxNumHdr
!    obsdat%mxobstotal=maxNumBdy
!    obsdat%numstns_recorded=0
!    obsdat%numobs_recorded=0

    ALLOCATE(obsdat%cfamily(maxNumHdr),STAT=ierr)
    obsdat%cfamily(:)='XX'

    ALLOCATE(obsdat%cstnid(maxNumHdr),STAT=ierr)
    obsdat%cstnid(:)='XXXXXXXXX' !! // 'XXX'   needed for EnKF

    ALLOCATE(obsdat%ROBHDR(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%ROBHDR=0.0

    ALLOCATE(obsdat%MOBHDR(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%MOBHDR=0

    ALLOCATE(obsdat%ROBDATA(NCM_LBO,maxNumBdy),STAT=ierr)
    obsdat%ROBDATA=0.0

    ALLOCATE(obsdat%ROBDATA8(ROBDATA8_LOWER:ROBDATA8_UPPER,maxNumBdy),STAT=ierr)
    obsdat%ROBDATA8=0.0D0

    ALLOCATE(obsdat%MOBDATA(NCM_LBO,maxNumBdy),STAT=ierr)
    obsdat%MOBDATA=0

  end subroutine obs_allocate

  subroutine obs_allocateG(obsdat,maxNumHdr)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)    :: maxNumHdr

    integer :: ierr

    ALLOCATE(obsdat%ROBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%ROBHDR_g=0.0

    ALLOCATE(obsdat%MOBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%MOBHDR_g=0

  end subroutine obs_allocateG


  subroutine obs_deallocateG(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    deallocate(obsdat%robhdr_g,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'ROBHDR_g checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in ROBHDR_g. IERR =',ierr
    endif

    deallocate(obsdat%mobhdr_g,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'MOBHDR_g checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in MOBHDR_g. IERR =',ierr
    endif

  end subroutine obs_deallocateG


  subroutine obs_deallocate(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    deallocate(obsdat%cfamily,STAT=ierr)
    if(ierr.eq.0) then
      write(*,*) 'CFAMILY checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in CFAMILY. IERR =',ierr
    endif

    deallocate(obsdat%cstnid,STAT=ierr)
    if(ierr.eq.0) then
      write(*,*) 'CSTNID checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in CSTNID. IERR =',ierr
    endif

    deallocate(obsdat%robhdr,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'ROBHDR checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in ROBHDR. IERR =',ierr
    endif

    deallocate(obsdat%mobhdr,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'MOBHDR checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in MOBHDR. IERR =',ierr
    endif

    deallocate(obsdat%robdata,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'ROBDATA checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in ROBDATA. IERR =',ierr
    endif

    deallocate(obsdat%robdata8,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'ROBDATA8 checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in ROBDATA8. IERR =',ierr
    endif

    deallocate(obsdat%mobdata,stat=ierr)
    if(ierr.eq.0) then
      write(*,*) 'MOBDATA checked and correct. IERR =',ierr
    else
      write(*,*) 'Problem detected in MOBDATA. IERR =',ierr
    endif

  end subroutine obs_deallocate


  subroutine obs_swapVarOmf(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    real(kind=4),allocatable :: temp_robdata(:)
    real(kind=8),allocatable :: temp_robdata8(:)
    integer                  :: ierr

!    temp = NCM_VAR
!    NCM_VAR = NCM_OMF
!    NCM_OMF = temp

    allocate(temp_robdata (lbound(obsdat%robdata ,2):ubound(obsdat%robdata ,2)),stat=ierr)
    temp_robdata(:)=obsdat%robdata(NCM_VAR,:)
    obsdat%robdata(NCM_VAR,:)=obsdat%robdata(NCM_OMF,:)
    obsdat%robdata(NCM_OMF,:)=temp_robdata(:)
    deallocate(temp_robdata)

    allocate(temp_robdata8(lbound(obsdat%robdata8,2):ubound(obsdat%robdata8,2)),stat=ierr)
    temp_robdata8(:)=obsdat%robdata8(NCM_VAR,:)
    obsdat%robdata8(NCM_VAR,:)=obsdat%robdata8(NCM_OMF,:)
    obsdat%robdata8(NCM_OMF,:)=temp_robdata8(:)
    deallocate(temp_robdata8)

  end subroutine obs_swapVarOmf


  function obs_getFamily(obsdat,headerIndex,bodyIndex)
    implicit none

    character(len=2)             :: obs_getFamily
    type(struct_obs), intent(in) :: obsdat
    integer,optional, intent(in) :: headerIndex,bodyIndex

    integer          :: headerIndex2

    if(present(headerIndex)) then
      obs_getFamily=obsdat%cfamily(headerIndex)
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obs_getFamily=obsdat%cfamily(headerIndex2)
    else
      write(*,*) 'OBS_GETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call exit(-1)
    endif

  end function obs_getFamily


  subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    character(len=2), intent(in)    :: Family_in
    integer,optional, intent(in)    :: headerIndex,bodyIndex

    integer          :: headerIndex2
    
    if(present(headerIndex)) then
      obsdat%cfamily(headerIndex)=Family_in
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obsdat%cfamily(headerIndex2)=Family_in
    else
      write(*,*) 'OBS_SETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call exit(-1)
    endif

  end subroutine obs_setFamily


  SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                    LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                    n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                    KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                    vconv,nonelev)
    IMPLICIT NONE
!
    type(struct_obs), intent(inout) :: obsdat
    INTEGER, intent(out) :: KNDAT
    INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
    INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
    INTEGER, intent(in)  :: KLIST(n_elements_in_block)
    INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
    integer, intent(in)  :: nvcordtyp,nonelev
!
    REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
    REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
    REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
    REAL(kind=8),intent(in)::PPMIS
    real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
    real(kind=8),intent(in)::vcordsf(:,:)
!
    LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI
!
#if defined (DOC)
!***********************************************************************
!
!***s/r OBS_BDY -FILL BODY OF CMA REPORT
!
!Author    . P. KOCLAS(CMC TEL. 4665)
!
!Revision:
!          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
!          .   before insertion of U and V for consistency
!          . P. Koclas *CMC/AES February  1995:
!          .  New call sequence neccessary to :
!          . -allow insertion of "grouped data" records in BURP files.
!          . -allow data observed in various vertical coordinates
!          . -observation errors no longer initialized
!
!          . P. Koclas *CMC/AES March     1995:
!            -Additions for humsat and satem data
!          .
!          . C. Charette *ARMA Jan        2001
!            -Max value for T-Td surface element(12203)
!
!           JM Belanger CMDA/SMC  Feb 2001
!                   . 32 bits conversion
!          . P. Koclas *CMC/CMDA Sept     2001:
!            -set first-guess and observation errors to missing values
!
!          .N Wagneur CMDA/SMC  Jine 2002
!                   . -Additions for goes data
!          . P. Koclas *CMC/CMDA Dec      2003:
!                -conversion for surface wind
!          . C. Charette *ARMA/SMC Apr      2005:
!                -Set flag bit #12 (Element assimilated by analysis) to zero
!                 (see banco-burp documentation for more detail)
!          . A. Beaulne *CMDA/SMC  Aug 2006
!                     -Additions for AIRS data
!          . S. Heilliette
!                     -Additions for IASI data
!
!
!    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
!              THE IN-CORE FORMAT (CMA) OF THE 3-D VARIATIONAL ANALYSIS
!
!    ARGUMENTS:
!     INPUT:
!
!           -PVALUES : DATA BLOCK
!           -KLIST   : LIST OF BUFR ELEMENTS
!           -KFLAGS  : QUALITY CONTROL FLAGS
!
!           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN CMA
!                      .FALSE. --> INSERT DUMMY VALUE(2**12)
!           -LERR    :  .TRUE. --> INSERT OBS ERROR IN CMA (HUMSAT DATA)
!           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN CMA (SATEMS)
!           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN CMA (GOES RADIANCES)
!           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (AIRS RADIANCES)
!           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (IASI RADIANCES)
!
!           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
!           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
!           -KNT     :  THIRD DIMENSION OF DATA BLOCK
!           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
!           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
!           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
!           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
!           -PPMIS   :  VALUE OF MISSING DATA
!           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
!
!    OUTPUT:
!           -KNDAT   : NUMBER OF DATA INSERTED IN CMA FILE
!
!***********************************************************************
#endif

#include "comcst.cdk"

    INTEGER ILEM,IND,IIND,IP,IK
    INTEGER IBAD,IFLAG
    INTEGER ielement,ilevel
    INTEGER ZESMAX,ZES
!
    REAL(kind=8) ZTORAD,ZFACT,padd,pmul,ZEMFACT,pvalue
!
!***********************************************************************
!     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
!***********************************************************************
!
    IIND  =-1
    IBAD=2**11
    ZTORAD=RPI/180.
!
    ZFACT=VCONV
!
    ZEMFACT=0.01
    ZESMAX=30.
!
    IP=obsdat%numobs_recorded + 1
    IND=0
!
!***********************************************************************
!     PUT ALL NON MISSING DATA IN CMA FILE
!     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO CMA FILE
!     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
!***********************************************************************
!
    IK= KINDEX
       DO ielement=1,n_elements_in_block
          ILEM=obs_ifind(KLIST(ielement))
          IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
             DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                    nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                      IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                         pvalue=PVALUES(ielement,ilevel,IK)
                         IF ( IP + IND .LE. obsdat%mxobstotal ) THEN
!                                       VERTICAL COORDINATE
                            obsdat%robdata8(NCM_PPP,IP+IND)=PVCORD(ilevel)*ZFACT +vcordsf(ilem,kidtyp)
!
!                           FOR PNM HEIGHT IS SET TO 0
!                           ----------------------------
                            IF ( ILEM .EQ. 53 ) THEN
                               obsdat%robdata8(NCM_PPP,IP+IND)=0.D0
                            ENDIF
!                           ----------------------------
!
!                           IF ( ILEM .EQ. 2 ) Units:  V
!                                        CONVERT TO GZ
                            IF ( ILEM .EQ. 3 ) THEN
                             pvalue=RG*pvalue
                            ENDIF
!                           IF ( ILEM .EQ. 4 ) Units: METERS
!                           IF ( ILEM .EQ. 8 ) Units:  CELSIUS
!                                  Max value T-Td upper air
                            IF ( ILEM .EQ. 9 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    Max value T-Td surface
                            IF ( ILEM .EQ. 11 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    CONVERT TO RADIANS
                            IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                             pvalue=ZTORAD*pvalue
                            ENDIF
!                                       FLAGS
                            IF  (LDFLAG) THEN
!                                 SET BIT 12  TO ZERO
!                                 (Element assim by 3dvar)
                               IFLAG = KFLAGS(ielement,ilevel,IK)
                               IFLAG = IBCLR(IFLAG,12)
                               obsdat%mobdata(NCM_FLG,IP+IND)= IFLAG
                            ELSE
                               obsdat%mobdata(NCM_FLG,IP+IND)= IBAD
                            ENDIF
!
                            obsdat%robdata8(NCM_VAR,IP+IND)=pvalue
                            obsdat%mobdata (NCM_VNM,IP+IND)=KLIST(ielement)
                            obsdat%mobdata (NCM_VCO,IP+IND)=NVCORDTYP
                            obsdat%robdata8(NCM_OMF,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMA,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMI,IP+IND)=PPMIS
                            obsdat%robdata (NCM_FGE,IP+IND)=real(PPMIS)
                            obsdat%robdata8(NCM_OER,IP+IND)=PPMIS
!
!                           OBS ERROR FOR HUMSAT
!
                            IF ( LDERR ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)
                            ENDIF
!
!                           REFERENCE LEVEL FOR SATEMS
!
                            IF ( LDSAT ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)*ZFACT
                              obsdat%robdata8(NCM_OER,IP+IND)=1.0D0
                            ENDIF
!
!                           SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
!
                            IF ( LDGO ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            ENDIF

                            IF ( LDAIRS ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            END IF

                            IF ( LDIASI ) THEN
                               obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                    *ZEMFACT
                            END IF

!
                            IND=IND + 1
                         ELSE
!==================================================
                            KNDAT = IND
                            obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!==================================================
                            RETURN
                         ENDIF
                      ENDIF
                ENDIF
             END DO
          ENDIF
       END DO
!=============================
    KNDAT = IND
    obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!=============================
!
    RETURN
!
  END SUBROUTINE obs_bdy


 real(kind=4) function obs_elem_r4(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr(NCM_BZ , index)

  case ('PPP '); value=obsdat%robdata(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata(NCM_PRL, index)
  case ('VAR '); value=obsdat%robdata(NCM_VAR, index)
  case ('OMP '); value=obsdat%robdata(NCM_OMP, index)
  case ('OMA '); value=obsdat%robdata(NCM_OMA, index)
  case ('OER '); value=obsdat%robdata(NCM_OER, index)
  case ('HPHT'); value=obsdat%robdata(NCM_HPHT,index)
  case ('ZHA '); value=obsdat%robdata(NCM_ZHA, index)
  ! Added for var3d
  case ('POB '); value=obsdat%robdata(NCM_POB, index)
  case ('OMF '); value=obsdat%robdata(NCM_OMF, index)
  case ('OMI '); value=obsdat%robdata(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata(NCM_OMN, index)
  case ('RER '); value=obsdat%robdata(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata(NCM_PRM, index)

  case default
   write(6,*)"ERROR:  ", name(1:4), " is not a real(4) observation."
   value=-999.
  end select
 end function obs_elem_r4

 real(kind=8) function obs_elem_r8(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  ! Added for var3d
  case ('PPP '); value=obsdat%robdata8(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata8(NCM_PRL, index)
  case ('POB '); value=obsdat%robdata8(NCM_POB, index)
  case ('VAR '); value=obsdat%robdata8(NCM_VAR, index)
  case ('OMF '); value=obsdat%robdata8(NCM_OMF, index)
  case ('OMA '); value=obsdat%robdata8(NCM_OMA, index)
  case ('OMI '); value=obsdat%robdata8(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata8(NCM_OMN, index)
  case ('OER '); value=obsdat%robdata8(NCM_OER, index)
  case ('RER '); value=obsdat%robdata8(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata8(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata8(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata8(NCM_PRM, index)

  case default
   write(6,*)"ERROR:  ", name(1:4), " is not a real(8) observation."
   value=-999
  end select
 end function obs_elem_r8

 integer function obs_elem_i(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr(NCM_CLF, index)
  ! Added for var3d
  case ('SID '); value=obsdat%mobhdr(NCM_SID, index)
  case ('OEC '); value=obsdat%mobhdr(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr(NCM_TLA, index)

  case ('VNM '); value=obsdat%mobdata(NCM_VNM, index)
  case ('FLG '); value=obsdat%mobdata(NCM_FLG, index)
  case ('KFA '); value=obsdat%mobdata(NCM_KFA, index)
  case ('ASS '); value=obsdat%mobdata(NCM_ASS, index)
  case ('OBS '); value=obsdat%mobdata(NCM_OBS, index)
  case ('VCO '); value=obsdat%mobdata(NCM_VCO, index)
  ! Added for var3d
  case ('LBO '); value=obsdat%mobdata(NCM_LBO, index)
  case ('POS '); value=obsdat%mobdata(NCM_POS, index)
  case ('XTR '); value=obsdat%mobdata(NCM_XTR, index)
  case ('LOBS'); value=obsdat%mobdata(NCM_LOBS,index)
  case ('LYR '); value=obsdat%mobdata(NCM_LYR, index)

  case default
   write(6,*)"ERROR:  ", name(1:4)," is not an integer observation."
   value=-999
  end select
 end function obs_elem_i


 function obs_elem_c9(obsdat,name,index) result(value)
  implicit none

  character(len=9) :: value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('STID'); value=obsdat%cstnid(index)

  case default
   write(6,*)"ERROR:  ", name(1:4)," is not character(len=9) observation."
   value='xxxxxxxxx'
  end select
 end function obs_elem_c9


 integer function obs_num_obstotal(obsdat)
!func obs_num_obstotal - returns the number of observations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of observations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_obstotal=obsdat%numobs_recorded
 end function obs_num_obstotal


 integer function obs_num_stn(obsdat)
!func obs_num_stn - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_stn=obsdat%numstns_recorded
 end function obs_num_stn


 subroutine obs_set(obsdat, index, &
                    val_RLN, val_ONM, val_BOX, val_OTP, val_ITY, &
                    val_DAT, val_ETM, val_NLV, val_OFL, val_PAS, &
                    val_REG, val_IP,  val_AZA, val_SUN, val_CLF, &
                    val_LAT, val_LON, val_ALT, val_BX,  val_BY,  &
                    val_BZ,  val_VNM, val_FLG, val_KFA, val_ASS, &
                    val_OBS, val_VCO, val_PPP, val_PRL, val_VAR, &
                    val_OMP, val_OMA, val_OER, val_HPHT,val_ZHA, &
                    val_SID, val_OEC, val_ST1, val_TLA, val_LBO, &
                    val_POB, val_OMF, val_OMI, val_OMN, val_RER, &
                    val_FGE, val_PER, val_POS, val_LYR, val_XTR, &
                    val_LOBS,val_PRM, val_PPP8,val_PRL8,val_POB8,&
                    val_VAR8,val_OMF8,val_OMA8,val_OMI8,val_OMN8,&
                    val_OER8,val_RER8,val_FGE8,val_PER8,val_PRM8,&
                    val_STID &
                   )
!s/r obs_set - set one or more values in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs) , intent(inout)  :: obsdat
  integer, intent(in) :: index
  integer,      intent(in), optional :: val_RLN, val_ONM, val_BOX, val_OTP, &
                                        val_ITY, val_DAT, val_ETM, val_NLV, &
                                        val_OFL, val_PAS, val_REG, val_IP,  &
                                        val_AZA, val_SUN, val_CLF, val_VNM, &
                                        val_FLG, val_KFA, val_ASS, val_OBS, &
                                        val_VCO, val_SID, val_OEC, val_ST1, &
                                        val_TLA, val_LBO, val_POS, val_LYR, &
                                        val_XTR, val_LOBS
  real(kind=4), intent(in), optional :: val_LAT, val_LON, val_ALT, val_BX,  &
                                        val_BY,  val_BZ,  val_PPP, val_PRL, &
                                        val_VAR, val_OMP, val_OMA, val_OER, &
                                        val_HPHT,val_ZHA, val_POB, val_OMF, &
                                        val_OMI, val_OMN, val_RER, val_FGE, &
                                        val_PER, val_PRM
  real(kind=8), intent(in), optional :: val_PPP8,val_PRL8,val_POB8,val_VAR8,&
                                        val_OMF8,val_OMA8,val_OMI8,val_OMN8,&
                                        val_OER8,val_RER8,val_FGE8,val_PER8,&
                                        val_PRM8
  character(len=9), intent(in), optional :: val_STID

  ! integer header values
  if(present(val_RLN)) obsdat%mobhdr (NCM_RLN, index) = val_RLN
  if(present(val_ONM)) obsdat%mobhdr (NCM_ONM, index) = val_ONM
  if(present(val_BOX)) obsdat%mobhdr (NCM_BOX, index) = val_BOX
  if(present(val_OTP)) obsdat%mobhdr (NCM_OTP, index) = val_OTP
  if(present(val_ITY)) obsdat%mobhdr (NCM_ITY, index) = val_ITY
  if(present(val_DAT)) obsdat%mobhdr (NCM_DAT, index) = val_DAT
  if(present(val_ETM)) obsdat%mobhdr (NCM_ETM, index) = val_ETM
  if(present(val_NLV)) obsdat%mobhdr (NCM_NLV, index) = val_NLV
  if(present(val_OFL)) obsdat%mobhdr (NCM_OFL, index) = val_OFL
  if(present(val_PAS)) obsdat%mobhdr (NCM_PAS, index) = val_PAS
  if(present(val_REG)) obsdat%mobhdr (NCM_REG, index) = val_REG
  if(present(val_IP )) obsdat%mobhdr (NCM_IP , index) = val_IP
  if(present(val_AZA)) obsdat%mobhdr (NCM_AZA, index) = val_AZA
  if(present(val_SUN)) obsdat%mobhdr (NCM_SUN, index) = val_SUN
  if(present(val_CLF)) obsdat%mobhdr (NCM_CLF, index) = val_CLF
  if(present(val_STID))obsdat%cstnid (         index) = val_STID !! // '   '
  ! Added for var3d
  if(present(val_SID)) obsdat%mobhdr (NCM_SID, index) = val_SID
  if(present(val_OEC)) obsdat%mobhdr (NCM_OEC, index) = val_OEC
  if(present(val_ST1)) obsdat%mobhdr (NCM_ST1, index) = val_ST1
  if(present(val_TLA)) obsdat%mobhdr (NCM_TLA, index) = val_TLA

  ! single-precision header values
  if(present(val_LAT)) obsdat%robhdr (NCM_LAT, index) = val_LAT
  if(present(val_LON)) obsdat%robhdr (NCM_LON, index) = val_LON
  if(present(val_ALT)) obsdat%robhdr (NCM_ALT, index) = val_ALT
  if(present(val_BX )) obsdat%robhdr (NCM_BX , index) = val_BX
  if(present(val_BY )) obsdat%robhdr (NCM_BY , index) = val_BY
  if(present(val_BZ )) obsdat%robhdr (NCM_BZ , index) = val_BZ

  ! integer body values
  if(present(val_VNM)) obsdat%mobdata(NCM_VNM, index) = val_VNM
  if(present(val_FLG)) obsdat%mobdata(NCM_FLG, index) = val_FLG
  if(present(val_KFA)) obsdat%mobdata(NCM_KFA, index) = val_KFA
  if(present(val_ASS)) obsdat%mobdata(NCM_ASS, index) = val_ASS
  if(present(val_OBS)) obsdat%mobdata(NCM_OBS, index) = val_OBS
  if(present(val_VCO)) obsdat%mobdata(NCM_VCO, index) = val_VCO
  if(present(val_LBO)) obsdat%mobdata(NCM_LBO, index) = val_LBO
  if(present(val_POS)) obsdat%mobdata(NCM_POS, index) = val_POS
  if(present(val_LYR)) obsdat%mobdata(NCM_LYR, index) = val_LYR
  if(present(val_XTR)) obsdat%mobdata(NCM_XTR, index) = val_XTR
  if(present(val_LOBS))obsdat%mobdata(NCM_LOBS,index) = val_LOBS

  ! single-precision body values
  if(present(val_PPP)) obsdat%robdata(NCM_PPP, index) = val_PPP
  if(present(val_PRL)) obsdat%robdata(NCM_PRL, index) = val_PRL
  if(present(val_VAR)) obsdat%robdata(NCM_VAR, index) = val_VAR
  if(present(val_OMP)) obsdat%robdata(NCM_OMP, index) = val_OMP
  if(present(val_OMA)) obsdat%robdata(NCM_OMA, index) = val_OMA
  if(present(val_OER)) obsdat%robdata(NCM_OER, index) = val_OER
  if(present(val_HPHT))obsdat%robdata(NCM_HPHT,index) = val_HPHT
  if(present(val_ZHA)) obsdat%robdata(NCM_ZHA, index) = val_ZHA
  if(present(val_POB)) obsdat%robdata(NCM_POB, index) = val_POB
  if(present(val_OMF)) obsdat%robdata(NCM_OMF, index) = val_OMF
  if(present(val_OMI)) obsdat%robdata(NCM_OMI, index) = val_OMI
  if(present(val_OMN)) obsdat%robdata(NCM_OMN, index) = val_OMN
  if(present(val_RER)) obsdat%robdata(NCM_RER, index) = val_RER
  if(present(val_FGE)) obsdat%robdata(NCM_FGE, index) = val_FGE
  if(present(val_PER)) obsdat%robdata(NCM_PER, index) = val_PER
  if(present(val_PRM)) obsdat%robdata(NCM_PRM, index) = val_PRM

  ! double-precision body values
  if(present(val_PPP8)) obsdat%robdata8(NCM_PPP, index) = val_PPP8
  if(present(val_PRL8)) obsdat%robdata8(NCM_PRL, index) = val_PRL8
  if(present(val_POB8)) obsdat%robdata8(NCM_POB, index) = val_POB8
  if(present(val_VAR8)) obsdat%robdata8(NCM_VAR, index) = val_VAR8
  if(present(val_OMF8)) obsdat%robdata8(NCM_OMF, index) = val_OMF8
  if(present(val_OMA8)) obsdat%robdata8(NCM_OMA, index) = val_OMA8
  if(present(val_OMI8)) obsdat%robdata8(NCM_OMI, index) = val_OMI8
  if(present(val_OMN8)) obsdat%robdata8(NCM_OMN, index) = val_OMN8
  if(present(val_OER8)) obsdat%robdata8(NCM_OER, index) = val_OER8
  if(present(val_RER8)) obsdat%robdata8(NCM_RER, index) = val_RER8
  if(present(val_FGE8)) obsdat%robdata8(NCM_FGE, index) = val_FGE8
  if(present(val_PER8)) obsdat%robdata8(NCM_PER, index) = val_PER8
  if(present(val_PRM8)) obsdat%robdata8(NCM_PRM, index) = val_PRM8
 end subroutine obs_set


 integer function obs_ifind(kbufrn)
  implicit none
!
  integer, intent(in) :: kbufrn
!
!      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
!               THAT CONTAINS A BUFR ELEMENT NUMBER
!
!    ARGUMENTS:
!               INPUT:
!                      -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
!                               i.e. known locally as the 'burp variable type'
!                               i.e. table B of the ECMWF BUFR reference
!                               BUFR = Binary Universal Form for the
!                                      Representation of meteorological data
!
!               OUTPUT:
!                      - obs_ifind:
!                                              THE FOUND INDEX (=-1 IF NOT FOUND)
!
!       AUTHOR: P. KOCLAS (CMC TEL. 4665)

  integer indbuf
  integer, parameter, dimension(OBS_JPNBRELEM) :: nvnumb = (/ &
    011003, 011004, 010194, 010192,     29, & !  1-10
    013208, 012063, 012001, 012192, 012004, &
    012203, 011215, 011216, 013210, 013220, & ! 11-20
        62, 015001,     64,     65, 015036, &
    015031, 015032,     69,     70,     71, & ! 21-30
        72,     73,     74,     75,     76, &
        77,     78,     79,     80,     81, & ! 31-40
        82,     83,     84,     85,     86, &
        87,     88,     89,     90,     91, & ! 41-50
    012163, 010004, 011001, 011002, 012062, &
    008001, 008004, 010051, 011011, 011012, & ! 51-57
        41,     42 /)


! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
!   Descriptions taken from 3d variational code (March 2011, revision 11.0.2)
!
!  1 =011003 (U COMPONENT)           (m/s)
!  2 =011004 (V COMPONENT)           (m/s)
!  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
!  4 =010192 (THICKNESS IN M)
!  5 =    29 (RELATIVE HUMIDITY)
!  6 =013208
!  7 =012063 BRIGHTNESS TEMPERATURE 1
!  8 =012001 (TEMPERATURE)            (kelvin)
!  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
! 10 =012004 (2M TEMPERATURE)
! 11 =012203 (2M DEW-POINT DEPRESSION)
! 12 =011215 SURFACE U     WIND COMPONENT M/S)
! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
! 16 =007006 HEIGHT ABOVE STATION (M)
! 17 =015001 (Total Ozone from TOVS)
! 18 =    64 (CM)
! 19 =    65 (CL)
! 20 =015036 (GPSRO REFRACTIVITY)
! 21 =015031 (GPSGB ZTD IN M)
! 22 =015032 (GPSGB ZTD ERROR IN M)
! 23 =    69 (C)
! 24 =    70 (NS)
! 25 =    71 (S)
! 26 =    72 (E)
! 27 =    73 (TGTG)
! 28 =    74 (SPSP)
! 29 =    75 (SPSP)
! 30 =    76 (RS)
! 31 =    77 (ESES)
! 32 =    78 (IS)
! 33 =    79 (TRTR)
! 34 =    80 (RR)
! 35 =    81 (JJ)
! 36 =    82 (VS)
! 37 =    83 (DS)
! 38 =    84 (HWHW)
! 39 =    85 (PWPW)
! 40 =    86 (DWDW)
! 41 =    87 (GENERAL CLOUD GROUP)
! 42 =    88 (RH FROM LOW CLOUDS)
! 43 =    89 (RH FROM MIDDLE CLOUDS)
! 44 =    90 (RH FROM HIGH CLOUDS)
! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
! 46 =012163 (TOVS LEVEL 1B RADIANCES)
! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
! 49 =011002(FF (WIND SPEED))                (m/s)
! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
! 51 =008001
! 52 =008004
! 53 =010051
! 54 =011011
! 55 =011012
! 56 =    41 (U AT 10M)
! 57 =    42 (V AT 10M)

  obs_ifind=-1
  do indbuf=1,OBS_JPNBRELEM
   if (nvnumb(indbuf) .EQ. kbufrn ) then
    obs_ifind=indbuf
    return
   endif
  enddo
  return

 end function obs_ifind


 SUBROUTINE obs_reduceToMpiLocal(obsdat, nobtot, nobtotp, nfiles, &
                                 nbegintyp, nendtyp, nbegintyp_g, nendtyp_g)
#if defined (DOC)
!
!**s/r obs_reduceToMpiLocal - re-construct observation data object by giving 
!                             local Obs TAG. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To retain in the observation object only those data that are
!                pertinent to the present mpi processor.
!
!
#endif

  USE mod4dv, only : l4dvar 
  USE obstag  
  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(inout) :: nobtot      ! Actual number of observations
  integer, intent(inout) :: nobtotp     ! Actual no. of obs. in POST FILE=nobtot
  integer, intent(in)    :: nfiles
  integer, intent(inout) :: nbegintyp(:), nendtyp(:)
  integer, intent  (out) :: nbegintyp_g(:), nendtyp_g(:)

! Declare Local Variables. 
  CHARACTER(len=9),ALLOCATABLE,DIMENSION(:) :: cstnid_tmp
  CHARACTER(len=2),ALLOCATABLE,DIMENSION(:) :: cfamily_tmp
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBHDR_tmp,ROBDATA_tmp
  REAL(8),ALLOCATABLE,DIMENSION(:,:) :: ROBDATA8_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp,MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:) :: locObsTag_tmp 
  
!     Declaire local variables. 
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,ifamid,istart,idata,ii 
  LOGICAL :: lfirst 
!!---------------------------------------------------------------
  WRITE(*,*) '============= Enter reBuildCMA =============='
  locObsize=size(locObsTag) 

  ALLOCATE(cfamily_tmp(locObsize),STAT=ierr) 
  ALLOCATE(cstnid_tmp(locObsize),STAT=ierr) 
  ALLOCATE(ROBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA8_tmp(3:11,obsdat%numobs_recorded_l),STAT=ierr) 
!  
  call obs_allocateG(obsdat,nobtot)
!
!0.1  Sorting locObsTag according to the family ID. 
  IF(l4dvar) THEN
     ALLOCATE(locObsTag_tmp(locObsize),STAT=ierr) 
     ALLOCATE(ObsTagLoc(nobtot),STAT=ierr) 
     ALLOCATE(ObsTagLocRev(nobtot),STAT=ierr) 
     ALLOCATE(locObsTag0(locObsize),STAT=ierr) 
     ObsTagLoc=0 
     locObsTag0=locObsTag
     CALL SORT(locObsTag0,locObsize) 
     ii=0
     DO J=1,NFILES
        DO i=1,locObsize
           iobs=locObsTag(i) 
           ifamid=obsdat%mobhdr(NCM_OEC, iobs)
           if(j == ifamid) then
             ii=ii+1
             locObsTag_tmp(ii) = iobs  
             ObsTagLoc(iobs) = ii   
             ObsTagLocRev(iobs) = i   
           endif
        ENDDO 
     ENDDO 

     locObsTag=locObsTag_tmp
     DEALLOCATE(locObsTag_tmp)  
  ENDIF  
 !  nobtotp and obsdat%mxobstotal are used in CMAABRP of POSTMIN . 
  nobtotp=nobtot
  obsdat%mxobstotal=obsdat%numobs_recorded

!! keep the Global ROBHDR and MOBHDR
  DO iobs=1,nobtotp
    obsdat%MOBHDR_G(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,iobs)
    obsdat%ROBHDR_G(1:NCM_LET,iobs)=obsdat%ROBHDR(1:NCM_LET,iobs)
  ENDDO  
!!
  DO i=1,locObsize 
    iobs=locObsTag(i) 
    ROBHDR_tmp(1:NCM_LET,i)=obsdat%ROBHDR(1:NCM_LET,iobs)
    MOBHDR_tmp(1:NCM_LET,i)=obsdat%MOBHDR(1:NCM_LET,iobs)
    cstnid_tmp(i) = obsdat%cstnid(iobs)
    cfamily_tmp(i) = obsdat%cfamily(iobs) 
    IF(i== 1) THEN
       MOBHDR_tmp(NCM_RLN,1) = 1
    ELSE
       MOBHDR_tmp(NCM_RLN,i)=MOBHDR_tmp(NCM_RLN,i-1) + MOBHDR_tmp(NCM_NLV,i-1) 
    ENDIF 
  ENDDO !  


  ii=0 
  DO i=1,locObsize
    iobs=locObsTag(i) 
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
    DO j=idata,idataend 
       ii=ii+1 
       ROBDATA8_tmp(3:11,ii)=obsdat%ROBDATA8(3:11,j)
       MOBDATA_tmp(1:NCM_LBO,ii)=obsdat%MOBDATA(1:NCM_LBO,j) 
       ROBDATA_tmp(1:NCM_LBO,ii)=obsdat%ROBDATA(1:NCM_LBO,j) 
       MOBDATA_tmp(NCM_OBS,ii) = i
    ENDDO 
  ENDDO 
 
! Save the global nobtot and obsdat%numobs_recorded to nobtotp and obsdat%mxobstotal 
  
  nobtot=locObsize  
  obsdat%numobs_recorded=obsdat%numobs_recorded_l
  write(*,*) 'NOBTOT= ',nobtot 
  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtot,obsdat%numobs_recorded)
!
  DO i=1,nobtot
     obsdat%cfamily(i)=cfamily_tmp(i) 
     obsdat%cstnid(i)=cstnid_tmp(i)
     obsdat%ROBHDR(1:NCM_LET,i)=ROBHDR_tmp(1:NCM_LET,i)
     obsdat%MOBHDR(1:NCM_LET,i)=MOBHDR_tmp(1:NCM_LET,i) 
  ENDDO 

  DO i=1,obsdat%numobs_recorded
     obsdat%ROBDATA8(3:11,i)=ROBDATA8_tmp(3:11,i) 
     obsdat%MOBDATA(1:NCM_LBO,i)=MOBDATA_tmp(1:NCM_LBO,i) 
     obsdat%ROBDATA(1:NCM_LBO,i)=ROBDATA_tmp(1:NCM_LBO,i)
  ENDDO 

  deallocate(cfamily_tmp)
  deallocate(cstnid_tmp)
  deallocate(ROBHDR_tmp)
  deallocate(MOBHDR_tmp)
  deallocate(ROBDATA8_tmp)
  deallocate(MOBDATA_tmp)
  deallocate(ROBDATA_tmp)

 ! rebuild NBEGINTYP and NENDTYP  
 !============================
  jj=0
  NBEGINTYP_G=NBEGINTYP
  NENDTYP_G=NENDTYP
 
  NBEGINTYP=0
  NENDTYP=0
  DO j=1,NFILES
    lfirst=.true. 
    DO i=1,locObsize
      istart=obsdat%mobhdr(NCM_RLN, i)
      idata=obsdat%mobhdr(NCM_NLV, i)
      ifamid=obsdat%mobhdr(NCM_OEC, i)
      IF(ifamid == J) THEN
         IF(lfirst) THEN
           NBEGINTYP(j) = istart 
           lfirst=.false. 
         ENDIF 
         JJ=JJ+idata 
      ENDIF 
    ENDDO 
    NENDTYP(J) = JJ 
    IF(NBEGINTYP(j) == 0)  NENDTYP(J) = 0
    WRITE(*,*) 'J NBEGINTYP(j) NENDTYP(j)= ',J,NBEGINTYP(j), NENDTYP(j),ifamid
  ENDDO  
  
  WRITE(*,*) '============= Leave reBuildCMA =============='
!!
  RETURN
 END SUBROUTINE obs_reduceToMpiLocal


 SUBROUTINE obs_expandToMpiGlobal(obsdat, nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global observation object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

  USE mod4dv, only : l4dvar 
  USE obstag  
  use profileData_mod 
  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in) :: nulout         ! standard output unit
  integer, intent(in) :: nobtot         ! Actual number of observations
  integer, intent(in) :: nobtotp        ! Actual no. of obs. in POST FILE=nobtot

! Declaire Local Variables. 
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBDATA_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp 
  REAL*8,ALLOCATABLE,DIMENSION(:) :: RMTMOBS_tmp
  
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,idata,ii,sizeMOBDATA  
  INTEGER ::sizeMOBHDR,sizeRMTMOBS  
!!---------------------------------------------------------------

!!1.      Release some memorys. 
  print*,'Entering restoreCMA'  

!!1.2 Added restore global array MOBHDR and RMTMOBS
!     MOBHDR and  RMTMOBS are used in "cmaabrp.ftn"
  ALLOCATE(MOBHDR_tmp(NCM_LET,NOBTOTP),STAT=ierr) 
  IF(ierr /= 0)  CALL ABORT3D(nulout,'Cannt allocate Mem. to MOBHDR_tmp,Abort!') 
  MOBHDR_TMP=0

  ALLOCATE(RMTMOBS_tmp(NOBTOTP),STAT=ierr) 
  IF(ierr /= 0)  CALL ABORT3D(nulout,'Cannt allocate Mem. to RMTMOBS_tmp,Abort!') 
  RMTMOBS_TMP=0.0D0 
! 1.3 retore global MOBHDR and RMTMOBS
  ii=1 
  DO i=1,NOBTOT
     iobs=locObsTag(i)
     MOBHDR_tmp(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,ii)
     RMTMOBS_tmp(iobs)=RMTMOBS(ii)
     ii=ii+1
  ENDDO  
  sizeMOBHDR=size(MOBHDR_tmp)
  sizeRMTMOBS=NOBTOTP
  CALL RPN_COMM_ALLReduce(MOBHDR_tmp,MOBHDR_tmp,sizeMOBHDR,"mpi_integer","mpi_sum","GRID",ierr)
  CALL RPN_COMM_ALLReduce(RMTMOBS_tmp,RMTMOBS_tmp,sizeRMTMOBS,"mpi_double_precision","mpi_sum","GRID",ierr)


!!      DEALLOCATE(RMTMOBS)
  deallocate(rmtmobs)
  allocate(rmtmobs(nobtotp))
!      CALL  HPDEALLC(PTMTMOBS,IERR,1)
!      CALL HPALLOC(PTMTMOBS,NOBTOTP,ierr,8) 
!      IF(ierr /= 0)  CALL ABORT3D(nulout,'Cannt allocate Mem. to RMTMOBS,Abort!') 
  RMTMOBS=RMTMOBS_tmp
  DEALLOCATE(RMTMOBS_tmp)
  

!!2.  Allocate memory to the temporol arrays.   
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr) 
  IF(ierr /= 0)  CALL ABORT3D(nulout,'Cannt allocate Mem. to MOBDATA_tmp,Abort!') 
  MOBDATA_tmp=0 

  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr) 
  IF(ierr /= 0) CALL  ABORT3D(nulout, 'Cannt allocate Mem. to ROBDATA_tmp,Abort!') 
  ROBDATA_tmp=0.0 

!3.  Re-store the global array MOBDATA and ROBDATA   
  ii=0 
  DO i=1,nobtot
    iobs=locObsTag(i) 
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
    DO j=idata,idataend 
       ii=ii+1 
       MOBDATA_tmp(1:NCM_LBO,j)=obsdat%MOBDATA(1:NCM_LBO,ii) 
       ROBDATA_tmp(1:NCM_LBO,j)=obsdat%ROBDATA(1:NCM_LBO,ii) 
    ENDDO 
  ENDDO 
   !   
   ! Merge the global array MOBDATA_tmp and ROBDATA_tmp. 
  sizeMOBDATA=size(MOBDATA_tmp) 
  CALL RPN_COMM_ALLReduce(MOBDATA_tmp,MOBDATA_tmp,sizeMOBDATA,"mpi_integer","mpi_sum","GRID",ierr)
  CALL RPN_COMM_ALLReduce(ROBDATA_tmp,ROBDATA_tmp,sizeMOBDATA,"mpi_real","mpi_sum","GRID",ierr)
   !  

  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtotp,obsdat%mxobstotal)

  obsdat%ROBDATA=ROBDATA_tmp 
  DEALLOCATE(ROBDATA_tmp) 
  obsdat%MOBDATA=MOBDATA_tmp
  DEALLOCATE(MOBDATA_tmp)  
  obsdat%MOBHDR=MOBHDR_tmp
  DEALLOCATE(MOBHDR_tmp)
  
!!
  call obs_deallocateG(obsdat)
  DEALLOCATE(locObsTag)
  IF(l4dvar) THEN
    DEALLOCATE(ObsTagLoc) 
    DEALLOCATE(locObsTag0) 
  ENDIF 
!!
  RETURN
 END SUBROUTINE obs_expandToMpiGlobal


end module obsSpaceData_mod
