MODULE obsSpaceData_mod
  implicit none
  save
  private

  ! main observation space data instance
  public           :: OBS_JPNBRELEM
  public           :: locObsTag

  ! header column numbers
  public           :: NCM_LET, NCM_RLN, NCM_ONM, NCM_BOX, NCM_OTP, NCM_ITY,  &
                      NCM_LAT, NCM_LON, NCM_DAT, NCM_ETM, NCM_SID, NCM_ALT,  &
                      NCM_NLV, NCM_OEC, NCM_OFL, NCM_ST1, NCM_TLA, NCM_AZA,  &
                      NCM_SUN, NCM_CLF, NCM_REG, NCM_PAS, NCM_IP,  NCM_BX,   &
                      NCM_BY,  NCM_BZ

  ! body column numbers
  public           :: NCM_LBO, NCM_VNM, NCM_PPP, NCM_PRL, NCM_POB, NCM_VAR,  &
                      NCM_OMF, NCM_OMA, NCM_OMI, NCM_OMN, NCM_OER, NCM_RER,  &
                      NCM_FGE, NCM_PER, NCM_FLG, NCM_POS, NCM_LYR, NCM_ASS,  &
                      NCM_XTR, NCM_OBS, NCM_LOBS,NCM_VCO, NCM_PRM, NCM_KFA,  &
                      NCM_ZHA, NCM_HPHT,NCM_OMP

  ! methods
  public           :: obs_initialize,obs_finalize
  public           :: obs_elem_i,obs_elem_r4,obs_elem_r8,obs_elem_c9
  public           ::  obs_set_i, obs_set_r4, obs_set_r8, obs_set_c9
  public           :: obs_num_obstotal,obs_num_stn,obs_swapVarOmf,obs_ifind
  public           :: obs_getFamily,obs_setFamily,obs_bdy,obs_getobstag
  public           :: obs_reduceToMpiLocal,obs_expandToMpiGlobal
  public           :: obs_elem_mpiglobal_r4,obs_elem_mpiglobal_i
  public           :: obs_setTimeInterpWeight,obs_getTimeInterpWeight
  public           :: obs_getTimeInterpWeight_mpiglobal,obs_prnthdr,obs_prntbdy
  public           :: obs_getHeaderIndices,obs_getBodyIndices


  interface obs_getBodyIndices
   module procedure obs_getBodyIndices_fromHeaderIndex
   module procedure obs_getBodyIndices_fromFamily
  end interface

  ! private methods
  !                obs_allocate, obs_deallocate, obs_allocateG, obs_deallocateG
  !                obs_abort

  ! derived type and module variable declarations

  public :: struct_obs

  type struct_obs
   character(len=9),  pointer, dimension(:)   :: cstnid   !! need len=12 for EnKF
   character(len=2),  pointer, dimension(:)   :: cfamily
   real(kind=4),      pointer, dimension(:,:) :: robhdr
   integer,           pointer, dimension(:,:) :: mobhdr
   real(kind=4),      pointer, dimension(:,:) :: robdata
   real(kind=8),      pointer, dimension(:,:) :: robdata8
   integer,           pointer, dimension(:,:) :: mobdata
   integer :: numstns_recorded          ! Actual number of stations on record
   integer :: mxstntotal                ! maximum number of stations
   integer :: numobs_recorded           ! Actual total number of data on record
   integer :: mxobstotal                ! maximum number observations

                                        ! Size of the mpi-Local obs data
   integer                                    :: numobs_recorded_l
                                        ! Headers of the mpi-Global obs data
   integer,           pointer, dimension(:,:) :: mobhdr_g
   real(kind=4),      pointer, dimension(:,:) :: robhdr_g
   real*8, pointer :: timeInterpWeight(:,:)  ! weights for linear temporal interpolation of increment to obs times
   real*8, pointer :: timeInterpWeight_mpiglobal(:,:)  ! weights for linear temporal interpolation of increment to obs times

   logical :: mpi_local                 ! T: keep only data needed by this PE
  end type struct_obs

  integer, pointer, dimension(:) :: locObsTag

  ! header column numbers
  integer,parameter :: NCM_LET = 22 ! Dimension for var3d
  integer,parameter :: NCM_RLN = 1
  integer,parameter :: NCM_ONM = 2
  integer,parameter :: NCM_BOX = 3
  integer,parameter :: NCM_OTP = 4
  integer,parameter :: NCM_ITY = 5
  integer,parameter :: NCM_LAT = 6
  integer,parameter :: NCM_LON = 7
  integer,parameter :: NCM_DAT = 8
  integer,parameter :: NCM_ETM = 9
  integer,parameter :: NCM_SID = 10
  integer,parameter :: NCM_ALT = 11
  integer,parameter :: NCM_NLV = 12
  integer,parameter :: NCM_OEC = 13
  integer,parameter :: NCM_OFL = 14
  integer,parameter :: NCM_ST1 = 15
  integer,parameter :: NCM_TLA = 16
  integer,parameter :: NCM_AZA = 20
  integer,parameter :: NCM_SUN = 21
  integer,parameter :: NCM_CLF = 22
! integer,parameter :: NCM_STID=    ! Not needed since only 1 cstnid exists
! integer,parameter :: NCM_FAM =    ! Not needed since only 1 cfamily exists
! These values are used only by EnKF, and not by var3d
  integer,parameter :: NCM_REG = 23
  integer,parameter :: NCM_PAS = 24
  integer,parameter :: NCM_IP  = 25
  integer,parameter :: NCM_BX  = 26
  integer,parameter :: NCM_BY  = 27
  integer,parameter :: NCM_BZ  = 28

  ! body column numbers
  integer,parameter :: NCM_LBO = 22
  integer,parameter :: NCM_VNM = 1
  integer,parameter :: NCM_POB = 2
  integer,parameter :: NCM_PRL = 3
  integer,parameter :: NCM_PPP = 4
  integer,parameter :: NCM_VAR = 5
  integer,parameter :: NCM_OMF = 6
  integer,parameter :: NCM_OMA = 7
  integer,parameter :: NCM_OMI = 8
  integer,parameter :: NCM_OMN = 9
  integer,parameter :: NCM_OER = 10
  integer,parameter :: NCM_PRM = 11
  integer,parameter :: NCM_RER = 12
  integer,parameter :: NCM_FGE = 13
  integer,parameter :: NCM_PER = 14
  integer,parameter :: NCM_FLG = 15
  integer,parameter :: NCM_POS = 16
  integer,parameter :: NCM_LYR = 17
  integer,parameter :: NCM_ASS = 18
  integer,parameter :: NCM_XTR = 19
  integer,parameter :: NCM_OBS = 20
  integer,parameter :: NCM_LOBS= 21
  integer,parameter :: NCM_VCO = 22
! added for EnKF
  integer,parameter :: NCM_KFA = 23
  integer,parameter :: NCM_ZHA = 24
  integer,parameter :: NCM_HPHT= 26
  integer,parameter :: NCM_OMP = 25

  integer, parameter :: OBS_JPNBRELEM = 57

  integer, parameter :: ROBDATA8_LOWER = NCM_POB
  integer, parameter :: ROBDATA8_UPPER = NCM_PER

  integer, parameter :: mxstepobs=9 ! temporarily specify max number of step obs for allocation

  contains


  subroutine obs_initialize(obsdat,mxstn,mxobs)
    implicit none

    type(struct_obs), intent(out) :: obsdat
    integer, intent(in) :: mxstn        ! maximum number of stations allocated
    integer, intent(in) :: mxobs        ! maximum no. of observations per source

    obsdat%mxstntotal=mxstn
    obsdat%mxobstotal=mxobs
    obsdat%numstns_recorded = 0
    obsdat%numobs_recorded  = 0
    obsdat%mpi_local = .false.

    obsdat%numobs_recorded_l = 0
    nullify(obsdat%mobhdr_g)
    nullify(obsdat%robhdr_g)
    nullify(obsdat%timeInterpWeight_mpiglobal)

    call obs_allocate(obsdat,mxstn,mxobs)
    return
  end subroutine obs_initialize


  subroutine obs_finalize(obsdat)
    implicit none
    type(struct_obs), intent(inout) :: obsdat

    call obs_deallocate(obsdat)
    call obs_deallocateG(obsdat)
  end subroutine obs_finalize


  subroutine obs_allocate(obsdat,mxstn,mxobs)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)  :: mxstn,mxobs

    integer :: ierr

    ALLOCATE(obsdat%cfamily(mxstn),STAT=ierr)
    obsdat%cfamily(:)='XX'

    ALLOCATE(obsdat%cstnid(mxstn),STAT=ierr)
    obsdat%cstnid(:)='XXXXXXXXX' !! // 'XXX'   needed for EnKF

    ALLOCATE(obsdat%ROBHDR(NCM_LET,mxstn),STAT=ierr)
    obsdat%ROBHDR=0.0

    ALLOCATE(obsdat%MOBHDR(NCM_LET,mxstn),STAT=ierr)
    obsdat%MOBHDR=0

    ALLOCATE(obsdat%ROBDATA(NCM_LBO,mxobs),STAT=ierr)
    obsdat%ROBDATA=0.0

    ALLOCATE(obsdat%ROBDATA8(ROBDATA8_LOWER:ROBDATA8_UPPER,mxobs),STAT=ierr)
    obsdat%ROBDATA8=0.0D0

    ALLOCATE(obsdat%MOBDATA(NCM_LBO,mxobs),STAT=ierr)
    obsdat%MOBDATA=0

    ALLOCATE(obsdat%timeInterpWeight(mxobs,mxstepobs),STAT=ierr)
    obsdat%timeInterpWeight=0.0d0

  end subroutine obs_allocate

  subroutine obs_allocateG(obsdat,maxNumHdr)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)    :: maxNumHdr

    integer :: ierr

    ALLOCATE(obsdat%ROBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%ROBHDR_g=0.0

    ALLOCATE(obsdat%MOBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%MOBHDR_g=0

    ALLOCATE(obsdat%timeInterpWeight_mpiglobal(maxNumHdr,mxstepobs),STAT=ierr)
    obsdat%timeInterpWeight_mpiglobal=0.0d0

  end subroutine obs_allocateG


  subroutine obs_deallocateG(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%robhdr_g)) then
      deallocate(obsdat%robhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR_g. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr_g)) then
      deallocate(obsdat%mobhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR_g. IERR =',ierr
      endif
    end if

    if (associated(obsdat%timeInterpWeight_mpiglobal))then
      deallocate(obsdat%timeInterpWeight_mpiglobal,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'timeInterpWeight_mpiglobal checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in timeInterpWeight_mpiglobal. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocateG


  subroutine obs_deallocate(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%cfamily)) then
      deallocate(obsdat%cfamily,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CFAMILY checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CFAMILY. IERR =',ierr
      endif
    end if

    if (associated(obsdat%cstnid))then
      deallocate(obsdat%cstnid,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CSTNID checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CSTNID. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robhdr))then
      deallocate(obsdat%robhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr))then
      deallocate(obsdat%mobhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata))then
      deallocate(obsdat%robdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata8))then
      deallocate(obsdat%robdata8,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA8 checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA8. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobdata))then
      deallocate(obsdat%mobdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBDATA. IERR =',ierr
      endif
    end if

    if (associated(obsdat%timeInterpWeight))then
      deallocate(obsdat%timeInterpWeight,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'timeInterpWeight checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in timeInterpWeight. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocate


  subroutine obs_abort(cdmessage)
#if defined (DOC) 
*
***s/r OBS_ABORT  - Abort a job on error
*
*
*Author  : P. Gauthier *ARMA/AES  June 9, 1992
*Revision:
*     . P. Gauthier *ARMA/AES  January 29, 1996 
*     . P. Koclas   CMC/CMSV   January  1997 
*         -add call to abort
*     . S. Pellerin ARMA/SMC   October 2000
*         - replace call to abort for call to exit(1)
*     . C. Charette ARMA/SMC   October 2001
*         - replace SUTERM by SUTERMF to only close files
*     . J. Blezius  import ABORT3D into obsspacedata_mod as OBS_ABORT
*         - delete call to SUTERMF
*    -------------------
**    Purpose:
*     To stop a job when an error occurred
*
*Arguments
*     i     CDMESSAGE: message to be printed
#endif

      implicit none
      character(len=*) cdmessage

      write(*,'(//,4X,"ABORTING IN ObsSpaceData_mod:-------",/,8X,A)')cdmessage

      call qqexit(1)

      stop
  end subroutine obs_abort


  subroutine obs_swapVarOmf(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    real(kind=4),allocatable :: temp_robdata(:)
    real(kind=8),allocatable :: temp_robdata8(:)
    integer                  :: ierr

!    temp = NCM_VAR
!    NCM_VAR = NCM_OMF
!    NCM_OMF = temp

    allocate(temp_robdata (lbound(obsdat%robdata ,2):ubound(obsdat%robdata ,2)),stat=ierr)
    temp_robdata(:)=obsdat%robdata(NCM_VAR,:)
    obsdat%robdata(NCM_VAR,:)=obsdat%robdata(NCM_OMF,:)
    obsdat%robdata(NCM_OMF,:)=temp_robdata(:)
    deallocate(temp_robdata)

    allocate(temp_robdata8(lbound(obsdat%robdata8,2):ubound(obsdat%robdata8,2)),stat=ierr)
    temp_robdata8(:)=obsdat%robdata8(NCM_VAR,:)
    obsdat%robdata8(NCM_VAR,:)=obsdat%robdata8(NCM_OMF,:)
    obsdat%robdata8(NCM_OMF,:)=temp_robdata8(:)
    deallocate(temp_robdata8)

  end subroutine obs_swapVarOmf


  function obs_getFamily(obsdat,headerIndex,bodyIndex)
    implicit none

    character(len=2)             :: obs_getFamily
    type(struct_obs), intent(in) :: obsdat
    integer,optional, intent(in) :: headerIndex,bodyIndex

    integer          :: headerIndex2

    if(present(headerIndex)) then
      obs_getFamily=obsdat%cfamily(headerIndex)
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obs_getFamily=obsdat%cfamily(headerIndex2)
    else
      write(*,*) 'OBS_GETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call qqexit(1)
    endif

  end function obs_getFamily


  subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    character(len=2), intent(in)    :: Family_in
    integer,optional, intent(in)    :: headerIndex,bodyIndex

    integer          :: headerIndex2
    
    if(present(headerIndex)) then
      obsdat%cfamily(headerIndex)=Family_in
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obsdat%cfamily(headerIndex2)=Family_in
    else
      write(*,*) 'OBS_SETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call qqexit(1)
    endif

  end subroutine obs_setFamily

  
  SUBROUTINE obs_setTimeInterpWeight(obsdat,weight_in,headerIndex,stepObs)
    implicit none
    type(struct_obs), intent(inout) :: obsdat
    integer, intent(in)    :: headerIndex,stepObs
    real(kind=8),intent(in):: weight_in

    obsdat%timeInterpWeight(headerIndex,stepObs)=weight_in

  end SUBROUTINE obs_setTimeInterpWeight


  real(kind=8) FUNCTION obs_getTimeInterpWeight(obsdat,headerIndex,stepObs) result(weight_out)
    implicit none
    type(struct_obs),intent(in) :: obsdat
    integer,intent(in)          :: headerIndex,stepObs

    weight_out=obsdat%timeInterpWeight(headerIndex,stepObs)

  end FUNCTION obs_getTimeInterpWeight


  real(kind=8) FUNCTION obs_getTimeInterpWeight_mpiglobal(obsdat,headerIndex,stepObs) result(weight_out)
    implicit none
    type(struct_obs),intent(in) :: obsdat
    integer,intent(in)          :: headerIndex,stepObs

    weight_out=obsdat%timeInterpWeight_mpiglobal(headerIndex,stepObs)

  end FUNCTION obs_getTimeInterpWeight_mpiglobal


  SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                    LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                    n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                    KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                    vconv,nonelev)
    use MathPhysConstants_mod
    IMPLICIT NONE
!
    type(struct_obs), intent(inout) :: obsdat
    INTEGER, intent(out) :: KNDAT
    INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
    INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
    INTEGER, intent(in)  :: KLIST(n_elements_in_block)
    INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
    integer, intent(in)  :: nvcordtyp,nonelev
!
    REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
    REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
    REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
    REAL(kind=8),intent(in)::PPMIS
    real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
    real(kind=8),intent(in)::vcordsf(:,:)
!
    LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI
!
#if defined (DOC)
!***********************************************************************
!
!***s/r OBS_BDY -FILL BODY OF CMA REPORT
!
!Author    . P. KOCLAS(CMC TEL. 4665)
!
!Revision:
!          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
!          .   before insertion of U and V for consistency
!          . P. Koclas *CMC/AES February  1995:
!          .  New call sequence neccessary to :
!          . -allow insertion of "grouped data" records in BURP files.
!          . -allow data observed in various vertical coordinates
!          . -observation errors no longer initialized
!
!          . P. Koclas *CMC/AES March     1995:
!            -Additions for humsat and satem data
!          .
!          . C. Charette *ARMA Jan        2001
!            -Max value for T-Td surface element(12203)
!
!           JM Belanger CMDA/SMC  Feb 2001
!                   . 32 bits conversion
!          . P. Koclas *CMC/CMDA Sept     2001:
!            -set first-guess and observation errors to missing values
!
!          .N Wagneur CMDA/SMC  Jine 2002
!                   . -Additions for goes data
!          . P. Koclas *CMC/CMDA Dec      2003:
!                -conversion for surface wind
!          . C. Charette *ARMA/SMC Apr      2005:
!                -Set flag bit #12 (Element assimilated by analysis) to zero
!                 (see banco-burp documentation for more detail)
!          . A. Beaulne *CMDA/SMC  Aug 2006
!                     -Additions for AIRS data
!          . S. Heilliette
!                     -Additions for IASI data
!
!
!    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
!              THE IN-CORE FORMAT (CMA) OF THE 3-D VARIATIONAL ANALYSIS
!
!    ARGUMENTS:
!     INPUT:
!
!           -PVALUES : DATA BLOCK
!           -KLIST   : LIST OF BUFR ELEMENTS
!           -KFLAGS  : QUALITY CONTROL FLAGS
!
!           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN CMA
!                      .FALSE. --> INSERT DUMMY VALUE(2**12)
!           -LERR    :  .TRUE. --> INSERT OBS ERROR IN CMA (HUMSAT DATA)
!           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN CMA (SATEMS)
!           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN CMA (GOES RADIANCES)
!           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (AIRS RADIANCES)
!           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (IASI RADIANCES)
!
!           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
!           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
!           -KNT     :  THIRD DIMENSION OF DATA BLOCK
!           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
!           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
!           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
!           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
!           -PPMIS   :  VALUE OF MISSING DATA
!           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
!
!    OUTPUT:
!           -KNDAT   : NUMBER OF DATA INSERTED IN CMA FILE
!
!***********************************************************************
#endif

    INTEGER ILEM,IND,IIND,IP,IK
    INTEGER IBAD,IFLAG
    INTEGER ielement,ilevel
    INTEGER ZESMAX,ZES
!
    REAL(kind=8) ZTORAD,ZFACT,padd,pmul,ZEMFACT,pvalue
!
!***********************************************************************
!     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
!***********************************************************************
!
    IIND  =-1
    IBAD=2**11
    ZTORAD=RPI/180.
!
    ZFACT=VCONV
!
    ZEMFACT=0.01
    ZESMAX=30.
!
    IP=obsdat%numobs_recorded + 1
    IND=0
!
!***********************************************************************
!     PUT ALL NON MISSING DATA IN CMA FILE
!     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO CMA FILE
!     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
!***********************************************************************
!
    IK= KINDEX
       DO ielement=1,n_elements_in_block
          ILEM=obs_ifind(KLIST(ielement))
          IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
             DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                    nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                      IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                         pvalue=PVALUES(ielement,ilevel,IK)
                         IF ( IP + IND .LE. obsdat%mxobstotal ) THEN
!                                       VERTICAL COORDINATE
                            obsdat%robdata8(NCM_PPP,IP+IND)=PVCORD(ilevel)*ZFACT +vcordsf(ilem,kidtyp)
!
!                           FOR PNM HEIGHT IS SET TO 0
!                           ----------------------------
                            IF ( ILEM .EQ. 53 ) THEN
                               obsdat%robdata8(NCM_PPP,IP+IND)=0.D0
                            ENDIF
!                           ----------------------------
!
!                           IF ( ILEM .EQ. 2 ) Units:  V
!                                        CONVERT TO GZ
                            IF ( ILEM .EQ. 3 ) THEN
                             pvalue=RG*pvalue
                            ENDIF
!                           IF ( ILEM .EQ. 4 ) Units: METERS
!                           IF ( ILEM .EQ. 8 ) Units:  CELSIUS
!                                  Max value T-Td upper air
                            IF ( ILEM .EQ. 9 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    Max value T-Td surface
                            IF ( ILEM .EQ. 11 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    CONVERT TO RADIANS
                            IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                             pvalue=ZTORAD*pvalue
                            ENDIF
!                                       FLAGS
                            IF  (LDFLAG) THEN
!                                 SET BIT 12  TO ZERO
!                                 (Element assim by 3dvar)
                               IFLAG = KFLAGS(ielement,ilevel,IK)
                               IFLAG = IBCLR(IFLAG,12)
                               obsdat%mobdata(NCM_FLG,IP+IND)= IFLAG
                            ELSE
                               obsdat%mobdata(NCM_FLG,IP+IND)= IBAD
                            ENDIF
!
                            obsdat%robdata8(NCM_VAR,IP+IND)=pvalue
                            obsdat%mobdata (NCM_VNM,IP+IND)=KLIST(ielement)
                            obsdat%mobdata (NCM_VCO,IP+IND)=NVCORDTYP
                            obsdat%robdata8(NCM_OMF,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMA,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMI,IP+IND)=PPMIS
                            obsdat%robdata (NCM_FGE,IP+IND)=real(PPMIS)
                            obsdat%robdata8(NCM_OER,IP+IND)=PPMIS
!
!                           OBS ERROR FOR HUMSAT
!
                            IF ( LDERR ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)
                            ENDIF
!
!                           REFERENCE LEVEL FOR SATEMS
!
                            IF ( LDSAT ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)*ZFACT
                              obsdat%robdata8(NCM_OER,IP+IND)=1.0D0
                            ENDIF
!
!                           SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
!
                            IF ( LDGO ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            ENDIF

                            IF ( LDAIRS ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            END IF

                            IF ( LDIASI ) THEN
                               obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                    *ZEMFACT
                            END IF

!
                            IND=IND + 1
                         ELSE
!==================================================
                            KNDAT = IND
                            obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!==================================================
                            RETURN
                         ENDIF
                      ENDIF
                ENDIF
             END DO
          ENDIF
       END DO
!=============================
    KNDAT = IND
    obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!=============================
!
    RETURN
!
  END SUBROUTINE obs_bdy


 real(kind=4) function obs_elem_r4(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr(NCM_BZ , index)

  case ('PPP '); value=obsdat%robdata(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata(NCM_PRL, index)
  case ('VAR '); value=obsdat%robdata(NCM_VAR, index)
  case ('OMP '); value=obsdat%robdata(NCM_OMP, index)
  case ('OMA '); value=obsdat%robdata(NCM_OMA, index)
  case ('OER '); value=obsdat%robdata(NCM_OER, index)
  case ('HPHT'); value=obsdat%robdata(NCM_HPHT,index)
  case ('ZHA '); value=obsdat%robdata(NCM_ZHA, index)
  ! Added for var3d
  case ('POB '); value=obsdat%robdata(NCM_POB, index)
  case ('OMF '); value=obsdat%robdata(NCM_OMF, index)
  case ('OMI '); value=obsdat%robdata(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata(NCM_OMN, index)
  case ('RER '); value=obsdat%robdata(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(4) observation."
   value=-999.
  end select
 end function obs_elem_r4

 real(kind=4) function obs_elem_mpiglobal_r4(obsdat,name,index) result(value)
  ! This method is supplied for use by those external to the present module who
  ! are aware of the mpi-local or -global state of this module.
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr_g(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr_g(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr_g(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr_g(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr_g(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr_g(NCM_BZ , index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not available in the mpi-global context."
   value=-999.
  end select
 end function obs_elem_mpiglobal_r4

 real(kind=8) function obs_elem_r8(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  ! Added for var3d
  case ('PPP '); value=obsdat%robdata8(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata8(NCM_PRL, index)
  case ('POB '); value=obsdat%robdata8(NCM_POB, index)
  case ('VAR '); value=obsdat%robdata8(NCM_VAR, index)
  case ('OMF '); value=obsdat%robdata8(NCM_OMF, index)
  case ('OMA '); value=obsdat%robdata8(NCM_OMA, index)
  case ('OMI '); value=obsdat%robdata8(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata8(NCM_OMN, index)
  case ('OER '); value=obsdat%robdata8(NCM_OER, index)
  case ('RER '); value=obsdat%robdata8(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata8(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata8(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata8(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(8) observation."
   value=-999
  end select
 end function obs_elem_r8

 integer function obs_elem_i(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr(NCM_CLF, index)
  ! Added for var3d
  case ('SID '); value=obsdat%mobhdr(NCM_SID, index)
  case ('OEC '); value=obsdat%mobhdr(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr(NCM_TLA, index)

  case ('VNM '); value=obsdat%mobdata(NCM_VNM, index)
  case ('FLG '); value=obsdat%mobdata(NCM_FLG, index)
  case ('KFA '); value=obsdat%mobdata(NCM_KFA, index)
  case ('ASS '); value=obsdat%mobdata(NCM_ASS, index)
  case ('OBS '); value=obsdat%mobdata(NCM_OBS, index)
  case ('VCO '); value=obsdat%mobdata(NCM_VCO, index)
  ! Added for var3d
  case ('LBO '); value=obsdat%mobdata(NCM_LBO, index)
  case ('POS '); value=obsdat%mobdata(NCM_POS, index)
  case ('XTR '); value=obsdat%mobdata(NCM_XTR, index)
  case ('LOBS'); value=obsdat%mobdata(NCM_LOBS,index)
  case ('LYR '); value=obsdat%mobdata(NCM_LYR, index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
   value=-999
  end select
 end function obs_elem_i

 integer function obs_elem_mpiglobal_i(obsdat,name,index) result(value)
  ! This method is supplied for use by those external to the present module who
  ! are aware of the mpi-local or -global state of this module.
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr_g(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr_g(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr_g(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr_g(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr_g(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr_g(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr_g(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr_g(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr_g(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr_g(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr_g(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr_g(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr_g(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr_g(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr_g(NCM_CLF, index)
  ! Added for var3d
  case ('SID '); value=obsdat%mobhdr_g(NCM_SID, index)
  case ('OEC '); value=obsdat%mobhdr_g(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr_g(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr_g(NCM_TLA, index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not available in the mpi-global context."
   value=-999
  end select
 end function obs_elem_mpiglobal_i


 function obs_elem_c9(obsdat,name,index) result(value)
  implicit none

  character(len=9) :: value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('STID'); value=obsdat%cstnid(index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not character(len=9) observation."
   value='xxxxxxxxx'
  end select
 end function obs_elem_c9


 subroutine obs_getHeaderIndices(obsdat, family, list_header, size_list)
  type(struct_obs), intent(in)  :: obsdat
  character(len=2), intent(in)  :: family
  integer, dimension(:), intent(out) :: list_header
  integer, intent(out) :: size_list

  integer :: header_index

  size_list = 0

  do header_index = 1,obsdat%numstns_recorded
   if(obsdat%cfamily(header_index) == family) then
    size_list = size_list + 1
    list_header(size_list) = header_index
   end if
  end do
 end subroutine obs_getHeaderIndices


 subroutine obs_getBodyIndices_fromHeaderIndex(obsdat, header_index, list_body, &
                                               size_list)
  type(struct_obs), intent(in)  :: obsdat
  integer, intent(in) :: header_index
  integer, dimension(:), intent(out) :: list_body
  integer, intent(out) :: size_list

  integer :: body_index, body_index_first, body_index_last

  size_list = 0

  body_index_first = obsdat%mobhdr(NCM_RLN, header_index)
  body_index_last = body_index_first + obsdat%mobhdr(NCM_NLV, header_index) -1
  do body_index = body_index_first, body_index_last
   size_list = size_list + 1
   list_body(size_list) = body_index
  end do
 end subroutine obs_getBodyIndices_fromHeaderIndex


 subroutine obs_getBodyIndices_fromFamily(obsdat, family, list_body, &
                                          size_list_body)
  type(struct_obs), intent(in)  :: obsdat
  character(len=2), intent(in)  :: family
  integer, dimension(:), intent(out) :: list_body
  integer, intent(out) :: size_list_body

  integer, dimension(obsdat%numstns_recorded) :: list_header
  integer :: header_index, size_list_header
  integer :: list_index, size_list_body_partial

  size_list_body = 0

  call obs_getHeaderIndices(obsdat, family, list_header, size_list_header)
  do list_index = 1, size_list_header
   header_index = list_header(list_index)
   call obs_getBodyIndices(obsdat, header_index, &
                           list_body(size_list_body+1 :), size_list_body_partial)
   size_list_body = size_list_body + size_list_body_partial
  end do

  
 end subroutine obs_getBodyIndices_fromFamily


 subroutine obs_getobstag(obsdat,nulout,nobtot,nfiles,cexc4dv,cfamtyp,nbegintyp, &
                      nendtyp,l4dvar)
#if defined (DOC)
!
!**s/r read local observation tag from GEM TLM-ADJ .
!
!Author  : Bin He *ARMA/MRB  Feb. 2009
!
!Revision:
!  
!Arguments: none
!
#endif
  use mpi
  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in) :: nulout         ! standard output unit
  integer, intent(in) :: nobtot         ! Actual number of observations
  integer, intent(in) :: nfiles
  character(len=128), intent(in) :: cexc4dv
  character(len=  2), intent(in) :: cfamtyp(:)
  integer, intent(in) :: nbegintyp(:), nendtyp(:)
  logical, intent(in) :: l4dvar         ! Logical control of 3Dvar/4Dvar

#include <prof_f.h>

!     Local Variables
  integer :: prof_wrrec,prof_rdrec
  integer :: ihdl,istat  
  character(len=2) :: cljx,cljy 
  character(len=512) :: clprof 

  integer ,allocatable,dimension(:) :: locObsTag_tmp  

  logical :: isExist_L
  integer ::  i,j, jj,k,ierr,interv,istart,iend   
  integer :: ibegin,ilast,ibeginob,ilastob
  integer :: length_l, iobs,idata 
  integer :: count,nsum
  real(8) :: a  
!-------------------------------------------------------------
  write(nulout,*) '-------- Start obs_getobstag ---------'
  IF(l4dvar) THEN
     write(cljx,'(i2.2)') mpi_myidx
     write(cljy,'(i2.2)') mpi_myidy

     clprof = trim(CEXC4DV) // '/obstag_'//cljx//'_'//cljy//'.prof'
     WRITE(*,*) 'Open File: ',clprof 
     count=0
     waiting: DO 
        INQUIRE(FILE=clprof,EXIST=isExist_L)
        if(isExist_L .and. (count>50000) ) EXIT 
        count=count+1
     ENDDO waiting

     ihdl= prof_open(clprof,'READ','FILE')
     If(ihdl < 0) call obs_abort('obs_getobstag')
     istat= prof_rdrec(ihdl) 
     istat= prof_gvar(ihdl,locObsTag,V2D_OTAG) 
       
     istat= prof_close(ihdl,.true.) 
     length_l=size(locObsTag) 
!-------------------------------------------------------------
  ELSE ! not l4dvar
    jj=0
    IF(mpi_nprocs == 0) mpi_nprocs=1
    WRITE(nulout,*) 'nobtot= ',nobtot 
    ALLOCATE(locObsTag_tmp(nobtot),STAT=ierr)
    DO J=1,NFILES
       ibegin= NBEGINTYP(j)
       ilast = NENDTYP(j) 

       IF(ibegin == -999 .and. ilast==-999) THEN
         ibeginob=0
         ilastob=-1
         istart=0
         iend=0 
       ELSE
         ibeginob= obsdat%mobdata(NCM_OBS, ibegin) 
         ilastob = obsdat%mobdata(NCM_OBS, ilast)  
         Write(*,*) 'J ibeginob ilastob= ',j,ibeginob,ilastob 
          
         nsum=ilastob-ibeginob+1
         interv=INT(nsum/mpi_nprocs)  
         IF(interv > 0) THEN
           istart=interv*mpi_myid+ibeginob
           iend=interv*(mpi_myid+1)+ibeginob -1 
           if(mpi_myid == mpi_nprocs-1) iend=ilastob
         ELSE 
           IF(mpi_myid<nsum)THEN
            istart=ibeginob+mpi_myid
            iend=istart 
           ELSE
            istart=0
            iend=0
           ENDIF 
         ENDIF  
 
       ENDIF !! ibegin=-999  

       write(*,*)'istart iend= ',istart,iend  
       IF (NBEGINTYP(J) .GT. 0)THEN
          SELECT CASE(CFAMTYP(J)) 
             CASE('UA') 
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('AI')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SW')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SF')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('TO') 
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('GO')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('RO')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('PR')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SC')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('GP')
                CALL calObsTag(ibeginob,ilastob,jj)
           END SELECT
       ELSE
         WRITE(nulout,*) 'Zero for Type ',CFAMTYP(J)  
       ENDIF

    ENDDO  ! J=1,NFILES   
    length_l=jj
    ALLOCATE(locObsTag(length_l),STAT=ierr)

    locObsTag(1:length_l)=locObsTag_tmp(1:length_l)

    DEALLOCATE(locObsTag_tmp) 

  ENDIF !! end if(l4dvar)  

   !! Calculate the size of the local obs data  
  obsdat%numobs_recorded_l=0
  IF(length_l<=0) call obs_abort('Zero length of ObsTag,Abort!') 
  DO i=1,length_l
   iobs=locObsTag(i)
   idata=obsdat%mobhdr(NCM_NLV, iobs)
   obsdat%numobs_recorded_l = obsdat%numobs_recorded_l + idata
  ENDDO 

  write(nulout,*) ' '
  write(nulout,*) '-------- END OF obs_getobstag ---------'
  write(nulout,*) ' '

  CONTAINS 
    subroutine calObsTag(startindx,endindx,jsize)
     integer,intent(in) :: startindx,endindx
     integer,intent(inout) :: jsize
     !Local variables
     integer :: k 
     DO k=startindx,endindx
       IF(k>=ISTART .and.k<= IEND) THEN
          jsize=jsize+1
          locObsTag_tmp(jsize)=k
       ENDIF
       
     ENDDO 
    end subroutine calObsTag 

 end subroutine obs_getobstag  



 integer function obs_num_obstotal(obsdat)
!func obs_num_obstotal - returns the number of observations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of observations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_obstotal=obsdat%numobs_recorded
 end function obs_num_obstotal


 integer function obs_num_stn(obsdat)
!func obs_num_stn - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_stn=obsdat%numstns_recorded
 end function obs_num_stn


 SUBROUTINE obs_prntbdy(obsdat,KOBS,KULOUT)
#if defined (DOC)
!
!**s/r PRNTBDY  - Print all data records associated with an observation
!
!Author  : P. Gauthier *ARMA/AES  June 9, 1992
!Revision:
!     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
!
!     . C. Charette *ARMA/AES Mar 1996 : format statement
!     . C. Charette *ARMA/AES Nov 1999 : Added print of flag NCM_ASS
!       JM Belanger CMDA/SMC  Jul 2000
!                   . 32 bits conversion
!     . S. Pellerin ARMA, January 2008 : Remove NCM_OMN print.
!
!Arguments
!     i   KOBS  : No. of observation
!     i   KULOUT: unit used for printing
!
#endif

  implicit none

  type(struct_obs), intent(in) :: obsdat
  INTEGER         , intent(in) :: KOBS, KULOUT

  INTEGER :: IPNT, IDATA, IDATA2, JDATA, IVCO
  CHARACTER(len=13) :: ccordtyp(3)

  ccordtyp(1)='HEIGHT      :'
  ccordtyp(2)='PRESSURE    :'
  ccordtyp(3)='VCO UNDEFINED'
!
! 1. General information
!
  IPNT  = obs_elem_i(obsdat,'RLN ',KOBS)
  IDATA = obs_elem_i(obsdat,'NLV ',KOBS)

  IF(IDATA.EQ.1) THEN
   WRITE(KULOUT,FMT=9101)IDATA,KOBS,NCM_LBO
  ELSE
   WRITE(KULOUT,FMT=9100)IDATA,KOBS,NCM_LBO
  END IF
 9100 FORMAT(4x,'THERE ARE ', &
           I3,1X,'DATA IN OBSERVATION RECORD NO.' &
           ,1X,I6,4X,'DATA RECORD''S LENGTH:',I6)
 9101 FORMAT(4x,'THERE IS ', &
           I3,1X,'DATA IN OBSERVATION RECORD NO.' &
           ,1X,I6,4X,'DATA RECORD''S LENGTH:',I6)
!
! 2. Print all data records
!
  DO JDATA = IPNT, IPNT + IDATA - 1
     IDATA2 = JDATA -IPNT + 1
     if(obs_elem_i(obsdat,'ASS ',JDATA).eq.1) then
        ivco=obs_elem_i(obsdat,'VCO ',JDATA)
        if(ivco.ne.1.and.ivco.ne.2) ivco=3
        WRITE(KULOUT,FMT=9201) IDATA2 &
             ,obs_elem_i (obsdat,'VNM ',JDATA) &
             ,ccordtyp   (ivco) &
             ,obs_elem_r4(obsdat,'PPP ',JDATA) &
             ,obs_elem_r4(obsdat,'PRL ',JDATA),obs_elem_r4(obsdat,'POB ',JDATA) &
             ,obs_elem_r4(obsdat,'VAR ',JDATA),obs_elem_r4(obsdat,'OMF ',JDATA) &
             ,obs_elem_r4(obsdat,'OMA ',JDATA),obs_elem_r4(obsdat,'OMI ',JDATA) &
             ,obs_elem_r4(obsdat,'OER ',JDATA) &
             ,obs_elem_r4(obsdat,'RER ',JDATA),obs_elem_r4(obsdat,'FGE ',JDATA) &
             ,obs_elem_r4(obsdat,'PER ',JDATA),obs_elem_i (obsdat,'FLG ',JDATA) &
             ,obs_elem_i (obsdat,'ASS ',JDATA)
     end if
  end do

 9201 FORMAT(4X,'DATA NO.',I6,/,10x &
!     ,'VARIABLE NO.:',I6,4X,'PRESSURE LEVEL:',G12.6,4X &
      ,'VARIABLE NO.:',I6,4X,A13,G12.6,4X &
           ,'REFERENCE LEVEL PRESSURE:',G12.6,4X &
           ,/,33X &
           ,'PRESSURE/GEOPOTENTIAL:',G12.6,4X &
           ,/,10X &
           ,'OBSERVE VALUE:',G23.16,15X,'FIRST-GUESS - OBSERVED VALUE:' &
           ,G23.16,4X &
           ,/,10X &
           ,'ANALYZED - OBSERVED VALUE:',G12.6,4X &
           ,'INITIALIZED - OBSERVED VALUE:',G23.16 &
           ,/,10X &
           ,'ERROR STANDARD DEVIATIONS FOR' &
           ,/,20X &
           ,'OBSERVATION:',G12.6,4X,'REPRESENTATIVENESS:',G12.6,4X &
           ,/,20X &
           ,'FIRST-GUESS:',G12.6,4X,'PERSISTENCE:',G12.6 &
           ,/,10X &
           ,'BURP FLAGS:',I6,4x,'OBS. ASSIMILATED (1-->YES;0-->NO):',I3)

  RETURN
 END subroutine obs_prntbdy


 SUBROUTINE obs_prnthdr(obsdat,KOBS,KULOUT)
#if defined (DOC)
!
!**s/r PRNTHDR  - Printing of the header of an observation record
!
!Author  : P. Gauthier *ARMA/AES  June 9, 1992
!Revision:
!     . P. Gauthier *ARMA/AES May 20,1993: modifications to the CMA files
!     . P. Koclas   *CMC:  Format for transformed latitude has been modified
!     .                    to handle an integer (latitude index of the first
!     .                    latitude circle north of the observation)
!Arguments
!     i   KOBS  : No. of observation
!     i   KULOUT: unit used for optional printing
!
#endif

  implicit none


  type(struct_obs), intent(in) :: obsdat
  INTEGER         , intent(in) :: KOBS, KULOUT

  CHARACTER(len=4) :: CSID14
  CHARACTER(len=9) :: CCSTNID

  WRITE(CSID14,'(a4)')obs_elem_i(obsdat,'SID ',KOBS)
  CCSTNID=CSID14

!
! 1. General information
!
  WRITE(KULOUT,FMT=9100)KOBS,NCM_LET
 9100 FORMAT(//,10x,'-- OBSERVATION RECORD NO.' &
        ,1X,I6,3X,'HEADER''S LENGTH:',I6)
!
! 2. PRINT HEADER'S CONTENT
!
  WRITE(KULOUT,FMT=9200)&
      obs_elem_i (obsdat,'RLN ',KOBS),obs_elem_i (obsdat,'ONM ',KOBS) &
     ,obs_elem_i (obsdat,'BOX ',KOBS),obs_elem_i (obsdat,'OTP ',KOBS) &
     ,obs_elem_i (obsdat,'ITY ',KOBS) &
     ,obs_elem_r4(obsdat,'LAT ',KOBS),obs_elem_r4(obsdat,'LON ',KOBS)&
     ,obs_elem_i (obsdat,'DAT ',KOBS),obs_elem_i (obsdat,'ETM ',KOBS) &
     ,CCSTNID                        ,obs_elem_r4(obsdat,'ALT ',KOBS) &
     ,obs_elem_i (obsdat,'NLV ',KOBS),obs_elem_i (obsdat,'OEC ',KOBS) &
     ,obs_elem_i (obsdat,'OFL ',KOBS),obs_elem_i (obsdat,'ST1 ',KOBS) &
     ,obs_elem_i (obsdat,'TLA ',KOBS)

 9200 FORMAT(6X,'Position within ROBDATA:',I6,1X,'OBS. NUMBER:',I6,1X &
           ,'MODEL BOX:',I6,1X,'OBS. TYPE:',I6,1X &
           ,'INSTR./RETR. TYPE:',I6,1X &
           ,/,6X &
           ,'OBSERVATION LOCATION. (LAT,LON):',2(F12.6,1X) &
           ,'DATE:',I12,1X,'EXACT TIME: ',I6,1X &
           ,/,6X &
           ,'STATION ID:',A9,1X &
           ,'STATION''S ALTITUDE:',G12.6,1X &
           ,'NUMBER OF DATA:',I6,1X,'ERROR CORR. TYPE',I6,1X &
           ,/,6X &
           ,'REPORT STATUS:',I6,5X,'REPORT STATUS 2:',I6,1X &
           ,/,6X &
           ,'Index of latitude north of the observation:',(1X,I6) &
           )

  RETURN
 END SUBROUTINE obs_prnthdr


 subroutine obs_set_i(obsdat, name, index, value)
!s/r obs_set_i - set an integer value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  integer         , intent(in)     :: value

  select case (name(1:4))
  case ('RLN '); obsdat%mobhdr (NCM_RLN, index) = value
  case ('ONM '); obsdat%mobhdr (NCM_ONM, index) = value
  case ('BOX '); obsdat%mobhdr (NCM_BOX, index) = value
  case ('OTP '); obsdat%mobhdr (NCM_OTP, index) = value
  case ('ITY '); obsdat%mobhdr (NCM_ITY, index) = value
  case ('DAT '); obsdat%mobhdr (NCM_DAT, index) = value
  case ('ETM '); obsdat%mobhdr (NCM_ETM, index) = value
  case ('NLV '); obsdat%mobhdr (NCM_NLV, index) = value
  case ('OFL '); obsdat%mobhdr (NCM_OFL, index) = value
  case ('PAS '); obsdat%mobhdr (NCM_PAS, index) = value
  case ('REG '); obsdat%mobhdr (NCM_REG, index) = value
  case ('IP  '); obsdat%mobhdr (NCM_IP , index) = value
  case ('AZA '); obsdat%mobhdr (NCM_AZA, index) = value
  case ('SUN '); obsdat%mobhdr (NCM_SUN, index) = value
  case ('CLF '); obsdat%mobhdr (NCM_CLF, index) = value
  ! Added for var3d
  case ('SID '); obsdat%mobhdr (NCM_SID, index) = value
  case ('OEC '); obsdat%mobhdr (NCM_OEC, index) = value
  case ('ST1 '); obsdat%mobhdr (NCM_ST1, index) = value
  case ('TLA '); obsdat%mobhdr (NCM_TLA, index) = value

  ! integer body values
  case ('VNM '); obsdat%mobdata(NCM_VNM, index) = value
  case ('FLG '); obsdat%mobdata(NCM_FLG, index) = value
  case ('KFA '); obsdat%mobdata(NCM_KFA, index) = value
  case ('ASS '); obsdat%mobdata(NCM_ASS, index) = value
  case ('OBS '); obsdat%mobdata(NCM_OBS, index) = value
  case ('VCO '); obsdat%mobdata(NCM_VCO, index) = value
  case ('LBO '); obsdat%mobdata(NCM_LBO, index) = value
  case ('POS '); obsdat%mobdata(NCM_POS, index) = value
  case ('LYR '); obsdat%mobdata(NCM_LYR, index) = value
  case ('XTR '); obsdat%mobdata(NCM_XTR, index) = value
  case ('LOBS'); obsdat%mobdata(NCM_LOBS,index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
  end select
 end subroutine obs_set_i


 subroutine obs_set_r4(obsdat, name, index, value)
!s/r obs_set_r4 - set a real value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  real(kind=4)    , intent(in)     :: value

  select case (name(1:4))
  case ('LAT '); obsdat%robhdr (NCM_LAT, index) = value
  case ('LON '); obsdat%robhdr (NCM_LON, index) = value
  case ('ALT '); obsdat%robhdr (NCM_ALT, index) = value
  case ('BX  '); obsdat%robhdr (NCM_BX , index) = value
  case ('BY  '); obsdat%robhdr (NCM_BY , index) = value
  case ('BZ  '); obsdat%robhdr (NCM_BZ , index) = value

  case ('PPP '); obsdat%robdata(NCM_PPP, index) = value
  case ('PRL '); obsdat%robdata(NCM_PRL, index) = value
  case ('VAR '); obsdat%robdata(NCM_VAR, index) = value
  case ('OMP '); obsdat%robdata(NCM_OMP, index) = value
  case ('OMA '); obsdat%robdata(NCM_OMA, index) = value
  case ('OER '); obsdat%robdata(NCM_OER, index) = value
  case ('HPHT'); obsdat%robdata(NCM_HPHT,index) = value
  case ('ZHA '); obsdat%robdata(NCM_ZHA, index) = value
  case ('POB '); obsdat%robdata(NCM_POB, index) = value
  case ('OMF '); obsdat%robdata(NCM_OMF, index) = value
  case ('OMI '); obsdat%robdata(NCM_OMI, index) = value
  case ('OMN '); obsdat%robdata(NCM_OMN, index) = value
  case ('RER '); obsdat%robdata(NCM_RER, index) = value
  case ('FGE '); obsdat%robdata(NCM_FGE, index) = value
  case ('PER '); obsdat%robdata(NCM_PER, index) = value
  case ('PRM '); obsdat%robdata(NCM_PRM, index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a real(4) observation."
  end select
 end subroutine obs_set_r4


 subroutine obs_set_r8(obsdat, name, index, value)
!s/r obs_set_r8 - set a double value in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  real(kind=8)    , intent(in)     :: value

  select case (name(1:4))
  case ('PPP '); obsdat%robdata8(NCM_PPP, index) = value
  case ('PRL '); obsdat%robdata8(NCM_PRL, index) = value
  case ('POB '); obsdat%robdata8(NCM_POB, index) = value
  case ('VAR '); obsdat%robdata8(NCM_VAR, index) = value
  case ('OMF '); obsdat%robdata8(NCM_OMF, index) = value
  case ('OMA '); obsdat%robdata8(NCM_OMA, index) = value
  case ('OMI '); obsdat%robdata8(NCM_OMI, index) = value
  case ('OMN '); obsdat%robdata8(NCM_OMN, index) = value
  case ('OER '); obsdat%robdata8(NCM_OER, index) = value
  case ('RER '); obsdat%robdata8(NCM_RER, index) = value
  case ('FGE '); obsdat%robdata8(NCM_FGE, index) = value
  case ('PER '); obsdat%robdata8(NCM_PER, index) = value
  case ('PRM '); obsdat%robdata8(NCM_PRM, index) = value

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a real(8) observation."
  end select
 end subroutine obs_set_r8


 subroutine obs_set_c9(obsdat, name, index, value)
!s/r obs_set_c9 - set a character(len=9) in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs), intent(inout)  :: obsdat
  character(len=4), intent(in)     :: name
  integer         , intent(in)     :: index
  character(len=9), intent(in)     :: value

  select case (name(1:4))
  case ('STID'); obsdat%cstnid (index) = value !! // '   '

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not a character(len=9) observation."
  end select
 end subroutine obs_set_c9


 integer function obs_ifind(kbufrn)
  implicit none
!
  integer, intent(in) :: kbufrn
!
!      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
!               THAT CONTAINS A BUFR ELEMENT NUMBER
!
!    ARGUMENTS:
!               INPUT:
!                      -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
!                               i.e. known locally as the 'burp variable type'
!                               i.e. table B of the ECMWF BUFR reference
!                               BUFR = Binary Universal Form for the
!                                      Representation of meteorological data
!
!               OUTPUT:
!                      - obs_ifind:
!                                              THE FOUND INDEX (=-1 IF NOT FOUND)
!
!       AUTHOR: P. KOCLAS (CMC TEL. 4665)

  integer indbuf
  integer, parameter, dimension(OBS_JPNBRELEM) :: nvnumb = (/ &
    011003, 011004, 010194, 010192,     29, & !  1-10
    013208, 012063, 012001, 012192, 012004, &
    012203, 011215, 011216, 013210, 013220, & ! 11-20
        62, 015001,     64,     65, 015036, &
    015031, 015032,     69,     70,     71, & ! 21-30
        72,     73,     74,     75,     76, &
        77,     78,     79,     80,     81, & ! 31-40
        82,     83,     84,     85,     86, &
        87,     88,     89,     90,     91, & ! 41-50
    012163, 010004, 011001, 011002, 012062, &
    008001, 008004, 010051, 011011, 011012, & ! 51-57
        41,     42 /)


! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
!   Descriptions taken from 3d variational code (March 2011, revision 11.0.2)
!
!  1 =011003 (U COMPONENT)           (m/s)
!  2 =011004 (V COMPONENT)           (m/s)
!  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
!  4 =010192 (THICKNESS IN M)
!  5 =    29 (RELATIVE HUMIDITY)
!  6 =013208
!  7 =012063 BRIGHTNESS TEMPERATURE 1
!  8 =012001 (TEMPERATURE)            (kelvin)
!  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
! 10 =012004 (2M TEMPERATURE)
! 11 =012203 (2M DEW-POINT DEPRESSION)
! 12 =011215 SURFACE U     WIND COMPONENT M/S)
! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
! 16 =007006 HEIGHT ABOVE STATION (M)
! 17 =015001 (Total Ozone from TOVS)
! 18 =    64 (CM)
! 19 =    65 (CL)
! 20 =015036 (GPSRO REFRACTIVITY)
! 21 =015031 (GPSGB ZTD IN M)
! 22 =015032 (GPSGB ZTD ERROR IN M)
! 23 =    69 (C)
! 24 =    70 (NS)
! 25 =    71 (S)
! 26 =    72 (E)
! 27 =    73 (TGTG)
! 28 =    74 (SPSP)
! 29 =    75 (SPSP)
! 30 =    76 (RS)
! 31 =    77 (ESES)
! 32 =    78 (IS)
! 33 =    79 (TRTR)
! 34 =    80 (RR)
! 35 =    81 (JJ)
! 36 =    82 (VS)
! 37 =    83 (DS)
! 38 =    84 (HWHW)
! 39 =    85 (PWPW)
! 40 =    86 (DWDW)
! 41 =    87 (GENERAL CLOUD GROUP)
! 42 =    88 (RH FROM LOW CLOUDS)
! 43 =    89 (RH FROM MIDDLE CLOUDS)
! 44 =    90 (RH FROM HIGH CLOUDS)
! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
! 46 =012163 (TOVS LEVEL 1B RADIANCES)
! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
! 49 =011002(FF (WIND SPEED))                (m/s)
! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
! 51 =008001
! 52 =008004
! 53 =010051
! 54 =011011
! 55 =011012
! 56 =    41 (U AT 10M)
! 57 =    42 (V AT 10M)

  obs_ifind=-1
  do indbuf=1,OBS_JPNBRELEM
   if (nvnumb(indbuf) .EQ. kbufrn ) then
    obs_ifind=indbuf
    return
   endif
  enddo
  return

 end function obs_ifind


 SUBROUTINE obs_reduceToMpiLocal(obsdat, nobtot, nobtotp, nfiles, nbegintyp, &
                                 nendtyp, nbegintyp_g, nendtyp_g, l4dvar)
#if defined (DOC)
!
!**s/r obs_reduceToMpiLocal - re-construct observation data object by giving 
!                             local Obs TAG. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To retain in the observation object only those data that are
!                pertinent to the present mpi processor.
!
!
#endif

  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(inout) :: nobtot      ! Actual number of observations
  integer, intent(inout) :: nobtotp     ! Actual no. of obs. in POST FILE=nobtot
  integer, intent(in)    :: nfiles
  integer, intent(inout) :: nbegintyp(:), nendtyp(:)
  integer, intent  (out) :: nbegintyp_g(:), nendtyp_g(:)
  logical, intent(in)    :: l4dvar      ! Logical control of 3Dvar/4Dvar

! Declare Local Variables
  CHARACTER(len=9),ALLOCATABLE,DIMENSION(:) :: cstnid_tmp
  CHARACTER(len=2),ALLOCATABLE,DIMENSION(:) :: cfamily_tmp
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBHDR_tmp,ROBDATA_tmp
  REAL(8),ALLOCATABLE,DIMENSION(:,:) :: ROBDATA8_tmp
  REAL(8),allocatable :: timeInterpWeight_tmp(:,:)

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp,MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:) :: locObsTag_tmp 
  
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,ifamid,istart,idata,ii 
  LOGICAL :: lfirst 
!!---------------------------------------------------------------
  WRITE(*,*) '============= Enter obs_reduceToMpiLocal =============='

  if(obsdat%mpi_local .eqv. .true.)then
    write(*,*)'ERROR: obs_reduceToMpiLocal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-local state'
    call qqexit(1)
  end if
  obsdat%mpi_local = .true.

  locObsize=size(locObsTag) 

  ALLOCATE(cfamily_tmp(locObsize),STAT=ierr) 
  ALLOCATE(cstnid_tmp(locObsize),STAT=ierr) 
  ALLOCATE(ROBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA8_tmp(3:11,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(timeInterpWeight_tmp(locObsize,mxstepobs),STAT=ierr) 
!  
  call obs_allocateG(obsdat,nobtot)
!
!0.1  Sorting locObsTag according to the family ID. 
  IF(l4dvar) THEN
     ALLOCATE(locObsTag_tmp(locObsize),STAT=ierr)
     ii=0
     DO J=1,NFILES
        DO i=1,locObsize
           iobs=locObsTag(i) 
           ifamid=obsdat%mobhdr(NCM_OEC, iobs)
           if(j == ifamid) then
             ii=ii+1
             locObsTag_tmp(ii) = iobs 
           endif
        ENDDO 
     ENDDO 

     locObsTag=locObsTag_tmp
     DEALLOCATE(locObsTag_tmp)  
  ENDIF

  nobtotp=nobtot

!! keep the Global ROBHDR and MOBHDR
  DO iobs=1,nobtotp
    obsdat%MOBHDR_G(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,iobs)
    obsdat%ROBHDR_G(1:NCM_LET,iobs)=obsdat%ROBHDR(1:NCM_LET,iobs)
    obsdat%timeInterpWeight_mpiglobal(iobs,:)=obsdat%timeInterpWeight(iobs,:)
  ENDDO  
!!
  DO i=1,locObsize 
    iobs=locObsTag(i) 
    ROBHDR_tmp(1:NCM_LET,i)=obsdat%ROBHDR(1:NCM_LET,iobs)
    MOBHDR_tmp(1:NCM_LET,i)=obsdat%MOBHDR(1:NCM_LET,iobs)
    cstnid_tmp(i) = obsdat%cstnid(iobs)
    cfamily_tmp(i) = obsdat%cfamily(iobs) 
    timeInterpWeight_tmp(i,:)=obsdat%timeInterpWeight(iobs,:)
    IF(i== 1) THEN
       MOBHDR_tmp(NCM_RLN,1) = 1
    ELSE
       MOBHDR_tmp(NCM_RLN,i)=MOBHDR_tmp(NCM_RLN,i-1) + MOBHDR_tmp(NCM_NLV,i-1) 
    ENDIF 
  ENDDO !  


  ii=0 
  DO i=1,locObsize
    iobs=locObsTag(i) 
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
    DO j=idata,idataend 
       ii=ii+1 
       ROBDATA8_tmp(3:11,ii)=obsdat%ROBDATA8(3:11,j)
       MOBDATA_tmp(1:NCM_LBO,ii)=obsdat%MOBDATA(1:NCM_LBO,j) 
       ROBDATA_tmp(1:NCM_LBO,ii)=obsdat%ROBDATA(1:NCM_LBO,j) 
       MOBDATA_tmp(NCM_OBS,ii) = i
    ENDDO 
  ENDDO 
  
  nobtot=locObsize
  obsdat%numstns_recorded=nobtot
  obsdat%numobs_recorded=obsdat%numobs_recorded_l
  write(*,*) 'NOBTOT= ',nobtot 
  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtot,obsdat%numobs_recorded)
!
  DO i=1,nobtot
     obsdat%cfamily(i)=cfamily_tmp(i) 
     obsdat%cstnid(i)=cstnid_tmp(i)
     obsdat%ROBHDR(1:NCM_LET,i)=ROBHDR_tmp(1:NCM_LET,i)
     obsdat%MOBHDR(1:NCM_LET,i)=MOBHDR_tmp(1:NCM_LET,i) 
     obsdat%timeInterpWeight(i,:)=timeInterpWeight_tmp(i,:)
  ENDDO 

  DO i=1,obsdat%numobs_recorded
     obsdat%ROBDATA8(3:11,i)=ROBDATA8_tmp(3:11,i) 
     obsdat%MOBDATA(1:NCM_LBO,i)=MOBDATA_tmp(1:NCM_LBO,i) 
     obsdat%ROBDATA(1:NCM_LBO,i)=ROBDATA_tmp(1:NCM_LBO,i)
  ENDDO 

  deallocate(cfamily_tmp)
  deallocate(cstnid_tmp)
  deallocate(ROBHDR_tmp)
  deallocate(MOBHDR_tmp)
  deallocate(ROBDATA8_tmp)
  deallocate(MOBDATA_tmp)
  deallocate(ROBDATA_tmp)
  deallocate(timeInterpWeight_tmp)

 ! rebuild NBEGINTYP and NENDTYP  
 !============================
  jj=0
  NBEGINTYP_G=NBEGINTYP
  NENDTYP_G=NENDTYP
 
  NBEGINTYP=0
  NENDTYP=0
  DO j=1,NFILES
    lfirst=.true. 
    DO i=1,locObsize
      istart=obsdat%mobhdr(NCM_RLN, i)
      idata=obsdat%mobhdr(NCM_NLV, i)
      ifamid=obsdat%mobhdr(NCM_OEC, i)
      IF(ifamid == J) THEN
         IF(lfirst) THEN
           NBEGINTYP(j) = istart 
           lfirst=.false. 
         ENDIF 
         JJ=JJ+idata 
      ENDIF 
    ENDDO 
    NENDTYP(J) = JJ 
    IF(NBEGINTYP(j) == 0)  NENDTYP(J) = 0
    WRITE(*,*) 'J NBEGINTYP(j) NENDTYP(j)= ',J,NBEGINTYP(j), NENDTYP(j),ifamid
  ENDDO  
  
  WRITE(*,*) '============= Leave obs_reduceToMpiLocal =============='
!!
  RETURN
 END SUBROUTINE obs_reduceToMpiLocal


 SUBROUTINE obs_expandToMpiGlobal(obsdat, nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global observation object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in) :: nulout         ! standard output unit
  integer, intent(in) :: nobtot         ! Actual number of observations
  integer, intent(in) :: nobtotp        ! Actual no. of obs. in POST FILE=nobtot

! Declaire Local Variables. 
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBDATA_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp 
  
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,idata,ii,sizeMOBDATA  
  INTEGER ::sizeMOBHDR  
!!---------------------------------------------------------------

!!1.      Release some memory
  print*,'Entering obs_expandToMpiGlobal'

  if(obsdat%mpi_local .eqv. .false.)then
    write(*,*)'ERROR: obs_expandToMpiGlobal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-global state'
    call qqexit(1)
  end if
  obsdat%mpi_local = .false.

!!1.2 Added restore global array MOBHDR
!     MOBHDR is used in "cmaabrp.ftn"
  ALLOCATE(MOBHDR_tmp(NCM_LET,NOBTOTP),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cant allocate Mem. to MOBHDR_tmp,Abort!')
  MOBHDR_TMP=0

! 1.3 retore global MOBHDR
  DO i=1,NOBTOT
     iobs=locObsTag(i)
     MOBHDR_tmp(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,i)
  ENDDO
  sizeMOBHDR=size(MOBHDR_tmp)
  CALL RPN_COMM_ALLReduce(MOBHDR_tmp,MOBHDR_tmp,sizeMOBHDR,"mpi_integer", &
                          "mpi_sum","GRID",ierr)


!!2.  Allocate memory for the temporary arrays.
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cant allocate Mem. to MOBDATA_tmp,Abort!')
  MOBDATA_tmp=0

  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr)
  IF(ierr /= 0) call  obs_abort('Cant allocate Mem. to ROBDATA_tmp,Abort!')
  ROBDATA_tmp=0.0

!3.  Restore the global arrays MOBDATA and ROBDATA
  ii=0
  DO i=1,nobtot
    iobs=locObsTag(i)
    idata= obsdat%mobhdr_g(NCM_RLN, iobs)
    idataend = obsdat%mobhdr_g(NCM_NLV, iobs) + idata -1
    DO j=idata,idataend
       ii=ii+1
       MOBDATA_tmp(1:NCM_LBO,j)=obsdat%MOBDATA(1:NCM_LBO,ii)
       ROBDATA_tmp(1:NCM_LBO,j)=obsdat%ROBDATA(1:NCM_LBO,ii)
    ENDDO
  ENDDO
   !
   ! Merge the global arrays MOBDATA_tmp and ROBDATA_tmp.
  sizeMOBDATA=size(MOBDATA_tmp)
  CALL RPN_COMM_ALLReduce(MOBDATA_tmp,MOBDATA_tmp,sizeMOBDATA,"mpi_integer",&
                          "mpi_sum","GRID",ierr)
  CALL RPN_COMM_ALLReduce(ROBDATA_tmp,ROBDATA_tmp,sizeMOBDATA,"mpi_real",&
                          "mpi_sum","GRID",ierr)
   !

  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtotp,obsdat%mxobstotal)

  obsdat%ROBDATA=ROBDATA_tmp
  DEALLOCATE(ROBDATA_tmp)
  obsdat%MOBDATA=MOBDATA_tmp
  DEALLOCATE(MOBDATA_tmp)
  obsdat%MOBHDR=MOBHDR_tmp
  DEALLOCATE(MOBHDR_tmp)

!!
  call obs_deallocateG(obsdat)
!!
  print*,'Leaving obs_expandToMpiGlobal'
  RETURN
 END SUBROUTINE obs_expandToMpiGlobal


end module obsSpaceData_mod
