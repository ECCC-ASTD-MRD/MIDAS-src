MODULE obsSpaceData_mod
  implicit none
  save
  private

  ! main observation space data instance
  public           :: obsSpaceData
  public           :: OBS_JPNBRELEM
  public           :: locObsTag

  ! header column numbers
  public           :: NCM_LET, NCM_RLN, NCM_ONM, NCM_BOX, NCM_OTP, NCM_ITY,  &
                      NCM_LAT, NCM_LON, NCM_DAT, NCM_ETM, NCM_SID, NCM_ALT,  &
                      NCM_NLV, NCM_OEC, NCM_OFL, NCM_ST1, NCM_TLA, NCM_AZA,  &
                      NCM_SUN, NCM_CLF, NCM_REG, NCM_PAS, NCM_IP,  NCM_BX,   &
                      NCM_BY,  NCM_BZ

  ! body column numbers
  public           :: NCM_LBO, NCM_VNM, NCM_PPP, NCM_PRL, NCM_POB, NCM_VAR,  &
                      NCM_OMF, NCM_OMA, NCM_OMI, NCM_OMN, NCM_OER, NCM_RER,  &
                      NCM_FGE, NCM_PER, NCM_FLG, NCM_POS, NCM_LYR, NCM_ASS,  &
                      NCM_XTR, NCM_OBS, NCM_LOBS,NCM_VCO, NCM_PRM, NCM_KFA,  &
                      NCM_ZHA, NCM_HPHT,NCM_OMP

  ! methods
  public           :: obs_initialize,obs_finalize
  public           :: obs_elem_i,obs_elem_r4,obs_elem_r8,obs_elem_c9,obs_set
  public           :: obs_num_obstotal,obs_num_stn,obs_swapVarOmf,obs_ifind
  public           :: obs_getFamily,obs_setFamily,obs_bdy,obs_getobstag
  public           :: obs_reduceToMpiLocal,obs_expandToMpiGlobal

  ! private methods
  !                obs_allocate, obs_deallocate, obs_allocateG, obs_deallocateG
  !                obs_abort

  ! derived type and module variable declarations

  type struct_obs
   character(len=9),  pointer, dimension(:)   :: cstnid   !! need len=12 for EnKF
   character(len=2),  pointer, dimension(:)   :: cfamily
   real(kind=4),      pointer, dimension(:,:) :: robhdr
   integer,           pointer, dimension(:,:) :: mobhdr
   real(kind=4),      pointer, dimension(:,:) :: robdata
   real(kind=8),      pointer, dimension(:,:) :: robdata8
   integer,           pointer, dimension(:,:) :: mobdata
   integer :: numstns_recorded          ! Actual number of stations on record
   integer :: mxstntotal                ! maximum number of stations
   integer :: numobs_recorded           ! Actual total number of data on record
   integer :: mxobstotal                ! maximum number observations

                                        ! Size of the mpi-Local obs data
   integer                                    :: numobs_recorded_l
                                        ! Headers of the mpi-Global obs data
   integer,           pointer, dimension(:,:) :: mobhdr_g
   real(kind=4),      pointer, dimension(:,:) :: robhdr_g

   logical :: mpi_local                 ! T: keep only data needed by this PE
  end type struct_obs

  type(struct_obs) :: obsSpaceData

  integer, pointer, dimension(:) :: locObsTag

  ! header column numbers
  integer,parameter :: NCM_LET = 22 ! Dimension for var3d
  integer,parameter :: NCM_RLN = 1
  integer,parameter :: NCM_ONM = 2
  integer,parameter :: NCM_BOX = 3
  integer,parameter :: NCM_OTP = 4
  integer,parameter :: NCM_ITY = 5
  integer,parameter :: NCM_LAT = 6
  integer,parameter :: NCM_LON = 7
  integer,parameter :: NCM_DAT = 8
  integer,parameter :: NCM_ETM = 9
  integer,parameter :: NCM_SID = 10
  integer,parameter :: NCM_ALT = 11
  integer,parameter :: NCM_NLV = 12
  integer,parameter :: NCM_OEC = 13
  integer,parameter :: NCM_OFL = 14
  integer,parameter :: NCM_ST1 = 15
  integer,parameter :: NCM_TLA = 16
  integer,parameter :: NCM_AZA = 20
  integer,parameter :: NCM_SUN = 21
  integer,parameter :: NCM_CLF = 22
! integer,parameter :: NCM_STID=    ! Not needed since only 1 cstnid exists
! integer,parameter :: NCM_FAM =    ! Not needed since only 1 cfamily exists
! These values are used only by EnKF, and not by var3d
  integer,parameter :: NCM_REG = 23
  integer,parameter :: NCM_PAS = 24
  integer,parameter :: NCM_IP  = 25
  integer,parameter :: NCM_BX  = 26
  integer,parameter :: NCM_BY  = 27
  integer,parameter :: NCM_BZ  = 28

  ! body column numbers
  integer,parameter :: NCM_LBO = 22
  integer,parameter :: NCM_VNM = 1
  integer,parameter :: NCM_POB = 2
  integer,parameter :: NCM_PRL = 3
  integer,parameter :: NCM_PPP = 4
  integer,parameter :: NCM_VAR = 5
  integer,parameter :: NCM_OMF = 6
  integer,parameter :: NCM_OMA = 7
  integer,parameter :: NCM_OMI = 8
  integer,parameter :: NCM_OMN = 9
  integer,parameter :: NCM_OER = 10
  integer,parameter :: NCM_PRM = 11
  integer,parameter :: NCM_RER = 12
  integer,parameter :: NCM_FGE = 13
  integer,parameter :: NCM_PER = 14
  integer,parameter :: NCM_FLG = 15
  integer,parameter :: NCM_POS = 16
  integer,parameter :: NCM_LYR = 17
  integer,parameter :: NCM_ASS = 18
  integer,parameter :: NCM_XTR = 19
  integer,parameter :: NCM_OBS = 20
  integer,parameter :: NCM_LOBS= 21
  integer,parameter :: NCM_VCO = 22
! added for EnKF
  integer,parameter :: NCM_KFA = 23
  integer,parameter :: NCM_ZHA = 24
  integer,parameter :: NCM_HPHT= 26
  integer,parameter :: NCM_OMP = 25

  integer, parameter :: OBS_JPNBRELEM = 57

  integer, parameter :: ROBDATA8_LOWER = NCM_POB
  integer, parameter :: ROBDATA8_UPPER = NCM_PER

  contains


  subroutine obs_initialize(obsdat,mxstn,mxobs)
    implicit none

    type(struct_obs), intent(out) :: obsdat
    integer, intent(in) :: mxstn        ! maximum number of stations allocated
    integer, intent(in) :: mxobs        ! maximum no. of observations per source

    obsdat%mxstntotal=mxstn
    obsdat%mxobstotal=mxobs
    obsdat%numstns_recorded = 0
    obsdat%numobs_recorded  = 0
    obsdat%mpi_local = .false.

    obsdat%numobs_recorded_l = 0
    nullify(obsdat%mobhdr_g)
    nullify(obsdat%robhdr_g)

    call obs_allocate(obsdat,mxstn,mxobs)
    return
  end subroutine obs_initialize


  subroutine obs_finalize(obsdat)
    implicit none
    type(struct_obs), intent(inout) :: obsdat

    call obs_deallocate(obsdat)
    call obs_deallocateG(obsdat)
  end subroutine obs_finalize


  subroutine obs_allocate(obsdat,mxstn,mxobs)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)  :: mxstn,mxobs

    integer :: ierr

    ALLOCATE(obsdat%cfamily(mxstn),STAT=ierr)
    obsdat%cfamily(:)='XX'

    ALLOCATE(obsdat%cstnid(mxstn),STAT=ierr)
    obsdat%cstnid(:)='XXXXXXXXX' !! // 'XXX'   needed for EnKF

    ALLOCATE(obsdat%ROBHDR(NCM_LET,mxstn),STAT=ierr)
    obsdat%ROBHDR=0.0

    ALLOCATE(obsdat%MOBHDR(NCM_LET,mxstn),STAT=ierr)
    obsdat%MOBHDR=0

    ALLOCATE(obsdat%ROBDATA(NCM_LBO,mxobs),STAT=ierr)
    obsdat%ROBDATA=0.0

    ALLOCATE(obsdat%ROBDATA8(ROBDATA8_LOWER:ROBDATA8_UPPER,mxobs),STAT=ierr)
    obsdat%ROBDATA8=0.0D0

    ALLOCATE(obsdat%MOBDATA(NCM_LBO,mxobs),STAT=ierr)
    obsdat%MOBDATA=0

  end subroutine obs_allocate

  subroutine obs_allocateG(obsdat,maxNumHdr)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    integer         , intent(in)    :: maxNumHdr

    integer :: ierr

    ALLOCATE(obsdat%ROBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%ROBHDR_g=0.0

    ALLOCATE(obsdat%MOBHDR_g(NCM_LET,maxNumHdr),STAT=ierr)
    obsdat%MOBHDR_g=0

  end subroutine obs_allocateG


  subroutine obs_deallocateG(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%robhdr_g)) then
      deallocate(obsdat%robhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR_g. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr_g)) then
      deallocate(obsdat%mobhdr_g,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR_g checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR_g. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocateG


  subroutine obs_deallocate(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    integer :: ierr

    if (associated(obsdat%cfamily)) then
      deallocate(obsdat%cfamily,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CFAMILY checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CFAMILY. IERR =',ierr
      endif
    end if

    if (associated(obsdat%cstnid))then
      deallocate(obsdat%cstnid,STAT=ierr)
      if(ierr.eq.0) then
        write(*,*) 'CSTNID checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in CSTNID. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robhdr))then
      deallocate(obsdat%robhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobhdr))then
      deallocate(obsdat%mobhdr,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBHDR checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBHDR. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata))then
      deallocate(obsdat%robdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA. IERR =',ierr
      endif
    end if

    if (associated(obsdat%robdata8))then
      deallocate(obsdat%robdata8,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'ROBDATA8 checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in ROBDATA8. IERR =',ierr
      endif
    end if

    if (associated(obsdat%mobdata))then
      deallocate(obsdat%mobdata,stat=ierr)
      if(ierr.eq.0) then
        write(*,*) 'MOBDATA checked and correct. IERR =',ierr
      else
        write(*,*) 'Problem detected in MOBDATA. IERR =',ierr
      endif
    end if

  end subroutine obs_deallocate


  subroutine obs_abort(cdmessage)
#if defined (DOC) 
*
***s/r OBS_ABORT  - Abort a job on error
*
*
*Author  : P. Gauthier *ARMA/AES  June 9, 1992
*Revision:
*     . P. Gauthier *ARMA/AES  January 29, 1996 
*     . P. Koclas   CMC/CMSV   January  1997 
*         -add call to abort
*     . S. Pellerin ARMA/SMC   October 2000
*         - replace call to abort for call to exit(1)
*     . C. Charette ARMA/SMC   October 2001
*         - replace SUTERM by SUTERMF to only close files
*     . J. Blezius  import ABORT3D into obsspacedata_mod as OBS_ABORT
*         - delete call to SUTERMF
*    -------------------
**    Purpose:
*     To stop a job when an error occurred
*
*Arguments
*     i     CDMESSAGE: message to be printed
#endif

      implicit none
      character(len=*) cdmessage

      write(*,'(//,4X,"ABORTING IN ObsSpaceData_mod:-------",/,8X,A)')cdmessage

      call qqexit(1)

      stop
  end subroutine obs_abort


  subroutine obs_swapVarOmf(obsdat)
    implicit none

    type(struct_obs), intent(inout) :: obsdat

    real(kind=4),allocatable :: temp_robdata(:)
    real(kind=8),allocatable :: temp_robdata8(:)
    integer                  :: ierr

!    temp = NCM_VAR
!    NCM_VAR = NCM_OMF
!    NCM_OMF = temp

    allocate(temp_robdata (lbound(obsdat%robdata ,2):ubound(obsdat%robdata ,2)),stat=ierr)
    temp_robdata(:)=obsdat%robdata(NCM_VAR,:)
    obsdat%robdata(NCM_VAR,:)=obsdat%robdata(NCM_OMF,:)
    obsdat%robdata(NCM_OMF,:)=temp_robdata(:)
    deallocate(temp_robdata)

    allocate(temp_robdata8(lbound(obsdat%robdata8,2):ubound(obsdat%robdata8,2)),stat=ierr)
    temp_robdata8(:)=obsdat%robdata8(NCM_VAR,:)
    obsdat%robdata8(NCM_VAR,:)=obsdat%robdata8(NCM_OMF,:)
    obsdat%robdata8(NCM_OMF,:)=temp_robdata8(:)
    deallocate(temp_robdata8)

  end subroutine obs_swapVarOmf


  function obs_getFamily(obsdat,headerIndex,bodyIndex)
    implicit none

    character(len=2)             :: obs_getFamily
    type(struct_obs), intent(in) :: obsdat
    integer,optional, intent(in) :: headerIndex,bodyIndex

    integer          :: headerIndex2

    if(present(headerIndex)) then
      obs_getFamily=obsdat%cfamily(headerIndex)
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obs_getFamily=obsdat%cfamily(headerIndex2)
    else
      write(*,*) 'OBS_GETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call exit(-1)
    endif

  end function obs_getFamily


  subroutine obs_setFamily(obsdat,Family_in,headerIndex,bodyIndex)
    implicit none

    type(struct_obs), intent(inout) :: obsdat
    character(len=2), intent(in)    :: Family_in
    integer,optional, intent(in)    :: headerIndex,bodyIndex

    integer          :: headerIndex2
    
    if(present(headerIndex)) then
      obsdat%cfamily(headerIndex)=Family_in
    elseif(present(bodyIndex)) then
      headerIndex2=obs_elem_i(obsdat,'OBS ',bodyIndex)
      obsdat%cfamily(headerIndex2)=Family_in
    else
      write(*,*) 'OBS_SETFAMILY: Header or Body index must be specified!'
      call flush(6)
      call exit(-1)
    endif

  end subroutine obs_setFamily


  SUBROUTINE obs_bdy(obsdat,PVALUES,KLIST,KFLAGS,LDFLAG,PROFIL,LDERR,LDSAT, &
                    LDGO,LDAIRS,LDIASI,n_elements_in_block, &
                    n_levels_in_block,KNT,KNDAT,KVCORD,PVCORD, &
                    KINDEX,KIDTYP,PPMIS,nvcordtyp,vcordsf, &
                    vconv,nonelev)
    IMPLICIT NONE
!
    type(struct_obs), intent(inout) :: obsdat
    INTEGER, intent(out) :: KNDAT
    INTEGER, intent(in)  :: n_elements_in_block,n_levels_in_block,KNT
    INTEGER, intent(in)  :: KVCORD,KINDEX,KIDTYP
    INTEGER, intent(in)  :: KLIST(n_elements_in_block)
    INTEGER, intent(in)  :: KFLAGS(n_elements_in_block,n_levels_in_block,KNT)
    integer, intent(in)  :: nvcordtyp,nonelev
!
    REAL(kind=8),intent(in)::PVALUES(n_elements_in_block,n_levels_in_block,KNT)
    REAL(kind=8),intent(in)::PVCORD(n_levels_in_block)
    REAL(kind=8),intent(in)::PROFIL(n_levels_in_block)
    REAL(kind=8),intent(in)::PPMIS
    real(kind=8),intent(in)::vconv
                                        ! vertical coordinate parameters
                                        ! for surface data
    real(kind=8),intent(in)::vcordsf(:,:)
!
    LOGICAL, intent(in) :: LDFLAG,LDERR,LDSAT,LDGO,LDAIRS,LDIASI
!
#if defined (DOC)
!***********************************************************************
!
!***s/r OBS_BDY -FILL BODY OF CMA REPORT
!
!Author    . P. KOCLAS(CMC TEL. 4665)
!
!Revision:
!          . P. Koclas *CMC/AES Sept  1994: Add call to cvt3d
!          .   before insertion of U and V for consistency
!          . P. Koclas *CMC/AES February  1995:
!          .  New call sequence neccessary to :
!          . -allow insertion of "grouped data" records in BURP files.
!          . -allow data observed in various vertical coordinates
!          . -observation errors no longer initialized
!
!          . P. Koclas *CMC/AES March     1995:
!            -Additions for humsat and satem data
!          .
!          . C. Charette *ARMA Jan        2001
!            -Max value for T-Td surface element(12203)
!
!           JM Belanger CMDA/SMC  Feb 2001
!                   . 32 bits conversion
!          . P. Koclas *CMC/CMDA Sept     2001:
!            -set first-guess and observation errors to missing values
!
!          .N Wagneur CMDA/SMC  Jine 2002
!                   . -Additions for goes data
!          . P. Koclas *CMC/CMDA Dec      2003:
!                -conversion for surface wind
!          . C. Charette *ARMA/SMC Apr      2005:
!                -Set flag bit #12 (Element assimilated by analysis) to zero
!                 (see banco-burp documentation for more detail)
!          . A. Beaulne *CMDA/SMC  Aug 2006
!                     -Additions for AIRS data
!          . S. Heilliette
!                     -Additions for IASI data
!
!
!    PURPOSE : TRANSFER DATA BLOCKS EXTRACTED FROM CMC BURP FILES TO
!              THE IN-CORE FORMAT (CMA) OF THE 3-D VARIATIONAL ANALYSIS
!
!    ARGUMENTS:
!     INPUT:
!
!           -PVALUES : DATA BLOCK
!           -KLIST   : LIST OF BUFR ELEMENTS
!           -KFLAGS  : QUALITY CONTROL FLAGS
!
!           -LDFLAG  :  .TRUE. --> INSERT FLAGS IN CMA
!                      .FALSE. --> INSERT DUMMY VALUE(2**12)
!           -LERR    :  .TRUE. --> INSERT OBS ERROR IN CMA (HUMSAT DATA)
!           -LDSAT   :  .TRUE. --> INSERT REF PRESSURE IN CMA (SATEMS)
!           -LDGO    :  .TRUE. --> INSERT EMISSIVITIES IN CMA (GOES RADIANCES)
!           -LDAIRS  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (AIRS RADIANCES)
!           -LDIASI  :  .TRUE. --> INSERT EMISSIVITIES IN CMA (IASI RADIANCES)
!
!           -n_elements_in_block  : NUMBER OF ELEMENTS IN DATA BLOCK
!           -n_levels_in_block    : NUMBER OF LEVELS IN DATA BLOCK
!           -KNT     :  THIRD DIMENSION OF DATA BLOCK
!           -KNDAT   :  THIRD DIMENSION OF DATA BLOCK
!           -KVCORD  :  BUFR ELEMENT CODE OF VERTICAL COORDINATE
!           -PVCORD  :  VERTICAL COORDINATE VALUES EXTRACTED FROM DATA BLOCK
!           -KINDEX  :  THIRD DIMENSION INDEX OF DATA BLOCK
!           -PPMIS   :  VALUE OF MISSING DATA
!           -VCONV   :  CONVERSION FACTOR FOR PRESSURE CO-ORDINATE
!
!    OUTPUT:
!           -KNDAT   : NUMBER OF DATA INSERTED IN CMA FILE
!
!***********************************************************************
#endif

#include "comcst.cdk"

    INTEGER ILEM,IND,IIND,IP,IK
    INTEGER IBAD,IFLAG
    INTEGER ielement,ilevel
    INTEGER ZESMAX,ZES
!
    REAL(kind=8) ZTORAD,ZFACT,padd,pmul,ZEMFACT,pvalue
!
!***********************************************************************
!     SET BAD FLAG VALUE IIND AND UNIT CONVERSION CONSTANTS
!***********************************************************************
!
    IIND  =-1
    IBAD=2**11
    ZTORAD=RPI/180.
!
    ZFACT=VCONV
!
    ZEMFACT=0.01
    ZESMAX=30.
!
    IP=obsdat%numobs_recorded + 1
    IND=0
!
!***********************************************************************
!     PUT ALL NON MISSING DATA IN CMA FILE
!     EXIT IF THERE IS MORE DATA AVAILABLE THAN ALLOCATED TO CMA FILE
!     DATA IS CONVERTED TO UNITS USED BY 3D-VAR ANALYSIS.
!***********************************************************************
!
    IK= KINDEX
       DO ielement=1,n_elements_in_block
          ILEM=obs_ifind(KLIST(ielement))
          IF ( (ILEM .GT. 0) .AND. (KLIST(ielement) .NE. KVCORD) ) THEN
             DO ilevel=1,n_levels_in_block
               if(pvcord(ilevel) .ne. ppmis .and. (nonelev .eq. -1 .or. &
                    nonelev .eq. nint(pvcord(ilevel)*zfact))) then
                      IF  ( PVALUES (ielement,ilevel,IK) .NE. PPMIS ) THEN
                         pvalue=PVALUES(ielement,ilevel,IK)
                         IF ( IP + IND .LE. obsdat%mxobstotal ) THEN
!                                       VERTICAL COORDINATE
                            obsdat%robdata8(NCM_PPP,IP+IND)=PVCORD(ilevel)*ZFACT +vcordsf(ilem,kidtyp)
!
!                           FOR PNM HEIGHT IS SET TO 0
!                           ----------------------------
                            IF ( ILEM .EQ. 53 ) THEN
                               obsdat%robdata8(NCM_PPP,IP+IND)=0.D0
                            ENDIF
!                           ----------------------------
!
!                           IF ( ILEM .EQ. 2 ) Units:  V
!                                        CONVERT TO GZ
                            IF ( ILEM .EQ. 3 ) THEN
                             pvalue=RG*pvalue
                            ENDIF
!                           IF ( ILEM .EQ. 4 ) Units: METERS
!                           IF ( ILEM .EQ. 8 ) Units:  CELSIUS
!                                  Max value T-Td upper air
                            IF ( ILEM .EQ. 9 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    Max value T-Td surface
                            IF ( ILEM .EQ. 11 ) THEN
                             IF ( pvalue .GT. ZESMAX) THEN
                                  pvalue=ZESMAX
                             ENDIF
                            ENDIF
!                                    CONVERT TO RADIANS
                            IF ( ILEM .EQ. 48 .OR. ILEM .EQ. 54 ) THEN
                             pvalue=ZTORAD*pvalue
                            ENDIF
!                                       FLAGS
                            IF  (LDFLAG) THEN
!                                 SET BIT 12  TO ZERO
!                                 (Element assim by 3dvar)
                               IFLAG = KFLAGS(ielement,ilevel,IK)
                               IFLAG = IBCLR(IFLAG,12)
                               obsdat%mobdata(NCM_FLG,IP+IND)= IFLAG
                            ELSE
                               obsdat%mobdata(NCM_FLG,IP+IND)= IBAD
                            ENDIF
!
                            obsdat%robdata8(NCM_VAR,IP+IND)=pvalue
                            obsdat%mobdata (NCM_VNM,IP+IND)=KLIST(ielement)
                            obsdat%mobdata (NCM_VCO,IP+IND)=NVCORDTYP
                            obsdat%robdata8(NCM_OMF,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMA,IP+IND)=PPMIS
                            obsdat%robdata8(NCM_OMI,IP+IND)=PPMIS
                            obsdat%robdata (NCM_FGE,IP+IND)=real(PPMIS)
                            obsdat%robdata8(NCM_OER,IP+IND)=PPMIS
!
!                           OBS ERROR FOR HUMSAT
!
                            IF ( LDERR ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)
                            ENDIF
!
!                           REFERENCE LEVEL FOR SATEMS
!
                            IF ( LDSAT ) THEN
                              obsdat%robdata8(NCM_OER,IP+IND)=PROFIL(ilevel)*ZFACT
                              obsdat%robdata8(NCM_OER,IP+IND)=1.0D0
                            ENDIF
!
!                           SURFACE EMISSIVITIES FOR GOES AIRS AND IASI RADIANCES
!
                            IF ( LDGO ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            ENDIF

                            IF ( LDAIRS ) THEN
                              obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                   *ZEMFACT
                            END IF

                            IF ( LDIASI ) THEN
                               obsdat%robdata8(NCM_PRL,IP+IND)=PROFIL(ilevel) &
                                    *ZEMFACT
                            END IF

!
                            IND=IND + 1
                         ELSE
!==================================================
                            KNDAT = IND
                            obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!==================================================
                            RETURN
                         ENDIF
                      ENDIF
                ENDIF
             END DO
          ENDIF
       END DO
!=============================
    KNDAT = IND
    obsdat%numobs_recorded = obsdat%numobs_recorded + KNDAT
!=============================
!
    RETURN
!
  END SUBROUTINE obs_bdy


 real(kind=4) function obs_elem_r4(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('LAT '); value=obsdat%robhdr(NCM_LAT, index)
  case ('LON '); value=obsdat%robhdr(NCM_LON, index)
  case ('ALT '); value=obsdat%robhdr(NCM_ALT, index)
  case ('BX  '); value=obsdat%robhdr(NCM_BX , index)
  case ('BY  '); value=obsdat%robhdr(NCM_BY , index)
  case ('BZ  '); value=obsdat%robhdr(NCM_BZ , index)

  case ('PPP '); value=obsdat%robdata(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata(NCM_PRL, index)
  case ('VAR '); value=obsdat%robdata(NCM_VAR, index)
  case ('OMP '); value=obsdat%robdata(NCM_OMP, index)
  case ('OMA '); value=obsdat%robdata(NCM_OMA, index)
  case ('OER '); value=obsdat%robdata(NCM_OER, index)
  case ('HPHT'); value=obsdat%robdata(NCM_HPHT,index)
  case ('ZHA '); value=obsdat%robdata(NCM_ZHA, index)
  ! Added for var3d
  case ('POB '); value=obsdat%robdata(NCM_POB, index)
  case ('OMF '); value=obsdat%robdata(NCM_OMF, index)
  case ('OMI '); value=obsdat%robdata(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata(NCM_OMN, index)
  case ('RER '); value=obsdat%robdata(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(4) observation."
   value=-999.
  end select
 end function obs_elem_r4

 real(kind=8) function obs_elem_r8(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  ! Added for var3d
  case ('PPP '); value=obsdat%robdata8(NCM_PPP, index)
  case ('PRL '); value=obsdat%robdata8(NCM_PRL, index)
  case ('POB '); value=obsdat%robdata8(NCM_POB, index)
  case ('VAR '); value=obsdat%robdata8(NCM_VAR, index)
  case ('OMF '); value=obsdat%robdata8(NCM_OMF, index)
  case ('OMA '); value=obsdat%robdata8(NCM_OMA, index)
  case ('OMI '); value=obsdat%robdata8(NCM_OMI, index)
  case ('OMN '); value=obsdat%robdata8(NCM_OMN, index)
  case ('OER '); value=obsdat%robdata8(NCM_OER, index)
  case ('RER '); value=obsdat%robdata8(NCM_RER, index)
  case ('FGE '); value=obsdat%robdata8(NCM_FGE, index)
  case ('PER '); value=obsdat%robdata8(NCM_PER, index)
  case ('PRM '); value=obsdat%robdata8(NCM_PRM, index)

  case default
   write(*,*)"ERROR:  ", name(1:4), " is not a real(8) observation."
   value=-999
  end select
 end function obs_elem_r8

 integer function obs_elem_i(obsdat,name,index) result(value)
  implicit none
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('RLN '); value=obsdat%mobhdr(NCM_RLN, index)
  case ('ONM '); value=obsdat%mobhdr(NCM_ONM, index)
  case ('BOX '); value=obsdat%mobhdr(NCM_BOX, index)
  case ('OTP '); value=obsdat%mobhdr(NCM_OTP, index)
  case ('ITY '); value=obsdat%mobhdr(NCM_ITY, index)
  case ('DAT '); value=obsdat%mobhdr(NCM_DAT, index)
  case ('ETM '); value=obsdat%mobhdr(NCM_ETM, index)
  case ('NLV '); value=obsdat%mobhdr(NCM_NLV, index)
  case ('OFL '); value=obsdat%mobhdr(NCM_OFL, index)
  case ('PAS '); value=obsdat%mobhdr(NCM_PAS, index)
  case ('REG '); value=obsdat%mobhdr(NCM_REG, index)
  case ('IP  '); value=obsdat%mobhdr(NCM_IP , index)
  case ('AZA '); value=obsdat%mobhdr(NCM_AZA, index)
  case ('SUN '); value=obsdat%mobhdr(NCM_SUN, index)
  case ('CLF '); value=obsdat%mobhdr(NCM_CLF, index)
  ! Added for var3d
  case ('SID '); value=obsdat%mobhdr(NCM_SID, index)
  case ('OEC '); value=obsdat%mobhdr(NCM_OEC, index)
  case ('ST1 '); value=obsdat%mobhdr(NCM_ST1, index)
  case ('TLA '); value=obsdat%mobhdr(NCM_TLA, index)

  case ('VNM '); value=obsdat%mobdata(NCM_VNM, index)
  case ('FLG '); value=obsdat%mobdata(NCM_FLG, index)
  case ('KFA '); value=obsdat%mobdata(NCM_KFA, index)
  case ('ASS '); value=obsdat%mobdata(NCM_ASS, index)
  case ('OBS '); value=obsdat%mobdata(NCM_OBS, index)
  case ('VCO '); value=obsdat%mobdata(NCM_VCO, index)
  ! Added for var3d
  case ('LBO '); value=obsdat%mobdata(NCM_LBO, index)
  case ('POS '); value=obsdat%mobdata(NCM_POS, index)
  case ('XTR '); value=obsdat%mobdata(NCM_XTR, index)
  case ('LOBS'); value=obsdat%mobdata(NCM_LOBS,index)
  case ('LYR '); value=obsdat%mobdata(NCM_LYR, index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not an integer observation."
   value=-999
  end select
 end function obs_elem_i


 function obs_elem_c9(obsdat,name,index) result(value)
  implicit none

  character(len=9) :: value
  type(struct_obs), intent(in)  :: obsdat
  character(len=4), intent(in)  :: name
  integer         , intent(in)  :: index

  select case (name(1:4))
  case ('STID'); value=obsdat%cstnid(index)

  case default
   write(*,*)"ERROR:  ", name(1:4)," is not character(len=9) observation."
   value='xxxxxxxxx'
  end select
 end function obs_elem_c9


 subroutine obs_getobstag(obsdat,nulout,nobtot,nfiles,cexc4dv,cfamtyp,nbegintyp, &
                      nendtyp,l4dvar)
#if defined (DOC)
!
!**s/r read local observation tag from GEM TLM-ADJ .
!
!Author  : Bin He *ARMA/MRB  Feb. 2009
!
!Revision:
!  
!Arguments: none
!
#endif
  use mpi
  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in) :: nulout         ! standard output unit
  integer, intent(in) :: nobtot         ! Actual number of observations
  integer, intent(in) :: nfiles
  character(len=128), intent(in) :: cexc4dv
  character(len=  2), intent(in) :: cfamtyp(:)
  integer, intent(in) :: nbegintyp(:), nendtyp(:)
  logical, intent(in) :: l4dvar         ! Logical control of 3Dvar/4Dvar

#include <prof_f.h>

!     Local Variables
  integer :: prof_wrrec,prof_rdrec
  integer :: ihdl,istat  
  character(len=2) :: cljx,cljy 
  character(len=512) :: clprof 

  integer ,allocatable,dimension(:) :: locObsTag_tmp  

  logical :: isExist_L
  integer ::  i,j, jj,k,ierr,interv,istart,iend   
  integer :: ibegin,ilast,ibeginob,ilastob
  integer :: length_l, iobs,idata 
  integer :: count
  real(8) :: a  
!-------------------------------------------------------------
  write(nulout,*) '-------- Start obs_getobstag ---------'
  IF(l4dvar) THEN
     write(cljx,'(i2.2)') mpi_myidx
     write(cljy,'(i2.2)') mpi_myidy

     clprof = trim(CEXC4DV) // '/obstag_'//cljx//'_'//cljy//'.prof'
     WRITE(*,*) 'Open File: ',clprof 
     count=0
     waiting: DO 
        INQUIRE(FILE=clprof,EXIST=isExist_L)
        if(isExist_L .and. (count>50000) ) EXIT 
        count=count+1
     ENDDO waiting

     ihdl= prof_open(clprof,'READ','FILE')
     If(ihdl < 0) call obs_abort('obs_getobstag')
     istat= prof_rdrec(ihdl) 
     istat= prof_gvar(ihdl,locObsTag,V2D_OTAG) 
       
     istat= prof_close(ihdl,.true.) 
     length_l=size(locObsTag) 
!-------------------------------------------------------------
  ELSE ! not l4dvar
    jj=0
    IF(mpi_nprocs == 0) mpi_nprocs=1
    WRITE(nulout,*) 'nobtot= ',nobtot 
    ALLOCATE(locObsTag_tmp(nobtot),STAT=ierr)
    DO J=1,NFILES
       ibegin= NBEGINTYP(j)
       ilast = NENDTYP(j) 

       ibeginob=obsdat%mobdata(NCM_OBS, ibegin)
       ilastob=obsdat%mobdata(NCM_OBS, ilast) 
       Write(*,*) 'J ibeginob ilastob= ',j,ibeginob,ilastob 

       interv=INT((ilastob-ibeginob+1)/mpi_nprocs)  
       IF(interv == 0) THEN
          IF(mpi_myid <= (ilastob-ibeginob)-1) THEN
            interv=1
          ENDIF 
       ENDIF  
       istart=interv*mpi_myid+ibeginob
       iend=interv*(mpi_myid+1)+ibeginob -1 
       if(mpi_myid == mpi_nprocs-1) iend=ilastob

       IF( interv == 0) THEN
          istart=ibeginob
          iend=istart
       ENDIF

       write(*,*)'istart iend= ',istart,iend  
       IF (NBEGINTYP(J) .GT. 0)THEN
          SELECT CASE(CFAMTYP(J)) 
             CASE('UA') 
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('AI')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SW')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SF')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('TO') 
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('GO')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('RO')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('PR')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('SC')
                CALL calObsTag(ibeginob,ilastob,jj)
             CASE('GP')
                CALL calObsTag(ibeginob,ilastob,jj)
           END SELECT
       ELSE
         WRITE(nulout,*) 'Zero for Type ',CFAMTYP(J)  
       ENDIF

    ENDDO  ! bhe   
    length_l=jj
    ALLOCATE(locObsTag(length_l),STAT=ierr)

    locObsTag(1:length_l)=locObsTag_tmp(1:length_l)

    DEALLOCATE(locObsTag_tmp) 

  ENDIF !! end if(l4dvar)  

   !! Calculate the size of the local obs data  
  obsdat%numobs_recorded_l=0
  IF(length_l<=0) call obs_abort('Zero length of ObsTag,Abort!') 
  DO i=1,length_l
   iobs=locObsTag(i)
   idata=obsdat%mobhdr(NCM_NLV, iobs)
   obsdat%numobs_recorded_l = obsdat%numobs_recorded_l + idata
  ENDDO 

  write(nulout,*) ' '
  write(nulout,*) '-------- END OF obs_getobstag ---------'
  write(nulout,*) ' '

  CONTAINS 
    subroutine calObsTag(startindx,endindx,jsize)
     integer,intent(in) :: startindx,endindx
     integer,intent(inout) :: jsize
     !Local variables
     integer :: k 
     DO k=startindx,endindx
       IF(k>=ISTART .and.k<= IEND) THEN
          jsize=jsize+1
          locObsTag_tmp(jsize)=k
       ENDIF
       
     ENDDO 
    end subroutine calObsTag 

 end subroutine obs_getobstag  



 integer function obs_num_obstotal(obsdat)
!func obs_num_obstotal - returns the number of observations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of observations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_obstotal=obsdat%numobs_recorded
 end function obs_num_obstotal


 integer function obs_num_stn(obsdat)
!func obs_num_stn - returns the number of stations recorded
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to provide the number of stations that are currently recorded
!              in the observation-data object
!
  implicit none
  type(struct_obs) , intent(in)  :: obsdat
  obs_num_stn=obsdat%numstns_recorded
 end function obs_num_stn


 subroutine obs_set(obsdat, index, &
                    val_RLN, val_ONM, val_BOX, val_OTP, val_ITY, &
                    val_DAT, val_ETM, val_NLV, val_OFL, val_PAS, &
                    val_REG, val_IP,  val_AZA, val_SUN, val_CLF, &
                    val_LAT, val_LON, val_ALT, val_BX,  val_BY,  &
                    val_BZ,  val_VNM, val_FLG, val_KFA, val_ASS, &
                    val_OBS, val_VCO, val_PPP, val_PRL, val_VAR, &
                    val_OMP, val_OMA, val_OER, val_HPHT,val_ZHA, &
                    val_SID, val_OEC, val_ST1, val_TLA, val_LBO, &
                    val_POB, val_OMF, val_OMI, val_OMN, val_RER, &
                    val_FGE, val_PER, val_POS, val_LYR, val_XTR, &
                    val_LOBS,val_PRM, val_PPP8,val_PRL8,val_POB8,&
                    val_VAR8,val_OMF8,val_OMA8,val_OMI8,val_OMN8,&
                    val_OER8,val_RER8,val_FGE8,val_PER8,val_PRM8,&
                    val_STID &
                   )
!s/r obs_set - set one or more values in the observation object
!
!Author    . J.W. Blezius
!
!    PURPOSE:  to control access to the observation object
!
  implicit none
  type(struct_obs) , intent(inout)  :: obsdat
  integer, intent(in) :: index
  integer,      intent(in), optional :: val_RLN, val_ONM, val_BOX, val_OTP, &
                                        val_ITY, val_DAT, val_ETM, val_NLV, &
                                        val_OFL, val_PAS, val_REG, val_IP,  &
                                        val_AZA, val_SUN, val_CLF, val_VNM, &
                                        val_FLG, val_KFA, val_ASS, val_OBS, &
                                        val_VCO, val_SID, val_OEC, val_ST1, &
                                        val_TLA, val_LBO, val_POS, val_LYR, &
                                        val_XTR, val_LOBS
  real(kind=4), intent(in), optional :: val_LAT, val_LON, val_ALT, val_BX,  &
                                        val_BY,  val_BZ,  val_PPP, val_PRL, &
                                        val_VAR, val_OMP, val_OMA, val_OER, &
                                        val_HPHT,val_ZHA, val_POB, val_OMF, &
                                        val_OMI, val_OMN, val_RER, val_FGE, &
                                        val_PER, val_PRM
  real(kind=8), intent(in), optional :: val_PPP8,val_PRL8,val_POB8,val_VAR8,&
                                        val_OMF8,val_OMA8,val_OMI8,val_OMN8,&
                                        val_OER8,val_RER8,val_FGE8,val_PER8,&
                                        val_PRM8
  character(len=9), intent(in), optional :: val_STID

  ! integer header values
  if(present(val_RLN)) obsdat%mobhdr (NCM_RLN, index) = val_RLN
  if(present(val_ONM)) obsdat%mobhdr (NCM_ONM, index) = val_ONM
  if(present(val_BOX)) obsdat%mobhdr (NCM_BOX, index) = val_BOX
  if(present(val_OTP)) obsdat%mobhdr (NCM_OTP, index) = val_OTP
  if(present(val_ITY)) obsdat%mobhdr (NCM_ITY, index) = val_ITY
  if(present(val_DAT)) obsdat%mobhdr (NCM_DAT, index) = val_DAT
  if(present(val_ETM)) obsdat%mobhdr (NCM_ETM, index) = val_ETM
  if(present(val_NLV)) obsdat%mobhdr (NCM_NLV, index) = val_NLV
  if(present(val_OFL)) obsdat%mobhdr (NCM_OFL, index) = val_OFL
  if(present(val_PAS)) obsdat%mobhdr (NCM_PAS, index) = val_PAS
  if(present(val_REG)) obsdat%mobhdr (NCM_REG, index) = val_REG
  if(present(val_IP )) obsdat%mobhdr (NCM_IP , index) = val_IP
  if(present(val_AZA)) obsdat%mobhdr (NCM_AZA, index) = val_AZA
  if(present(val_SUN)) obsdat%mobhdr (NCM_SUN, index) = val_SUN
  if(present(val_CLF)) obsdat%mobhdr (NCM_CLF, index) = val_CLF
  if(present(val_STID))obsdat%cstnid (         index) = val_STID !! // '   '
  ! Added for var3d
  if(present(val_SID)) obsdat%mobhdr (NCM_SID, index) = val_SID
  if(present(val_OEC)) obsdat%mobhdr (NCM_OEC, index) = val_OEC
  if(present(val_ST1)) obsdat%mobhdr (NCM_ST1, index) = val_ST1
  if(present(val_TLA)) obsdat%mobhdr (NCM_TLA, index) = val_TLA

  ! single-precision header values
  if(present(val_LAT)) obsdat%robhdr (NCM_LAT, index) = val_LAT
  if(present(val_LON)) obsdat%robhdr (NCM_LON, index) = val_LON
  if(present(val_ALT)) obsdat%robhdr (NCM_ALT, index) = val_ALT
  if(present(val_BX )) obsdat%robhdr (NCM_BX , index) = val_BX
  if(present(val_BY )) obsdat%robhdr (NCM_BY , index) = val_BY
  if(present(val_BZ )) obsdat%robhdr (NCM_BZ , index) = val_BZ

  ! integer body values
  if(present(val_VNM)) obsdat%mobdata(NCM_VNM, index) = val_VNM
  if(present(val_FLG)) obsdat%mobdata(NCM_FLG, index) = val_FLG
  if(present(val_KFA)) obsdat%mobdata(NCM_KFA, index) = val_KFA
  if(present(val_ASS)) obsdat%mobdata(NCM_ASS, index) = val_ASS
  if(present(val_OBS)) obsdat%mobdata(NCM_OBS, index) = val_OBS
  if(present(val_VCO)) obsdat%mobdata(NCM_VCO, index) = val_VCO
  if(present(val_LBO)) obsdat%mobdata(NCM_LBO, index) = val_LBO
  if(present(val_POS)) obsdat%mobdata(NCM_POS, index) = val_POS
  if(present(val_LYR)) obsdat%mobdata(NCM_LYR, index) = val_LYR
  if(present(val_XTR)) obsdat%mobdata(NCM_XTR, index) = val_XTR
  if(present(val_LOBS))obsdat%mobdata(NCM_LOBS,index) = val_LOBS

  ! single-precision body values
  if(present(val_PPP)) obsdat%robdata(NCM_PPP, index) = val_PPP
  if(present(val_PRL)) obsdat%robdata(NCM_PRL, index) = val_PRL
  if(present(val_VAR)) obsdat%robdata(NCM_VAR, index) = val_VAR
  if(present(val_OMP)) obsdat%robdata(NCM_OMP, index) = val_OMP
  if(present(val_OMA)) obsdat%robdata(NCM_OMA, index) = val_OMA
  if(present(val_OER)) obsdat%robdata(NCM_OER, index) = val_OER
  if(present(val_HPHT))obsdat%robdata(NCM_HPHT,index) = val_HPHT
  if(present(val_ZHA)) obsdat%robdata(NCM_ZHA, index) = val_ZHA
  if(present(val_POB)) obsdat%robdata(NCM_POB, index) = val_POB
  if(present(val_OMF)) obsdat%robdata(NCM_OMF, index) = val_OMF
  if(present(val_OMI)) obsdat%robdata(NCM_OMI, index) = val_OMI
  if(present(val_OMN)) obsdat%robdata(NCM_OMN, index) = val_OMN
  if(present(val_RER)) obsdat%robdata(NCM_RER, index) = val_RER
  if(present(val_FGE)) obsdat%robdata(NCM_FGE, index) = val_FGE
  if(present(val_PER)) obsdat%robdata(NCM_PER, index) = val_PER
  if(present(val_PRM)) obsdat%robdata(NCM_PRM, index) = val_PRM

  ! double-precision body values
  if(present(val_PPP8)) obsdat%robdata8(NCM_PPP, index) = val_PPP8
  if(present(val_PRL8)) obsdat%robdata8(NCM_PRL, index) = val_PRL8
  if(present(val_POB8)) obsdat%robdata8(NCM_POB, index) = val_POB8
  if(present(val_VAR8)) obsdat%robdata8(NCM_VAR, index) = val_VAR8
  if(present(val_OMF8)) obsdat%robdata8(NCM_OMF, index) = val_OMF8
  if(present(val_OMA8)) obsdat%robdata8(NCM_OMA, index) = val_OMA8
  if(present(val_OMI8)) obsdat%robdata8(NCM_OMI, index) = val_OMI8
  if(present(val_OMN8)) obsdat%robdata8(NCM_OMN, index) = val_OMN8
  if(present(val_OER8)) obsdat%robdata8(NCM_OER, index) = val_OER8
  if(present(val_RER8)) obsdat%robdata8(NCM_RER, index) = val_RER8
  if(present(val_FGE8)) obsdat%robdata8(NCM_FGE, index) = val_FGE8
  if(present(val_PER8)) obsdat%robdata8(NCM_PER, index) = val_PER8
  if(present(val_PRM8)) obsdat%robdata8(NCM_PRM, index) = val_PRM8
 end subroutine obs_set


 integer function obs_ifind(kbufrn)
  implicit none
!
  integer, intent(in) :: kbufrn
!
!      PURPOSE: TO FIND THE INDEX OF THE OBSDAT VARIABLE TYPES LIST ELEMENT
!               THAT CONTAINS A BUFR ELEMENT NUMBER
!
!    ARGUMENTS:
!               INPUT:
!                      -KBUFRN: THE BUFR CLASSIFICATION ELEMENT NUMBER
!                               i.e. known locally as the 'burp variable type'
!                               i.e. table B of the ECMWF BUFR reference
!                               BUFR = Binary Universal Form for the
!                                      Representation of meteorological data
!
!               OUTPUT:
!                      - obs_ifind:
!                                              THE FOUND INDEX (=-1 IF NOT FOUND)
!
!       AUTHOR: P. KOCLAS (CMC TEL. 4665)

  integer indbuf
  integer, parameter, dimension(OBS_JPNBRELEM) :: nvnumb = (/ &
    011003, 011004, 010194, 010192,     29, & !  1-10
    013208, 012063, 012001, 012192, 012004, &
    012203, 011215, 011216, 013210, 013220, & ! 11-20
        62, 015001,     64,     65, 015036, &
    015031, 015032,     69,     70,     71, & ! 21-30
        72,     73,     74,     75,     76, &
        77,     78,     79,     80,     81, & ! 31-40
        82,     83,     84,     85,     86, &
        87,     88,     89,     90,     91, & ! 41-50
    012163, 010004, 011001, 011002, 012062, &
    008001, 008004, 010051, 011011, 011012, & ! 51-57
        41,     42 /)


! OBS. ARRAY VARIABLES NUMBERING IN A BURP FILE
!   Descriptions taken from 3d variational code (March 2011, revision 11.0.2)
!
!  1 =011003 (U COMPONENT)           (m/s)
!  2 =011004 (V COMPONENT)           (m/s)
!  3 =010194 (GEOPOTENTIAL IN J/KG)   (z metres)
!  4 =010192 (THICKNESS IN M)
!  5 =    29 (RELATIVE HUMIDITY)
!  6 =013208
!  7 =012063 BRIGHTNESS TEMPERATURE 1
!  8 =012001 (TEMPERATURE)            (kelvin)
!  9 =012192  (DEW-POINT DEPRESSION)              (t-td kelvin)
! 10 =012004 (2M TEMPERATURE)
! 11 =012203 (2M DEW-POINT DEPRESSION)
! 12 =011215 SURFACE U     WIND COMPONENT M/S)
! 13 =011216 SURFACE V N-S WIND COMPONENT M/S)
! 14 =013210 (NAPIERIAN LOGARITHM OF SPECIFIC HUMIDITY) LN(KG/KG)
! 15 =013220 (NAPIERIAN LOGARITHM OF 2M SPECIFIC HUMIDITY) LN(KG/KG)
! 16 =007006 HEIGHT ABOVE STATION (M)
! 17 =015001 (Total Ozone from TOVS)
! 18 =    64 (CM)
! 19 =    65 (CL)
! 20 =015036 (GPSRO REFRACTIVITY)
! 21 =015031 (GPSGB ZTD IN M)
! 22 =015032 (GPSGB ZTD ERROR IN M)
! 23 =    69 (C)
! 24 =    70 (NS)
! 25 =    71 (S)
! 26 =    72 (E)
! 27 =    73 (TGTG)
! 28 =    74 (SPSP)
! 29 =    75 (SPSP)
! 30 =    76 (RS)
! 31 =    77 (ESES)
! 32 =    78 (IS)
! 33 =    79 (TRTR)
! 34 =    80 (RR)
! 35 =    81 (JJ)
! 36 =    82 (VS)
! 37 =    83 (DS)
! 38 =    84 (HWHW)
! 39 =    85 (PWPW)
! 40 =    86 (DWDW)
! 41 =    87 (GENERAL CLOUD GROUP)
! 42 =    88 (RH FROM LOW CLOUDS)
! 43 =    89 (RH FROM MIDDLE CLOUDS)
! 44 =    90 (RH FROM HIGH CLOUDS)
! 45 =    91 (TOTAL AMOUNT OF CLOUDS)
! 46 =012163 (TOVS LEVEL 1B RADIANCES)
! 47 =010004(PRESSURE (VERT COORDINATE=Z))   (pascals)
! 48 =011001(DD (WIND DIRECTION IN RADIANS)) (degrees)
! 49 =011002(FF (WIND SPEED))                (m/s)
! 50 =012062 (RAW RADIANCE (BRIGHTNESS TEMPERATURE IN K)
! 51 =008001
! 52 =008004
! 53 =010051
! 54 =011011
! 55 =011012
! 56 =    41 (U AT 10M)
! 57 =    42 (V AT 10M)

  obs_ifind=-1
  do indbuf=1,OBS_JPNBRELEM
   if (nvnumb(indbuf) .EQ. kbufrn ) then
    obs_ifind=indbuf
    return
   endif
  enddo
  return

 end function obs_ifind


 SUBROUTINE obs_reduceToMpiLocal(obsdat, nobtot, nobtotp, nfiles, nbegintyp, &
                                 nendtyp, nbegintyp_g, nendtyp_g, l4dvar)
#if defined (DOC)
!
!**s/r obs_reduceToMpiLocal - re-construct observation data object by giving 
!                             local Obs TAG. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To retain in the observation object only those data that are
!                pertinent to the present mpi processor.
!
!
#endif

  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(inout) :: nobtot      ! Actual number of observations
  integer, intent(inout) :: nobtotp     ! Actual no. of obs. in POST FILE=nobtot
  integer, intent(in)    :: nfiles
  integer, intent(inout) :: nbegintyp(:), nendtyp(:)
  integer, intent  (out) :: nbegintyp_g(:), nendtyp_g(:)
  logical, intent(in)    :: l4dvar      ! Logical control of 3Dvar/4Dvar

! Declare Local Variables
  CHARACTER(len=9),ALLOCATABLE,DIMENSION(:) :: cstnid_tmp
  CHARACTER(len=2),ALLOCATABLE,DIMENSION(:) :: cfamily_tmp
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBHDR_tmp,ROBDATA_tmp
  REAL(8),ALLOCATABLE,DIMENSION(:,:) :: ROBDATA8_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp,MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:) :: locObsTag_tmp 
  
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,ifamid,istart,idata,ii 
  LOGICAL :: lfirst 
!!---------------------------------------------------------------
  WRITE(*,*) '============= Enter obs_reduceToMpiLocal =============='

  if(obsdat%mpi_local .eqv. .true.)then
    write(*,*)'ERROR: obs_reduceToMpiLocal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-local state'
    call exit(1)
  end if
  obsdat%mpi_local = .true.

  locObsize=size(locObsTag) 

  ALLOCATE(cfamily_tmp(locObsize),STAT=ierr) 
  ALLOCATE(cstnid_tmp(locObsize),STAT=ierr) 
  ALLOCATE(ROBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBHDR_tmp(NCM_LET,locObsize),STAT=ierr) 
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%numobs_recorded_l),STAT=ierr) 
  ALLOCATE(ROBDATA8_tmp(3:11,obsdat%numobs_recorded_l),STAT=ierr) 
!  
  call obs_allocateG(obsdat,nobtot)
!
!0.1  Sorting locObsTag according to the family ID. 
  IF(l4dvar) THEN
     ALLOCATE(locObsTag_tmp(locObsize),STAT=ierr)
     ii=0
     DO J=1,NFILES
        DO i=1,locObsize
           iobs=locObsTag(i) 
           ifamid=obsdat%mobhdr(NCM_OEC, iobs)
           if(j == ifamid) then
             ii=ii+1
             locObsTag_tmp(ii) = iobs 
           endif
        ENDDO 
     ENDDO 

     locObsTag=locObsTag_tmp
     DEALLOCATE(locObsTag_tmp)  
  ENDIF

  nobtotp=nobtot

!! keep the Global ROBHDR and MOBHDR
  DO iobs=1,nobtotp
    obsdat%MOBHDR_G(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,iobs)
    obsdat%ROBHDR_G(1:NCM_LET,iobs)=obsdat%ROBHDR(1:NCM_LET,iobs)
  ENDDO  
!!
  DO i=1,locObsize 
    iobs=locObsTag(i) 
    ROBHDR_tmp(1:NCM_LET,i)=obsdat%ROBHDR(1:NCM_LET,iobs)
    MOBHDR_tmp(1:NCM_LET,i)=obsdat%MOBHDR(1:NCM_LET,iobs)
    cstnid_tmp(i) = obsdat%cstnid(iobs)
    cfamily_tmp(i) = obsdat%cfamily(iobs) 
    IF(i== 1) THEN
       MOBHDR_tmp(NCM_RLN,1) = 1
    ELSE
       MOBHDR_tmp(NCM_RLN,i)=MOBHDR_tmp(NCM_RLN,i-1) + MOBHDR_tmp(NCM_NLV,i-1) 
    ENDIF 
  ENDDO !  


  ii=0 
  DO i=1,locObsize
    iobs=locObsTag(i) 
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1 
    DO j=idata,idataend 
       ii=ii+1 
       ROBDATA8_tmp(3:11,ii)=obsdat%ROBDATA8(3:11,j)
       MOBDATA_tmp(1:NCM_LBO,ii)=obsdat%MOBDATA(1:NCM_LBO,j) 
       ROBDATA_tmp(1:NCM_LBO,ii)=obsdat%ROBDATA(1:NCM_LBO,j) 
       MOBDATA_tmp(NCM_OBS,ii) = i
    ENDDO 
  ENDDO 
  
  nobtot=locObsize  
  obsdat%numobs_recorded=obsdat%numobs_recorded_l
  write(*,*) 'NOBTOT= ',nobtot 
  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtot,obsdat%numobs_recorded)
!
  DO i=1,nobtot
     obsdat%cfamily(i)=cfamily_tmp(i) 
     obsdat%cstnid(i)=cstnid_tmp(i)
     obsdat%ROBHDR(1:NCM_LET,i)=ROBHDR_tmp(1:NCM_LET,i)
     obsdat%MOBHDR(1:NCM_LET,i)=MOBHDR_tmp(1:NCM_LET,i) 
  ENDDO 

  DO i=1,obsdat%numobs_recorded
     obsdat%ROBDATA8(3:11,i)=ROBDATA8_tmp(3:11,i) 
     obsdat%MOBDATA(1:NCM_LBO,i)=MOBDATA_tmp(1:NCM_LBO,i) 
     obsdat%ROBDATA(1:NCM_LBO,i)=ROBDATA_tmp(1:NCM_LBO,i)
  ENDDO 

  deallocate(cfamily_tmp)
  deallocate(cstnid_tmp)
  deallocate(ROBHDR_tmp)
  deallocate(MOBHDR_tmp)
  deallocate(ROBDATA8_tmp)
  deallocate(MOBDATA_tmp)
  deallocate(ROBDATA_tmp)

 ! rebuild NBEGINTYP and NENDTYP  
 !============================
  jj=0
  NBEGINTYP_G=NBEGINTYP
  NENDTYP_G=NENDTYP
 
  NBEGINTYP=0
  NENDTYP=0
  DO j=1,NFILES
    lfirst=.true. 
    DO i=1,locObsize
      istart=obsdat%mobhdr(NCM_RLN, i)
      idata=obsdat%mobhdr(NCM_NLV, i)
      ifamid=obsdat%mobhdr(NCM_OEC, i)
      IF(ifamid == J) THEN
         IF(lfirst) THEN
           NBEGINTYP(j) = istart 
           lfirst=.false. 
         ENDIF 
         JJ=JJ+idata 
      ENDIF 
    ENDDO 
    NENDTYP(J) = JJ 
    IF(NBEGINTYP(j) == 0)  NENDTYP(J) = 0
    WRITE(*,*) 'J NBEGINTYP(j) NENDTYP(j)= ',J,NBEGINTYP(j), NENDTYP(j),ifamid
  ENDDO  
  
  WRITE(*,*) '============= Leave obs_reduceToMpiLocal =============='
!!
  RETURN
 END SUBROUTINE obs_reduceToMpiLocal


 SUBROUTINE obs_expandToMpiGlobal(obsdat, nulout, nobtot, nobtotp)
#if defined (DOC)
!
!**s/r obs_expandToMpiGlobal - restore Global array ROBDATA and MOBDATA. 
!
!Author    . Bin He (ARMA/MRB )
!
!Revision:
!      PURPOSE:  To reconstitute the mpi-global observation object by gathering
!                the necessary data from all processors (to all processors).
!
#endif

  IMPLICIT NONE

  type(struct_obs), intent(inout) :: obsdat
  integer, intent(in) :: nulout         ! standard output unit
  integer, intent(in) :: nobtot         ! Actual number of observations
  integer, intent(in) :: nobtotp        ! Actual no. of obs. in POST FILE=nobtot

! Declaire Local Variables. 
  REAL,ALLOCATABLE,DIMENSION(:,:) :: ROBDATA_tmp

  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBDATA_TMP 
  INTEGER,ALLOCATABLE,DIMENSION(:,:) :: MOBHDR_tmp 
  
  INTEGER :: i,j,iobs,ierr ,locObsize ,startindx,endindx 
  INTEGER :: idataend,jj,idata,ii,sizeMOBDATA  
  INTEGER ::sizeMOBHDR  
!!---------------------------------------------------------------

!!1.      Release some memory
  print*,'Entering obs_expandToMpiGlobal'

  if(obsdat%mpi_local .eqv. .false.)then
    write(*,*)'ERROR: obs_expandToMpiGlobal() has been called,'
    write(*,*)'       but the obsSpaceData object is already in mpi-global state'
    call exit(1)
  end if
  obsdat%mpi_local = .false.

!!1.2 Added restore global array MOBHDR
!     MOBHDR is used in "cmaabrp.ftn"
  ALLOCATE(MOBHDR_tmp(NCM_LET,NOBTOTP),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cant allocate Mem. to MOBHDR_tmp,Abort!')
  MOBHDR_TMP=0

! 1.3 retore global MOBHDR
  DO i=1,NOBTOT
     iobs=locObsTag(i)
     MOBHDR_tmp(1:NCM_LET,iobs)=obsdat%MOBHDR(1:NCM_LET,i)
  ENDDO
  sizeMOBHDR=size(MOBHDR_tmp)
  CALL RPN_COMM_ALLReduce(MOBHDR_tmp,MOBHDR_tmp,sizeMOBHDR,"mpi_integer", &
                          "mpi_sum","GRID",ierr)


!!2.  Allocate memory for the temporary arrays.
  ALLOCATE(MOBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr)
  IF(ierr /= 0)  call obs_abort('Cant allocate Mem. to MOBDATA_tmp,Abort!')
  MOBDATA_tmp=0

  ALLOCATE(ROBDATA_tmp(NCM_LBO,obsdat%mxobstotal),STAT=ierr)
  IF(ierr /= 0) call  obs_abort('Cant allocate Mem. to ROBDATA_tmp,Abort!')
  ROBDATA_tmp=0.0

!3.  Restore the global arrays MOBDATA and ROBDATA
  ii=0
  DO i=1,nobtot
    iobs=locObsTag(i)
    idata= obsdat%mobhdr(NCM_RLN, iobs)
    idataend = obsdat%mobhdr(NCM_NLV, iobs) + idata -1
    DO j=idata,idataend
       ii=ii+1
       MOBDATA_tmp(1:NCM_LBO,j)=obsdat%MOBDATA(1:NCM_LBO,ii)
       ROBDATA_tmp(1:NCM_LBO,j)=obsdat%ROBDATA(1:NCM_LBO,ii)
    ENDDO
  ENDDO
   !
   ! Merge the global arrays MOBDATA_tmp and ROBDATA_tmp.
  sizeMOBDATA=size(MOBDATA_tmp)
  CALL RPN_COMM_ALLReduce(MOBDATA_tmp,MOBDATA_tmp,sizeMOBDATA,"mpi_integer",&
                          "mpi_sum","GRID",ierr)
  CALL RPN_COMM_ALLReduce(ROBDATA_tmp,ROBDATA_tmp,sizeMOBDATA,"mpi_real",&
                          "mpi_sum","GRID",ierr)
   !

  call obs_deallocate(obsdat)
  call obs_allocate(obsdat,nobtotp,obsdat%mxobstotal)

  obsdat%ROBDATA=ROBDATA_tmp
  DEALLOCATE(ROBDATA_tmp)
  obsdat%MOBDATA=MOBDATA_tmp
  DEALLOCATE(MOBDATA_tmp)
  obsdat%MOBHDR=MOBHDR_tmp
  DEALLOCATE(MOBHDR_tmp)

!!
  call obs_deallocateG(obsdat)
!!
  print*,'Leaving obs_expandToMpiGlobal'
  RETURN
 END SUBROUTINE obs_expandToMpiGlobal


end module obsSpaceData_mod
