!--------------------------------------- LICENCE BEGIN -----------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------

!--------------------------------------------------------------------------
!!
!! *Purpose*: Main program for computing diagnostics of the B matrix
!!
!--------------------------------------------------------------------------
program main_diagBmatrix
  use mpivar_mod
  use MathPhysConstants_mod
  use controlVector_mod
  use gridStateVector_mod
  use bmatrix_mod
  use horizontalCoord_mod
  use verticalCoord_mod
  use timeCoord_mod
  use LamAnalysisGrid_mod
  use randomNumber_mod
  use utilities_mod
  IMPLICIT NONE

  type(struct_gsv) :: statevector
  type(struct_hco), pointer :: hco_anl => null()
  type(struct_vco), pointer :: vco_anl => null()
  real(8), pointer :: field(:,:,:)
  real(4), allocatable :: ensemble(:,:,:,:)
  real(8), allocatable :: gdmean(:,:,:)
  real(8), allocatable :: gdstddev(:,:,:)
  real(8), allocatable :: gdstddev_zm(:,:),gdstddev_zm2(:,:)
  real(8), allocatable :: gdstddev_dm(:,:),gdstddev_dm2(:,:)
  real(8), allocatable :: cvm_vazx_global(:)
  integer :: fclos, fnom, fstopc, newdate, get_max_rss
  integer :: ierr, nsize, iseed, cvDim_local
  integer :: jmem, jj, jlon, jlat, jlev, nkgdim
  integer :: idate, itime, nulnam, nstamp
  integer :: nlons, nlats, nlevs, nlevs2, jvar, ip3
   character(len=128) :: filename
  character(len=10)  :: datestr
  character(len=12)  :: etiket

  ! namelist variables
  integer :: numperturbations, nrandseed, diagdate
  integer :: oneobs_levs(100),oneobs_lons(100),oneobs_lats(100)

  namelist /namdiag/numperturbations, nrandseed, diagdate, oneobs_levs, oneobs_lons, oneobs_lats
  
  write(*,*) " -------------------------------------------"
  write(*,*) " --- START OF MAIN PROGRAM diagBmatrix   ---"
  write(*,*) " --- Diagnositcs of the B matrix         ---"
  write(*,*) " -------------------------------------------"

  ! MPI, tmg initialization
  call mpi_initialize 
  call tmg_init(mpi_myid, 'TMG_DIAGBMATRIX' )
  call tmg_start(1,'MAIN')
  ierr = fstopc('MSGLVL','ERRORS',0)

  ! Set default values for namelist NAMDIAG parameters
  diagdate = 2011020100
  numperturbations = -1
  nrandseed = 1
  oneobs_levs(:)=-1
  oneobs_lons(:)=-1
  oneobs_lats(:)=-1
  
  ! Read the parameters from NAMDIAG
  nulnam=0
  ierr=fnom(nulnam,'./flnml','FTN+SEQ+R/O',0)
  read(nulnam,nml=namdiag,iostat=ierr)
  if(ierr.ne.0) call utl_abort('diagBmatrix: Error reading namelist')
  write(*,nml=namdiag)
  ierr=fclos(nulnam)
  
  nlevs=0
  do jj = 1, size(oneobs_levs)
     if(oneobs_levs(jj).ge.1) nlevs=nlevs+1  
  enddo
  nlons=0
  do jj = 1, size(oneobs_lons)
     if(oneobs_lons(jj).ge.1) nlons=nlons+1  
  enddo
  nlats=0
  do jj = 1, size(oneobs_lats)
     if(oneobs_lats(jj).ge.1) nlats=nlats+1  
  enddo
  
  ! Decompose diagdate(yyyymmddhh) into idate(YYYYMMDD) itime(HHMMSShh)
  ! and calculate date-time stamp
  idate = diagdate/100
  itime = (diagdate-idate*100)*1000000
  ierr = newdate(nstamp,idate,itime,3)
  write(datestr,'(i10.10)') diagdate
  write(*,*)' idate= ',idate,' time= ',itime
  write(*,*)' date= ',diagdate,' stamp= ',nstamp
  call tim_setDatestamp(nstamp)

  !- Initialize the Temporal grid
  call tim_setup

  ! Initialize variables of the model states
  call gsv_setup
  
  ! Initialize the Analysis horizontal grid
  call hco_SetupFromFile( './analysisgrid', 'ANALYSIS', 'Analysis' ) ! IN
  hco_anl => hco_Get('Analysis')

  if ( .not. hco_anl % global ) then
     !- Iniatilized the core (Non-Exteded) analysis grid
     call hco_SetupFromFile( './analysisgrid', 'COREGRID', 'AnalysisCore' ) ! IN
     !- Setup the LAM analysis grid metrics
     call lag_SetupFromHCO( 'Analysis', 'AnalysisCore' ) ! IN
  end if
  
  write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

  ! Initialize the vertical coordinate from the statistics file
  if ( hco_anl % global ) then
     etiket = 'BGCK_STDDEV'
  else
     etiket = 'STDDEV'
  end if
  call vco_SetupFromFile(vco_anl,'./bgcov',etiket)

  ! Allocate the statevector
  call gsv_setVco(statevector,vco_anl)
  call gsv_setHco(statevector,hco_anl)
  call gsv_allocate(statevector,tim_nstepobsinc,datestamp=tim_getDatestamp(),mpi_local=.true.)
  nkgdim = statevector%nk

  ! Setup the B matrix
  call bmat_setup(hco_anl,vco_anl)

  write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

  !
  !==============================================
  !- Compute columns of B matrix
  !==============================================
  !
  if ( nlevs.ge.1 .and. nlons.ge.1 .and. nlats.ge.1 ) then

     write(*,*) '********************************************'
     write(*,*) 'Compute columns of B matrix'
     write(*,*) '********************************************'

     write(*,*) 'number of levels     =',nlevs
     write(*,*) 'number of longitudes =',nlons
     write(*,*) 'number of latitudes  =',nlats
     
     do jvar = 1, vnl_numvarmax

        if (.not. gsv_varExist(varName=vnl_varNameList(jvar)) ) cycle

        filename = 'columnB_' // trim(vnl_varNameList(jvar)) // '_' // datestr // '.fst'
  
        if(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'SF') then
          nlevs2 = 1
        else
          nlevs2 = nlevs
        endif

        ip3 = 0
        do jlev = 1, nlevs2
           do jlon = 1, nlons
              do jlat = 1, nlats

                 call gsv_zero(statevector)                   
                 field => gsv_getField3d_r8(statevector,vnl_varNameList(jvar))

                 if(oneobs_lats(jlat).ge.statevector%myLatBeg .and. oneobs_lats(jlat).le.statevector%myLatEnd .and.  &
                    oneobs_lons(jlon).ge.statevector%myLonBeg .and. oneobs_lons(jlon).le.statevector%myLonEnd) then
                    if(vnl_varLevelFromVarname(vnl_varNameList(jvar)).eq.'SF') then
                      field(oneobs_lons(jlon),oneobs_lats(jlat),1) = 1.0D0
                    else
                      field(oneobs_lons(jlon),oneobs_lats(jlat),oneobs_levs(jlev)) = 1.0D0
                    endif
                 endif

                 cvm_vazx(:)=0.0d0
                 call bmat_sqrtBT(cvm_vazx,cvm_nvadim,statevector)
                 call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)
                 
                 write(*,*)'diagBmatrix: writing out the column of B, jlev,jlon,jlat=',jlev,jlon,jlat
                 call flush(6)

                 ip3 = ip3 + 1
                 call gsv_writeToFileMpi(statevector,filename,'ONEOBS_'//trim(vnl_varNameList(jvar)),  &
                                         ip3_in=ip3,HUcontainsLQ=.true.,unitConversion=.true.)
                 
              enddo
           enddo
        enddo
 
     enddo
     
  endif ! if any oneobs selected

  write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

  !
  !==============================================
  !- Compute the stddev from random perturbations
  !==============================================
  !
  if ( numperturbations > 1 ) then

     write(*,*) '********************************************'
     write(*,*) 'Compute the stddev from random perturbations'
     write(*,*) '********************************************'

     allocate(cvm_vazx_global(cvm_nvadim_mpiglobal))

     call gsv_zero(statevector)
     
     ! Allocate the ensemble, mean and stddev
     allocate(ensemble(statevector%myLonBeg:statevector%myLonEnd,statevector%myLatBeg:statevector%myLatEnd,nkgdim,numperturbations))
     allocate(gdmean(statevector%myLonBeg:statevector%myLonEnd,statevector%myLatBeg:statevector%myLatEnd,nkgdim))
     allocate(gdstddev(statevector%myLonBeg:statevector%myLonEnd,statevector%myLatBeg:statevector%myLatEnd,nkgdim))

     iseed = abs(nrandseed)
     call rng_setup(iseed)

     field => gsv_getField3d_r8(statevector)

     !
     !- Compute the ensemble of random perturbations
     !
     do jmem = 1, numperturbations
        write(*,*) ' computing member number= ',jmem
        call flush(6)

        !- Global vector (same for each processors)
        do jj = 1, cvm_nvadim_mpiglobal
           cvm_vazx_global(jj) = rng_gaussian()
        enddo
        
        !- Extract only the subvector for this processor
        call bmat_reduceToMPILocal(cvm_vazx,        & ! OUT
                                   cvm_vazx_global, & ! IN
                                   cvDim_local )      ! OUT

        !- Transform to control variables in physical space
        call bmat_sqrtB(cvm_vazx,cvm_nvadim,statevector)

!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)    
        do jlev = 1, nkgdim
           do jlat = statevector%myLatBeg, statevector%myLatEnd
              do jlon = statevector%myLonBeg, statevector%myLonEnd
                 ensemble(jlon,jlat,jlev,jmem) = field(jlon,jlat,jlev)
              enddo
           enddo
        enddo
!$OMP END PARALLEL DO

     enddo ! Loop on ens member

     !
     !- Compute the ensemble mean
     !
     gdmean(:,:,:) = 0.0d0
     do jmem = 1, numperturbations
!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)
        do jlev = 1, nkgdim
           do jlat = statevector%myLatBeg, statevector%myLatEnd
              do jlon = statevector%myLonBeg, statevector%myLonEnd
                 gdmean(jlon,jlat,jlev) = gdmean(jlon,jlat,jlev) + ensemble(jlon,jlat,jlev,jmem)
              enddo
           enddo
        enddo
!$OMP END PARALLEL DO
     enddo

!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)    
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              gdmean(jlon,jlat,jlev) = gdmean(jlon,jlat,jlev)/real(numperturbations,8)
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO
     
     !
     !- Remove the ensemble mean from the ensemble
     !
!$OMP PARALLEL DO PRIVATE (jlon,jmem,jlat,jlev)    
     do jmem = 1, numperturbations
        do jlev = 1, nkgdim
           do jlat = statevector%myLatBeg, statevector%myLatEnd
              do jlon = statevector%myLonBeg, statevector%myLonEnd
                 ensemble(jlon,jlat,jlev,jmem) = ensemble(jlon,jlat,jlev,jmem) - gdmean(jlon,jlat,jlev)
              enddo
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO
     deallocate(gdmean)

     !
     !- Compute the ensemble stddev
     !
     gdstddev(:,:,:) = 0.0d0

     do jmem = 1, numperturbations
!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)
        do jlon = statevector%myLonBeg, statevector%myLonEnd
           do jlat = statevector%myLatBeg, statevector%myLatEnd
              do jlev = 1, nkgdim
                 gdstddev(jlon,jlat,jlev) = gdstddev(jlon,jlat,jlev) + &
                    (ensemble(jlon,jlat,jlev,jmem)**2)/real(numperturbations,8)
              enddo
           enddo
        enddo
!$OMP END PARALLEL DO
     enddo
     deallocate(ensemble)

!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              gdstddev(jlon,jlat,jlev) = sqrt(gdstddev(jlon,jlat,jlev))
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO

     !- Insert results in statevector
!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)    
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              field(jlon,jlat,jlev) = gdstddev(jlon,jlat,jlev)
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO
     deallocate(gdstddev)

     !- Write to file
     call gsv_writeToFileMpi(statevector,'stddev_' // datestr // '.fst','GD_STDDEV',  &
                             HUcontainsLQ=.true.,unitConversion=.true.)

     !
     !- Compute the zonal mean std dev
     !
     write(*,*) 'Compute the zonal mean stddev'
     call flush(6)

     allocate(gdstddev_zm(hco_anl%nj,nkgdim))
     allocate(gdstddev_zm2(hco_anl%nj,nkgdim))
     gdstddev_zm(:,:) = 0.d0
     gdstddev_zm2(:,:) = 0.d0

!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              gdstddev_zm(jlat,jlev) = gdstddev_zm(jlat,jlev) + (field(jlon,jlat,jlev)**2)/real(hco_anl%ni,8)
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO

     nsize = statevector%nj*nkgdim
     call rpn_comm_allreduce(gdstddev_zm,gdstddev_zm2,nsize,  &
                            "MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)

     !- Insert results in statevector
!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)    
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              if(gdstddev_zm2(jlat,jlev)> 0.0d0) then
                 field(jlon,jlat,jlev) = sqrt(gdstddev_zm2(jlat,jlev))
              else
                 field(jlon,jlat,jlev) = 0.0d0
              endif
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO
     deallocate(gdstddev_zm)
     deallocate(gdstddev_zm2)

     call gsv_writeToFileMpi(statevector,'stddev_' // datestr // '.fst','ZM_STDDEV',  &
                             HUcontainsLQ=.true.,unitConversion=.true.)

     !
     !- Compute the domain mean std dev
     !
     write(*,*) 'Compute the domain mean stddev'
     call flush(6)

     allocate(gdstddev_dm(hco_anl%ni,nkgdim))
     allocate(gdstddev_dm2(hco_anl%ni,nkgdim))
     gdstddev_dm(:,:) = 0.d0
     gdstddev_dm2(:,:) = 0.d0

!$OMP PARALLEL DO PRIVATE (jlat,jlev)
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              gdstddev_dm(jlon,jlev) = gdstddev_dm(jlon,jlev) + (field(jlon,jlat,jlev)**2)/real(hco_anl%nj,8)
           end do
        enddo
     enddo
!$OMP END PARALLEL DO 

     nsize = statevector%ni*nkgdim
     call rpn_comm_allreduce(gdstddev_dm,gdstddev_dm2,nsize,  &
                            "MPI_DOUBLE_PRECISION","MPI_SUM","GRID",ierr)

     !- Insert results in statevector
                                                                                                                  
!$OMP PARALLEL DO PRIVATE (jlon,jlat,jlev)
     do jlev = 1, nkgdim
        do jlat = statevector%myLatBeg, statevector%myLatEnd
           do jlon = statevector%myLonBeg, statevector%myLonEnd
              if(gdstddev_dm2(jlon,jlev)> 0.0d0) then
                 field(jlon,jlat,jlev) = sqrt(gdstddev_dm2(jlon,jlev))
              else
                 field(jlon,jlat,jlev) = 0.0d0
              endif
           enddo
        enddo
     enddo
!$OMP END PARALLEL DO
     deallocate(gdstddev_dm)
     deallocate(gdstddev_dm2)
 
     call gsv_writeToFileMpi(statevector,'stddev_' // datestr // '.fst','DM_STDDEV',  &
                             HUcontainsLQ=.true.,unitConversion=.true.)

  endif ! if numperturbations.gt.1

  call gsv_deallocate(statevector)

  write(*,*) 'Memory Used: ',get_max_rss()/1024,'Mb'

  ! MPI, tmg finalize
  call tmg_stop(1)
  call tmg_terminate(mpi_myid, 'TMG_DIAGBMATRIX' )
  call rpn_comm_finalize(ierr) 
  
  write(*,*) ' --------------------------------'
  write(*,*) ' diagBmatrix ENDS'
  write(*,*) ' --------------------------------'
  
end program main_diagBmatrix
