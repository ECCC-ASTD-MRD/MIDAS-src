!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer,
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer
!version 3 or (at your option) any later version that should be found at:
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software;
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec),
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
!--------------------------------------------------------------------------
!! *Purpose*: Fill profiles structure by interpolating contents of
!!            columnData to RTTOV space 
!!
!! @author j. halle *cmda/aes  december 13, 2004
!
!revision 001  : a. beaulne *cmda/smc  june 2006
!                    -add ozone from climatology to all sensors
!                    -modifications for AIRS :
!                       + addition of geopotential field to subr argument
!                       + addition of latitude, longitude, height field,
!                         sun zenith angle and cloud fraction 
!                         to personnalized profile structure
!
!revision 002  : j. halle  *cmda/smc  march 2007
!                    -fix zvlev for hybrid coordinate
!revision 003  : C. Charette - ARMA et N.Wagneur - CMDA - Juillet 2011
!                   . Ajout de la capacite de lire le champ d'essai de GEM Version 4 
!                   . ayant une grille verticale decalee dite "STAGGERED"
!revision 004  : s. macpherson  nov 2012
!                  - remove #include "comtovst.cdk"
!revision 005  : S. Heilliette october 2010
!                    -adapt to rttov10
!
!--------------------------------------------------------------------------
subroutine tovs_fill_profiles(columnghr,lobsSpaceData,datestamp,LIMLVHU,bgckMode)
  use EarthConstants_mod
  use MathPhysConstants_mod
  use tovs_nl_mod
  use multi_ir_bgck_mod
  use ozoneclim_mod
  use obsSpaceData_mod
  use columnData_mod 
  use tovs_extrap_mod
  use presProfileOperators_mod
  use utilities_mod
  use tovs_extrap_mod

  use rttov_const, only : gas_unit_specconc, zenmax, inst_id_amsua, &
       inst_id_mhs, platform_id_eos

  implicit none
  type(struct_obs),intent(in) :: lobsSpaceData
  type(struct_columnData),intent(in) :: columnghr
  integer,intent(in) :: datestamp
  real(8),intent(in)  :: LIMLVHU
  logical,intent(in) :: bgckMode


  logical :: diagTtop,TopAt10hPa

  integer :: ksurf, jpmotop, jpmolev
  integer :: isatzen 
  integer :: isatazim, instrum, iplatform
  integer :: isunazim
  integer :: isunza
  integer :: nthreads
  integer :: istride, ilen, imodulo
  integer :: nlevels,nobmax
  integer :: j, i, sensor_id, iobs, jj
  integer :: count_profile, header_index
  integer :: jn, jl
  integer :: ilowlvl_M,ilowlvl_T,nlv_M,nlv_T
  integer :: status, Vcode
  integer :: ier,day,month,year,ijour,itime
  integer :: alloc_status(15)

  integer,external ::  omp_get_num_threads
  integer,external ::  newdate

  integer, allocatable :: iptobs    (:) 
  integer, allocatable :: iptobscma (:) 
  
  type(struct_vco), pointer :: vco

  real(8), allocatable :: to    (:,:)
  real(8), allocatable :: lqo   (:,:)
  real(8), allocatable :: zho   (:,:)
  real(8), allocatable :: toext (:,:)
  real(8), allocatable :: qoext (:,:)
  real(8), allocatable :: zhoext(:,:)
  real(8), allocatable :: zvlev (:,:)
  real(8), allocatable :: zt    (:,:)
  real(8), allocatable :: zlq   (:,:)
  real(8), allocatable :: zht   (:,:)
  real(8), allocatable :: xpres (:)
  real(8), allocatable :: zlat  (:)
  real(8), allocatable :: toto3obs(:),PP(:,:) 
  real(8), allocatable :: ozo     (:,:)
 
  real(8)  :: zlon
  real(8) :: zptop, zptopmbs
 

  write(*,*) "Entering tovs_fill_profiles subroutine"
  
  if(TVS_NOBTOV.eq.0) return    ! exit if there are no tovs data

  !
  !     1.    Set index for model's lowest level and model top
  !     .     ------------------------------------------------

  nlv_M = col_getNumLev(columnghr,'MM')
  nlv_T = col_getNumLev(columnghr,'TH')

  if (  col_getPressure(columnghr,1,1,'TH') < col_getPressure(columnghr,nlv_T,1,'TH') ) then
     ilowlvl_M = nlv_M
     ilowlvl_T = nlv_T
  else
     ilowlvl_M = 1
     ilowlvl_T = 1
  endif

  vco => col_getVco(columnghr)
  status = vgd_get(vco%vgrid,key='ig_1 - vertical coord code',value=Vcode)
  diagTtop = (Vcode.eq.5002)
  write(*,*) 'tovs_fill_profiles: diagTtop=',diagTtop 

 

  ! find model level top, within 0.000001 mbs.
  zptop    = col_getPressure(columnghr,1,1,'TH')
  zptopmbs = zptop/100.d0
  zptopmbs = zptopmbs - 0.000001d0
  write(*,*) 'tovs_fill_profiles: zptopmbs=',zptopmbs

  TopAt10hPa = ( abs( zptopmbs - 10.0d0 ) <= .1d0 )

  ier = newdate(datestamp,ijour,itime,-3)
  if (ier<0) then
     Write(*,*) "Invalid datestamp ",datestamp,ijour,itime,ier
     call utl_abort('tovs_fill_profiles')
  endif
  year= ijour / 10000
  MONTH = MOD(ijour/100,100)
  DAY = MOD(ijour,100)


!     1.1   Number of threads and memory allocation
!     .     ---------------------------------------

!$omp parallel 
  nthreads = omp_get_num_threads()
!$omp end parallel


!     1.2   Read ozone climatology
!     .     ----------------------

  call ozo_read_climatology(datestamp)

!
!     2.  Fill profiles structure
!     .   -----------------------

! loop over all instruments
  sensor_loop: do sensor_id=1,tvs_nsensors

! first loop over all obs.
     count_profile = 0
     bobs1: do iobs = 1, TVS_NOBTOV
        if (tvs_lsensor(iobs)==sensor_id) then
           count_profile = count_profile + 1
           NOBMAX=iobs
        endif
     enddo bobs1

     if (count_profile ==0) cycle sensor_loop

     nlevels=tvs_coefs(sensor_id) %coef% nlevels
     allocate ( xpres (nlevels) )
     xpres = tvs_coefs(1)% coef % ref_prfl_p
     jpmotop = 1
     do jl = 2, nlevels
        if ( zptopmbs >= xpres(jl-1) .and.       &
             zptopmbs < xpres(jl)        ) then 
           jpmotop = jl
           exit
        endif
     enddo
     write(*,*) 'tovs_fill_profiles: jpmotop=', sensor_id, jpmotop
     jpmolev = (nlevels-jpmotop+1)

     alloc_status(:) = 0
     allocate (iptobs    (count_profile)        ,stat= alloc_status(1) )
     allocate (iptobscma (count_profile)        ,stat= alloc_status(2) )
     allocate (zlat      (count_profile)        ,stat= alloc_status(3) )
     allocate (ozo       (nlevels,count_profile),stat= alloc_status(4)) 
     allocate (to        (jpmolev,count_profile),stat= alloc_status(5))
     allocate (lqo       (jpmolev,count_profile),stat= alloc_status(6))
     allocate (zho       (jpmolev,count_profile),stat= alloc_status(7))
     allocate (toext     (nlevels  ,count_profile),stat= alloc_status(8))
     allocate (qoext     (nlevels  ,count_profile),stat= alloc_status(9))
     allocate (zhoext    (nlevels  ,count_profile),stat= alloc_status(10))
     allocate (zvlev     (nlv_T,count_profile),stat= alloc_status(11))
     allocate (zt        (nlv_T,count_profile),stat= alloc_status(12))
     allocate (zlq       (nlv_T,count_profile),stat= alloc_status(13))
     allocate (zht       (nlv_T,count_profile),stat= alloc_status(14))
     call utl_checkAllocationStatus(alloc_status, " tovs_fill_profiles")
    
     count_profile = 0

! second loop over all obs.
     bobs2: do iobs = 1, NOBMAX
        if (tvs_lsensor(iobs)/=sensor_id) cycle bobs2
        count_profile = count_profile + 1
        iptobs(count_profile) = iobs
        header_index = tvs_lobsno(iobs)
        iptobscma(count_profile) = header_index
!    extract land/sea/sea-ice flag (0=land, 1=sea, 2=sea-ice)
        ksurf = obs_headElem_i(lobsSpaceData,OBS_OFL,header_index)
        tvs_profiles(iobs) % skin % surftype = ksurf
!    extract satellite zenith and azimuth angle, 
!    sun zenith angle, cloud fraction, latitude and longitude

        isatzen = obs_headElem_i(lobsSpaceData,OBS_SZA,header_index)
        tvs_profiles(iobs) % zenangle   = (isatzen-9000)/100.0
        !pour ne pas faire planter RTTOV dans le cas (rare) ou isatzen n'est pas defini ou invalide         
        if (tvs_profiles(iobs) % zenangle <0.0d0 .or. &
             tvs_profiles(iobs) % zenangle > zenmax ) then
           write(*,*) "!!! WARNING !!!"
           write(*,*) "INVALID ZENITH ANGLE"
           write(*,*) "angle, profile number, sensor", tvs_profiles(iobs) % zenangle, iobs, sensor_id
           write(*,*) "replaced by 0.0 !!!"
           tvs_profiles(iobs) % zenangle=0.d0
        endif
        !**********************************************************  
        isatazim = obs_headElem_i(lobsSpaceData,OBS_AZA,header_index) ! Satellite Azimuth Angle
        isunazim = obs_headElem_i(lobsSpaceData,OBS_SAZ,header_index) ! Sun Azimuth Angle
        tvs_profiles(iobs) % azangle   = ( isatazim/100.0d0 )
        tvs_profiles(iobs) % sunazangle  =  ( isunazim/100.0d0 )! necessaire pour radiation solaire
        iplatform = tvs_coefs(sensor_id) % coef % id_platform
        instrum = tvs_coefs(sensor_id) % coef % id_inst
        if ( (instrum==inst_id_amsua .or. instrum ==inst_id_mhs) .and. iplatform/=platform_id_eos )then
!Correction a valider
           tvs_profiles(iobs) % azangle   = (isatazim + isunazim)/100.d0
           if ( tvs_profiles(iobs) % azangle > 360.d0 ) tvs_profiles(iobs) % azangle=tvs_profiles(iobs) % azangle - 360.d0
        endif
        isunza = obs_headElem_i(lobsSpaceData,OBS_SUN,header_index)
        tvs_profiles(iobs) % sunzenangle = (isunza-9000)/100.0d0
        zlat(count_profile) = obs_headElem_r(lobsSpaceData,OBS_LAT,header_index) *MPC_DEGREES_PER_RADIAN_R8
        zlon = obs_headElem_r(lobsSpaceData,OBS_LON,header_index) *MPC_DEGREES_PER_RADIAN_R8
        tvs_profiles(iobs) % longitude = zlon
        do jl = 1, nlv_T
           zt   (jl,count_profile) = col_getElem(columnghr,jl,header_index,'TT')
           zlq  (jl,count_profile) = col_getElem(columnghr,jl,header_index,'HU')
           zvlev(jl,count_profile) = col_getPressure(columnghr,jl,header_index,'TH') * MPC_MBAR_PER_PA_R8
           zht  (jl,count_profile) = col_getHeight(columnghr,jl,header_index,'TH') / rg
        enddo

        if (diagTtop) then
!!! Fix temporaire (?) pour eviter probleme au toit avec GEM 4: on ne veut pas utiliser
!!! le premier niveau de GEM qui est disgnostique (extrapole a partir des deux niveaux plus bas)
!!! (grosse varibilite de la temperature au dernier niveau thermo due a l'extrapolation utilisee)
           zt   (1,count_profile) =  zt   (2,count_profile) + tvs_MesosphereLapseRate *  &
                log( col_getPressure(columnghr,1,header_index,'TH') /  &
                col_getPressure(columnghr,2,header_index,'TH') )
           zlq  (1,count_profile) =  zlq  (2,count_profile)         ! extrapolation valeur constante pour H2O peu important a cette hauteur
!!!!
        ENDIF
        
     enddo bobs2
 
!     .  2.1  Vertical interpolation of model temperature, logarithm of
!             specific humidity and height levels to pressure levels
!             required by tovs rt model
!     .       ------------------------------------------


!$omp parallel private(istride)
     imodulo = mod(count_profile,nthreads)
     if ( imodulo .eq. 0 ) then
        istride = max(1,(count_profile/nthreads))
     else
        istride = max(1,(count_profile/nthreads)+1)
     endif
!$omp do private(jn,ilen)
     do jn=1,count_profile,istride
        ilen = min (count_profile-jn+1,istride)
        if ( ilen > 0) then
           call ppo_IntAvg (zvlev(:,jn:jn+ilen-1),zt(:,jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),to(:,jn:jn+ilen-1))
           call ppo_IntAvg (zvlev(:,jn:jn+ilen-1),zlq(:,jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),lqo(:,jn:jn+ilen-1))
           call ppo_lintv (zvlev(:,jn:jn+ilen-1),zht(:,jn:jn+ilen-1),nlv_T,nlv_T,ilen, &
                jpmolev,xpres(jpmotop:nlevels),zho(:,jn:jn+ilen-1))
        endif
     enddo
!$omp end do
!$omp end parallel


!     .  2.2  Extrapolation of temperature profile above model top
!     .       ----------------------------------------------------
     toext(:,:) = 0.0d0
     if ( .not. TopAt10hPa) then ! si le toit n'est pas a 10. hPa 
        do jn=1,count_profile
           toext(jpmotop:nlevels,jn) = to(1:jpmolev,jn)
              ! New approach based on a specified lapse rate
           do jl=1,jpmotop-1
              toext(jl,jn) = toext(jpmotop,jn)  + &
                   ( log(xpres(jl)/xpres(jpmotop)) * tvs_MesosphereLapseRate )
           enddo

        enddo
     else
        ! old code for temperature profile extrapolation (only apropriate if model top at 10 hPa)
        call extrap (to,toext,jpmolev,nlevels,count_profile)
     endif

!     .  2.3  Extrapolation of height profile above model top
!     .       -----------------------------------------------
     zhoext(:,:) = 0.0d0
     call htextrap (zhoext,zho,xpres(1:nlevels),nlevels,jpmolev,jpmotop,count_profile)

!     .  2.4  Extrapolation of humidity profile (kg/kg)
!             above rlimlvhu (normally 300mbs or 70mbs)
!     .       -----------------------------------------

     qoext(:,:) = 0.0d0
     
     do jn = 1, count_profile
        do jl = 1, jpmolev
           qoext(nlevels-jpmolev+jl,jn) = exp(lqo(jl,jn)) 
        enddo
     enddo

     if ( .not. TopAt10hPa ) then ! if model top not at 10. hPa
        qoext(1:jpmotop,1:count_profile) = MPC_MINIMUM_HU_R8 ! to replace with LIMLVHU ?
     else                    
        if ( tvs_debug ) then
           do jn = 1, count_profile
              write(*,*)'qoext*1000 avant exthum4    = '
              write(*,'(1x,10f8.4)')(qoext(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
        call exthum4 (count_profile,nlevels,xpres(1:nlevels),qoext,LIMLVHU)
        if ( tvs_debug ) then
           do jn = 1, count_profile
              write(*,*)'qoext*1000 apres exthum4    = '
              write(*,'(1x,10f8.4)')(qoext(i,jn)*1000.d0,i=1,nlevels)
              write(*,*)' '
           enddo
        endif
     endif


!     .  2.5  Get ozone profiles (ppmv)
!     .       -------------------------
     if (tvs_coefs(sensor_id) %coef %nozone > 0) then
        allocate ( toto3obs(count_profile) )     
        toto3obs(:) = 0.d0
        allocate( PP(nlevels,count_profile) )
        DO J=1,count_profile
           PP(1:nlevels,J)=xpres(1:nlevels)
        ENDDO
        call ozo_get_profile (ozo,toto3obs,zlat,pp,nlevels,count_profile,datestamp)
        deallocate( PP )
        deallocate ( toto3obs )
     endif


        !     .  2.6  Fill profiles structure
        !     .       -----------------------


     do  j = 1 , count_profile 
        jj=iptobs(j)
        tvs_profiles(jj) % gas_units       = gas_unit_specconc ! all gas profiles are supposed to be provided in kg/kg (specific humidity, i.e. mass mixing ratio [kg/kg] over wet air)
        tvs_profiles(jj) % id              = "" ! profile id, up to 128 characters, to consider for use
        tvs_profiles(jj) % nlevels         = nlevels
        tvs_profiles(jj) % nlayers         = nlevels - 1
        
        tvs_profiles(jj) % date(1)         = year
        tvs_profiles(jj) % date(2)         = month
        tvs_profiles(jj) % date(3)         = day
       
        
        tvs_profiles(jj) % latitude        = zlat(j)
        
        tvs_profiles(jj) % elevation       = 0.001d0*zht(ilowlvl_T,j) ! unite km

        tvs_profiles(jj) % skin % watertype= 1 !utilise pour calcul rayonnement solaire reflechi seulement
        tvs_profiles(jj) % skin % t        = col_getElem(columnghr,1,iptobscma(j),'TG')
        tvs_profiles(jj) % skin % salinity = 35.d0 ! for FASTEM-4 only to revise (practical salinity units)
        tvs_profiles(jj) % skin % fastem(:)= 0.0d0
        tvs_profiles(jj) % skin % snow_fraction  = 0.d0 ! Surface coverage snow fraction(0-1), used only by IR emissivity atlas
        tvs_profiles(jj) % skin % soil_moisture  = 0.d0 ! soil moisure (m**3/m**3) not yet used
!
        tvs_profiles(jj) % s2m % t         = col_getElem(columnghr,ilowlvl_T,iptobscma(j),'TT')
!!!        tvs_profiles(jj) % s2m % q         = exp(col_getElem(columnghr,ilowlvl_T,iptobscma(j),'HU')) * tvs_qMixratio2ppmv
        tvs_profiles(jj) % s2m % q         = 0.3D6  !! new a value between 0 and 0.6d6 so that RTTOV will not complain
        tvs_profiles(jj) % s2m % p         = col_getElem(columnghr,1      ,iptobscma(j),'P0')*MPC_MBAR_PER_PA_R8
        tvs_profiles(jj) % s2m % u         = col_getElem(columnghr,ilowlvl_M,iptobscma(j),'UU')
        tvs_profiles(jj) % s2m % v         = col_getElem(columnghr,ilowlvl_M,iptobscma(j),'VV')
        tvs_profiles(jj) % s2m % o         = 0.0d0 !surface ozone never used
        tvs_profiles(jj) % s2m % wfetc     = 100000.0d0 ! Wind fetch (in meter for rttov10 ?) used to calculate reflection of solar radiation by sea surface
!
        tvs_profiles(jj) % idg             = 0
        
        tvs_profiles(jj) % Be              = 0.4d0 ! earth magnetic field strength (gauss) (must be non zero)
        tvs_profiles(jj) % cosbk           = 0.0d0 ! cosine of the angle between the earth magnetic field and wave propagation direction
        
        if ( bgckMode ) then
           profiles_qc(jj) % lat   = tvs_profiles(jj) % latitude
           profiles_qc(jj) % lon   = tvs_profiles(jj) % longitude
           profiles_qc(jj) % sunza = tvs_profiles(jj) % sunzenangle
           profiles_qc(jj) % z(:)  = zhoext(:,j)
        endif
  
        tvs_profiles(jj) % p(:)            = tvs_coefs(sensor_id) %coef% ref_prfl_p(:)
        tvs_profiles(jj) % t(:)            = toext(:,j)

        if (tvs_coefs(sensor_id) %coef %nozone > 0) tvs_profiles(jj) % o3(:) = ozo(:,j) / tvs_o3Mixratio2ppmv ! Climatology output is ppmv (over dry or wet air? not sure but this conversion is only approximate but it should not matter
                                                                                                              ! because atmosphere is very dry where there is significant absorption by ozone)
        tvs_profiles(jj) % q(:)            = qoext(:,j)
        tvs_profiles(jj) % ctp = 1013.25d0
        tvs_profiles(jj) % cfraction = 0.d0
        
     end do

     alloc_status(:) = 0
     deallocate (iptobs    ,stat= alloc_status(1))
     deallocate (iptobscma ,stat= alloc_status(2))
     deallocate (zlat      ,stat= alloc_status(3))
     deallocate (ozo       ,stat= alloc_status(4))
     deallocate (to        ,stat= alloc_status(5))
     deallocate (lqo       ,stat= alloc_status(6))
     deallocate (zho       ,stat= alloc_status(7))
     deallocate (toext     ,stat= alloc_status(8))
     deallocate (qoext     ,stat= alloc_status(9))
     deallocate (zhoext    ,stat= alloc_status(10))
     deallocate (zvlev     ,stat= alloc_status(11))
     deallocate (zt        ,stat= alloc_status(12))
     deallocate (zlq       ,stat= alloc_status(13))
     deallocate (zht       ,stat= alloc_status(14))
     deallocate (xpres     ,stat= alloc_status(15))
     call utl_checkAllocationStatus(alloc_status, " tovs_fill_profiles", .false.)
     
  enddo sensor_loop

contains

  SUBROUTINE EXTHUM4(KNPF,KLAPF,PPRES,PAV,LIMLVHU)
    !
    !**** *exthum4* - extrapolate upper level humidity profile.
    !                 (adapted from exthum by J. Eyre)
    !
    !     purpose.
    !     --------
    !          to extend mixing ratio profile into stratosphere in
    !          a reasonable way.
    !
    !**   interface.
    !     ----------
    !          *call* *exthum4(knpf,klapf,ppres,pav)*
    !               *knpf*:  no. of profiles to be processed.
    !               *klapf*: length of atm. profiles.
    !               *ppres*: pressure levels of atm. profiles.
    !               *pav*:   humidity profiles.
    !
    !     method.
    !     -------
    !          take top tropospheric mixing ratio (e.g. near 300 mb) and
    !          extrapolate with given fall off into lower stratosphere
    !          (e.g. to 70 mb).  constrain mixing ratio to be >= zwmin
    !          (e.g. 0.000003 kg/kg).   in upper strat, mixing ratio = zwmin.
    !
    !     externals.
    !     ----------
    !          none.
    !
    !     reference.
    !     ----------
    !          ecmwf tech mem 176.
    !
    use MathPhysConstants_mod
    implicit none
    !
    integer klapf, knpf
    REAL(8) PPRES(*),PAV(KLAPF,*)
    real(8) :: LIMLVHU

    !
    REAL(8) :: ZPRES3(KLAPF)
    !
    REAL(8) zwb
    REAL(8),parameter :: ZP1 = 70.0D0  !PRESS LIMITS (IN HPA) OF REGION to be extrapolated
    integer :: j, inlvw, jnpf
    
    !
    !          find top level of given profile
    DO J=KLAPF,1,-1
       IF (PPRES(J)<LIMLVHU) THEN
          INLVW=J
          GOTO 120
       ENDIF
    end do
    !
    !** Null extrapolation case
    !
    RETURN
    !
    !          constants defining p**3 fall off around tropopause
120 DO J=1,INLVW
       ZPRES3(J)=(PPRES(J)/PPRES(INLVW+1))**3
    end do
    !
    DO JNPF=1,KNPF
       ZWB=PAV(INLVW+1,JNPF)
       DO J=1,INLVW
          IF (PPRES(J)<ZP1) THEN
             PAV(J,JNPF)=MPC_MINIMUM_HU_R8
          ELSE
             PAV(J,JNPF)=MAX((ZWB*ZPRES3(J)),MPC_MINIMUM_HU_R8)
          ENDIF
       end do
    end do
    
  END SUBROUTINE EXTHUM4

  SUBROUTINE HTEXTRAP ( PROFOUT, profin,xpres,jplev,jpmolev,jpmotop,nprf )

    !*****************************************************************
    !
    !**ID HTEXTRAP -- EXTRAPOLATION OF HEIGHT PROFILES
    !
    !       AUTHOR:   A. BEAULNE (CMDA/SMC) March 2006
    !
    !       REVISION:
    !
    !       OBJECT:  EXTRAPOLATE HEIGHT PROFILES ABOVE 10MB MODEL TOP
    !                ON RTTOV LEVELS UP TO 0.1MB (RTTOV LEVELS 1 TO 7)
    !                USING 10 RTTOV HEIGHT LEVELS FROM 100MB TO 10MB
    !                (RTTOV LEVELS 8 TO 17) FOR LINEAR FIT.
    !
    !                -- LINEAR EXTRAPOLATION FOLLOWING
    !                --    PROFOUT(m) = A * ln(XPRES(mb)) + B
    !                -- AND SOLVE A AND B BY LEAST SQUARE METHOD 
    !
    !       ARGUMENTS:
    !          INPUT:
    !            -PROFIN(JPMOLEV,NPRF) :: HEIGHT PROFILES  -TO BE EXTRAPOLATED- (M)
    !            -XPRES(JPLEV)         :: PRESSURE LEVELS OF RTTOV MODEL (HPA)
    !            -JPLEV                :: NUMBER OF PRESSURE LEVELS OF RTTOV MODEL
    !            -JPMOLEV              :: NUMBER OF RTTOV MODEL LEVELS BELOW NWP MODEL TOP
    !            -JPMOTOP              :: FIRST RTTOV MODEL LEVEL UNDER NWP MODEL TOP
    !            -NPRF                 :: NUMBER OF PROFILES
    !
    !          OUTPUT:
    !            -PROFOUT(JPLEV,NPRF)  :: HEIGHT PROFILES  -EXTRAPOLATED- (M)
    !
    !
    !******************************************************************

    IMPLICIT NONE


    INTEGER      :: I, JK, JN, NPRF, JPMOLEV, JPMOTOP, JPLEV
    REAL(8)      :: LNX_SUM, LNX_AVG, Y_SUM, Y_AVG, A_NUM, A_DEN, A, B
    REAL(8)      :: XPRES(JPLEV), PROFIN(JPMOLEV,NPRF), PROFOUT(JPLEV,NPRF)

    INTEGER, PARAMETER :: NL = 10  ! number of points used in the extrapolation


    DO JN = 1, NPRF

       LNX_SUM = 0.d0
       Y_SUM   = 0.d0
       A_NUM   = 0.d0
       A_DEN   = 0.d0


       !*      FIND AVERAGED VALUES OF HEIGHT AND LN ( PRESSURE )

       DO I = 1, NL
          LNX_SUM = LNX_SUM + LOG(XPRES(JPMOTOP+I-1))
          Y_SUM   = Y_SUM   + PROFIN(I,JN)
       END DO

       LNX_AVG = LNX_SUM / NL
       Y_AVG   = Y_SUM   / NL


       !*      FIND CONSTANTS A AND B BY LEAST-SQUARE METHOD

       DO I = 1, NL
          A_NUM = A_NUM + ( LOG(XPRES(JPMOTOP+I-1)) - LNX_AVG ) * ( PROFIN(I,JN) - Y_AVG )
          A_DEN = A_DEN + ( LOG(XPRES(JPMOTOP+I-1)) - LNX_AVG )**2
       END DO

       A = A_NUM / A_DEN

       B = Y_AVG - A * LNX_AVG


       !*      INITIALIZE HEIGHT FOR RTTOV LEVELS UNDER NWP MODEL TOP

       DO JK = 1, JPMOLEV
          PROFOUT(JPLEV-JPMOLEV+JK,JN) = PROFIN(JK,JN)
       END DO


       !*      EXTRAPOLATE HEIGHT FOR RTTOV LEVELS ABOVE NWP MODEL TOP

       DO JK = 1, JPMOTOP-1
          PROFOUT(JK,JN) = A * LOG(XPRES(JK)) + B
       END DO

    END DO


  END SUBROUTINE HTEXTRAP

end subroutine tovs_fill_profiles
